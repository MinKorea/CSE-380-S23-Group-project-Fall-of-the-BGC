(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){
'use strict';

var width = 256;// each RC4 output is 0 <= x < 256
var chunks = 6;// at least six RC4 outputs for each double
var digits = 52;// there are 52 significant digits in a double
var pool = [];// pool: entropy pool starts empty
var GLOBAL = typeof global === 'undefined' ? window : global;

//
// The following constants are related to IEEE 754 limits.
//
var startdenom = Math.pow(width, chunks),
    significance = Math.pow(2, digits),
    overflow = significance * 2,
    mask = width - 1;


var oldRandom = Math.random;

//
// seedrandom()
// This is the seedrandom function described above.
//
module.exports = function(seed, options) {
  if (options && options.global === true) {
    options.global = false;
    Math.random = module.exports(seed, options);
    options.global = true;
    return Math.random;
  }
  var use_entropy = (options && options.entropy) || false;
  var key = [];

  // Flatten the seed string or build one from local entropy if needed.
  var shortseed = mixkey(flatten(
    use_entropy ? [seed, tostring(pool)] :
    0 in arguments ? seed : autoseed(), 3), key);

  // Use the seed to initialize an ARC4 generator.
  var arc4 = new ARC4(key);

  // Mix the randomness into accumulated entropy.
  mixkey(tostring(arc4.S), pool);

  // Override Math.random

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.

  return function() {         // Closure to return a random double:
    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
        d = startdenom,                 //   and denominator d = 2 ^ 48.
        x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer Math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };
};

module.exports.resetGlobal = function () {
  Math.random = oldRandom;
};

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
/** @constructor */
function ARC4(key) {
  var t, keylen = key.length,
      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) {
    s[i] = i++;
  }
  for (i = 0; i < width; i++) {
    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
    s[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  (me.g = function(count) {
    // Using instance members instead of closure state nearly doubles speed.
    var t, r = 0,
        i = me.i, j = me.j, s = me.S;
    while (count--) {
      t = s[i = mask & (i + 1)];
      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
    }
    me.i = i; me.j = j;
    return r;
    // For robust unpredictability discard an initial batch of values.
    // See http://www.rsa.com/rsalabs/node.asp?id=2009
  })(width);
}

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj, depth) {
  var result = [], typ = (typeof obj)[0], prop;
  if (depth && typ == 'o') {
    for (prop in obj) {
      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
    }
  }
  return (result.length ? result : typ == 's' ? obj : obj + '\0');
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed, key) {
  var stringseed = seed + '', smear, j = 0;
  while (j < stringseed.length) {
    key[mask & j] =
      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
  }
  return tostring(key);
}

//
// autoseed()
// Returns an object for autoseeding, using window.crypto if available.
//
/** @param {Uint8Array=} seed */
function autoseed(seed) {
  try {
    GLOBAL.crypto.getRandomValues(seed = new Uint8Array(width));
    return tostring(seed);
  } catch (e) {
    return [+new Date, GLOBAL, GLOBAL.navigator && GLOBAL.navigator.plugins,
            GLOBAL.screen, tostring(pool)];
  }
}

//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a) {
  return String.fromCharCode.apply(0, a);
}

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to intefere with determinstic PRNG state later,
// seedrandom will not call Math.random on its own again after
// initialization.
//
mixkey(Math.random(), pool);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],2:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = __importDefault(require("../DataTypes/Collections/Map"));
/**
 * A manager class for all of the AI in a scene.
 * Keeps a list of registered actors and handles AI generation for actors.
 */
class AIManager {
    constructor() {
        this.actors = new Array();
        this.registeredAI = new Map_1.default();
    }
    /**
     * Registers an actor with the AIManager
     * @param actor The actor to register
     */
    registerActor(actor) {
        this.actors.push(actor);
    }
    removeActor(actor) {
        let index = this.actors.indexOf(actor);
        if (index !== -1) {
            this.actors.splice(index, 1);
        }
    }
    /**
     * Registers an AI with the AIManager for use later on
     * @param name The name of the AI to register
     * @param constr The constructor for the AI
     */
    registerAI(name, constr) {
        this.registeredAI.add(name, constr);
    }
    /**
     * Generates an AI instance from its name
     * @param name The name of the AI to add
     * @returns A new AI instance
     */
    generateAI(name) {
        if (this.registeredAI.has(name)) {
            return new (this.registeredAI.get(name))();
        }
        else {
            throw `Cannot create AI with name ${name}, no AI with that name is registered`;
        }
    }
    update(deltaT) {
        // Run the ai for every active actor
        this.actors.forEach(actor => { if (actor.aiActive)
            actor.ai.update(deltaT); });
    }
}
exports.default = AIManager;

},{"../DataTypes/Collections/Map":8}],3:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GoapActionStatus = void 0;
const State_1 = __importDefault(require("../../DataTypes/State/State"));
class GoapAction extends State_1.default {
    constructor(parent, actor) {
        super(parent);
        this.actor = actor;
        this._preconditions = new Set();
        this._effects = new Set();
        this._cost = 0;
    }
    /** Cost it takes to complete this action */
    get cost() { return this._cost; }
    set cost(cost) { this._cost = cost; }
    /** Preconditions that have to be satisfied for an action to happen */
    get preconditions() { return Array.from(this._preconditions.values()); }
    ;
    /** Resulting statuses after this action completes */
    get effects() { return Array.from(this._effects.values()); }
    checkPreconditions(status) {
        return Array.from(this._preconditions.values()).every(precondition => status.includes(precondition));
    }
    addPrecondition(status) {
        this._preconditions.add(status);
    }
    addEffect(status) {
        this._effects.add(status);
    }
    finished() {
        this.parent.changeState();
    }
}
exports.default = GoapAction;
var GoapActionStatus;
(function (GoapActionStatus) {
    GoapActionStatus[GoapActionStatus["FAILURE"] = 0] = "FAILURE";
    GoapActionStatus[GoapActionStatus["SUCCESS"] = 1] = "SUCCESS";
    GoapActionStatus[GoapActionStatus["RUNNING"] = 2] = "RUNNING";
})(GoapActionStatus = exports.GoapActionStatus || (exports.GoapActionStatus = {}));

},{"../../DataTypes/State/State":23}],4:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Graph_1 = __importDefault(require("../../DataTypes/Graphs/Graph"));
const Stack_1 = __importDefault(require("../../DataTypes/Collections/Stack"));
const GraphUtils_1 = __importDefault(require("../../Utils/GraphUtils"));
class GoapActionPlanner {
    static plan(status, goal, actions) {
        let graph = new Graph_1.default(true);
        let mapping = new Map();
        //0 is our root
        graph.addNode();
        mapping.set(0, "Start");
        //1 is the goal
        graph.addNode();
        mapping.set(1, "Goal");
        graph.addEdge(1, 1, Number.POSITIVE_INFINITY);
        //Build tree from 0 to 1
        this.buildTree(status, actions, 0, goal, mapping, graph);
        //Run djikstra to find shortest path
        let path = GraphUtils_1.default.djikstra(graph, 0);
        //Push all elements of the plan
        let plan = new Stack_1.default();
        let i = 1;
        while (path[i] !== -1) {
            if (path[i] !== 0) {
                plan.push(mapping.get(path[i]));
            }
            i = path[i];
        }
        return plan;
    }
    static buildTree(status, actions, root, goal, mapping, graph) {
        //For each possible action 
        actions.forEach(action => {
            //Can it be performed?
            if (action.checkPreconditions(status)) {
                //This action can be performed
                //Add effects to currentStatus
                let newStatus = [...status];
                newStatus.push(...action.effects);
                //Check if the new node is the goal
                if (newStatus.includes(goal)) {
                    let newNode = graph.addNode();
                    mapping.set(newNode, action);
                    graph.addEdge(root, newNode, action.cost);
                    graph.addEdge(newNode, 1, 0);
                    return;
                }
                //Add node and edge from root
                let newNode = graph.addNode();
                mapping.set(newNode, action);
                graph.addEdge(root, newNode, action.cost);
                //Recursive call
                let newActions = actions.filter(act => act !== action);
                this.buildTree(newStatus, newActions, newNode, goal, mapping, graph);
            }
        });
    }
}
exports.default = GoapActionPlanner;

},{"../../DataTypes/Collections/Stack":10,"../../DataTypes/Graphs/Graph":13,"../../Utils/GraphUtils":108}],5:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A state for a GoapAI. The "state" is not the same as a state in a state machine, or something of that nature.
 */
class GoapState {
}
exports.default = GoapState;

},{}],6:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Stack_1 = __importDefault(require("../../DataTypes/Collections/Stack"));
const GoapActionPlanner_1 = __importDefault(require("./GoapActionPlanner"));
const Map_1 = __importDefault(require("../../DataTypes/Collections/Map"));
const StateMachineAI_1 = __importDefault(require("../StateMachineAI"));
/**
 * An implementation of basic Goap behavior.
 *
 * GOAP requires a lot of overhead for managing all of the symbols (statuses and goals), the
 * actual goap-actions, and creating the action plans.
 *
 * I've opted to try and extend the StateMachineAI for this class, mostly to try and keep things
 * similar to the StateMachineAI. My StateMachineGoapAI class kind of breaks LSP (Liskov's substitution principle)
 * which cues me into the fact that I should probably make a seperate class.
 *
 * Something I'd like to add is an additional class for managing a set of goals. The goals
 * are pretty similar to statuses, except that goals have some kind off priority associated
 * with them. Not sure how we'd do this.
 *
 * @author Peter Walsh
 */
class StateMachineGoapAI extends StateMachineAI_1.default {
    constructor() {
        super();
        this.statuses = new Map_1.default();
        this.stateMap = new Map_1.default();
        this.stack = new Stack_1.default();
        this.goal = null;
    }
    update(deltaT) {
        super.update(deltaT);
    }
    initialize() {
        // Initialize the AI by building a plan from the the current actions
        this.stack = this.buildPlan();
        this.currentState = this.stack.peek();
        this.currentState.onEnter({});
        this.setActive(true);
    }
    // NOTE; this method might trigger infinite recursion in your GOAP AI - Peteylumpkins
    changeState() {
        // Exit the current state
        let options = this.currentState.onExit();
        // Remove the previous state
        this.stack.pop();
        // If the plan is empty, build a new plan
        if (this.stack.isEmpty()) {
            this.stack = this.buildPlan();
        }
        // Set the current action
        this.currentState = this.stack.peek();
        // Emit an event if turned on
        if (this.emitEventOnStateChange) {
            this.emitter.fireEvent(this.stateChangeEventName, { state: this.currentState });
        }
        // Enter the new action
        this.currentState.onEnter(options);
    }
    buildPlan() {
        // Get all the current statuses
        let statuses = this.currentStatus();
        // Get all the current actions
        let actions = Array.from(this.stateMap.keys()).map(key => this.stateMap.get(key));
        // Create the plan
        return GoapActionPlanner_1.default.plan(statuses, this.goal, actions);
    }
    currentStatus() {
        return Array.from(this.statuses.keys()).filter(stat => this.statuses.get(stat).isSatisfied());
    }
    setGoal(goal) {
        if (!this.statuses.has(goal)) {
            throw new Error("Goal doesn't exist. Make sure your goal is a status for this GOAP AI");
        }
        this.goal = goal;
    }
    addStatus(statusName, status) {
        this.statuses.set(statusName, status);
    }
    addState(stateName, state) {
        super.addState(stateName, state);
    }
}
exports.default = StateMachineGoapAI;

},{"../../DataTypes/Collections/Map":8,"../../DataTypes/Collections/Stack":10,"../StateMachineAI":7,"./GoapActionPlanner":4}],7:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const StateMachine_1 = __importDefault(require("../DataTypes/State/StateMachine"));
/**
 * A version of a @reference[StateMachine] that is configured to work as an AI controller for a @reference[GameNode]
 */
class StateMachineAI extends StateMachine_1.default {
    // @implemented
    initializeAI(owner, config) { }
    // @implemented
    destroy() {
        // Get rid of our reference to the owner
        delete this.owner;
        this.receiver.destroy();
    }
    // @implemented
    activate(options) { }
}
exports.default = StateMachineAI;

},{"../DataTypes/State/StateMachine":24}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Associates strings with elements of type T
 */
class Map {
    /** Creates a new map */
    constructor() {
        this.map = {};
    }
    /**
     * Adds a value T stored at a key.
     * @param key The key of the item to be stored
     * @param value The item to be stored
     */
    add(key, value) {
        this.map[key] = value;
    }
    /**
     * Get the value associated with a key.
     * @param key The key of the item
     * @returns The item at the key or undefined
     */
    get(key) {
        return this.map[key];
    }
    /**
     * An alias of add. Sets the value stored at key to the new specified value
     * @param key The key of the item to be stored
     * @param value The item to be stored
     */
    set(key, value) {
        this.add(key, value);
    }
    /**
     * Returns true if there is a value stored at the specified key, false otherwise.
     * @param key The key to check
     * @returns A boolean representing whether or not there is an item at the given key.
     */
    has(key) {
        return this.map[key] !== undefined;
    }
    /**
     * Returns an array of all of the keys in this map.
     * @returns An array containing all keys in the map.
     */
    keys() {
        return Object.keys(this.map);
    }
    // @implemented
    forEach(func) {
        Object.keys(this.map).forEach(key => func(key));
    }
    /**
     * Deletes an item associated with a key
     * @param key The key at which to delete an item
     */
    delete(key) {
        delete this.map[key];
    }
    // @implemented
    clear() {
        this.forEach(key => delete this.map[key]);
    }
    /**
     * Converts this map to a string representation.
     * @returns The string representation of this map.
     */
    toString() {
        let str = "";
        this.forEach((key) => str += key + " -> " + this.get(key).toString() + "\n");
        return str;
    }
}
exports.default = Map;

},{}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A FIFO queue with elements of type T
 */
class Queue {
    /**
     * Constructs a new queue
     * @param maxElements The maximum size of the stack
     */
    constructor(maxElements = 100) {
        this.MAX_ELEMENTS = maxElements;
        this.q = new Array(this.MAX_ELEMENTS);
        this.head = 0;
        this.tail = 0;
        this.size = 0;
    }
    /**
     * Adds an item to the back of the queue
     * @param item The item to add to the back of the queue
     */
    enqueue(item) {
        if ((this.tail + 1) % this.MAX_ELEMENTS === this.head) {
            throw new Error("Queue full - cannot add element");
        }
        this.size += 1;
        this.q[this.tail] = item;
        this.tail = (this.tail + 1) % this.MAX_ELEMENTS;
    }
    /**
     * Retrieves an item from the front of the queue
     * @returns The item at the front of the queue
     */
    dequeue() {
        if (this.head === this.tail) {
            throw new Error("Queue empty - cannot remove element");
        }
        this.size -= 1;
        let item = this.q[this.head];
        // Now delete the item
        delete this.q[this.head];
        this.head = (this.head + 1) % this.MAX_ELEMENTS;
        return item;
    }
    /**
     * Returns the item at the front of the queue, but does not remove it
     * @returns The item at the front of the queue
     */
    peekNext() {
        if (this.head === this.tail) {
            throw "Queue empty - cannot get element";
        }
        let item = this.q[this.head];
        return item;
    }
    /**
     * Returns true if the queue has items in it, false otherwise
     * @returns A boolean representing whether or not this queue has items
     */
    hasItems() {
        return this.head !== this.tail;
    }
    /**
     * Returns the number of elements in the queue.
     * @returns The size of the queue
     */
    getSize() {
        return this.size;
    }
    // @implemented
    clear() {
        this.forEach((item, index) => delete this.q[index]);
        this.size = 0;
        this.head = this.tail;
    }
    // @implemented
    forEach(func) {
        let i = this.head;
        while (i !== this.tail) {
            func(this.q[i], i);
            i = (i + 1) % this.MAX_ELEMENTS;
        }
    }
    /**
     * Converts this queue into a string format
     * @returns A string representing this queue
     */
    toString() {
        let retval = "";
        this.forEach((item, index) => {
            let str = item.toString();
            if (index !== 0) {
                str += " -> ";
            }
            retval = str + retval;
        });
        return "Top -> " + retval;
    }
}
exports.default = Queue;

},{}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A LIFO stack with items of type T
 */
class Stack {
    /**
     * Constructs a new stack
     * @param maxElements The maximum size of the stack
     */
    constructor(maxElements = 100) {
        this.MAX_ELEMENTS = maxElements;
        this.stack = new Array(this.MAX_ELEMENTS);
        this.head = -1;
    }
    /**
     * Adds an item to the top of the stack
     * @param item The new item to add to the stack
     */
    push(item) {
        if (this.head + 1 === this.MAX_ELEMENTS) {
            throw "Stack full - cannot add element";
        }
        this.head += 1;
        this.stack[this.head] = item;
    }
    /**
     * Removes an item from the top of the stack
     * @returns The item at the top of the stack
     */
    pop() {
        if (this.head === -1) {
            throw "Stack empty - cannot remove element";
        }
        this.head -= 1;
        return this.stack[this.head + 1];
    }
    /**
     * Returns the element currently at the top of the stack
     * @returns The item at the top of the stack
     */
    peek() {
        if (this.head === -1) {
            throw "Stack empty - cannot get element";
        }
        return this.stack[this.head];
    }
    /** Returns true if this stack is empty
     * @returns A boolean that represents whether or not the stack is empty
    */
    isEmpty() {
        return this.head === -1;
    }
    // @implemented
    clear() {
        this.forEach((item, index) => delete this.stack[index]);
        this.head = -1;
    }
    /**
     * Returns the number of items currently in the stack
     * @returns The number of items in the stack
     */
    size() {
        return this.head + 1;
    }
    // @implemented
    forEach(func) {
        let i = 0;
        while (i <= this.head) {
            func(this.stack[i], i);
            i += 1;
        }
    }
    /**
     * Converts this stack into a string format
     * @returns A string representing this stack
     */
    toString() {
        let retval = "";
        this.forEach((item, index) => {
            let str = item.toString();
            if (index !== 0) {
                str += " -> ";
            }
            retval = str + retval;
        });
        return "Top -> " + retval;
    }
}
exports.default = Stack;

},{}],11:[function(require,module,exports){
"use strict";
// @ignorePage
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A placeholder function for No Operation. Does nothing
 */
const NullFunc = () => { };
exports.default = NullFunc;

},{}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A linked-list for the edges in a @reference[Graph].
 */
class EdgeNode {
    /**
     * Creates a new EdgeNode
     * @param index The index of the node this edge connects to
     * @param weight The weight of this edge
     */
    constructor(index, weight) {
        this.y = index;
        this.next = null;
        this.weight = weight ? weight : 1;
    }
}
exports.default = EdgeNode;

},{}],13:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MAX_V = void 0;
const EdgeNode_1 = __importDefault(require("./EdgeNode"));
exports.MAX_V = 10000;
/**
 * An implementation of a graph data structure using edge lists. Inspired by The Algorithm Design Manual.
 */
class Graph {
    /**
     * Constructs a new graph
     * @param directed Whether or not this graph is directed
     */
    constructor(directed = false) {
        this.directed = directed;
        this.weighted = false;
        this.numVertices = 0;
        this.numEdges = 0;
        this.edges = new Array(exports.MAX_V);
        this.degree = new Array(exports.MAX_V);
    }
    /** Adds a node to this graph and returns the index of it
     * @returns The index of the new node
    */
    addNode() {
        return this.numVertices++;
    }
    /** Adds an edge between node x and y, with an optional weight
     * @param x The index of the start of the edge
     * @param y The index of the end of the edge
     * @param weight The optional weight of the new edge
    */
    addEdge(x, y, weight) {
        let edge = new EdgeNode_1.default(y, weight);
        if (this.edges[x]) {
            edge.next = this.edges[x];
        }
        this.edges[x] = edge;
        if (!this.directed) {
            edge = new EdgeNode_1.default(x, weight);
            if (this.edges[y]) {
                edge.next = this.edges[y];
            }
            this.edges[y] = edge;
        }
        this.numEdges += 1;
    }
    /**
     * Checks whether or not an edge exists between two nodes.
     * This check is directional if this is a directed graph.
     * @param x The first node
     * @param y The second node
     * @returns true if an edge exists, false otherwise
     */
    edgeExists(x, y) {
        let edge = this.edges[x];
        while (edge !== null) {
            if (edge.y === y) {
                return true;
            }
            edge = edge.next;
        }
    }
    /**
     * Gets the edge list associated with node x
     * @param x The index of the node
     * @returns The head of a linked-list of edges
     */
    getEdges(x) {
        return this.edges[x];
    }
    /**
     * Gets the degree associated with node x
     * @param x The index of the node
     */
    getDegree(x) {
        return this.degree[x];
    }
    /**
     * Converts the specifed node into a string
     * @param index The index of the node to convert to a string
     * @returns The string representation of the node: "Node x"
     */
    nodeToString(index) {
        return "Node " + index;
    }
    /**
     * Converts the Graph into a string format
     * @returns The graph as a string
     */
    toString() {
        let retval = "";
        for (let i = 0; i < this.numVertices; i++) {
            let edge = this.edges[i];
            let edgeStr = "";
            while (edge !== undefined && edge !== null) {
                edgeStr += edge.y.toString();
                if (this.weighted) {
                    edgeStr += " (" + edge.weight + ")";
                }
                if (edge.next !== null) {
                    edgeStr += ", ";
                }
                edge = edge.next;
            }
            retval += this.nodeToString(i) + ": " + edgeStr + "\n";
        }
        return retval;
    }
}
exports.default = Graph;

},{"./EdgeNode":12}],14:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const Graph_1 = __importStar(require("./Graph"));
/**
 * An extension of Graph that has nodes with positions in 2D space.
 * This is a weighted graph (though not inherently directd)
*/
class PositionGraph extends Graph_1.default {
    /**
     * Createes a new PositionGraph
     * @param directed Whether or not this graph is directed
     */
    constructor(directed = false) {
        super(directed);
        this.debugRender = () => {
            // for(let point of this.positions){
            // 	ctx.fillRect((point.x - origin.x - 4)*zoom, (point.y - origin.y - 4)*zoom, 8, 8);
            // }
        };
        this.positions = new Array(Graph_1.MAX_V);
    }
    /**
     * Adds a positioned node to this graph
     * @param position The position of the node to add
     * @returns The index of the added node
     */
    addPositionedNode(position) {
        this.positions[this.numVertices] = position;
        return this.addNode();
    }
    /**
     * Changes the position of a node.
     * Automatically adjusts the weights of the graph tied to this node.
     * As such, be warned that this function has an O(n + m) running time, and use it sparingly.
     * @param index The index of the node
     * @param position The new position of the node
     */
    setNodePosition(index, position) {
        this.positions[index] = position;
        // Recalculate all weights associated with this index
        for (let i = 0; i < this.numEdges; i++) {
            let edge = this.edges[i];
            while (edge !== null) {
                // If this node is on either side of the edge, recalculate weight
                if (i === index || edge.y === index) {
                    edge.weight = this.positions[i].distanceTo(this.positions[edge.y]);
                }
                edge = edge.next;
            }
        }
    }
    /**
     * Gets the position of a node
     * @param index The index of the node
     * @returns The position of the node
     */
    getNodePosition(index) {
        return this.positions[index];
    }
    /**
     * Adds an edge to this graph between node x and y.
     * Automatically calculates the weight of the edge as the distance between the nodes.
     * @param x The beginning of the edge
     * @param y The end of the edge
     */
    addEdge(x, y) {
        if (!this.positions[x] || !this.positions[y]) {
            throw "Can't add edge to un-positioned node!";
        }
        // Weight is the distance between the nodes
        let weight = this.positions[x].distanceTo(this.positions[y]);
        super.addEdge(x, y, weight);
    }
    // @override
    nodeToString(index) {
        return "Node " + index + " - " + this.positions[index].toString();
    }
    /**
     * Finds the node in the graph with the position closest to the given position
     * @param position the position
     * @returns the node in the graph that is closest to the given position
     */
    snap(position) {
        let n = this.numVertices;
        let i = 1;
        let index = 0;
        let dist = position.distanceSqTo(this.positions[0]);
        while (i < n) {
            let d = position.distanceSqTo(this.positions[i]);
            if (d < dist) {
                dist = d;
                index = i;
            }
            i++;
        }
        return index;
    }
}
exports.default = PositionGraph;

},{"./Graph":13}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isRegion = void 0;
function isRegion(arg) {
    return arg && arg.size && arg.scale && arg.boundary;
}
exports.isRegion = isRegion;

},{}],16:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("./Vec2"));
/** A 4x4 matrix0 */
class Mat4x4 {
    constructor() {
        this.mat = new Float32Array([
            0, 0, 0, 0,
            0, 0, 0, 0,
            0, 0, 0, 0,
            0, 0, 0, 0
        ]);
    }
    // Static members
    static get IDENTITY() {
        return new Mat4x4().identity();
    }
    static get ZERO() {
        return new Mat4x4().zero();
    }
    // Accessors
    set _00(x) {
        this.mat[0] = x;
    }
    set(col, row, value) {
        if (col < 0 || col > 3 || row < 0 || row > 3) {
            throw `Error - index (${col}, ${row}) is out of bounds for Mat4x4`;
        }
        this.mat[row * 4 + col] = value;
        return this;
    }
    get(col, row) {
        return this.mat[row * 4 + col];
    }
    setAll(...items) {
        this.mat.set(items);
        return this;
    }
    identity() {
        return this.setAll(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }
    zero() {
        return this.setAll(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
    /**
     * Makes this Mat4x4 a rotation matrix of the specified number of radians ccw
     * @param zRadians The number of radians to rotate
     * @returns this Mat4x4
     */
    rotate(zRadians) {
        return this.setAll(Math.cos(zRadians), -Math.sin(zRadians), 0, 0, Math.sin(zRadians), Math.cos(zRadians), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }
    /**
     * Turns this Mat4x4 into a translation matrix of the specified translation
     * @param translation The translation in x and y
     * @returns this Mat4x4
     */
    translate(translation) {
        // If translation is a vec, get its array
        if (translation instanceof Vec2_1.default) {
            translation = translation.toArray();
        }
        return this.setAll(1, 0, 0, translation[0], 0, 1, 0, translation[1], 0, 0, 1, 0, 0, 0, 0, 1);
    }
    scale(scale) {
        // Make sure scale is a float32Array
        if (scale instanceof Vec2_1.default) {
            scale = scale.toArray();
        }
        else if (!(scale instanceof Float32Array)) {
            scale = new Float32Array([scale, scale]);
        }
        return this.setAll(scale[0], 0, 0, 0, 0, scale[1], 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }
    /**
     * Returns a new Mat4x4 that represents the right side multiplication THIS x OTHER
     * @param other The other Mat4x4 to multiply by
     * @returns a new Mat4x4 containing the product of these two Mat4x4s
     */
    mult(other, out) {
        let temp = new Float32Array(16);
        for (let i = 0; i < 4; i++) {
            for (let j = 0; j < 4; j++) {
                let value = 0;
                for (let k = 0; k < 4; k++) {
                    value += this.get(k, i) * other.get(j, k);
                }
                temp[j * 4 + i] = value;
            }
        }
        if (out !== undefined) {
            return out.setAll(...temp);
        }
        else {
            return new Mat4x4().setAll(...temp);
        }
    }
    /**
     * Multiplies all given matricies in order. e.g. MULT(A, B, C) -> A*B*C
     * @param mats A list of Mat4x4s to multiply in order
     * @returns A new Mat4x4 holding the result of the operation
     */
    static MULT(...mats) {
        // Create a new array
        let temp = Mat4x4.IDENTITY;
        // Multiply by every array in order, in place
        for (let i = 0; i < mats.length; i++) {
            temp.mult(mats[i], temp);
        }
        return temp;
    }
    toArray() {
        return this.mat;
    }
    toString() {
        return `|${this.mat[0].toFixed(2)}, ${this.mat[1].toFixed(2)}, ${this.mat[2].toFixed(2)}, ${this.mat[3].toFixed(2)}|\n` +
            `|${this.mat[4].toFixed(2)}, ${this.mat[5].toFixed(2)}, ${this.mat[6].toFixed(2)}, ${this.mat[7].toFixed(2)}|\n` +
            `|${this.mat[8].toFixed(2)}, ${this.mat[9].toFixed(2)}, ${this.mat[10].toFixed(2)}, ${this.mat[11].toFixed(2)}|\n` +
            `|${this.mat[12].toFixed(2)}, ${this.mat[13].toFixed(2)}, ${this.mat[14].toFixed(2)}, ${this.mat[15].toFixed(2)}|`;
    }
}
exports.default = Mat4x4;

},{"./Vec2":26}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A class that contains the area of overlap of two colliding objects to allow for sorting by the physics system.
 */
class AreaCollision {
    /**
     * Creates a new AreaCollision object
     * @param area The area of the collision
     * @param collider The other collider
     */
    constructor(area, collider, other, type, tile) {
        this.area = area;
        this.collider = collider;
        this.other = other;
        this.type = type;
        this.tile = tile;
    }
}
exports.default = AreaCollision;

},{}],18:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../Vec2"));
/**
 * An object representing the data collected from a physics hit between two geometric objects.
 * Inspired by the helpful collision documentation @link(here)(https://noonat.github.io/intersect/).
 */
class Hit {
    constructor() {
        /** The near times of the collision */
        this.nearTimes = Vec2_1.default.ZERO;
        /** The position of the collision */
        this.pos = Vec2_1.default.ZERO;
        /** The overlap distance of the hit */
        this.delta = Vec2_1.default.ZERO;
        /** The normal vector of the hit */
        this.normal = Vec2_1.default.ZERO;
    }
}
exports.default = Hit;

},{"../Vec2":26}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** A container for info about a webGL shader program */
class WebGLProgramType {
    /**
     * Deletes this shader program
     */
    delete(gl) {
        // Clean up all aspects of this program
        if (this.program) {
            gl.deleteProgram(this.program);
        }
        if (this.vertexShader) {
            gl.deleteShader(this.vertexShader);
        }
        if (this.fragmentShader) {
            gl.deleteShader(this.fragmentShader);
        }
    }
}
exports.default = WebGLProgramType;

},{}],20:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Shape_1 = __importDefault(require("./Shape"));
const Vec2_1 = __importDefault(require("../Vec2"));
const MathUtils_1 = __importDefault(require("../../Utils/MathUtils"));
const Circle_1 = __importDefault(require("./Circle"));
const Hit_1 = __importDefault(require("../Physics/Hit"));
/**
 * An Axis-Aligned Bounding Box. In other words, a rectangle that is always aligned to the x-y grid.
 * Inspired by the helpful collision documentation @link(here)(https://noonat.github.io/intersect/).
 */
class AABB extends Shape_1.default {
    /**
     * Creates a new AABB
     * @param center The center of the AABB
     * @param halfSize The half size of the AABB - The distance from the center to an edge in x and y
     */
    constructor(center, halfSize) {
        super();
        this.center = center ? center : new Vec2_1.default(0, 0);
        this.halfSize = halfSize ? halfSize : new Vec2_1.default(0, 0);
    }
    /** Returns a point representing the top left corner of the AABB */
    get topLeft() {
        return new Vec2_1.default(this.left, this.top);
    }
    /** Returns a point representing the top right corner of the AABB */
    get topRight() {
        return new Vec2_1.default(this.right, this.top);
    }
    /** Returns a point representing the bottom left corner of the AABB */
    get bottomLeft() {
        return new Vec2_1.default(this.left, this.bottom);
    }
    /** Returns a point representing the bottom right corner of the AABB */
    get bottomRight() {
        return new Vec2_1.default(this.right, this.bottom);
    }
    // @override
    getBoundingRect() {
        return this.clone();
    }
    // @override
    getBoundingCircle() {
        let r = Math.max(this.hw, this.hh);
        return new Circle_1.default(this.center.clone(), r);
    }
    // @deprecated
    getHalfSize() {
        return this.halfSize;
    }
    // @deprecated
    setHalfSize(halfSize) {
        this.halfSize = halfSize;
    }
    // TODO - move these all to the Shape class
    /**
     * A simple boolean check of whether this AABB contains a point
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    containsPoint(point) {
        return point.x >= this.x - this.hw && point.x <= this.x + this.hw
            && point.y >= this.y - this.hh && point.y <= this.y + this.hh;
    }
    /**
     * A simple boolean check of whether this AABB contains a point
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    intersectPoint(point) {
        let dx = point.x - this.x;
        let px = this.hw - Math.abs(dx);
        if (px <= 0) {
            return false;
        }
        let dy = point.y - this.y;
        let py = this.hh - Math.abs(dy);
        if (py <= 0) {
            return false;
        }
        return true;
    }
    /**
     * A boolean check of whether this AABB contains a point with soft left and top boundaries.
     * In other words, if the top left is (0, 0), the point (0, 0) is not in the AABB
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    containsPointSoft(point) {
        return point.x > this.x - this.hw && point.x <= this.x + this.hw
            && point.y > this.y - this.hh && point.y <= this.y + this.hh;
    }
    /**
     * Returns the data from the intersection of this AABB with a line segment from a point in a direction
     * @param point The point that the line segment starts from
     * @param delta The direction and distance of the segment
     * @param padding Pads the AABB to make it wider for the intersection test
     * @returns The Hit object representing the intersection, or null if there was no intersection
     */
    intersectSegment(point, delta, padding) {
        let paddingX = padding ? padding.x : 0;
        let paddingY = padding ? padding.y : 0;
        let scaleX = 1 / delta.x;
        let scaleY = 1 / delta.y;
        let signX = MathUtils_1.default.sign(scaleX);
        let signY = MathUtils_1.default.sign(scaleY);
        let tnearx = scaleX * (this.x - signX * (this.hw + paddingX) - point.x);
        let tneary = scaleY * (this.y - signY * (this.hh + paddingY) - point.y);
        let tfarx = scaleX * (this.x + signX * (this.hw + paddingX) - point.x);
        let tfary = scaleY * (this.y + signY * (this.hh + paddingY) - point.y);
        if (tnearx > tfary || tneary > tfarx) {
            // We aren't colliding - we clear one axis before intersecting another
            return null;
        }
        let tnear = Math.max(tnearx, tneary);
        // Double check for NaNs
        if (tnearx !== tnearx) {
            tnear = tneary;
        }
        else if (tneary !== tneary) {
            tnear = tnearx;
        }
        let tfar = Math.min(tfarx, tfary);
        if (tnear === -Infinity) {
            return null;
        }
        if (tnear >= 1 || tfar <= 0) {
            return null;
        }
        // We are colliding
        let hit = new Hit_1.default();
        hit.time = MathUtils_1.default.clamp01(tnear);
        hit.nearTimes.x = tnearx;
        hit.nearTimes.y = tneary;
        if (tnearx > tneary) {
            // We hit on the left or right size
            hit.normal.x = -signX;
            hit.normal.y = 0;
        }
        else if (Math.abs(tnearx - tneary) < 0.0001) {
            // We hit on the corner
            hit.normal.x = -signX;
            hit.normal.y = -signY;
            hit.normal.normalize();
        }
        else {
            // We hit on the top or bottom
            hit.normal.x = 0;
            hit.normal.y = -signY;
        }
        hit.delta.x = (1.0 - hit.time) * -delta.x;
        hit.delta.y = (1.0 - hit.time) * -delta.y;
        hit.pos.x = point.x + delta.x * hit.time;
        hit.pos.y = point.y + delta.y * hit.time;
        return hit;
    }
    // @override
    overlaps(other) {
        if (other instanceof AABB) {
            return this.overlapsAABB(other);
        }
        throw "Overlap not defined between these shapes.";
    }
    /**
     * A simple boolean check of whether this AABB overlaps another
     * @param other The other AABB to check against
     * @returns True if this AABB overlaps the other, false otherwise
     */
    overlapsAABB(other) {
        let dx = other.x - this.x;
        let px = this.hw + other.hw - Math.abs(dx);
        if (px <= 0) {
            return false;
        }
        let dy = other.y - this.y;
        let py = this.hh + other.hh - Math.abs(dy);
        if (py <= 0) {
            return false;
        }
        return true;
    }
    /**
     * Determines whether these AABBs are JUST touching - not overlapping.
     * Vec2.x is -1 if the other is to the left, 1 if to the right.
     * Likewise, Vec2.y is -1 if the other is on top, 1 if on bottom.
     * @param other The other AABB to check
     * @returns The collision sides stored in a Vec2 if the AABBs are touching, null otherwise
     */
    touchesAABB(other) {
        let dx = other.x - this.x;
        let px = this.hw + other.hw - Math.abs(dx);
        let dy = other.y - this.y;
        let py = this.hh + other.hh - Math.abs(dy);
        // If one axis is just touching and the other is overlapping, true
        if ((px === 0 && py >= 0) || (py === 0 && px >= 0)) {
            let ret = new Vec2_1.default();
            if (px === 0) {
                ret.x = other.x < this.x ? -1 : 1;
            }
            if (py === 0) {
                ret.y = other.y < this.y ? -1 : 1;
            }
            return ret;
        }
        else {
            return null;
        }
    }
    /**
     * Determines whether these AABBs are JUST touching - not overlapping.
     * Also, if they are only touching corners, they are considered not touching.
     * Vec2.x is -1 if the other is to the left, 1 if to the right.
     * Likewise, Vec2.y is -1 if the other is on top, 1 if on bottom.
     * @param other The other AABB to check
     * @returns The side of the touch, stored as a Vec2, or null if there is no touch
     */
    touchesAABBWithoutCorners(other) {
        let dx = other.x - this.x;
        let px = this.hw + other.hw - Math.abs(dx);
        let dy = other.y - this.y;
        let py = this.hh + other.hh - Math.abs(dy);
        // If one axis is touching, and the other is strictly overlapping
        if ((px === 0 && py > 0) || (py === 0 && px > 0)) {
            let ret = new Vec2_1.default();
            if (px === 0) {
                ret.x = other.x < this.x ? -1 : 1;
            }
            else {
                ret.y = other.y < this.y ? -1 : 1;
            }
            return ret;
        }
        else {
            return null;
        }
    }
    /**
     * Calculates the area of the overlap between this AABB and another
     * @param other The other AABB
     * @returns The area of the overlap between the AABBs
     */
    overlapArea(other) {
        let leftx = Math.max(this.x - this.hw, other.x - other.hw);
        let rightx = Math.min(this.x + this.hw, other.x + other.hw);
        let dx = rightx - leftx;
        let lefty = Math.max(this.y - this.hh, other.y - other.hh);
        let righty = Math.min(this.y + this.hh, other.y + other.hh);
        let dy = righty - lefty;
        if (dx < 0 || dy < 0)
            return 0;
        return dx * dy;
    }
    /**
     * Moves and resizes this rect from its current position to the position specified
     * @param velocity The movement of the rect from its position
     * @param fromPosition A position specified to be the starting point of sweeping
     * @param halfSize The halfSize of the sweeping rect
     */
    sweep(velocity, fromPosition, halfSize) {
        if (!fromPosition) {
            fromPosition = this.center;
        }
        if (!halfSize) {
            halfSize = this.halfSize;
        }
        let centerX = fromPosition.x + velocity.x / 2;
        let centerY = fromPosition.y + velocity.y / 2;
        let minX = Math.min(fromPosition.x - halfSize.x, fromPosition.x + velocity.x - halfSize.x);
        let minY = Math.min(fromPosition.y - halfSize.y, fromPosition.y + velocity.y - halfSize.y);
        this.center.set(centerX, centerY);
        this.halfSize.set(centerX - minX, centerY - minY);
    }
    // @override
    clone() {
        return new AABB(this.center.clone(), this.halfSize.clone());
    }
    /**
     * Converts this AABB to a string format
     * @returns (center: (x, y), halfSize: (x, y))
     */
    toString() {
        return "(center: " + this.center.toString() + ", half-size: " + this.halfSize.toString() + ")";
    }
}
exports.default = AABB;

},{"../../Utils/MathUtils":109,"../Physics/Hit":18,"../Vec2":26,"./Circle":21,"./Shape":22}],21:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../Vec2"));
const AABB_1 = __importDefault(require("./AABB"));
const Shape_1 = __importDefault(require("./Shape"));
/**
 * A Circle
 */
class Circle extends Shape_1.default {
    /**
     * Creates a new Circle
     * @param center The center of the circle
     * @param radius The radius of the circle
     */
    constructor(center, radius) {
        super();
        this._center = center ? center : new Vec2_1.default(0, 0);
        this.radius = radius ? radius : 0;
    }
    get center() {
        return this._center;
    }
    set center(center) {
        this._center = center;
    }
    get halfSize() {
        return new Vec2_1.default(this.radius, this.radius);
    }
    get r() {
        return this.radius;
    }
    set r(radius) {
        this.radius = radius;
    }
    // @override
    /**
     * A simple boolean check of whether this AABB contains a point
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    containsPoint(point) {
        return this.center.distanceSqTo(point) <= this.radius * this.radius;
    }
    // @override
    getBoundingRect() {
        return new AABB_1.default(this._center.clone(), new Vec2_1.default(this.radius, this.radius));
    }
    // @override
    getBoundingCircle() {
        return this.clone();
    }
    // @override
    overlaps(other) {
        throw new Error("Method not implemented.");
    }
    // @override
    clone() {
        return new Circle(this._center.clone(), this.radius);
    }
    toString() {
        return "(center: " + this.center.toString() + ", radius: " + this.radius + ")";
    }
}
exports.default = Circle;

},{"../Vec2":26,"./AABB":20,"./Shape":22}],22:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../Vec2"));
const AABB_1 = __importDefault(require("./AABB"));
/**
 * An abstract Shape class that acts as an interface for better interactions with subclasses.
 */
class Shape {
    get x() {
        return this.center.x;
    }
    get y() {
        return this.center.y;
    }
    get hw() {
        return this.halfSize.x;
    }
    get hh() {
        return this.halfSize.y;
    }
    get top() {
        return this.y - this.hh;
    }
    get bottom() {
        return this.y + this.hh;
    }
    get left() {
        return this.x - this.hw;
    }
    get right() {
        return this.x + this.hw;
    }
    static getTimeOfCollision(A, velA, B, velB) {
        if (A instanceof AABB_1.default && B instanceof AABB_1.default) {
            return Shape.getTimeOfCollision_AABB_AABB(A, velA, B, velB);
        }
    }
    static getTimeOfCollision_AABB_AABB(A, velA, B, velB) {
        let posSmaller = A.center;
        let posLarger = B.center;
        let sizeSmaller = A.halfSize;
        let sizeLarger = B.halfSize;
        let firstContact = new Vec2_1.default(0, 0);
        let lastContact = new Vec2_1.default(0, 0);
        let collidingX = false;
        let collidingY = false;
        // Sort by position
        if (posLarger.x < posSmaller.x) {
            // Swap, because smaller is further right than larger
            let temp;
            temp = sizeSmaller;
            sizeSmaller = sizeLarger;
            sizeLarger = temp;
            temp = posSmaller;
            posSmaller = posLarger;
            posLarger = temp;
            temp = velA;
            velA = velB;
            velB = temp;
        }
        // A is left, B is right
        firstContact.x = Infinity;
        lastContact.x = Infinity;
        if (posLarger.x - sizeLarger.x >= posSmaller.x + sizeSmaller.x) {
            // If we aren't currently colliding
            let relVel = velA.x - velB.x;
            if (relVel > 0) {
                // If they are moving towards each other
                firstContact.x = ((posLarger.x - sizeLarger.x) - (posSmaller.x + sizeSmaller.x)) / (relVel);
                lastContact.x = ((posLarger.x + sizeLarger.x) - (posSmaller.x - sizeSmaller.x)) / (relVel);
            }
        }
        else {
            collidingX = true;
        }
        if (posLarger.y < posSmaller.y) {
            // Swap, because smaller is further up than larger
            let temp;
            temp = sizeSmaller;
            sizeSmaller = sizeLarger;
            sizeLarger = temp;
            temp = posSmaller;
            posSmaller = posLarger;
            posLarger = temp;
            temp = velA;
            velA = velB;
            velB = temp;
        }
        // A is top, B is bottom
        firstContact.y = Infinity;
        lastContact.y = Infinity;
        if (posLarger.y - sizeLarger.y >= posSmaller.y + sizeSmaller.y) {
            // If we aren't currently colliding
            let relVel = velA.y - velB.y;
            if (relVel > 0) {
                // If they are moving towards each other
                firstContact.y = ((posLarger.y - sizeLarger.y) - (posSmaller.y + sizeSmaller.y)) / (relVel);
                lastContact.y = ((posLarger.y + sizeLarger.y) - (posSmaller.y - sizeSmaller.y)) / (relVel);
            }
        }
        else {
            collidingY = true;
        }
        return [firstContact, lastContact, collidingX, collidingY];
    }
}
exports.default = Shape;

},{"../Vec2":26,"./AABB":20}],23:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Emitter_1 = __importDefault(require("../../Events/Emitter"));
/**
 * An abstract implementation of a state for a @reference[StateMachine].
 * This class should be extended to allow for custom state behaviors.
 */
class State {
    /**
     * Constructs a new State
     * @param parent The parent StateMachine of this state
     */
    constructor(parent) {
        this.parent = parent;
        this.emitter = new Emitter_1.default();
    }
    /**
     * Tells the state machine that this state has ended, and makes it transition to the new state specified
     * @param stateName The name of the state to transition to
     */
    finished(stateName) {
        this.parent.changeState(stateName);
    }
}
exports.default = State;

},{"../../Events/Emitter":29}],24:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Stack_1 = __importDefault(require("../Collections/Stack"));
const Map_1 = __importDefault(require("../Collections/Map"));
const Receiver_1 = __importDefault(require("../../Events/Receiver"));
const Emitter_1 = __importDefault(require("../../Events/Emitter"));
/**
 * An implementation of a Push Down Automata State machine. States can also be hierarchical
 * for more flexibility, as described in @link(Game Programming Patterns)(https://gameprogrammingpatterns.com/state.html).
 */
class StateMachine {
    /**
     * Creates a new StateMachine
     */
    constructor() {
        this.stack = new Stack_1.default();
        this.stateMap = new Map_1.default();
        this.receiver = new Receiver_1.default();
        this.emitter = new Emitter_1.default();
        this.emitEventOnStateChange = false;
    }
    /**
     * Sets the activity state of this state machine
     * @param flag True if you want to set this machine running, false otherwise
     */
    setActive(flag) {
        this.active = flag;
    }
    /**
     * Makes this state machine emit an event any time its state changes
     * @param stateChangeEventName The name of the event to emit
     */
    setEmitEventOnStateChange(stateChangeEventName) {
        this.emitEventOnStateChange = true;
        this.stateChangeEventName = stateChangeEventName;
    }
    /**
     * Stops this state machine from emitting events on state change.
     */
    cancelEmitEventOnStateChange() {
        this.emitEventOnStateChange = false;
    }
    /**
     * Initializes this state machine with an initial state and sets it running
     * @param initialState The name of initial state of the state machine
     */
    initialize(initialState, options) {
        this.stack.push(this.stateMap.get(initialState));
        this.currentState = this.stack.peek();
        this.currentState.onEnter(options);
        this.setActive(true);
    }
    /**
     * Adds a state to this state machine
     * @param stateName The name of the state to add
     * @param state The state to add
     */
    addState(stateName, state) {
        this.stateMap.add(stateName, state);
    }
    /**
     * Changes the state of this state machine to the provided string
     * @param state The string name of the state to change to
     */
    changeState(state) {
        // Exit the current state
        let options = this.currentState.onExit();
        // Make sure the correct state is at the top of the stack
        if (state === "previous") {
            // Pop the current state off the stack
            this.stack.pop();
        }
        else {
            // Retrieve the new state from the statemap and put it at the top of the stack
            this.stack.pop();
            this.stack.push(this.stateMap.get(state));
        }
        // Retreive the new state from the stack
        this.currentState = this.stack.peek();
        // Emit an event if turned on
        if (this.emitEventOnStateChange) {
            this.emitter.fireEvent(this.stateChangeEventName, { state: this.currentState });
        }
        // Enter the new state
        this.currentState.onEnter(options);
    }
    /**
     * Handles input. This happens at the very beginning of this state machine's update cycle.
     * @param event The game event to process
     */
    handleEvent(event) {
        if (this.active) {
            this.currentState.handleInput(event);
        }
    }
    // @implemented
    update(deltaT) {
        // Distribute events
        while (this.receiver.hasNextEvent()) {
            let event = this.receiver.getNextEvent();
            this.handleEvent(event);
        }
        // Delegate the update to the current state
        this.currentState.update(deltaT);
    }
}
exports.default = StateMachine;

},{"../../Events/Emitter":29,"../../Events/Receiver":33,"../Collections/Map":8,"../Collections/Stack":10}],25:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = __importDefault(require("../../ResourceManager/ResourceManager"));
const Vec2_1 = __importDefault(require("../Vec2"));
/**
 * The data representation of a Tileset for the game engine. This represents one image,
 * with a startIndex if required (as it is with Tiled using two images in one tilset).
 */
class Tileset {
    // TODO: Change this to be more general and work with other tileset formats
    constructor(tilesetData) {
        // Defer handling of the data to a helper class
        this.initFromTiledData(tilesetData);
    }
    /**
     * Initialize the tileset from the data from a Tiled json file
     * @param tiledData The parsed object from a Tiled json file
     */
    initFromTiledData(tiledData) {
        this.numRows = tiledData.tilecount / tiledData.columns;
        this.numCols = tiledData.columns;
        this.startIndex = tiledData.firstgid;
        this.endIndex = this.startIndex + tiledData.tilecount - 1;
        this.tileSize = new Vec2_1.default(tiledData.tilewidth, tiledData.tilewidth);
        this.imageKey = tiledData.image;
        this.imageSize = new Vec2_1.default(tiledData.imagewidth, tiledData.imageheight);
    }
    /**
     * Gets the image key associated with this tilemap
     * @returns The image key of this tilemap
     */
    getImageKey() {
        return this.imageKey;
    }
    /**
     * Returns a Vec2 containing the left and top offset from the image origin for this tile.
     * @param tileIndex The index of the tile from startIndex to endIndex of this tileset
     * @returns A Vec2 containing the offset for the specified tile.
     */
    getImageOffsetForTile(tileIndex) {
        // Get the true index
        let index = tileIndex - this.startIndex;
        let row = Math.floor(index / this.numCols);
        let col = index % this.numCols;
        let width = this.tileSize.x;
        let height = this.tileSize.y;
        // Calculate the position to start a crop in the tileset image
        let left = col * width;
        let top = row * height;
        return new Vec2_1.default(left, top);
    }
    /**
     * Gets the start index
     * @returns The start index
     */
    getStartIndex() {
        return this.startIndex;
    }
    /**
     * Gets the tile set
     * @returns A Vec2 containing the tile size
     */
    getTileSize() {
        return this.tileSize;
    }
    /**
     * Gets the number of rows in the tileset
     * @returns The number of rows
     */
    getNumRows() {
        return this.numRows;
    }
    /**
     * Gets the number of columns in the tilset
     * @returns The number of columns
     */
    getNumCols() {
        return this.numCols;
    }
    getTileCount() {
        return this.endIndex - this.startIndex + 1;
    }
    /**
     * Checks whether or not this tilset contains the specified tile index. This is used for rendering.
     * @param tileIndex The index of the tile to check
     * @returns A boolean representing whether or not this tilset uses the specified index
     */
    hasTile(tileIndex) {
        return tileIndex >= this.startIndex && tileIndex <= this.endIndex;
    }
    /**
     * Render a singular tile with index tileIndex from the tileset located at position dataIndex
     * @param ctx The rendering context
     * @param tileIndex The value of the tile to render
     * @param dataIndex The index of the tile in the data array
     * @param worldSize The size of the world
     * @param origin The viewport origin in the current layer
     * @param scale The scale of the tilemap
     */
    renderTile(ctx, tileIndex, dataIndex, maxCols, origin, scale, zoom) {
        let image = ResourceManager_1.default.getInstance().getImage(this.imageKey);
        // Get the true index
        let index = tileIndex - this.startIndex;
        let row = Math.floor(index / this.numCols);
        let col = index % this.numCols;
        let width = this.tileSize.x;
        let height = this.tileSize.y;
        // Calculate the position to start a crop in the tileset image
        let left = col * width;
        let top = row * height;
        // Calculate the position in the world to render the tile
        let x = Math.floor((dataIndex % maxCols) * width * scale.x);
        let y = Math.floor(Math.floor(dataIndex / maxCols) * height * scale.y);
        ctx.drawImage(image, left, top, width, height, Math.floor((x - origin.x) * zoom), Math.floor((y - origin.y) * zoom), Math.ceil(width * scale.x * zoom), Math.ceil(height * scale.y * zoom));
    }
}
exports.default = Tileset;

},{"../../ResourceManager/ResourceManager":90,"../Vec2":26}],26:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = __importDefault(require("../Utils/MathUtils"));
/**
 * A two-dimensional vector (x, y)
 */
class Vec2 {
    /**
     * Creates a new Vec2
     * @param x The x value of the vector
     * @param y The y value of the vector
     */
    constructor(x = 0, y = 0) {
        /**
         * When this vector changes its value, do something
         */
        this.onChange = () => { };
        this.vec = new Float32Array(2);
        this.vec[0] = x;
        this.vec[1] = y;
    }
    // Expose x and y with getters and setters
    get x() {
        return this.vec[0];
    }
    set x(x) {
        this.vec[0] = x;
        if (this.onChange) {
            this.onChange();
        }
    }
    get y() {
        return this.vec[1];
    }
    set y(y) {
        this.vec[1] = y;
        if (this.onChange) {
            this.onChange();
        }
    }
    static get ZERO() {
        return new Vec2(0, 0);
    }
    static get INF() {
        return new Vec2(Infinity, Infinity);
    }
    static get UP() {
        return new Vec2(0, -1);
    }
    static get DOWN() {
        return new Vec2(0, 1);
    }
    static get LEFT() {
        return new Vec2(-1, 0);
    }
    static get RIGHT() {
        return new Vec2(1, 0);
    }
    /**
     * The squared magnitude of the vector. This tends to be faster, so use it in situations where taking the
     * square root doesn't matter, like for comparing distances.
     * @returns The squared magnitude of the vector
     */
    magSq() {
        return this.x * this.x + this.y * this.y;
    }
    /**
     * The magnitude of the vector.
     * @returns The magnitude of the vector.
     */
    mag() {
        return Math.sqrt(this.magSq());
    }
    /**
     * Divdes x and y by the magnitude to obtain the unit vector in the direction of this vector.
     * @returns This vector as a unit vector.
     */
    normalize() {
        if (this.x === 0 && this.y === 0)
            return this;
        let mag = this.mag();
        this.x /= mag;
        this.y /= mag;
        return this;
    }
    /**
     * Works like normalize(), but returns a new Vec2
     * @returns A new vector that is the unit vector for this one
     */
    normalized() {
        if (this.isZero()) {
            return this;
        }
        let mag = this.mag();
        return new Vec2(this.x / mag, this.y / mag);
    }
    /**
     * Sets the x and y elements of this vector to zero.
     * @returns This vector, with x and y set to zero.
     */
    zero() {
        return this.set(0, 0);
    }
    /**
     * Sets the vector's x and y based on the angle provided. Goes counter clockwise.
     * @param angle The angle in radians
     * @param radius The magnitude of the vector at the specified angle
     * @returns This vector.
     */
    setToAngle(angle, radius = 1) {
        this.x = MathUtils_1.default.floorToPlace(Math.cos(angle) * radius, 5);
        this.y = MathUtils_1.default.floorToPlace(-Math.sin(angle) * radius, 5);
        return this;
    }
    /**
     * Returns a vector that point from this vector to another one
     * @param other The vector to point to
     * @returns A new Vec2 that points from this vector to the one provided
     */
    vecTo(other) {
        return new Vec2(other.x - this.x, other.y - this.y);
    }
    /**
     * Returns a vector containing the direction from this vector to another
     * @param other The vector to point to
     * @returns A new Vec2 that points from this vector to the one provided. This new Vec2 will be a unit vector.
     */
    dirTo(other) {
        return this.vecTo(other).normalize();
    }
    /**
     * Keeps the vector's direction, but sets its magnitude to be the provided magnitude
     * @param magnitude The magnitude the vector should be
     * @returns This vector with its magnitude set to the new magnitude
     */
    scaleTo(magnitude) {
        return this.normalize().scale(magnitude);
    }
    /**
     * Scales x and y by the number provided, or if two number are provided, scales them individually.
     * @param factor The scaling factor for the vector, or for only the x-component if yFactor is provided
     * @param yFactor The scaling factor for the y-component of the vector
     * @returns This vector after scaling
     */
    scale(factor, yFactor = null) {
        if (yFactor !== null) {
            this.x *= factor;
            this.y *= yFactor;
            return this;
        }
        this.x *= factor;
        this.y *= factor;
        return this;
    }
    /**
     * Returns a scaled version of this vector without modifying it.
     * @param factor The scaling factor for the vector, or for only the x-component if yFactor is provided
     * @param yFactor The scaling factor for the y-component of the vector
     * @returns A new vector that has the values of this vector after scaling
     */
    scaled(factor, yFactor = null) {
        return this.clone().scale(factor, yFactor);
    }
    /**
     * Rotates the vector counter-clockwise by the angle amount specified
     * @param angle The angle to rotate by in radians
     * @returns This vector after rotation.
     */
    rotateCCW(angle) {
        let cs = Math.cos(angle);
        let sn = Math.sin(angle);
        let tempX = this.x * cs - this.y * sn;
        let tempY = this.x * sn + this.y * cs;
        this.x = tempX;
        this.y = tempY;
        return this;
    }
    /**
     * Sets the vectors coordinates to be the ones provided
     * @param x The new x value for this vector
     * @param y The new y value for this vector
     * @returns This vector
     */
    set(x, y) {
        this.x = x;
        this.y = y;
        return this;
    }
    /**
     * Copies the values of the other Vec2 into this one.
     * @param other The Vec2 to copy
     * @returns This vector with its values set to the vector provided
     */
    copy(other) {
        return this.set(other.x, other.y);
    }
    /**
     * Adds this vector the another vector
     * @param other The Vec2 to add to this one
     * @returns This vector after adding the one provided
     */
    add(other) {
        this.x += other.x;
        this.y += other.y;
        return this;
    }
    /**
     * Increments the fields of this vector. Both are incremented with a, if only a is provided.
     * @param a The first number to increment by
     * @param b The second number to increment by
     * @returnss This vector after incrementing
     */
    inc(a, b) {
        if (b === undefined) {
            this.x += a;
            this.y += a;
        }
        else {
            this.x += a;
            this.y += b;
        }
        return this;
    }
    /**
     * Subtracts another vector from this vector
     * @param other The Vec2 to subtract from this one
     * @returns This vector after subtracting the one provided
     */
    sub(other) {
        this.x -= other.x;
        this.y -= other.y;
        return this;
    }
    /**
     * Multiplies this vector with another vector element-wise. In other words, this.x *= other.x and this.y *= other.y
     * @param other The Vec2 to multiply this one by
     * @returns This vector after multiplying its components by this one
     */
    mult(other) {
        this.x *= other.x;
        this.y *= other.y;
        return this;
    }
    /**
     * Divides this vector with another vector element-wise. In other words, this.x /= other.x and this.y /= other.y
     * @param other The vector to divide this one by
     * @returns This vector after division
     */
    div(other) {
        if (other.x === 0 || other.y === 0)
            throw "Divide by zero error";
        this.x /= other.x;
        this.y /= other.y;
        return this;
    }
    /**
     * Does an element wise remainder operation on this vector. this.x %= other.x and this.y %= other.y
     * @param other The other vector
     * @returns this vector
     */
    remainder(other) {
        this.x = this.x % other.x;
        this.y = this.y % other.y;
        return this;
    }
    /**
     * Returns the squared distance between this vector and another vector
     * @param other The vector to compute distance squared to
     * @returns The squared distance between this vector and the one provided
     */
    distanceSqTo(other) {
        return (this.x - other.x) * (this.x - other.x) + (this.y - other.y) * (this.y - other.y);
    }
    /**
     * Returns the distance between this vector and another vector
     * @param other The vector to compute distance to
     * @returns The distance between this vector and the one provided
     */
    distanceTo(other) {
        return Math.sqrt(this.distanceSqTo(other));
    }
    /**
     * Returns the dot product of this vector and another
     * @param other The vector to compute the dot product with
     * @returns The dot product of this vector and the one provided.
     */
    dot(other) {
        return this.x * other.x + this.y * other.y;
    }
    /**
     * Returns the angle counter-clockwise in radians from this vector to another vector
     * @param other The vector to compute the angle to
     * @returns The angle, rotating CCW, from this vector to the other vector
     */
    angleToCCW(other) {
        let dot = this.dot(other);
        let det = this.x * other.y - this.y * other.x;
        let angle = -Math.atan2(det, dot);
        if (angle < 0) {
            angle += 2 * Math.PI;
        }
        return angle;
    }
    /**
     * Returns a string representation of this vector rounded to 1 decimal point
     * @returns This vector as a string
     */
    toString() {
        return this.toFixed();
    }
    /**
     * Returns a string representation of this vector rounded to the specified number of decimal points
     * @param numDecimalPoints The number of decimal points to create a string to
     * @returns This vector as a string
     */
    toFixed(numDecimalPoints = 1) {
        return "(" + this.x.toFixed(numDecimalPoints) + ", " + this.y.toFixed(numDecimalPoints) + ")";
    }
    /**
     * Returns a new vector with the same coordinates as this one.
     * @returns A new Vec2 with the same values as this one
     */
    clone() {
        return new Vec2(this.x, this.y);
    }
    /**
     * Returns true if this vector and other have the EXACT same x and y (not assured to be safe for floats)
     * @param other The vector to check against
     * @returns A boolean representing the equality of the two vectors
     */
    strictEquals(other) {
        return this.x === other.x && this.y === other.y;
    }
    /**
     * Returns true if this vector and other have the same x and y
     * @param other The vector to check against
     * @returns A boolean representing the equality of the two vectors
     */
    equals(other) {
        let xEq = Math.abs(this.x - other.x) < 0.0000001;
        let yEq = Math.abs(this.y - other.y) < 0.0000001;
        return xEq && yEq;
    }
    /**
     * Returns true if this vector is the zero vector exactly (not assured to be safe for floats).
     * @returns A boolean representing the equality of this vector and the zero vector
     */
    strictIsZero() {
        return this.x === 0 && this.y === 0;
    }
    /**
     * Returns true if this x and y for this vector are both zero.
     * @returns A boolean representing the equality of this vector and the zero vector
     */
    isZero() {
        return Math.abs(this.x) < 0.0000001 && Math.abs(this.y) < 0.0000001;
    }
    /**
     * Sets the function that is called whenever this vector is changed.
     * @param f The function to be called
     */
    setOnChange(f) {
        this.onChange = f;
    }
    toArray() {
        return this.vec;
    }
    /**
     * Performs linear interpolation between two vectors
     * @param a The first vector
     * @param b The second vector
     * @param t The time of the lerp, with 0 being vector A, and 1 being vector B
     * @returns A new Vec2 representing the lerp between vector a and b.
     */
    static lerp(a, b, t) {
        return new Vec2(MathUtils_1.default.lerp(a.x, b.x, t), MathUtils_1.default.lerp(a.y, b.y, t));
    }
}
exports.default = Vec2;
Vec2.ZERO_STATIC = new Vec2(0, 0);

},{"../Utils/MathUtils":109}],27:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = __importDefault(require("../DataTypes/Collections/Map"));
const Vec2_1 = __importDefault(require("../DataTypes/Vec2"));
const Color_1 = __importDefault(require("../Utils/Color"));
/**
 * A util class for rendering Debug messages to the canvas.
 */
class Debug {
    /**
     * Add a message to display on the debug screen
     * @param id A unique ID for this message
     * @param messages The messages to print to the debug screen
     */
    static log(id, ...messages) {
        // let message = "";
        // for(let i = 0; i < messages.length; i++){
        // 	message += messages[i].toString();
        // }
        // Join all messages with spaces
        let message = messages.map((m) => m.toString()).join(" ");
        this.logMessages.add(id, message);
    }
    /**
     * Deletes a a key from the log and stops it from keeping up space on the screen
     * @param id The id of the log item to clear
     */
    static clearLogItem(id) {
        this.logMessages.delete(id);
    }
    /**
     * Sets the list of nodes to render with the debugger
     * @param nodes The new list of nodes
     */
    static setNodes(nodes) {
        this.nodes = nodes;
    }
    /**
     * Draws a box at the specified position
     * @param center The center of the box
     * @param halfSize The dimensions of the box
     * @param filled A boolean for whether or not the box is filled
     * @param color The color of the box to draw
     */
    static drawBox(center, halfSize, filled, color) {
        let alpha = this.debugRenderingContext.globalAlpha;
        this.debugRenderingContext.globalAlpha = color.a;
        if (filled) {
            this.debugRenderingContext.fillStyle = color.toString();
            this.debugRenderingContext.fillRect(center.x - halfSize.x, center.y - halfSize.y, halfSize.x * 2, halfSize.y * 2);
        }
        else {
            let lineWidth = 2;
            this.debugRenderingContext.lineWidth = lineWidth;
            this.debugRenderingContext.strokeStyle = color.toString();
            this.debugRenderingContext.strokeRect(center.x - halfSize.x, center.y - halfSize.y, halfSize.x * 2, halfSize.y * 2);
        }
        this.debugRenderingContext.globalAlpha = alpha;
    }
    /**
     * Draws a circle at the specified position
     * @param center The center of the circle
     * @param radius The dimensions of the box
     * @param filled A boolean for whether or not the circle is filled
     * @param color The color of the circle
     */
    static drawCircle(center, radius, filled, color) {
        let alpha = this.debugRenderingContext.globalAlpha;
        this.debugRenderingContext.globalAlpha = color.a;
        if (filled) {
            this.debugRenderingContext.fillStyle = color.toString();
            this.debugRenderingContext.beginPath();
            this.debugRenderingContext.arc(center.x, center.y, radius, 0, 2 * Math.PI);
            this.debugRenderingContext.closePath();
            this.debugRenderingContext.fill();
        }
        else {
            let lineWidth = 2;
            this.debugRenderingContext.lineWidth = lineWidth;
            this.debugRenderingContext.strokeStyle = color.toString();
            this.debugRenderingContext.beginPath();
            this.debugRenderingContext.arc(center.x, center.y, radius, 0, 2 * Math.PI);
            this.debugRenderingContext.closePath();
            this.debugRenderingContext.stroke();
        }
        this.debugRenderingContext.globalAlpha = alpha;
    }
    /**
     * Draws a ray at the specified position
     * @param from The starting position of the ray
     * @param to The ending position of the ray
     * @param color The color of the ray
     */
    static drawRay(from, to, color) {
        this.debugRenderingContext.lineWidth = 2;
        this.debugRenderingContext.strokeStyle = color.toString();
        this.debugRenderingContext.beginPath();
        this.debugRenderingContext.moveTo(from.x, from.y);
        this.debugRenderingContext.lineTo(to.x, to.y);
        this.debugRenderingContext.closePath();
        this.debugRenderingContext.stroke();
    }
    /**
     * Draws a point at the specified position
     * @param pos The position of the point
     * @param color The color of the point
     */
    static drawPoint(pos, color) {
        let pointSize = 6;
        this.debugRenderingContext.fillStyle = color.toString();
        this.debugRenderingContext.fillRect(pos.x - pointSize / 2, pos.y - pointSize / 2, pointSize, pointSize);
    }
    /**
     * Sets the default rendering color for text for the debugger
     * @param color The color to render the text
     */
    static setDefaultTextColor(color) {
        this.defaultTextColor = color;
    }
    /**
     * Performs any necessary setup operations on the Debug canvas
     * @param canvas The debug canvas
     * @param width The desired width of the canvas
     * @param height The desired height of the canvas
     * @returns The rendering context extracted from the canvas
     */
    static initializeDebugCanvas(canvas, width, height) {
        canvas.width = width;
        canvas.height = height;
        this.debugCanvasSize = new Vec2_1.default(width, height);
        this.debugRenderingContext = canvas.getContext("2d");
        return this.debugRenderingContext;
    }
    /** Clears the debug canvas */
    static clearCanvas() {
        this.debugRenderingContext.clearRect(0, 0, this.debugCanvasSize.x, this.debugCanvasSize.y);
    }
    /** Renders the text and nodes sent to the Debug system */
    static render() {
        this.renderText();
        this.renderNodes();
    }
    /** Renders the text sent to the Debug canvas */
    static renderText() {
        let y = 20;
        this.debugRenderingContext.font = "20px Arial";
        this.debugRenderingContext.fillStyle = this.defaultTextColor.toString();
        // Draw all of the text
        this.logMessages.forEach((key) => {
            this.debugRenderingContext.fillText(this.logMessages.get(key), 10, y);
            y += 30;
        });
    }
    /** Renders the nodes registered with the debug canvas */
    static renderNodes() {
        if (this.nodes) {
            this.nodes.forEach(node => {
                node.debugRender();
            });
        }
    }
}
exports.default = Debug;
/** A map of log messages to display on the screen */
Debug.logMessages = new Map_1.default();
/** The rendering color for text */
Debug.defaultTextColor = Color_1.default.WHITE;

},{"../DataTypes/Collections/Map":8,"../DataTypes/Vec2":26,"../Utils/Color":106}],28:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Color_1 = __importDefault(require("../Utils/Color"));
// @ignorePage
class Stats extends Object {
    static initStats() {
        let canvas = document.getElementById("stats-canvas");
        canvas.width = this.CANVAS_WIDTH;
        canvas.height = this.CANVAS_HEIGHT;
        this.ctx = canvas.getContext("2d");
        this.statsDiv = document.getElementById("stats-display");
        this.prevfps = new Array();
        this.prevClearTimes = new Array();
        this.SGClearTimes = new Array();
        this.avgSGClearTime = 0;
        this.prevFillTimes = new Array();
        this.SGFillTimes = new Array();
        this.avgSGFillTime = 0;
        this.prevUpdateTimes = new Array();
        this.SGUpdateTimes = new Array();
        this.avgSGUpdateTime = 0;
        this.prevQueryTimes = new Array();
        this.SGQueryTimes = new Array();
        this.avgSGQueryTime = 0;
        let clearTime = document.createElement("span");
        clearTime.setAttribute("id", "sgclear");
        let fillTime = document.createElement("span");
        fillTime.setAttribute("id", "sgfill");
        let updateTime = document.createElement("span");
        updateTime.setAttribute("id", "sgupdate");
        let queryTime = document.createElement("span");
        queryTime.setAttribute("id", "sgquery");
        let br1 = document.createElement("br");
        let br2 = document.createElement("br");
        let br3 = document.createElement("br");
        this.statsDiv.append(clearTime, br1, fillTime, br2, updateTime, br3, queryTime);
        this.graphChoices = document.getElementById("chart-option");
        let option1 = document.createElement("option");
        option1.value = "prevfps";
        option1.label = "FPS";
        let option2 = document.createElement("option");
        option2.value = "prevClearTimes";
        option2.label = "Clear Time";
        let option3 = document.createElement("option");
        option3.value = "prevFillTimes";
        option3.label = "Fill time";
        let option4 = document.createElement("option");
        option4.value = "prevUpdateTimes";
        option4.label = "Update time";
        let option5 = document.createElement("option");
        option5.value = "prevQueryTimes";
        option5.label = "Query Time";
        let optionAll = document.createElement("option");
        optionAll.value = "all";
        optionAll.label = "All";
        this.graphChoices.append(option1, option2, option3, option4, option5, optionAll);
    }
    static updateFPS(fps) {
        this.prevfps.push(fps);
        if (this.prevfps.length > Stats.NUM_POINTS) {
            this.prevfps.shift();
        }
        if (this.SGClearTimes.length > 0) {
            this.prevClearTimes.push(this.avgSGClearTime);
            if (this.prevClearTimes.length > this.NUM_POINTS) {
                this.prevClearTimes.shift();
            }
        }
        if (this.SGFillTimes.length > 0) {
            this.prevFillTimes.push(this.avgSGFillTime);
            if (this.prevFillTimes.length > this.NUM_POINTS) {
                this.prevFillTimes.shift();
            }
        }
        if (this.SGUpdateTimes.length > 0) {
            this.prevUpdateTimes.push(this.avgSGUpdateTime);
            if (this.prevUpdateTimes.length > this.NUM_POINTS) {
                this.prevUpdateTimes.shift();
            }
        }
        if (this.SGQueryTimes.length > 0) {
            this.prevQueryTimes.push(this.avgSGQueryTime);
            if (this.prevQueryTimes.length > this.NUM_POINTS) {
                this.prevQueryTimes.shift();
            }
        }
        this.updateSGStats();
    }
    static log(key, data) {
        if (key === "sgclear") {
            this.SGClearTimes.push(data);
            if (this.SGClearTimes.length > 100) {
                this.SGClearTimes.shift();
            }
        }
        else if (key === "sgfill") {
            this.SGFillTimes.push(data);
            if (this.SGFillTimes.length > 100) {
                this.SGFillTimes.shift();
            }
        }
        else if (key === "sgupdate") {
            this.SGUpdateTimes.push(data);
            if (this.SGUpdateTimes.length > 100) {
                this.SGUpdateTimes.shift();
            }
        }
        else if (key === "sgquery") {
            this.SGQueryTimes.push(data);
            if (this.SGQueryTimes.length > 1000) {
                this.SGQueryTimes.shift();
            }
        }
    }
    static render() {
        // Display stats
        this.drawCharts();
    }
    static drawCharts() {
        this.ctx.clearRect(0, 0, this.CANVAS_WIDTH, this.CANVAS_HEIGHT);
        let paramString = this.graphChoices.value;
        if (paramString === "prevfps" || paramString === "all") {
            let param = this.prevfps;
            let color = Color_1.default.BLUE.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevClearTimes" || paramString === "all") {
            let param = this.prevClearTimes;
            let color = Color_1.default.RED.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevFillTimes" || paramString === "all") {
            let param = this.prevFillTimes;
            let color = Color_1.default.GREEN.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevUpdateTimes" || paramString === "all") {
            let param = this.prevUpdateTimes;
            let color = Color_1.default.CYAN.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevQueryTimes" || paramString === "all") {
            let param = this.prevQueryTimes;
            let color = Color_1.default.ORANGE.toString();
            this.drawChart(param, color);
        }
    }
    static drawChart(param, color) {
        this.ctx.strokeStyle = Color_1.default.BLACK.toString();
        this.ctx.beginPath();
        this.ctx.moveTo(10, 10);
        this.ctx.lineTo(10, this.CANVAS_HEIGHT - 10);
        this.ctx.closePath();
        this.ctx.stroke();
        this.ctx.beginPath();
        this.ctx.moveTo(10, this.CANVAS_HEIGHT - 10);
        this.ctx.lineTo(this.CANVAS_WIDTH - 10, this.CANVAS_HEIGHT - 10);
        this.ctx.closePath();
        this.ctx.stroke();
        let max = Math.max(...param);
        let prevX = 10;
        let prevY = this.CANVAS_HEIGHT - 10 - param[0] / max * (this.CANVAS_HEIGHT - 20);
        this.ctx.strokeStyle = color;
        for (let i = 1; i < param.length; i++) {
            let fps = param[i];
            let x = 10 + i * (this.CANVAS_WIDTH - 20) / this.NUM_POINTS;
            let y = this.CANVAS_HEIGHT - 10 - fps / max * (this.CANVAS_HEIGHT - 20);
            this.ctx.beginPath();
            this.ctx.moveTo(prevX, prevY);
            this.ctx.lineTo(x, y);
            this.ctx.closePath();
            this.ctx.stroke();
            prevX = x;
            prevY = y;
        }
    }
    static updateSGStats() {
        if (this.SGClearTimes.length > 0) {
            this.avgSGClearTime = this.SGClearTimes.reduce((acc, val) => acc + val) / this.SGClearTimes.length;
        }
        if (this.SGFillTimes.length > 0) {
            this.avgSGFillTime = this.SGFillTimes.reduce((acc, val) => acc + val) / this.SGFillTimes.length;
        }
        if (this.SGUpdateTimes.length > 0) {
            this.avgSGUpdateTime = this.SGUpdateTimes.reduce((acc, val) => acc + val) / this.SGUpdateTimes.length;
        }
        if (this.SGQueryTimes.length > 0) {
            this.avgSGQueryTime = this.SGQueryTimes.reduce((acc, val) => acc + val) / this.SGQueryTimes.length;
        }
        document.getElementById("sgclear").innerHTML = "Avg SG clear time: " + this.avgSGClearTime;
        document.getElementById("sgfill").innerHTML = "Avg SG fill time: " + this.avgSGFillTime;
        document.getElementById("sgupdate").innerHTML = "Avg SG update time: " + this.avgSGUpdateTime;
        document.getElementById("sgquery").innerHTML = "Avg SG query time: " + this.avgSGQueryTime;
    }
}
exports.default = Stats;
Stats.NUM_POINTS = 60;
Stats.CANVAS_WIDTH = 300;
Stats.CANVAS_HEIGHT = 300;

},{"../Utils/Color":106}],29:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const EventQueue_1 = __importDefault(require("./EventQueue"));
const GameEvent_1 = __importDefault(require("./GameEvent"));
/**
 * An event emitter object other systems can use to hook into the EventQueue.
 * Provides an easy interface for firing off events.
 */
class Emitter {
    /** Creates a new Emitter */
    constructor() {
        this.eventQueue = EventQueue_1.default.getInstance();
    }
    /**
     * Emit and event of type eventType with the data packet data
     * @param eventType The name of the event to fire off
     * @param data A @reference[Map] or record containing any data about the event
     */
    fireEvent(eventType, data = null) {
        this.eventQueue.addEvent(new GameEvent_1.default(eventType, data));
    }
}
exports.default = Emitter;

},{"./EventQueue":30,"./GameEvent":31}],30:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Queue_1 = __importDefault(require("../DataTypes/Collections/Queue"));
const Map_1 = __importDefault(require("../DataTypes/Collections/Map"));
const GameEventType_1 = require("./GameEventType");
/**
 * The main event system of the game engine.
 * Events are sent to the EventQueue, which handles distribution to any systems that are listening for those events.
 * This allows for handling of input without having classes directly hook into javascript event handles,
 * and allows otherwise separate classes to communicate with each other cleanly, such as a Player object
 * requesting a sound be played by the audio system.
 *
 * The distribution of @reference[GameEvent]s happens as follows:
 *
 * Events are recieved throughout a frame and are queued up by the EventQueue.
 * At the beginning of the next frame, events are sent out to any receivers that are hooked into the event type.
 * @reference[Receiver]s are then free to process events as they see fit.
 *
 * Overall, the EventQueue can be considered as something similar to an email server,
 * and the @reference[Receiver]s can be considered as the client inboxes.
 *
 * See @link(Game Programming Patterns)(https://gameprogrammingpatterns.com/event-queue.html) for more discussion on EventQueues
 */
class EventQueue {
    constructor() {
        this.MAX_SIZE = 200;
        this.q = new Queue_1.default(this.MAX_SIZE);
        this.receivers = new Map_1.default();
    }
    /** Retrieves the instance of the Singleton EventQueue */
    static getInstance() {
        if (this.instance === null) {
            this.instance = new EventQueue();
        }
        return this.instance;
    }
    /** Adds an event to the EventQueue.
     * This is exposed to the rest of the game engine through the @reference[Emitter] class */
    addEvent(event) {
        this.q.enqueue(event);
    }
    /**
     * Associates a receiver with a type of event. Every time this event appears in the future,
     * it will be given to the receiver (and any others watching that type).
     * This is exposed to the rest of the game engine through the @reference[Receiver] class
     * @param receiver The event receiver
     * @param type The type or types of events to subscribe to
     */
    subscribe(receiver, type) {
        if (type instanceof Array) {
            // If it is an array, subscribe to all event types
            for (let t of type) {
                this.addListener(receiver, t);
            }
        }
        else {
            this.addListener(receiver, type);
        }
    }
    /**
     * Unsubscribes the specified receiver from all events, or from whatever events are provided
     * @param receiver The receiver to unsubscribe
     * @param keys The events to unsubscribe from. If none are provided, unsubscribe from all
     */
    unsubscribe(receiver, ...events) {
        this.receivers.forEach(eventName => {
            // If keys were provided, only continue if this key is one of them
            if (events.length > 0 && events.indexOf(eventName) === -1)
                return;
            // Find the index of our receiver for this key
            let index = this.receivers.get(eventName).indexOf(receiver);
            // If an index was found, remove the receiver
            if (index !== -1) {
                this.receivers.get(eventName).splice(index, 1);
            }
        });
    }
    // Associate the receiver and the type
    addListener(receiver, type) {
        if (this.receivers.has(type)) {
            this.receivers.get(type).push(receiver);
        }
        else {
            this.receivers.add(type, [receiver]);
        }
    }
    update(deltaT) {
        while (this.q.hasItems()) {
            // Retrieve each event
            let event = this.q.dequeue();
            // If a receiver has this event type, send it the event
            if (this.receivers.has(event.type)) {
                for (let receiver of this.receivers.get(event.type)) {
                    receiver.receive(event);
                }
            }
            // If a receiver is subscribed to all events, send it the event
            if (this.receivers.has(GameEventType_1.GameEventType.ALL)) {
                for (let receiver of this.receivers.get(GameEventType_1.GameEventType.ALL)) {
                    receiver.receive(event);
                }
            }
        }
    }
}
exports.default = EventQueue;
EventQueue.instance = null;

},{"../DataTypes/Collections/Map":8,"../DataTypes/Collections/Queue":9,"./GameEventType":32}],31:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = __importDefault(require("../DataTypes/Collections/Map"));
/**
 * A representation of an in-game event that is passed through the @reference[EventQueue]
 */
class GameEvent {
    /**
     * Creates a new GameEvent.
     * This is handled implicitly through the @reference[Emitter] class
     * @param type The type of the GameEvent
     * @param data The data contained by the GameEvent
     */
    constructor(type, data = null) {
        // Parse the game event data
        if (data === null) {
            this.data = new Map_1.default();
        }
        else if (!(data instanceof Map_1.default)) {
            // data is a raw object, unpack
            this.data = new Map_1.default();
            for (let key in data) {
                this.data.add(key, data[key]);
            }
        }
        else {
            this.data = data;
        }
        this.type = type;
        this.time = Date.now();
    }
    /**
     * Checks the type of the GameEvent
     * @param type The type to check
     * @returns True if the GameEvent is the specified type, false otherwise.
     */
    isType(type) {
        return this.type === type;
    }
    /**
     * Returns this GameEvent as a string
     * @returns The string representation of the GameEvent
     */
    toString() {
        return this.type + ": @" + this.time;
    }
}
exports.default = GameEvent;

},{"../DataTypes/Collections/Map":8}],32:[function(require,module,exports){
"use strict";
// @ignorePage
Object.defineProperty(exports, "__esModule", { value: true });
exports.GameEventType = void 0;
var GameEventType;
(function (GameEventType) {
    /**
     * Mouse Down event. Has data: {position: Vec2 - Mouse Position}
     */
    GameEventType["MOUSE_DOWN"] = "mouse_down";
    /**
     * Mouse Up event. Has data: {position: Vec2 - Mouse Position}
     */
    GameEventType["MOUSE_UP"] = "mouse_up";
    /**
     * Mouse Move event. Has data: {position: Vec2 - Mouse Position}
     */
    GameEventType["MOUSE_MOVE"] = "mouse_move";
    /**
     * Key Down event. Has data: {key: string - The key that is down}
     */
    GameEventType["KEY_DOWN"] = "key_down";
    /**
     * Key Up event. Has data: {key: string - The key that is up}
     */
    GameEventType["KEY_UP"] = "key_up";
    /**
     * Canvas Blur event. Has data: {}
     */
    GameEventType["CANVAS_BLUR"] = "canvas_blur";
    /**
     * Mouse wheel up event. Has data: {}
     */
    GameEventType["WHEEL_UP"] = "wheel_up";
    /**
     * Mouse wheel down event. Has data: {}
     */
    GameEventType["WHEEL_DOWN"] = "wheel_down";
    /**
     * Start Recording event. Has data: {recording: AbstractRecording}
     */
    GameEventType["START_RECORDING"] = "start_recording";
    /**
     * Stop Recording event. Has data: {}
     */
    GameEventType["STOP_RECORDING"] = "stop_recording";
    /**
     * Play Recording event. Has data: {}
     */
    GameEventType["PLAY_RECORDING"] = "play_recording";
    /**
     * Play Sound event. Has data: {key: string, loop: boolean, holdReference: boolean }
     */
    GameEventType["PLAY_SOUND"] = "play_sound";
    /**
     * Play Sound event. Has data: {key: string}
     */
    GameEventType["STOP_SOUND"] = "stop_sound";
    /**
     * Play Sound event. Has data: {key: string, loop: boolean, holdReference: boolean, channel: AudioChannelType }
     */
    GameEventType["PLAY_SFX"] = "play_sfx";
    /**
     * Play Sound event. Has data: {key: string, loop: boolean, holdReference: boolean }
     */
    GameEventType["PLAY_MUSIC"] = "play_music";
    /**
     * Mute audio channel event. Has data: {channel: AudioChannelType}
     */
    GameEventType["MUTE_CHANNEL"] = "mute_channel";
    /**
     * Unmute audio channel event. Has data: {channel: AudioChannelType}
     */
    GameEventType["UNMUTE_CHANNEL"] = "unmute_channel";
    /**
     * Encompasses all event types. Used for receivers only.
     */
    GameEventType["ALL"] = "all";
    /**
     * Disables reveiving input from the user for the specified inputs. Has data: {inputs: InputHanlders[]}
     */
    GameEventType["DISABLE_USER_INPUT"] = "disable_user_input";
    /**
     * Enables receiving input from the user for the specified inputs. Has data: {inputs: InputHandlers[]}
     */
    GameEventType["ENABLE_USER_INPUT"] = "enable_user_input";
    /**
     * Triggers a scene change. Has data: {scene: new (...args: any) => T extends Scene, init: Record<string, any>}
     */
    GameEventType["CHANGE_SCENE"] = "change_scene";
})(GameEventType = exports.GameEventType || (exports.GameEventType = {}));

},{}],33:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Queue_1 = __importDefault(require("../DataTypes/Collections/Queue"));
const EventQueue_1 = __importDefault(require("./EventQueue"));
/**
 * Receives subscribed events from the EventQueue.
 */
class Receiver {
    /** Creates a new Receiver */
    constructor() {
        this.MAX_SIZE = 200;
        this.q = new Queue_1.default(this.MAX_SIZE);
    }
    destroy() {
        EventQueue_1.default.getInstance().unsubscribe(this);
    }
    /**
     * Adds these types of events to this receiver's queue every update.
     * @param eventTypes The types of events this receiver will be subscribed to
     */
    subscribe(eventTypes) {
        EventQueue_1.default.getInstance().subscribe(this, eventTypes);
        this.q.clear();
    }
    /**
     * Adds an event to the queue of this reciever. This is used by the @reference[EventQueue] to distribute events
     * @param event The event to receive
     */
    receive(event) {
        try {
            this.q.enqueue(event);
        }
        catch (e) {
            console.warn("Receiver overflow for event " + event.toString());
            throw e;
        }
    }
    /**
     * Retrieves the next event from the receiver's queue
     * @returns The next GameEvent
     */
    getNextEvent() {
        return this.q.dequeue();
    }
    /**
     * Looks at the next event in the receiver's queue, but doesn't remove it from the queue
     * @returns The next GameEvent
     */
    peekNextEvent() {
        return this.q.peekNext();
    }
    /**
     * Returns true if the receiver has any events in its queue
     * @returns True if the receiver has another event, false otherwise
     */
    hasNextEvent() {
        return this.q.hasItems();
    }
    /**
     * Ignore all events this frame
     */
    ignoreEvents() {
        this.q.clear();
    }
}
exports.default = Receiver;

},{"../DataTypes/Collections/Queue":9,"./EventQueue":30}],34:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Receiver_1 = __importDefault(require("../Events/Receiver"));
const Map_1 = __importDefault(require("../DataTypes/Collections/Map"));
const Vec2_1 = __importDefault(require("../DataTypes/Vec2"));
const EventQueue_1 = __importDefault(require("../Events/EventQueue"));
const GameEventType_1 = require("../Events/GameEventType");
/**
 * Receives input events from the @reference[EventQueue] and allows for easy access of information about input by other systems
 */
class Input {
    /**
     * Initializes the Input object
     * @param viewport A reference to the viewport of the game
     */
    static initialize(viewport, keyMap) {
        Input.viewport = viewport;
        Input.mousePressed = false;
        Input.mouseJustPressed = false;
        Input.receiver = new Receiver_1.default();
        Input.keyJustPressed = new Map_1.default();
        Input.keyPressed = new Map_1.default();
        Input.mousePosition = new Vec2_1.default(0, 0);
        Input.mousePressPosition = new Vec2_1.default(0, 0);
        Input.scrollDirection = 0;
        Input.justScrolled = false;
        Input.keysDisabled = false;
        Input.mouseDisabled = false;
        // Initialize the keymap
        Input.keyMap = new Map_1.default();
        // Add all keys to the keymap
        for (let entry in keyMap) {
            let name = keyMap[entry].name;
            let keys = keyMap[entry].keys;
            Input.keyMap.add(name, keys);
        }
        Input.eventQueue = EventQueue_1.default.getInstance();
        // Subscribe to all input events
        Input.eventQueue.subscribe(Input.receiver, [GameEventType_1.GameEventType.MOUSE_DOWN, GameEventType_1.GameEventType.MOUSE_UP, GameEventType_1.GameEventType.MOUSE_MOVE,
            GameEventType_1.GameEventType.KEY_DOWN, GameEventType_1.GameEventType.KEY_UP, GameEventType_1.GameEventType.CANVAS_BLUR, GameEventType_1.GameEventType.WHEEL_UP, GameEventType_1.GameEventType.WHEEL_DOWN]);
    }
    static update(deltaT) {
        // Reset the justPressed values to false
        Input.mouseJustPressed = false;
        Input.keyJustPressed.forEach((key) => Input.keyJustPressed.set(key, false));
        Input.justScrolled = false;
        Input.scrollDirection = 0;
        while (Input.receiver.hasNextEvent()) {
            let event = Input.receiver.getNextEvent();
            // Handle each event type
            if (event.type === GameEventType_1.GameEventType.MOUSE_DOWN) {
                Input.mouseJustPressed = true;
                Input.mousePressed = true;
                Input.mousePressPosition = event.data.get("position");
                Input.mouseButtonPressed = event.data.get("button");
            }
            if (event.type === GameEventType_1.GameEventType.MOUSE_UP) {
                Input.mousePressed = false;
            }
            if (event.type === GameEventType_1.GameEventType.MOUSE_MOVE) {
                Input.mousePosition = event.data.get("position");
            }
            if (event.type === GameEventType_1.GameEventType.KEY_DOWN) {
                let key = event.data.get("key");
                // Handle space bar
                if (key === " ") {
                    key = "space";
                }
                if (!Input.keyPressed.get(key)) {
                    Input.keyJustPressed.set(key, true);
                    Input.keyPressed.set(key, true);
                }
            }
            if (event.type === GameEventType_1.GameEventType.KEY_UP) {
                let key = event.data.get("key");
                // Handle space bar
                if (key === " ") {
                    key = "space";
                }
                Input.keyPressed.set(key, false);
            }
            if (event.type === GameEventType_1.GameEventType.CANVAS_BLUR) {
                Input.clearKeyPresses();
            }
            if (event.type === GameEventType_1.GameEventType.WHEEL_UP) {
                Input.scrollDirection = -1;
                Input.justScrolled = true;
            }
            else if (event.type === GameEventType_1.GameEventType.WHEEL_DOWN) {
                Input.scrollDirection = 1;
                Input.justScrolled = true;
            }
        }
    }
    static clearKeyPresses() {
        Input.keyJustPressed.forEach((key) => Input.keyJustPressed.set(key, false));
        Input.keyPressed.forEach((key) => Input.keyPressed.set(key, false));
    }
    /**
     * Returns whether or not a key was newly pressed Input frame.
     * If the key is still pressed from last frame and wasn't re-pressed, Input will return false.
     * @param key The key
     * @returns True if the key was just pressed, false otherwise
     */
    static isKeyJustPressed(key) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyJustPressed.has(key)) {
            return Input.keyJustPressed.get(key);
        }
        else {
            return false;
        }
    }
    /**
     * Returns an array of all of the keys that are newly pressed Input frame.
     * If a key is still pressed from last frame and wasn't re-pressed, it will not be in Input list.
     * @returns An array of all of the newly pressed keys.
     */
    static getKeysJustPressed() {
        if (Input.keysDisabled)
            return [];
        let keys = Array();
        Input.keyJustPressed.forEach(key => {
            if (Input.keyJustPressed.get(key)) {
                keys.push(key);
            }
        });
        return keys;
    }
    /**
     * Returns whether or not a key is being pressed.
     * @param key The key
     * @returns True if the key is currently pressed, false otherwise
     */
    static isKeyPressed(key) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyPressed.has(key)) {
            return Input.keyPressed.get(key);
        }
        else {
            return false;
        }
    }
    /**
     * Changes the binding of an input name to keys
     * @param inputName The name of the input
     * @param keys The corresponding keys
     */
    static changeKeyBinding(inputName, keys) {
        Input.keyMap.set(inputName, keys);
    }
    /**
     * Clears all key bindings
     */
    static clearAllKeyBindings() {
        Input.keyMap.clear();
    }
    /**
     * Returns whether or not an input was just pressed this frame
     * @param inputName The name of the input
     * @returns True if the input was just pressed, false otherwise
     */
    static isJustPressed(inputName) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyMap.has(inputName)) {
            const keys = Input.keyMap.get(inputName);
            let justPressed = false;
            for (let key of keys) {
                justPressed = justPressed || Input.isKeyJustPressed(key);
            }
            return justPressed;
        }
        else {
            return false;
        }
    }
    /**
     * Returns whether or not an input is currently pressed
     * @param inputName The name of the input
     * @returns True if the input is pressed, false otherwise
     */
    static isPressed(inputName) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyMap.has(inputName)) {
            const keys = Input.keyMap.get(inputName);
            let pressed = false;
            for (let key of keys) {
                pressed = pressed || Input.isKeyPressed(key);
            }
            return pressed;
        }
        else {
            return false;
        }
    }
    /**
     *
     * Returns whether or not the mouse was newly pressed Input frame.
     * @param mouseButton Optionally specify which mouse click you want to know was pressed.
     * 0 for left click, 1 for middle click, 2 for right click.
     * @returns True if the mouse was just pressed, false otherwise
     */
    static isMouseJustPressed(mouseButton) {
        if (mouseButton !== undefined) {
            return Input.mouseJustPressed && !Input.mouseDisabled && mouseButton == this.mouseButtonPressed;
        }
        return Input.mouseJustPressed && !Input.mouseDisabled;
    }
    /**
     * Returns whether or not the mouse is currently pressed
     * @param mouseButton Optionally specify which mouse click you want to know was pressed.
     * 0 for left click, 1 for middle click, 2 for right click.
     * @returns True if the mouse is currently pressed, false otherwise
     */
    static isMousePressed(mouseButton) {
        if (mouseButton !== undefined) {
            return Input.mousePressed && !Input.mouseDisabled && mouseButton == this.mouseButtonPressed;
        }
        return Input.mousePressed && !Input.mouseDisabled;
    }
    /**
     * Returns whether the user scrolled or not
     * @returns True if the user just scrolled Input frame, false otherwise
     */
    static didJustScroll() {
        return Input.justScrolled && !Input.mouseDisabled;
    }
    /**
     * Gets the direction of the scroll
     * @returns -1 if the user scrolled up, 1 if they scrolled down
     */
    static getScrollDirection() {
        return Input.scrollDirection;
    }
    /**
     * Gets the position of the player's mouse
     * @returns The mouse position stored as a Vec2
     */
    static getMousePosition() {
        return Input.mousePosition.scaled(1 / this.viewport.getZoomLevel());
    }
    /**
     * Gets the position of the player's mouse in the game world,
     * taking into consideration the scrolling of the viewport
     * @returns The mouse position stored as a Vec2
     */
    static getGlobalMousePosition() {
        return Input.mousePosition.clone().scale(1 / this.viewport.getZoomLevel()).add(Input.viewport.getOrigin());
    }
    /**
     * Gets the position of the last mouse press
     * @returns The mouse position stored as a Vec2
     */
    static getMousePressPosition() {
        return Input.getMousePosition();
    }
    /**
     * Gets the position of the last mouse press in the game world,
     * taking into consideration the scrolling of the viewport
     * @returns The mouse position stored as a Vec2
     */
    static getGlobalMousePressPosition() {
        return Input.mousePressPosition.clone().add(Input.viewport.getOrigin());
    }
    /**
     * Disables all keypress and mouse click inputs
     */
    static disableInput() {
        Input.keysDisabled = true;
        Input.mouseDisabled = true;
    }
    /**
     * Enables all keypress and mouse click inputs
     */
    static enableInput() {
        Input.keysDisabled = false;
        Input.mouseDisabled = false;
    }
}
exports.default = Input;

},{"../DataTypes/Collections/Map":8,"../DataTypes/Vec2":26,"../Events/EventQueue":30,"../Events/GameEventType":32,"../Events/Receiver":33}],35:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InputHandlers = void 0;
const EventQueue_1 = __importDefault(require("../Events/EventQueue"));
const Vec2_1 = __importDefault(require("../DataTypes/Vec2"));
const GameEvent_1 = __importDefault(require("../Events/GameEvent"));
const GameEventType_1 = require("../Events/GameEventType");
const Receiver_1 = __importDefault(require("../Events/Receiver"));
var InputHandlers;
(function (InputHandlers) {
    InputHandlers[InputHandlers["MOUSE_DOWN"] = 0] = "MOUSE_DOWN";
    InputHandlers[InputHandlers["MOUSE_UP"] = 1] = "MOUSE_UP";
    InputHandlers[InputHandlers["CONTEXT_MENU"] = 2] = "CONTEXT_MENU";
    InputHandlers[InputHandlers["MOUSE_MOVE"] = 3] = "MOUSE_MOVE";
    InputHandlers[InputHandlers["KEY_DOWN"] = 4] = "KEY_DOWN";
    InputHandlers[InputHandlers["KEY_UP"] = 5] = "KEY_UP";
    InputHandlers[InputHandlers["ON_BLUR"] = 6] = "ON_BLUR";
    InputHandlers[InputHandlers["ON_WHEEL"] = 7] = "ON_WHEEL";
})(InputHandlers = exports.InputHandlers || (exports.InputHandlers = {}));
/**
 * Handles communication with the web browser to receive asynchronous events and send them to the @reference[EventQueue]
 */
class InputHandler {
    /**
     * Creates a new InputHandler
     * @param canvas The game canvas
     */
    constructor(canvas) {
        this.handleMouseDown = (event, canvas) => {
            if (!this.enabled[InputHandlers.MOUSE_DOWN])
                return;
            let pos = this.getMousePosition(event, canvas);
            let button = event.button;
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.MOUSE_DOWN, { position: pos, button: button });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleMouseUp = (event, canvas) => {
            if (!this.enabled[InputHandlers.MOUSE_DOWN])
                return;
            let pos = this.getMousePosition(event, canvas);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.MOUSE_UP, { position: pos });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleMouseMove = (event, canvas) => {
            if (!this.enabled[InputHandlers.MOUSE_MOVE])
                return;
            let pos = this.getMousePosition(event, canvas);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.MOUSE_MOVE, { position: pos });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleKeyDown = (event) => {
            if (!this.enabled[InputHandlers.KEY_DOWN])
                return;
            let key = this.getKey(event);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.KEY_DOWN, { key: key });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleKeyUp = (event) => {
            if (!this.enabled[InputHandlers.KEY_UP])
                return;
            let key = this.getKey(event);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.KEY_UP, { key: key });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleBlur = (event) => {
            if (!this.enabled[InputHandlers.ON_BLUR])
                return;
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.CANVAS_BLUR, {});
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleContextMenu = (event) => {
            event.preventDefault();
            event.stopPropagation();
        };
        this.handleWheel = (event) => {
            event.preventDefault();
            event.stopPropagation();
            if (!this.enabled[InputHandlers.ON_WHEEL])
                return;
            let gameEvent;
            if (event.deltaY < 0) {
                gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.WHEEL_UP, {});
            }
            else {
                gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.WHEEL_DOWN, {});
            }
            this.eventQueue.addEvent(gameEvent);
        };
        this.eventQueue = EventQueue_1.default.getInstance();
        this.enabled = new Array(...[true, true, true, true, true, true, true, true]);
        canvas.onmousedown = (event) => this.handleMouseDown(event, canvas);
        canvas.onmouseup = (event) => this.handleMouseUp(event, canvas);
        canvas.oncontextmenu = this.handleContextMenu;
        canvas.onmousemove = (event) => this.handleMouseMove(event, canvas);
        document.onkeydown = this.handleKeyDown;
        document.onkeyup = this.handleKeyUp;
        document.onblur = this.handleBlur;
        document.oncontextmenu = this.handleBlur;
        document.onwheel = this.handleWheel;
        this.receiver = new Receiver_1.default();
        this.receiver.subscribe(GameEventType_1.GameEventType.DISABLE_USER_INPUT);
        this.receiver.subscribe(GameEventType_1.GameEventType.ENABLE_USER_INPUT);
    }
    update(deltaT) {
        while (this.receiver.hasNextEvent()) {
            this.handleEvent(this.receiver.getNextEvent());
        }
    }
    handleEvent(event) {
        switch (event.type) {
            case GameEventType_1.GameEventType.DISABLE_USER_INPUT: {
                this.disableHandlers(event.data.get("inputs"));
                break;
            }
            case GameEventType_1.GameEventType.ENABLE_USER_INPUT: {
                this.enableHandlers(event.data.get("inputs"));
                break;
            }
            default: {
                throw new Error(`Unhandled event with type: ${event.type} caught in InputHandler.ts`);
            }
        }
    }
    enableHandlers(handlers) {
        handlers.forEach(handler => this.enabled[handler] = true);
    }
    disableHandlers(handlers) {
        handlers.forEach(handler => this.enabled[handler] = false);
    }
    getKey(keyEvent) {
        return keyEvent.key.toLowerCase();
    }
    getMousePosition(mouseEvent, canvas) {
        let rect = canvas.getBoundingClientRect();
        let x = mouseEvent.clientX - rect.left;
        let y = mouseEvent.clientY - rect.top;
        return new Vec2_1.default(x, y);
    }
}
exports.default = InputHandler;

},{"../DataTypes/Vec2":26,"../Events/EventQueue":30,"../Events/GameEvent":31,"../Events/GameEventType":32,"../Events/Receiver":33}],36:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// @ignorePage
/**
 * Sets up the environment of the game engine
 */
class EnvironmentInitializer {
    static setup() {
        CanvasRenderingContext2D.prototype.roundedRect = function (x, y, w, h, r) {
            // Clamp the radius between 0 and the min of the width or height
            if (r < 0)
                r = 0;
            if (r > Math.min(w, h))
                r = Math.min(w, h);
            // Draw the rounded rect
            this.beginPath();
            // Top
            this.moveTo(x + r, y);
            this.lineTo(x + w - r, y);
            this.arcTo(x + w, y, x + w, y + r, r);
            // Right
            this.lineTo(x + w, y + h - r);
            this.arcTo(x + w, y + h, x + w - r, y + h, r);
            // Bottom
            this.lineTo(x + r, y + h);
            this.arcTo(x, y + h, x, y + h - r, r);
            // Left
            this.lineTo(x, y + r);
            this.arcTo(x, y, x + r, y, r);
            this.closePath();
        };
        CanvasRenderingContext2D.prototype.strokeRoundedRect = function (x, y, w, h, r) {
            this.roundedRect(x, y, w, h, r);
            this.stroke();
        };
        CanvasRenderingContext2D.prototype.fillRoundedRect = function (x, y, w, h, r) {
            this.roundedRect(x, y, w, h, r);
            this.fill();
        };
    }
}
exports.default = EnvironmentInitializer;

},{}],37:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const GameLoop_1 = __importDefault(require("./GameLoop"));
const Debug_1 = __importDefault(require("../Debug/Debug"));
const Stats_1 = __importDefault(require("../Debug/Stats"));
/**
 * A game loop with a fixed update time and a variable render time.
 * Every frame, the game updates until all time since the last frame has been processed.
 * If too much time has passed, such as if the last update was too slow,
 * or if the browser was put into the background, the loop will panic and discard time.
 * A render happens at the end of every frame. This happens as fast as possible unless specified.
 * A loop of this type allows for deterministic behavior - No matter what the frame rate is, the update should behave the same,
 * as it is occuring in a fixed interval.
 */
class FixedUpdateGameLoop extends GameLoop_1.default {
    constructor() {
        super();
        /**
         * The main loop of the game. Updates until the current time is reached. Renders once
         * @param timestamp The current time in ms
         */
        this.doFrame = (timestamp) => {
            // If a pause was executed, stop doing the loop.
            if (this.paused) {
                return;
            }
            // Request animation frame to prepare for another update or render
            window.requestAnimationFrame((t) => this.doFrame(t));
            // If we are trying to render too soon, do nothing.
            if (timestamp < this.lastFrameTime + this.minFrameDelay) {
                return;
            }
            // A frame is actually happening
            this.startFrame(timestamp);
            // Update while there is still time to make up. If we do too many update steps, panic and exit the loop.
            this.numUpdateSteps = 0;
            let panic = false;
            while (this.frameDelta >= this.updateTimestep) {
                // Do an update
                this._doUpdate(this.updateTimestep / 1000);
                // Remove the update step time from the time we have to process
                this.frameDelta -= this.updateTimestep;
                // Increment steps and check if we've done too many
                this.numUpdateSteps++;
                if (this.numUpdateSteps > 100) {
                    panic = true;
                    break;
                }
            }
            // Updates are done, render
            this._doRender();
            // Wrap up the frame
            this.finishFrame(panic);
        };
        this.maxUpdateFPS = 60;
        this.updateTimestep = Math.floor(1000 / this.maxUpdateFPS);
        this.frameDelta = 0;
        this.lastFrameTime = 0;
        this.minFrameDelay = 0;
        this.frame = 0;
        this.fps = this.maxUpdateFPS; // Initialize the fps to the max allowed fps
        this.fpsUpdateInterval = 1000;
        this.lastFpsUpdate = 0;
        this.framesSinceLastFpsUpdate = 0;
        this.started = false;
        this.paused = false;
        this.running = false;
        this.numUpdateSteps = 0;
    }
    getFPS() {
        return 0;
    }
    /**
     * Updates the frame count and sum of time for the framerate of the game
     * @param timestep The current time in ms
     */
    updateFPS(timestamp) {
        this.fps = 0.9 * this.framesSinceLastFpsUpdate * 1000 / (timestamp - this.lastFpsUpdate) + (1 - 0.9) * this.fps;
        this.lastFpsUpdate = timestamp;
        this.framesSinceLastFpsUpdate = 0;
        Debug_1.default.log("fps", "FPS: " + this.fps.toFixed(1));
        Stats_1.default.updateFPS(this.fps);
    }
    /**
 * Changes the maximum allowed physics framerate of the game
 * @param initMax The max framerate
 */
    setMaxUpdateFPS(initMax) {
        this.maxUpdateFPS = initMax;
        this.updateTimestep = Math.floor(1000 / this.maxUpdateFPS);
    }
    /**
     * Sets the maximum rendering framerate
     * @param maxFPS The max framerate
     */
    setMaxFPS(maxFPS) {
        this.minFrameDelay = 1000 / maxFPS;
    }
    /**
     * This function is called when the game loop panics, i.e. it tries to process too much time in an entire frame.
     * This will reset the amount of time back to zero.
     * @returns The amount of time we are discarding from processing.
     */
    resetFrameDelta() {
        let oldFrameDelta = this.frameDelta;
        this.frameDelta = 0;
        return oldFrameDelta;
    }
    /**
     * Starts up the game loop and calls the first requestAnimationFrame
     */
    start() {
        if (!this.started) {
            this.started = true;
            window.requestAnimationFrame((timestamp) => this.doFirstFrame(timestamp));
        }
    }
    pause() {
        this.paused = true;
    }
    resume() {
        this.paused = false;
    }
    /**
     * The first game frame - initializes the first frame time and begins the render
     * @param timestamp The current time in ms
     */
    doFirstFrame(timestamp) {
        this.running = true;
        this._doRender();
        this.lastFrameTime = timestamp;
        this.lastFpsUpdate = timestamp;
        this.framesSinceLastFpsUpdate = 0;
        window.requestAnimationFrame((t) => this.doFrame(t));
    }
    /**
     * Handles any processing that needs to be done at the start of the frame
     * @param timestamp The time of the frame in ms
     */
    startFrame(timestamp) {
        // Update the amount of time we need our update to process
        this.frameDelta += timestamp - this.lastFrameTime;
        // Set the new time of the last frame
        this.lastFrameTime = timestamp;
        // Update the estimate of the framerate
        if (timestamp > this.lastFpsUpdate + this.fpsUpdateInterval) {
            this.updateFPS(timestamp);
        }
        // Increment the number of frames
        this.frame++;
        this.framesSinceLastFpsUpdate++;
    }
    /**
     * Wraps up the frame and handles the panic state if there is one
     * @param panic Whether or not the loop panicked
     */
    finishFrame(panic) {
        if (panic) {
            var discardedTime = Math.round(this.resetFrameDelta());
            console.warn('Main loop panicked, probably because the browser tab was put in the background. Discarding ' + discardedTime + 'ms');
        }
    }
}
exports.default = FixedUpdateGameLoop;

},{"../Debug/Debug":27,"../Debug/Stats":28,"./GameLoop":39}],38:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const EventQueue_1 = __importDefault(require("../Events/EventQueue"));
const Input_1 = __importDefault(require("../Input/Input"));
const InputHandler_1 = __importDefault(require("../Input/InputHandler"));
const Debug_1 = __importDefault(require("../Debug/Debug"));
const ResourceManager_1 = __importDefault(require("../ResourceManager/ResourceManager"));
const Viewport_1 = __importDefault(require("../SceneGraph/Viewport"));
const SceneManager_1 = __importDefault(require("../Scene/SceneManager"));
const AudioManager_1 = __importDefault(require("../Sound/AudioManager"));
const Stats_1 = __importDefault(require("../Debug/Stats"));
const CanvasRenderer_1 = __importDefault(require("../Rendering/CanvasRenderer"));
const Color_1 = __importDefault(require("../Utils/Color"));
const GameOptions_1 = __importDefault(require("./GameOptions"));
const FixedUpdateGameLoop_1 = __importDefault(require("./FixedUpdateGameLoop"));
const EnvironmentInitializer_1 = __importDefault(require("./EnvironmentInitializer"));
const Vec2_1 = __importDefault(require("../DataTypes/Vec2"));
const RegistryManager_1 = __importDefault(require("../Registry/RegistryManager"));
const WebGLRenderer_1 = __importDefault(require("../Rendering/WebGLRenderer"));
const PlaybackManager_1 = __importDefault(require("../Playback/PlaybackManager"));
/**
 * The main loop of the game engine.
 * Handles the update order, and initializes all subsystems.
 * The Game manages the update cycle, and requests animation frames to render to the browser.
 */
class Game {
    /**
     * Creates a new Game
     * @param options The options for Game initialization
     */
    constructor(options) {
        // Before anything else, build the environment
        EnvironmentInitializer_1.default.setup();
        // Typecast the config object to a GameConfig object
        this.gameOptions = GameOptions_1.default.parse(options);
        this.showDebug = this.gameOptions.showDebug;
        this.showStats = this.gameOptions.showStats;
        // Create an instance of a game loop
        this.loop = new FixedUpdateGameLoop_1.default();
        // Get the game canvas and give it a background color
        this.GAME_CANVAS = document.getElementById("game-canvas");
        this.DEBUG_CANVAS = document.getElementById("debug-canvas");
        // Give the canvas a size and get the rendering context
        this.WIDTH = this.gameOptions.canvasSize.x;
        this.HEIGHT = this.gameOptions.canvasSize.y;
        // This step MUST happen before the resource manager does anything
        if (this.gameOptions.useWebGL) {
            this.renderingManager = new WebGLRenderer_1.default();
        }
        else {
            this.renderingManager = new CanvasRenderer_1.default();
        }
        this.initializeGameWindow();
        this.ctx = this.renderingManager.initializeCanvas(this.GAME_CANVAS, this.WIDTH, this.HEIGHT);
        this.clearColor = new Color_1.default(this.gameOptions.clearColor.r, this.gameOptions.clearColor.g, this.gameOptions.clearColor.b);
        // Initialize debugging and stats
        Debug_1.default.initializeDebugCanvas(this.DEBUG_CANVAS, this.WIDTH, this.HEIGHT);
        Stats_1.default.initStats();
        if (this.gameOptions.showStats) {
            // Find the stats output and make it no longer hidden
            document.getElementById("stats").hidden = false;
        }
        // Size the viewport to the game canvas
        const canvasSize = new Vec2_1.default(this.WIDTH, this.HEIGHT);
        this.viewport = new Viewport_1.default(canvasSize, this.gameOptions.zoomLevel);
        // Initialize all necessary game subsystems
        this.eventQueue = EventQueue_1.default.getInstance();
        this.inputHandler = new InputHandler_1.default(this.GAME_CANVAS);
        Input_1.default.initialize(this.viewport, this.gameOptions.inputs);
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.sceneManager = new SceneManager_1.default(this.viewport, this.renderingManager);
        this.audioManager = AudioManager_1.default.getInstance();
        this.playbackManager = new PlaybackManager_1.default();
    }
    /**
     * Set up the game window that holds the canvases
     */
    initializeGameWindow() {
        const gameWindow = document.getElementById("game-window");
        // Set the height of the game window
        gameWindow.style.width = this.WIDTH + "px";
        gameWindow.style.height = this.HEIGHT + "px";
    }
    /**
     * Retreives the SceneManager from the Game
     * @returns The SceneManager
     */
    getSceneManager() {
        return this.sceneManager;
    }
    /**
     * Starts the game
     */
    start(InitialScene, options) {
        // Set the update function of the loop
        this.loop.doUpdate = (deltaT) => this.update(deltaT);
        // Set the render function of the loop
        this.loop.doRender = () => this.render();
        // Preload registry items
        RegistryManager_1.default.preload();
        // Load the items with the resource manager
        this.resourceManager.loadResourcesFromQueue(() => {
            // When we're done loading, start the loop
            console.log("Finished Preload - loading first scene");
            this.sceneManager.changeToScene(InitialScene, {}, options);
            this.loop.start();
        });
    }
    /**
     * Updates all necessary subsystems of the game. Defers scene updates to the sceneManager
     * @param deltaT The time sine the last update
     */
    update(deltaT) {
        try {
            // Handle all events that happened since the start of the last loop
            this.eventQueue.update(deltaT);
            // Update the input handler - disabling/enabling user input
            this.inputHandler.update(deltaT);
            // Update the input data structures so game objects can see the input
            Input_1.default.update(deltaT);
            // Update the recording of the game
            this.playbackManager.update(deltaT);
            // Update all scenes
            this.sceneManager.update(deltaT);
            // Update all sounds
            this.audioManager.update(deltaT);
            // Load or unload any resources if needed
            this.resourceManager.update(deltaT);
        }
        catch (e) {
            this.loop.pause();
            console.warn("Uncaught Error in Update - Crashing gracefully");
            console.error(e);
        }
    }
    /**
     * Clears the canvas and defers scene rendering to the sceneManager. Renders the debug canvas
     */
    render() {
        try {
            // Clear the canvases
            Debug_1.default.clearCanvas();
            this.renderingManager.clear(this.clearColor);
            this.sceneManager.render();
            // Hacky debug mode
            if (Input_1.default.isKeyJustPressed("g")) {
                this.showDebug = !this.showDebug;
            }
            // Debug render
            if (this.showDebug) {
                Debug_1.default.render();
            }
            if (this.showStats) {
                Stats_1.default.render();
            }
        }
        catch (e) {
            this.loop.pause();
            console.warn("Uncaught Error in Render - Crashing gracefully");
            console.error(e);
        }
    }
}
exports.default = Game;

},{"../DataTypes/Vec2":26,"../Debug/Debug":27,"../Debug/Stats":28,"../Events/EventQueue":30,"../Input/Input":34,"../Input/InputHandler":35,"../Playback/PlaybackManager":69,"../Registry/RegistryManager":72,"../Rendering/CanvasRenderer":78,"../Rendering/WebGLRenderer":83,"../ResourceManager/ResourceManager":90,"../Scene/SceneManager":98,"../SceneGraph/Viewport":102,"../Sound/AudioManager":103,"../Utils/Color":106,"./EnvironmentInitializer":36,"./FixedUpdateGameLoop":37,"./GameOptions":40}],39:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const NullFunc_1 = __importDefault(require("../DataTypes/Functions/NullFunc"));
/**
 * The main game loop of the game. Keeps track of fps and handles scheduling of updates and rendering.
 * This class is left abstract, so that a subclass can handle exactly how the loop is scheduled.
 * For an example of different types of game loop scheduling, check out @link(Game Programming Patterns)(https://gameprogrammingpatterns.com/game-loop.html)
 */
class GameLoop {
    constructor() {
        /** The function to call when an update occurs */
        this._doUpdate = NullFunc_1.default;
        /** The function to call when a render occurs */
        this._doRender = NullFunc_1.default;
    }
    set doUpdate(update) {
        this._doUpdate = update;
    }
    set doRender(render) {
        this._doRender = render;
    }
}
exports.default = GameLoop;

},{"../DataTypes/Functions/NullFunc":11}],40:[function(require,module,exports){
"use strict";
// @ignorePage
Object.defineProperty(exports, "__esModule", { value: true });
/** The options for initializing the @reference[GameLoop] */
class GameOptions {
    /**
     * Parses the data in the raw options object
     * @param options The game options as a Record
     * @returns A version of the options converted to a GameOptions object
     */
    static parse(options) {
        let gOpt = new GameOptions();
        gOpt.canvasSize = options.canvasSize ? options.canvasSize : { x: 800, y: 600 };
        gOpt.zoomLevel = options.zoomLevel ? options.zoomLevel : 1;
        gOpt.clearColor = options.clearColor ? options.clearColor : { r: 255, g: 255, b: 255 };
        gOpt.inputs = options.inputs ? options.inputs : [];
        gOpt.showDebug = !!options.showDebug;
        gOpt.showStats = !!options.showStats;
        gOpt.useWebGL = !!options.useWebGL;
        return gOpt;
    }
}
exports.default = GameOptions;

},{}],41:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const GameNode_1 = __importDefault(require("./GameNode"));
const Vec2_1 = __importDefault(require("../DataTypes/Vec2"));
const AABB_1 = __importDefault(require("../DataTypes/Shapes/AABB"));
const Debug_1 = __importDefault(require("../Debug/Debug"));
const Color_1 = __importDefault(require("../Utils/Color"));
/**
 * The representation of an object in the game world that can be drawn to the screen
 */
class CanvasNode extends GameNode_1.default {
    constructor() {
        super();
        /** A flag for whether or not the CanvasNode is visible */
        this.visible = true;
        this._size = new Vec2_1.default(0, 0);
        this._size.setOnChange(() => this.sizeChanged());
        this._scale = new Vec2_1.default(1, 1);
        this._scale.setOnChange(() => this.scaleChanged());
        this._boundary = new AABB_1.default();
        this.updateBoundary();
        this._hasCustomShader = false;
    }
    get alpha() {
        return this._alpha;
    }
    set alpha(a) {
        this._alpha = a;
    }
    get size() {
        return this._size;
    }
    set size(size) {
        this._size = size;
        // Enter as a lambda to bind "this"
        this._size.setOnChange(() => this.sizeChanged());
        this.sizeChanged();
    }
    get scale() {
        return this._scale;
    }
    set scale(scale) {
        this._scale = scale;
        // Enter as a lambda to bind "this"
        this._scale.setOnChange(() => this.scaleChanged());
        this.scaleChanged();
    }
    set scaleX(value) {
        this.scale.x = value;
    }
    set scaleY(value) {
        this.scale.y = value;
    }
    get hasCustomShader() {
        return this._hasCustomShader;
    }
    get customShaderKey() {
        return this._customShaderKey;
    }
    // @override
    positionChanged() {
        super.positionChanged();
        this.updateBoundary();
    }
    /** Called if the size vector is changed or replaced. */
    sizeChanged() {
        this.updateBoundary();
    }
    /** Called if the scale vector is changed or replaced */
    scaleChanged() {
        this.updateBoundary();
    }
    // @docIgnore
    /** Called if the position, size, or scale of the CanvasNode is changed. Updates the boundary. */
    updateBoundary() {
        this._boundary.center.set(this.position.x, this.position.y);
        this._boundary.halfSize.set(this.size.x * this.scale.x / 2, this.size.y * this.scale.y / 2);
    }
    get boundary() {
        return this._boundary;
    }
    get sizeWithZoom() {
        let zoom = this.scene.getViewScale();
        return this.boundary.halfSize.clone().scaled(zoom, zoom);
    }
    /**
     * Adds a custom shader to this CanvasNode
     * @param key The registry key of the ShaderType
     */
    useCustomShader(key) {
        this._hasCustomShader = true;
        this._customShaderKey = key;
    }
    /**
     * Returns true if the point (x, y) is inside of this canvas object
     * @param x The x position of the point
     * @param y The y position of the point
     * @returns A flag representing whether or not this node contains the point.
     */
    contains(x, y) {
        return this._boundary.containsPoint(new Vec2_1.default(x, y));
    }
    // @implemented
    debugRender() {
        Debug_1.default.drawBox(this.relativePosition, this.sizeWithZoom, false, Color_1.default.BLUE);
        super.debugRender();
    }
}
exports.default = CanvasNode;

},{"../DataTypes/Shapes/AABB":20,"../DataTypes/Vec2":26,"../Debug/Debug":27,"../Utils/Color":106,"./GameNode":42}],42:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TweenableProperties = void 0;
const Vec2_1 = __importDefault(require("../DataTypes/Vec2"));
const Receiver_1 = __importDefault(require("../Events/Receiver"));
const Emitter_1 = __importDefault(require("../Events/Emitter"));
const Region_1 = require("../DataTypes/Interfaces/Region");
const AABB_1 = __importDefault(require("../DataTypes/Shapes/AABB"));
const TweenController_1 = __importDefault(require("../Rendering/Animations/TweenController"));
const Debug_1 = __importDefault(require("../Debug/Debug"));
const Color_1 = __importDefault(require("../Utils/Color"));
const Circle_1 = __importDefault(require("../DataTypes/Shapes/Circle"));
/**
 * The representation of an object in the game world.
 * To construct GameNodes, see the @reference[Scene] documentation.
 */
class GameNode {
    // Constructor docs are ignored, as the user should NOT create new GameNodes with a raw constructor
    constructor() {
        /*---------- PHYSICAL ----------*/
        this.hasPhysics = false;
        this.moving = false;
        this.frozen = false;
        this.onGround = false;
        this.onWall = false;
        this.onCeiling = false;
        this.active = false;
        this.isColliding = false;
        this.pathfinding = false;
        this._position = new Vec2_1.default(0, 0);
        this._position.setOnChange(() => this.positionChanged());
        this.receiver = new Receiver_1.default();
        this.emitter = new Emitter_1.default();
        this.tweens = new TweenController_1.default(this);
        this.rotation = 0;
    }
    destroy() {
        this.tweens.destroy();
        this.receiver.destroy();
        if (this.hasPhysics) {
            this.removePhysics();
        }
        if (this._ai) {
            this._ai.destroy();
            delete this._ai;
            this.scene.getAIManager().removeActor(this);
        }
        this.scene.remove(this);
        this.layer.removeNode(this);
    }
    /*---------- POSITIONED ----------*/
    get position() {
        return this._position;
    }
    set position(pos) {
        this._position = pos;
        this._position.setOnChange(() => this.positionChanged());
        this.positionChanged();
    }
    get relativePosition() {
        return this.inRelativeCoordinates(this.position);
    }
    /**
     * Converts a point to coordinates relative to the zoom and origin of this node
     * @param point The point to conver
     * @returns A new Vec2 representing the point in relative coordinates
     */
    inRelativeCoordinates(point) {
        let origin = this.scene.getViewTranslation(this);
        let zoom = this.scene.getViewScale();
        return point.clone().sub(origin).scale(zoom);
    }
    /*---------- UNIQUE ----------*/
    get id() {
        return this._id;
    }
    set id(id) {
        // id can only be set once
        if (this._id === undefined) {
            this._id = id;
        }
        else {
            throw "Attempted to assign id to object that already has id.";
        }
    }
    /*---------- PHYSICAL ----------*/
    // @implemented
    /**
     * @param velocity The velocity with which to move the object.
     */
    move(velocity) {
        if (this.frozen)
            return;
        this.moving = true;
        this._velocity = velocity;
    }
    ;
    moveOnPath(speed, path) {
        if (this.frozen || path.isDone())
            return;
        this.path = path;
        let dir = path.getMoveDirection(this);
        this.moving = true;
        this.pathfinding = true;
        this._velocity = dir.scale(speed);
    }
    // @implemented
    /**
     * @param velocity The velocity with which the object will move.
     */
    finishMove() {
        this.moving = false;
        this.position.add(this._velocity);
        if (this.pathfinding) {
            this.path.handlePathProgress(this);
            this.path = null;
            this.pathfinding = false;
        }
    }
    // @implemented
    /**
     * @param collisionShape The collider for this object. If this has a region (implements Region),
     * it will be used when no collision shape is specified (or if collision shape is null).
     * @param isCollidable Whether this is collidable or not. True by default.
     * @param isStatic Whether this is static or not. False by default
     */
    addPhysics(collisionShape, colliderOffset, isCollidable = true, isStatic = false) {
        // Initialize the physics variables
        this.hasPhysics = true;
        this.moving = false;
        this.onGround = false;
        this.onWall = false;
        this.onCeiling = false;
        this.active = true;
        this.isCollidable = isCollidable;
        this.isStatic = isStatic;
        this.isTrigger = false;
        this.triggerMask = 0;
        this.triggerEnters = new Array(32);
        this.triggerExits = new Array(32);
        this._velocity = Vec2_1.default.ZERO;
        this.sweptRect = new AABB_1.default();
        this.collidedWithTilemap = false;
        this.group = -1; // The default group, collides with everything
        // Set the collision shape if provided, or simply use the the region if there is one.
        if (collisionShape) {
            this.collisionShape = collisionShape;
            this.collisionShape.center = this.position;
        }
        else if ((0, Region_1.isRegion)(this)) {
            // If the gamenode has a region and no other is specified, use that
            this.collisionShape = this.boundary.clone();
        }
        else {
            throw "No collision shape specified for physics object.";
        }
        // If we were provided with a collider offset, set it. Otherwise there is no offset, so use the zero vector
        if (colliderOffset) {
            this.colliderOffset = colliderOffset;
        }
        else {
            this.colliderOffset = Vec2_1.default.ZERO;
        }
        // Initialize the swept rect
        this.sweptRect = this.collisionShape.getBoundingRect();
        // Register the object with physics
        this.scene.getPhysicsManager().registerObject(this);
    }
    /** Removes this object from the physics system */
    removePhysics() {
        // Remove this from the physics manager
        this.scene.getPhysicsManager().deregisterObject(this);
        // Nullify all physics fields
        this.hasPhysics = false;
        this.moving = false;
        this.onGround = false;
        this.onWall = false;
        this.onCeiling = false;
        this.active = false;
        this.isCollidable = false;
        this.isStatic = false;
        this.isTrigger = false;
        this.triggerMask = 0;
        this.triggerEnters = null;
        this.triggerExits = null;
        this._velocity = Vec2_1.default.ZERO;
        this.sweptRect = null;
        this.collidedWithTilemap = false;
        this.group = -1;
        this.collisionShape = null;
        this.colliderOffset = Vec2_1.default.ZERO;
        this.sweptRect = null;
    }
    /** Disables physics movement for this node */
    freeze() {
        this.frozen = true;
    }
    /** Reenables physics movement for this node */
    unfreeze() {
        this.frozen = false;
    }
    /** Prevents this object from participating in all collisions and triggers. It can still move. */
    disablePhysics() {
        this.active = false;
    }
    /** Enables this object to participate in collisions and triggers. This is only necessary if disablePhysics was called */
    enablePhysics() {
        this.active = true;
    }
    /**
     * Sets the collider for this GameNode
     * @param collider The new collider to use
     */
    setCollisionShape(collider) {
        this.collisionShape = collider;
        this.collisionShape.center.copy(this.position);
    }
    // @implemented
    /**
     * Sets this object to be a trigger for a specific group
     * @param group The name of the group that activates the trigger
     * @param onEnter The name of the event to send when this trigger is activated
     * @param onExit The name of the event to send when this trigger stops being activated
     */
    setTrigger(group, onEnter, onExit) {
        // Make this object a trigger
        this.isTrigger = true;
        // Get the number of the physics layer
        let layerNumber = this.scene.getPhysicsManager().getGroupNumber(group);
        if (layerNumber === 0) {
            console.warn(`Trigger for GameNode ${this.id} not set - group "${group}" was not recognized by the physics manager.`);
            return;
        }
        // Add this to the trigger mask
        this.triggerMask |= layerNumber;
        // Layer numbers are bits, so get which bit it is
        let index = Math.log2(layerNumber);
        // Set the event names
        this.triggerEnters[index] = onEnter;
        this.triggerExits[index] = onExit;
    }
    ;
    // @implemented
    /**
     * @param group The physics group this node should belong to
     */
    setGroup(group) {
        this.scene.getPhysicsManager().setGroup(this, group);
    }
    // @implemened
    getLastVelocity() {
        return this._velocity;
    }
    /*---------- ACTOR ----------*/
    get ai() {
        return this._ai;
    }
    set ai(ai) {
        if (!this._ai) {
            // If we haven't been previously had an ai, register us with the ai manager
            this.scene.getAIManager().registerActor(this);
        }
        this._ai = ai;
        this.aiActive = true;
    }
    // @implemented
    addAI(ai, options, type) {
        if (!this._ai) {
            this.scene.getAIManager().registerActor(this);
        }
        if (typeof ai === "string") {
            this._ai = this.scene.getAIManager().generateAI(ai);
        }
        else {
            this._ai = new ai();
        }
        // Question, how much do we want different type of AI to be handled the same, i.e. should GoapAI and AI similar methods and signatures for the sake of unity
        this._ai.initializeAI(this, options);
        this.aiActive = true;
    }
    // @implemented
    setAIActive(active, options) {
        this.aiActive = active;
        if (this.aiActive) {
            this.ai.activate(options);
        }
    }
    /*---------- TWEENABLE PROPERTIES ----------*/
    set positionX(value) {
        this.position.x = value;
    }
    set positionY(value) {
        this.position.y = value;
    }
    /*---------- GAME NODE ----------*/
    /**
     * Sets the scene for this object.
     * @param scene The scene this object belongs to.
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * Gets the scene this object is in.
     * @returns The scene this object belongs to
    */
    getScene() {
        return this.scene;
    }
    /**
     * Sets the layer of this object.
     * @param layer The layer this object will be on.
     */
    setLayer(layer) {
        this.layer = layer;
    }
    /**
     * Returns the layer this object is on.
     * @returns This layer this object is on.
    */
    getLayer() {
        return this.layer;
    }
    /** Called if the position vector is modified or replaced */
    positionChanged() {
        if (this.collisionShape) {
            if (this.colliderOffset) {
                this.collisionShape.center = this.position.clone().add(this.colliderOffset);
            }
            else {
                this.collisionShape.center = this.position.clone();
            }
        }
    }
    ;
    /**
     * Updates this GameNode
     * @param deltaT The timestep of the update.
     */
    update(deltaT) {
        // Defer event handling to AI.
        while (this.receiver.hasNextEvent()) {
            this._ai.handleEvent(this.receiver.getNextEvent());
        }
    }
    // @implemented
    debugRender() {
        // Draw the position of this GameNode
        Debug_1.default.drawPoint(this.relativePosition, Color_1.default.BLUE);
        // If velocity is not zero, draw a vector for it
        if (this._velocity && !this._velocity.isZero()) {
            Debug_1.default.drawRay(this.relativePosition, this._velocity.clone().scaleTo(20).add(this.relativePosition), Color_1.default.BLUE);
        }
        // If this has a collider, draw it
        if (this.collisionShape) {
            let color = this.isColliding ? Color_1.default.RED : Color_1.default.GREEN;
            if (this.isTrigger) {
                color = Color_1.default.MAGENTA;
            }
            color.a = 0.2;
            if (this.collisionShape instanceof AABB_1.default) {
                Debug_1.default.drawBox(this.inRelativeCoordinates(this.collisionShape.center), this.collisionShape.halfSize.scaled(this.scene.getViewScale()), true, color);
            }
            else if (this.collisionShape instanceof Circle_1.default) {
                Debug_1.default.drawCircle(this.inRelativeCoordinates(this.collisionShape.center), this.collisionShape.hw * this.scene.getViewScale(), true, color);
            }
        }
    }
}
exports.default = GameNode;
var TweenableProperties;
(function (TweenableProperties) {
    TweenableProperties["posX"] = "positionX";
    TweenableProperties["posY"] = "positionY";
    TweenableProperties["scaleX"] = "scaleX";
    TweenableProperties["scaleY"] = "scaleY";
    TweenableProperties["rotation"] = "rotation";
    TweenableProperties["alpha"] = "alpha";
})(TweenableProperties = exports.TweenableProperties || (exports.TweenableProperties = {}));

},{"../DataTypes/Interfaces/Region":15,"../DataTypes/Shapes/AABB":20,"../DataTypes/Shapes/Circle":21,"../DataTypes/Vec2":26,"../Debug/Debug":27,"../Events/Emitter":29,"../Events/Receiver":33,"../Rendering/Animations/TweenController":76,"../Utils/Color":106}],43:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasNode_1 = __importDefault(require("./CanvasNode"));
const Color_1 = __importDefault(require("../Utils/Color"));
/**
 * The representation of a game object that doesn't rely on any resources to render - it is drawn to the screen by the canvas
 */
class Graphic extends CanvasNode_1.default {
    constructor() {
        super();
        this.color = Color_1.default.RED;
    }
    get alpha() {
        return this.color.a;
    }
    set alpha(a) {
        this.color.a = a;
    }
    // @deprecated
    /**
     * Sets the color of the Graphic. DEPRECATED
     * @param color The new color of the Graphic.
     */
    setColor(color) {
        this.color = color;
    }
    set colorR(r) {
        this.color.r = r;
    }
    get colorR() {
        return this.color.r;
    }
    set colorG(g) {
        this.color.g = g;
    }
    get colorG() {
        return this.color.g;
    }
    set colorB(b) {
        this.color.b = b;
    }
    get colorB() {
        return this.color.b;
    }
}
exports.default = Graphic;

},{"../Utils/Color":106,"./CanvasNode":41}],44:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphicType = void 0;
var GraphicType;
(function (GraphicType) {
    GraphicType["POINT"] = "POINT";
    GraphicType["RECT"] = "RECT";
    GraphicType["LINE"] = "LINE";
    GraphicType["PARTICLE"] = "PARTICLE";
})(GraphicType = exports.GraphicType || (exports.GraphicType = {}));

},{}],45:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Graphic_1 = __importDefault(require("../Graphic"));
class Line extends Graphic_1.default {
    constructor(start, end) {
        super();
        this.start = start;
        this.end = end;
        this.thickness = 2;
        // Does this really have a meaning for lines?
        this.size.set(5, 5);
    }
    set start(pos) {
        this.position = pos;
    }
    get start() {
        return this.position;
    }
    set end(pos) {
        this._end = pos;
    }
    get end() {
        return this._end;
    }
}
exports.default = Line;

},{"../Graphic":43}],46:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Point_1 = __importDefault(require("./Point"));
/**
 * - Position X
- Velocity (speed and direction) X
- Color X
- Lifetime
- Age can be handled as lifetime
- Shape X
- Size X
- Transparency X
 */
class Particle extends Point_1.default {
    constructor(position, size, mass) {
        // Are we making this a circle?
        super(position);
        this.inUse = false;
        this.mass = mass;
    }
    setParticleActive(lifetime, position) {
        this.age = lifetime;
        this.inUse = true;
        this.visible = true;
        this.position = position;
    }
    decrementAge(decay) {
        this.age -= decay;
    }
    setParticleInactive() {
        this.inUse = false;
        this.visible = false;
    }
    set velY(y) {
        this.vel.y = y;
    }
    get velY() {
        return this.vel.y;
    }
}
exports.default = Particle;

},{"./Point":47}],47:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Graphic_1 = __importDefault(require("../Graphic"));
/** A basic point to be drawn on the screen. */
class Point extends Graphic_1.default {
    constructor(position) {
        // Are we making this a circle?
        super();
        this.position = position;
        this.size.set(5, 5);
    }
}
exports.default = Point;

},{"../Graphic":43}],48:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Graphic_1 = __importDefault(require("../Graphic"));
const Color_1 = __importDefault(require("../../Utils/Color"));
/** A basic rectangle to be drawn on the screen. */
class Rect extends Graphic_1.default {
    constructor(position, size) {
        super();
        this.position = position;
        this.size = size;
        this.borderColor = Color_1.default.TRANSPARENT;
        this.borderWidth = 0;
    }
    /**
     * Sets the border color of this rectangle
     * @param color The border color
     */
    setBorderColor(color) {
        this.borderColor = color;
    }
    // @deprecated
    getBorderColor() {
        return this.borderColor;
    }
    /**
     * Sets the border width of this rectangle
     * @param width The width of the rectangle in pixels
     */
    setBorderWidth(width) {
        this.borderWidth = width;
    }
    getBorderWidth() {
        return this.borderWidth;
    }
}
exports.default = Rect;

},{"../../Utils/Color":106,"../Graphic":43}],49:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Sprite_1 = __importDefault(require("./Sprite"));
const AnimationManager_1 = __importDefault(require("../../Rendering/Animations/AnimationManager"));
const Vec2_1 = __importDefault(require("../../DataTypes/Vec2"));
/** An sprite with specified animation frames. */
class AnimatedSprite extends Sprite_1.default {
    constructor(spritesheet) {
        super(spritesheet.name);
        this.numCols = spritesheet.columns;
        this.numRows = spritesheet.rows;
        // Set the size of the sprite to the sprite size specified by the spritesheet
        this.size.set(spritesheet.spriteWidth, spritesheet.spriteHeight);
        this.animation = new AnimationManager_1.default(this);
        // Add the animations to the animated sprite
        for (let animation of spritesheet.animations) {
            this.animation.add(animation.name, animation);
        }
    }
    get cols() {
        return this.numCols;
    }
    get rows() {
        return this.numRows;
    }
    /**
     * Gets the image offset for the current index of animation
     * @param index The index we're at in the animation
     * @returns A Vec2 containing the image offset
     */
    getAnimationOffset(index) {
        return new Vec2_1.default((index % this.numCols) * this.size.x, Math.floor(index / this.numCols) * this.size.y);
    }
}
exports.default = AnimatedSprite;

},{"../../DataTypes/Vec2":26,"../../Rendering/Animations/AnimationManager":73,"./Sprite":50}],50:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasNode_1 = __importDefault(require("../CanvasNode"));
const ResourceManager_1 = __importDefault(require("../../ResourceManager/ResourceManager"));
const Vec2_1 = __importDefault(require("../../DataTypes/Vec2"));
/**
 * The representation of a sprite - an in-game image
 */
class Sprite extends CanvasNode_1.default {
    constructor(imageId) {
        super();
        this.imageId = imageId;
        let image = ResourceManager_1.default.getInstance().getImage(this.imageId);
        this.size = new Vec2_1.default(image.width, image.height);
        this.imageOffset = Vec2_1.default.ZERO;
        this.invertX = false;
        this.invertY = false;
    }
    /**
     * Sets the offset of the sprite from (0, 0) in the image's coordinates
     * @param offset The offset of the sprite from (0, 0) in image coordinates
     */
    setImageOffset(offset) {
        this.imageOffset = offset;
    }
}
exports.default = Sprite;

},{"../../DataTypes/Vec2":26,"../../ResourceManager/ResourceManager":90,"../CanvasNode":41}],51:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../DataTypes/Vec2"));
const CanvasNode_1 = __importDefault(require("./CanvasNode"));
/**
 * The representation of a tilemap - this can consist of a combination of tilesets in one layer
 */
class Tilemap extends CanvasNode_1.default {
    // TODO: Make this no longer be specific to Tiled
    constructor(tilemapData, layer, tilesets, scale) {
        super();
        this.tilesets = tilesets;
        this.tileSize = new Vec2_1.default(0, 0);
        this.name = layer.name;
        this.numCols = tilemapData.width;
        this.numRows = tilemapData.height;
        let tilecount = 0;
        for (let tileset of tilesets) {
            tilecount += tileset.getTileCount() + 1;
        }
        this.collisionMap = new Array(tilecount);
        for (let i = 0; i < this.collisionMap.length; i++) {
            this.collisionMap[i] = false;
        }
        // Defer parsing of the data to child classes - this allows for isometric vs. orthographic tilemaps and handling of Tiled data or other data
        this.parseTilemapData(tilemapData, layer);
        this.scale.set(scale.x, scale.y);
    }
    get name() { return this._name; }
    set name(name) { this._name = name; }
    /**
     * Gets the data value of the tile at the specified index
     * @param index The index of the tile
     * @returns The data value of the tile
     */
    getTile(col, row) {
        let index = this.getTileIndex(col, row);
        if (index === -1) {
            return -1;
        }
        return this.data[index];
    }
    /**
     * Gets the index of the tile in the tilemaps backing array.
     * @param position the position in row-column format in the backing array of the tilemap
     * @returns the index of position in the tilemap
     */
    getTileIndex(col, row) {
        if (col < 0 || col >= this.numCols || row < 0 || row >= this.numRows) {
            return -1;
        }
        return row * this.numCols + col;
    }
    /**
     * Gets the column and row of a tile in the tilemap from the index of the tile
     * in the backing array.
     * @param index the index of the tile in the backing array
     * @return a Vec2 containing the column and row indices of the tile
     */
    getTileColRow(index) {
        let col = index % this.numCols;
        let row = Math.floor(index / this.numCols);
        return new Vec2_1.default(col, row);
    }
    /**
     * Sets the tile at the specified position to the given tile.
     * @param position the row and column of the tile in the backing array
     * @param tile the number of the tile to set
     */
    setTile(col, row, tile) {
        let index = this.getTileIndex(col, row);
        if (index !== -1) {
            this.data[index] = tile;
        }
    }
    /**
     * Returns an array of the tilesets associated with this tilemap
     * @returns An array of all of the tilesets assocaited with this tilemap.
     */
    getTilesets() {
        return this.tilesets;
    }
    /**
     * Gets the dimensions of the tilemap
     * @returns A Vec2 containing the number of columns and the number of rows in the tilemap.
     */
    getDimensions() {
        return new Vec2_1.default(this.numCols, this.numRows);
    }
    // Methods for getting the size of a tile
    /**
     * Gets the raw size of the tiles, without any scaling or zooming.
     * @returns the size of the tiles in this tilemap
     */
    getTileSize() {
        return this.tileSize;
    }
    /**
     * Returns the size of tiles in this tilemap as they appear in the game world after scaling
     * @returns A vector containing the size of tiles in this tilemap as they appear in the game world after scaling.
     */
    getScaledTileSize() {
        return this.getTileSize().scaled(this.scale.x, this.scale.y);
    }
    /**
     * Returns true if the tile at the specified row and column of the tilemap is collidable
     * @param col the specified column
     * @param row the specified row
     * @returns A flag representing whether or not the tile is collidable.
     */
    isTileCollidable(col, row) {
        if (col < 0 || col >= this.numCols || row < 0 || row >= this.numRows) {
            return false;
        }
        return this.collisionMap[this.getTile(col, row)];
    }
    /**
     * Adds this tilemap to the physics system
     */
    addPhysics() {
        this.hasPhysics = true;
        this.active = true;
        this.group = -1;
        this.scene.getPhysicsManager().registerTilemap(this);
    }
}
exports.default = Tilemap;

},{"../DataTypes/Vec2":26,"./CanvasNode":41}],52:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../../DataTypes/Vec2"));
const Debug_1 = __importDefault(require("../../Debug/Debug"));
const Color_1 = __importDefault(require("../../Utils/Color"));
const Tilemap_1 = __importDefault(require("../Tilemap"));
class IsometricTilemap extends Tilemap_1.default {
    getMinColRow(region) {
        return new Vec2_1.default(0, 0);
    }
    getMaxColRow(region) {
        return new Vec2_1.default(this.numCols, this.numRows);
    }
    getWorldPosition(col, row) {
        if (col < 0 || col > this.numCols || row < 0 || row > this.numRows) {
            return null;
        }
        let vpx = this.scene.getViewport().getHalfSize().x;
        let x = Math.floor(this.scale.x * this.tileSize.x / 2 * (col - row) + vpx);
        let y = Math.floor(this.scale.y * this.tileSize.y / 2 * (col + row));
        return new Vec2_1.default(x, y);
    }
    getTilemapPosition(x, y) {
        let vpx = this.scene.getViewport().getHalfSize().x;
        let col = Math.floor((x - vpx) / this.scale.x / this.tileSize.x + y / this.scale.y / this.tileSize.y);
        let row = Math.floor(y / this.scale.y / this.tileSize.y - (x - vpx) / this.scale.x / this.tileSize.x);
        if (col < 0 || col > this.numCols || row < 0 || row > this.numRows) {
            return null;
        }
        return new Vec2_1.default(col, row);
    }
    getTileCollider(col, row) {
        return;
    }
    parseTilemapData(tilemapData, layer) {
        // The size of the tilemap in local space
        this.numCols = tilemapData.width;
        this.numRows = tilemapData.height;
        // The size of tiles
        this.tileSize.set(tilemapData.tilewidth, tilemapData.tileheight);
        // The size of the tilemap on the canvas
        this.size.set(this.numCols * this.tileSize.x, this.numRows * this.tileSize.y);
        this.position.copy(this.size.scaled(0.5));
        this.data = layer.data;
        this.visible = layer.visible;
        // Whether the tilemap is collidable or not
        this.isCollidable = false;
        if (layer.properties) {
            for (let item of layer.properties) {
                if (item.name === "Collidable") {
                    this.isCollidable = item.value;
                    // Set all tiles besides "empty: 0" to be collidable
                    for (let i = 1; i < this.collisionMap.length; i++) {
                        this.collisionMap[i] = true;
                    }
                }
            }
        }
    }
    debugRender() {
        for (let tile = 0; tile < this.data.length; tile++) {
            let pos = this.getTileColRow(tile);
            Debug_1.default.drawPoint(this.getWorldPosition(pos.x, pos.y), Color_1.default.BLUE);
        }
    }
}
exports.default = IsometricTilemap;

},{"../../DataTypes/Vec2":26,"../../Debug/Debug":27,"../../Utils/Color":106,"../Tilemap":51}],53:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Tilemap_1 = __importDefault(require("../Tilemap"));
const Vec2_1 = __importDefault(require("../../DataTypes/Vec2"));
const Debug_1 = __importDefault(require("../../Debug/Debug"));
const Color_1 = __importDefault(require("../../Utils/Color"));
const AABB_1 = __importDefault(require("../../DataTypes/Shapes/AABB"));
/**
 * The representation of an orthogonal tilemap - i.e. a top down or platformer tilemap
 */
class OrthogonalTilemap extends Tilemap_1.default {
    getMinColRow(region) {
        return this.getTilemapPosition(region.topLeft.x, region.topLeft.y);
    }
    getMaxColRow(region) {
        return this.getTilemapPosition(region.bottomRight.x, region.bottomRight.y);
    }
    getTilemapPosition(x, y) {
        let col = Math.floor(x / this.tileSize.x / this.scale.x);
        let row = Math.floor(y / this.tileSize.y / this.scale.y);
        return new Vec2_1.default(col, row);
    }
    getWorldPosition(col, row) {
        let x = col * this.tileSize.x * this.scale.x;
        let y = row * this.tileSize.y * this.scale.y;
        return new Vec2_1.default(x, y);
    }
    getTileCollider(col, row) {
        let tileSize = this.getScaledTileSize();
        let centerX = col * tileSize.x + tileSize.x / 2;
        let centerY = row * tileSize.y + tileSize.y / 2;
        let center = new Vec2_1.default(centerX, centerY);
        let halfSize = tileSize.scaled(0.5);
        return new AABB_1.default(center, halfSize);
    }
    parseTilemapData(tilemapData, layer) {
        // The size of the tilemap in local space
        this.numCols = tilemapData.width;
        this.numRows = tilemapData.height;
        // The size of tiles
        this.tileSize.set(tilemapData.tilewidth, tilemapData.tileheight);
        // The size of the tilemap on the canvas
        this.size.set(this.numCols * this.tileSize.x, this.numRows * this.tileSize.y);
        this.position.copy(this.size.scaled(0.5));
        this.data = layer.data;
        this.visible = layer.visible;
        // Whether the tilemap is collidable or not
        this.isCollidable = false;
        if (layer.properties) {
            for (let item of layer.properties) {
                if (item.name === "Collidable") {
                    this.isCollidable = item.value;
                    // Set all tiles besides "empty: 0" to be collidable
                    for (let i = 1; i < this.collisionMap.length; i++) {
                        this.collisionMap[i] = true;
                    }
                }
            }
        }
    }
    // @override
    update(deltaT) { }
    // @override
    debugRender() {
        for (let i = 0; i < this.data.length; i++) {
            let cr = this.getTileColRow(i);
            if (this.isCollidable && this.isTileCollidable(cr.x, cr.y)) {
                let box = this.getTileCollider(cr.x, cr.y);
                Debug_1.default.drawBox(this.inRelativeCoordinates(box.center), box.halfSize.scale(this.scene.getViewScale()), false, Color_1.default.BLUE);
            }
        }
    }
}
exports.default = OrthogonalTilemap;

},{"../../DataTypes/Shapes/AABB":20,"../../DataTypes/Vec2":26,"../../Debug/Debug":27,"../../Utils/Color":106,"../Tilemap":51}],54:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const AABB_1 = __importDefault(require("../../DataTypes/Shapes/AABB"));
const Vec2_1 = __importDefault(require("../../DataTypes/Vec2"));
const Debug_1 = __importDefault(require("../../Debug/Debug"));
const Color_1 = __importDefault(require("../../Utils/Color"));
const Tilemap_1 = __importDefault(require("../Tilemap"));
class StaggeredIsometricTilemap extends Tilemap_1.default {
    getTilemapPosition(x, y) {
        let col = x / this.tileSize.x / this.scale.x;
        let row = Math.floor(y / this.tileSize.y / this.scale.y * 2);
        if (row % 2 !== 0) {
            col = (x - this.tileSize.x / this.scale.x / 2) / this.tileSize.x / this.scale.x;
        }
        return new Vec2_1.default(Math.floor(col), row);
    }
    getWorldPosition(col, row) {
        let x = col * this.tileSize.x * this.scale.x;
        let y = row * this.tileSize.y / 2 * this.scale.y;
        if (row % 2 !== 0) {
            x += this.tileSize.x * this.scale.x / 2;
        }
        return new Vec2_1.default(Math.floor(x), Math.floor(y));
    }
    getTileCollider(col, row) {
        let tileSize = this.getScaledTileSize();
        let centerX = col * tileSize.x + tileSize.x / 2;
        let centerY = row * tileSize.y / 2 + tileSize.y + tileSize.y / 2;
        if (row % 2 !== 0) {
            centerX += tileSize.x / 2;
        }
        let center = new Vec2_1.default(centerX, centerY);
        let halfSize = tileSize.scaled(0.5);
        return new AABB_1.default(center, halfSize);
    }
    getMinColRow(region) {
        return new Vec2_1.default(0, 0);
    }
    getMaxColRow(region) {
        return new Vec2_1.default(this.numCols, this.numRows);
    }
    parseTilemapData(tilemapData, layer) {
        // The size of the tilemap in local space
        this.numCols = tilemapData.width;
        this.numRows = tilemapData.height;
        // The size of tiles
        this.tileSize.set(tilemapData.tilewidth, tilemapData.tileheight);
        // The size of the tilemap on the canvas
        this.size.set(this.numCols * this.tileSize.x, this.numRows * this.tileSize.y);
        this.position.copy(this.size.scaled(0.5));
        this.data = layer.data;
        this.visible = layer.visible;
        // Whether the tilemap is collidable or not
        this.isCollidable = false;
        if (layer.properties) {
            for (let item of layer.properties) {
                if (item.name === "Collidable") {
                    this.isCollidable = item.value;
                    // Set all tiles besides "empty: 0" to be collidable
                    for (let i = 1; i < this.collisionMap.length; i++) {
                        this.collisionMap[i] = true;
                    }
                }
            }
        }
    }
    debugRender() {
        for (let i = 0; i < this.data.length; i++) {
            let rc = this.getTileColRow(i);
            let box = this.getTileCollider(rc.x, rc.y);
            Debug_1.default.drawBox(this.inRelativeCoordinates(box.center), box.halfSize.scale(this.scene.getViewScale()), false, Color_1.default.BLUE);
        }
    }
}
exports.default = StaggeredIsometricTilemap;

},{"../../DataTypes/Shapes/AABB":20,"../../DataTypes/Vec2":26,"../../Debug/Debug":27,"../../Utils/Color":106,"../Tilemap":51}],55:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasNode_1 = __importDefault(require("./CanvasNode"));
const Color_1 = __importDefault(require("../Utils/Color"));
const Vec2_1 = __importDefault(require("../DataTypes/Vec2"));
const Input_1 = __importDefault(require("../Input/Input"));
/**
 * The representation of a UIElement - the parent class of things like buttons
 */
class UIElement extends CanvasNode_1.default {
    constructor(position) {
        super();
        this.position = position;
        this.backgroundColor = new Color_1.default(0, 0, 0, 0);
        this.borderColor = new Color_1.default(0, 0, 0, 0);
        this.borderRadius = 5;
        this.borderWidth = 1;
        this.padding = Vec2_1.default.ZERO;
        this.onClick = null;
        this.onClickEventId = null;
        this.onRelease = null;
        this.onReleaseEventId = null;
        this.onEnter = null;
        this.onEnterEventId = null;
        this.onLeave = null;
        this.onLeaveEventId = null;
        this.isClicked = false;
        this.isEntered = false;
    }
    // @deprecated
    setBackgroundColor(color) {
        this.backgroundColor = color;
    }
    // @deprecated
    setPadding(padding) {
        this.padding.copy(padding);
    }
    update(deltaT) {
        super.update(deltaT);
        // See of this object was just clicked
        if (Input_1.default.isMouseJustPressed()) {
            let clickPos = Input_1.default.getMousePressPosition();
            if (this.contains(clickPos.x, clickPos.y) && this.visible && !this.layer.isHidden()) {
                this.isClicked = true;
                if (this.onClick !== null) {
                    this.onClick();
                }
                if (this.onClickEventId !== null) {
                    let data = {};
                    this.emitter.fireEvent(this.onClickEventId, data);
                }
            }
        }
        // If the mouse wasn't just pressed, then we definitely weren't clicked
        if (!Input_1.default.isMousePressed()) {
            if (this.isClicked) {
                this.isClicked = false;
            }
        }
        // Check if the mouse is hovering over this element
        let mousePos = Input_1.default.getMousePosition();
        if (mousePos && this.contains(mousePos.x, mousePos.y)) {
            this.isEntered = true;
            if (this.onEnter !== null) {
                this.onEnter();
            }
            if (this.onEnterEventId !== null) {
                let data = {};
                this.emitter.fireEvent(this.onEnterEventId, data);
            }
        }
        else if (this.isEntered) {
            this.isEntered = false;
            if (this.onLeave !== null) {
                this.onLeave();
            }
            if (this.onLeaveEventId !== null) {
                let data = {};
                this.emitter.fireEvent(this.onLeaveEventId, data);
            }
        }
        else if (this.isClicked) {
            // If mouse is dragged off of element while down, it is not clicked anymore
            this.isClicked = false;
        }
    }
    /**
     * Overridable method for calculating background color - useful for elements that want to be colored on different after certain events
     * @returns The background color of the UIElement
     */
    calculateBackgroundColor() {
        return this.backgroundColor;
    }
    /**
     * Overridable method for calculating border color - useful for elements that want to be colored on different after certain events
     * @returns The border color of the UIElement
     */
    calculateBorderColor() {
        return this.borderColor;
    }
}
exports.default = UIElement;

},{"../DataTypes/Vec2":26,"../Input/Input":34,"../Utils/Color":106,"./CanvasNode":41}],56:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Label_1 = __importDefault(require("./Label"));
const Color_1 = __importDefault(require("../../Utils/Color"));
/** A clickable button UIElement */
class Button extends Label_1.default {
    constructor(position, text) {
        super(position, text);
        this.backgroundColor = new Color_1.default(150, 75, 203);
        this.borderColor = new Color_1.default(41, 46, 30);
        this.textColor = new Color_1.default(255, 255, 255);
    }
    // @override
    calculateBackgroundColor() {
        // Change the background color if clicked or hovered
        if (this.isEntered && !this.isClicked) {
            return this.backgroundColor.lighten();
        }
        else if (this.isClicked) {
            return this.backgroundColor.darken();
        }
        else {
            return this.backgroundColor;
        }
    }
}
exports.default = Button;

},{"../../Utils/Color":106,"./Label":57}],57:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HAlign = exports.VAlign = void 0;
const Vec2_1 = __importDefault(require("../../DataTypes/Vec2"));
const Color_1 = __importDefault(require("../../Utils/Color"));
const UIElement_1 = __importDefault(require("../UIElement"));
/** A basic text-containing label */
class Label extends UIElement_1.default {
    constructor(position, text) {
        super(position);
        this.text = text;
        this.textColor = new Color_1.default(0, 0, 0, 1);
        this.font = "Arial";
        this.fontSize = 30;
        this.hAlign = "center";
        this.vAlign = "center";
        this.sizeAssigned = false;
    }
    // @deprecated
    setText(text) {
        this.text = text;
    }
    // @deprecated
    setTextColor(color) {
        this.textColor = color;
    }
    /**
     * Gets a string containg the font details for rendering
     * @returns A string containing the font details
     */
    getFontString() {
        return this.fontSize + "px " + this.font;
    }
    /**
     * Overridable method for calculating text color - useful for elements that want to be colored on different after certain events
     * @returns a string containg the text color
     */
    calculateTextColor() {
        return this.textColor.toStringRGBA();
    }
    /**
     * Uses the canvas to calculate the width of the text
     * @param ctx The rendering context
     * @returns A number representing the rendered text width
     */
    calculateTextWidth(ctx) {
        ctx.font = this.fontSize + "px " + this.font;
        return ctx.measureText(this.text).width;
    }
    setHAlign(align) {
        this.hAlign = align;
    }
    setVAlign(align) {
        this.vAlign = align;
    }
    /**
     * Calculate the offset of the text - this is used for rendering text with different alignments
     * @param ctx The rendering context
     * @returns The offset of the text in a Vec2
     */
    calculateTextOffset(ctx) {
        let textWidth = this.calculateTextWidth(ctx);
        let offset = new Vec2_1.default(0, 0);
        let hDiff = this.size.x - textWidth;
        if (this.hAlign === HAlign.CENTER) {
            offset.x = hDiff / 2;
        }
        else if (this.hAlign === HAlign.RIGHT) {
            offset.x = hDiff;
        }
        if (this.vAlign === VAlign.TOP) {
            ctx.textBaseline = "top";
            offset.y = 0;
        }
        else if (this.vAlign === VAlign.BOTTOM) {
            ctx.textBaseline = "bottom";
            offset.y = this.size.y;
        }
        else {
            ctx.textBaseline = "middle";
            offset.y = this.size.y / 2;
        }
        return offset;
    }
    sizeChanged() {
        super.sizeChanged();
        this.sizeAssigned = true;
    }
    /**
     * Automatically sizes the element to the text within it
     * @param ctx The rendering context
     */
    autoSize(ctx) {
        let width = this.calculateTextWidth(ctx);
        let height = this.fontSize;
        this.size.set(width + this.padding.x * 2, height + this.padding.y * 2);
        this.sizeAssigned = true;
    }
    /**
     * Initially assigns a size to the UIElement if none is provided
     * @param ctx The rendering context
     */
    handleInitialSizing(ctx) {
        if (!this.sizeAssigned) {
            this.autoSize(ctx);
        }
    }
    /** On the next render, size this element to it's current text using its current font size */
    sizeToText() {
        this.sizeAssigned = false;
    }
}
exports.default = Label;
var VAlign;
(function (VAlign) {
    VAlign["TOP"] = "top";
    VAlign["CENTER"] = "center";
    VAlign["BOTTOM"] = "bottom";
})(VAlign = exports.VAlign || (exports.VAlign = {}));
var HAlign;
(function (HAlign) {
    HAlign["LEFT"] = "left";
    HAlign["CENTER"] = "center";
    HAlign["RIGHT"] = "right";
})(HAlign = exports.HAlign || (exports.HAlign = {}));

},{"../../DataTypes/Vec2":26,"../../Utils/Color":106,"../UIElement":55}],58:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../../DataTypes/Vec2"));
const Input_1 = __importDefault(require("../../Input/Input"));
const Color_1 = __importDefault(require("../../Utils/Color"));
const MathUtils_1 = __importDefault(require("../../Utils/MathUtils"));
const UIElement_1 = __importDefault(require("../UIElement"));
/** A slider UIElement */
class Slider extends UIElement_1.default {
    constructor(position, initValue) {
        super(position);
        this.value = initValue;
        this.nibColor = Color_1.default.RED;
        this.sliderColor = Color_1.default.BLACK;
        this.backgroundColor = Color_1.default.TRANSPARENT;
        this.borderColor = Color_1.default.TRANSPARENT;
        this.nibSize = new Vec2_1.default(10, 20);
        // Set a default size
        this.size.set(200, 20);
    }
    /**
     * Retrieves the value of the slider
     * @returns The value of the slider
     */
    getValue() {
        return this.value;
    }
    /** A method called in response to the value changing */
    valueChanged() {
        if (this.onValueChange) {
            this.onValueChange(this.value);
        }
        if (this.onValueChangeEventId) {
            this.emitter.fireEvent(this.onValueChangeEventId, { target: this, value: this.value });
        }
    }
    update(deltaT) {
        super.update(deltaT);
        if (this.isClicked) {
            let val = MathUtils_1.default.invLerp(this.position.x - this.size.x / 2, this.position.x + this.size.x / 2, Input_1.default.getMousePosition().x);
            this.value = MathUtils_1.default.clamp01(val);
            this.valueChanged();
        }
    }
}
exports.default = Slider;

},{"../../DataTypes/Vec2":26,"../../Input/Input":34,"../../Utils/Color":106,"../../Utils/MathUtils":109,"../UIElement":55}],59:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Color_1 = __importDefault(require("../../Utils/Color"));
const Label_1 = __importDefault(require("./Label"));
const Input_1 = __importDefault(require("../../Input/Input"));
/** A text input UIElement */
class TextInput extends Label_1.default {
    constructor(position) {
        super(position, "");
        this.focused = false;
        this.cursorCounter = 0;
        // Give a default size to the x only
        this.size.set(200, this.fontSize);
        this.hAlign = "left";
        this.borderColor = Color_1.default.BLACK;
        this.backgroundColor = Color_1.default.WHITE;
    }
    update(deltaT) {
        super.update(deltaT);
        if (Input_1.default.isMouseJustPressed()) {
            let clickPos = Input_1.default.getMousePressPosition();
            if (this.contains(clickPos.x, clickPos.y)) {
                this.focused = true;
                this.cursorCounter = 30;
            }
            else {
                this.focused = false;
            }
        }
        if (this.focused) {
            let keys = Input_1.default.getKeysJustPressed();
            let nums = "1234567890";
            let specialChars = "`~!@#$%^&*()-_=+[{]}\\|;:'\",<.>/?";
            let letters = "qwertyuiopasdfghjklzxcvbnm";
            let mask = nums + specialChars + letters;
            keys = keys.filter(key => mask.includes(key));
            let shiftPressed = Input_1.default.isKeyPressed("shift");
            let backspacePressed = Input_1.default.isKeyJustPressed("backspace");
            let spacePressed = Input_1.default.isKeyJustPressed("space");
            if (backspacePressed) {
                this.text = this.text.substring(0, this.text.length - 1);
            }
            else if (spacePressed) {
                this.text += " ";
            }
            else if (keys.length > 0) {
                if (shiftPressed) {
                    this.text += keys[0].toUpperCase();
                }
                else {
                    this.text += keys[0];
                }
            }
        }
    }
}
exports.default = TextInput;

},{"../../Input/Input":34,"../../Utils/Color":106,"./Label":57}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UIElementType = void 0;
var UIElementType;
(function (UIElementType) {
    UIElementType["BUTTON"] = "BUTTON";
    UIElementType["LABEL"] = "LABEL";
    UIElementType["SLIDER"] = "SLIDER";
    UIElementType["TEXT_INPUT"] = "TEXTINPUT";
})(UIElementType = exports.UIElementType || (exports.UIElementType = {}));

},{}],61:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = __importDefault(require("../DataTypes/Collections/Map"));
/**
 * The manager class for navigation.
 * Handles all navigable entities, such and allows them to be accessed by outside systems by requesting a path
 * from one position to another.
 */
class NavigationManager {
    constructor() {
        this.navigableEntities = new Map_1.default();
    }
    /**
     * Adds a navigable entity to the NavigationManager
     * @param navName The name of the navigable entitry
     * @param nav The actual Navigable instance
     */
    addNavigableEntity(navName, nav) {
        this.navigableEntities.add(navName, nav);
    }
    /**
     * Gets a path frome one point to another using a specified Navigable object
     * @param navName The name of the registered Navigable object
     * @param fromPosition The starting position of navigation
     * @param toPosition The ending position of Navigation
     * @param direct If true, go direct from fromPosition to toPosition, don't use NavMesh
     * @returns A NavigationPath containing the route to take over the Navigable entity to get between the provided positions.
     */
    getPath(navName, fromPosition, toPosition) {
        let nav = this.navigableEntities.get(navName);
        return nav.getNavigationPath(fromPosition.clone(), toPosition.clone());
    }
}
exports.default = NavigationManager;

},{"../DataTypes/Collections/Map":8}],62:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../DataTypes/Vec2"));
/**
 * A path that AIs can follow. Uses finishMove() in Physical to determine progress on the route
 */
class NavigationPath {
    /**
     * Constructs a new NavigationPath
     * @param path The path of nodes to take
     */
    constructor(path) {
        this.path = path;
        this.currentMoveDirection = Vec2_1.default.ZERO;
        this.distanceThreshold = 4;
    }
    /**
     * Returns the status of navigation along this NavigationPath
     * @returns True if the node has reached the end of the path, false otherwise
     */
    isDone() {
        return this.path.isEmpty();
    }
    next() { return this.path.isEmpty() ? null : this.path.peek(); }
    /**
     * Gets the movement direction in the current position along the path
     * @param node The node to move along the path
     * @returns The movement direction as a Vec2
     */
    getMoveDirection(node) {
        // Return direction to next point in the nav
        return node.position.dirTo(this.path.peek());
    }
    /**
     * Updates this NavigationPath to the current state of the GameNode
     * @param node The node moving along the path
     */
    handlePathProgress(node) {
        if (!this.path.isEmpty() && node.position.distanceSqTo(this.path.peek()) < this.distanceThreshold * this.distanceThreshold) {
            // We've reached our node, move on to the next destination
            this.path.pop();
        }
    }
    toString() {
        return this.path.toString();
    }
}
exports.default = NavigationPath;

},{"../DataTypes/Vec2":26}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * An implementation of a Navmesh. Navmeshes are graphs in the game world along which nodes can move.
 */
class Navmesh {
    /**
     * Creates a new Navmesh from the points in the speecified graph. Navigation is done using the
     * given NavigationStrategy.
     * @param graph the graph to construct a navmesh from
     * @param strategy a constructor for strategy to use to build paths for this navmesh
     */
    constructor(graph) {
        this._graph = graph;
        this._strategies = new Map();
        this._strategy = undefined;
    }
    get graph() { return this._graph; }
    setStrategy(strategy) { this._strategy = this._strategies.get(strategy); }
    // @implemented
    getNavigationPath(fromPosition, toPosition) {
        if (this._strategy === undefined) {
            throw new Error("Error.No pathfinding strategy set for this navmesh.");
        }
        return this._strategy.buildPath(toPosition, fromPosition);
    }
    registerStrategy(key, strategy) {
        this._strategies.set(key, strategy);
    }
}
exports.default = Navmesh;

},{}],64:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Stack_1 = __importDefault(require("../../DataTypes/Collections/Stack"));
const NavigationPath_1 = __importDefault(require("../NavigationPath"));
const NavigationStrategy_1 = __importDefault(require("./NavigationStrategy"));
/**
 * Constructs a navigation path that goes directly from point A to point B. In the
 * original implementation of the NavigationPath, you could set a flag to tell it to
 * create a direct path. I've basically removed that flag and created this class in
 * it's place.
 * @author PeteyLumpkins
 */
class DirectPathStrat extends NavigationStrategy_1.default {
    /**
     * @see NavPathStrat.buildPath()
     */
    buildPath(to, from) {
        let stack = new Stack_1.default();
        stack.push(to.clone());
        return new NavigationPath_1.default(stack);
    }
}
exports.default = DirectPathStrat;

},{"../../DataTypes/Collections/Stack":10,"../NavigationPath":62,"./NavigationStrategy":66}],65:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Stack_1 = __importDefault(require("../../DataTypes/Collections/Stack"));
const GraphUtils_1 = __importDefault(require("../../Utils/GraphUtils"));
const NavigationPath_1 = __importDefault(require("../NavigationPath"));
const NavigationStrategy_1 = __importDefault(require("./NavigationStrategy"));
/**
 * Constructs a navigation path for Wolfie2D using djikstras shortest path algorithm. This
 * was the original implementation used in the NavigationPath class.
 * @author PeteyLumpkins
 */
class DjikstraPathStrat extends NavigationStrategy_1.default {
    /**
     * @see NavPathStrat.buildPath()
     */
    buildPath(to, from) {
        // Get the closest nodes in the graph to our to and from positions
        let start = this.mesh.graph.snap(from);
        let end = this.mesh.graph.snap(to);
        let pathStack = new Stack_1.default(this.mesh.graph.numVertices);
        // Push the final position and the final position in the graph
        pathStack.push(to.clone());
        pathStack.push(this.mesh.graph.positions[end]);
        // Use Djikstras to construct the path
        let parent = GraphUtils_1.default.djikstra(this.mesh.graph, start);
        // Add all parents along the path
        let i = end;
        while (parent[i] !== -1) {
            pathStack.push(this.mesh.graph.positions[parent[i]]);
            i = parent[i];
        }
        return new NavigationPath_1.default(pathStack);
    }
}
exports.default = DjikstraPathStrat;

},{"../../DataTypes/Collections/Stack":10,"../../Utils/GraphUtils":108,"../NavigationPath":62,"./NavigationStrategy":66}],66:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * An abstract navigation strategy for Wolfie2Ds navigation system. You can extend this class to create
 * your own strategy for constructing a NavigationPath for the navigation system.
 * @author PeteyLumpkins
 */
class NavigationStrategy {
    constructor(mesh) {
        this.mesh = mesh;
    }
    get mesh() { return this._mesh; }
    set mesh(mesh) { this._mesh = mesh; }
}
exports.default = NavigationStrategy;

},{}],67:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const PhysicsManager_1 = __importDefault(require("./PhysicsManager"));
const Vec2_1 = __importDefault(require("../DataTypes/Vec2"));
const OrthogonalTilemap_1 = __importDefault(require("../Nodes/Tilemaps/OrthogonalTilemap"));
const AreaCollision_1 = __importDefault(require("../DataTypes/Physics/AreaCollision"));
/**
 * ALGORITHM:
 * 	In an effort to keep things simple and working effectively, each dynamic node will resolve its
 * 	collisions considering the rest of the world as static.
 *
 * 	Collision detecting will happen first. This can be considered a broad phase, but it is not especially
 * 	efficient, as it does not need to be for this game engine. Every dynamic node is checked against every
 * 	other node for collision area. If collision area is non-zero (meaning the current node sweeps into another),
 * 	it is added to a list of hits.
 *
 * 	INITIALIZATION:
 * 		- Physics constants are reset
 * 		- Swept shapes are recalculated. If a node isn't moving, it is skipped.
 *
 * 	COLLISION DETECTION:
 * 		- For a node, collision area will be calculated using the swept AABB of the node against every other AABB in a static state
 * 		- These collisions will be sorted by area in descending order
 *
 * 	COLLISION RESOLUTION:
 * 		- For each hit, time of collision is calculated using a swept line through the AABB of the static node expanded
 * 			with minkowski sums (discretely, but the concept is there)
 * 		- The collision is resolved based on the near time of the collision (from method of separated axes)
 * 			- X is resolved by near x, Y by near y.
 * 			- There is some fudging to allow for sliding along walls of separate colliders. Sorting by area also helps with this.
 * 			- Corner to corner collisions are resolve to favor x-movement. This is in consideration of platformers, to give
 * 				the player some help with jumps
 *
 * 	Pros:
 * 		- Everything happens with a consistent time. There is a distinct before and after for each resolution.
 * 		- No back-tracking needs to be done. Once we resolve a node, it is definitively resolved.
 *
 * 	Cons:
 * 		- Nodes that are processed early have movement priority over other nodes. This can lead to some undesirable interactions.
 */
class BasicPhysicsManager extends PhysicsManager_1.default {
    constructor(options) {
        super();
        this.staticNodes = new Array();
        this.dynamicNodes = new Array();
        this.tilemaps = new Array();
        this.collisionMasks = new Array(32);
        // Parse options
        this.parseOptions(options);
    }
    /**
     * Parses the options for constructing the physics manager
     * @param options A record of options
     */
    parseOptions(options) {
        if (options.groupNames !== undefined && options.collisions !== undefined) {
            for (let i = 0; i < options.groupNames.length; i++) {
                let group = options.groupNames[i];
                // Register the group name and number
                this.groupNames[i] = group;
                this.groupMap.set(group, 1 << i);
                let collisionMask = 0;
                for (let j = 0; j < options.collisions[i].length; j++) {
                    if (options.collisions[i][j]) {
                        collisionMask |= 1 << j;
                    }
                }
                this.collisionMasks[i] = collisionMask;
            }
        }
    }
    // @override
    registerObject(node) {
        if (node.isStatic) {
            // Static and not collidable
            this.staticNodes.push(node);
        }
        else {
            // Dynamic and not collidable
            this.dynamicNodes.push(node);
        }
    }
    // @override
    deregisterObject(node) {
        if (node.isStatic) {
            // Remove the node from the static list
            const index = this.staticNodes.indexOf(node);
            this.staticNodes.splice(index, 1);
        }
        else {
            // Remove the node from the dynamic list
            const index = this.dynamicNodes.indexOf(node);
            this.dynamicNodes.splice(index, 1);
        }
    }
    // @override
    registerTilemap(tilemap) {
        this.tilemaps.push(tilemap);
    }
    // @override
    deregisterTilemap(tilemap) {
        const index = this.tilemaps.indexOf(tilemap);
        this.tilemaps.splice(index, 1);
    }
    // @override
    update(deltaT) {
        for (let node of this.dynamicNodes) {
            /*---------- INITIALIZATION PHASE ----------*/
            // Clear frame dependent boolean values for each node
            node.onGround = false;
            node.onCeiling = false;
            node.onWall = false;
            node.collidedWithTilemap = false;
            node.isColliding = false;
            // If this node is not active, don't process it
            if (!node.active) {
                continue;
            }
            // Update the swept shapes of each node
            if (node.moving) {
                // If moving, reflect that in the swept shape
                node.sweptRect.sweep(node._velocity, node.collisionShape.center, node.collisionShape.halfSize);
            }
            else {
                // If our node isn't moving, don't bother to check it (other nodes will detect if they run into it)
                node._velocity.zero();
                continue;
            }
            /*---------- DETECTION PHASE ----------*/
            // Gather a set of overlaps
            let overlaps = new Array();
            let groupIndex = node.group === -1 ? -1 : Math.log2(node.group);
            // First, check this node against every static node (order doesn't actually matter here, since we sort anyways)
            for (let other of this.staticNodes) {
                // Ignore inactive nodes
                if (!other.active)
                    continue;
                let collider = other.collisionShape.getBoundingRect();
                let area = node.sweptRect.overlapArea(collider);
                if (area > 0) {
                    // We had a collision
                    overlaps.push(new AreaCollision_1.default(area, collider, other, "GameNode", null));
                }
            }
            // Then, check it against every dynamic node
            for (let other of this.dynamicNodes) {
                // Ignore ourselves
                if (node === other)
                    continue;
                // Ignore inactive nodes
                if (!other.active)
                    continue;
                let collider = other.collisionShape.getBoundingRect();
                let area = node.sweptRect.overlapArea(collider);
                if (area > 0) {
                    // We had a collision
                    overlaps.push(new AreaCollision_1.default(area, collider, other, "GameNode", null));
                }
            }
            // Lastly, gather a set of AABBs from the tilemap.
            // This step involves the most extra work, so it is abstracted into a method
            for (let tilemap of this.tilemaps) {
                // Ignore inactive tilemaps
                if (!tilemap.active)
                    continue;
                if (tilemap instanceof OrthogonalTilemap_1.default) {
                    this.collideWithOrthogonalTilemap(node, tilemap, overlaps);
                }
            }
            // Sort the overlaps by area
            overlaps = overlaps.sort((a, b) => b.area - a.area);
            // Keep track of hits to use later
            let hits = [];
            /*---------- RESOLUTION PHASE ----------*/
            // For every overlap, determine if we need to collide with it and when
            for (let overlap of overlaps) {
                // Ignore nodes we don't interact with
                if (groupIndex !== -1 && overlap.other.group !== -1 && ((this.collisionMasks[groupIndex] & overlap.other.group) === 0))
                    continue;
                // Do a swept line test on the static AABB with this AABB size as padding (this is basically using a minkowski sum!)
                // Start the sweep at the position of this node with a delta of _velocity
                const point = node.collisionShape.center;
                const delta = node._velocity;
                const padding = node.collisionShape.halfSize;
                const otherAABB = overlap.collider;
                const hit = otherAABB.intersectSegment(node.collisionShape.center, node._velocity, node.collisionShape.halfSize);
                overlap.hit = hit;
                if (hit !== null) {
                    hits.push(hit);
                    // We got a hit, resolve with the time inside of the hit
                    let tnearx = hit.nearTimes.x;
                    let tneary = hit.nearTimes.y;
                    // Allow edge clipping (edge overlaps don't count, only area overlaps)
                    // Importantly don't allow both cases to be true. Then we clip through corners. Favor x to help players land jumps
                    if (tnearx < 1.0 && (point.y === otherAABB.top - padding.y || point.y === otherAABB.bottom + padding.y) && delta.x !== 0) {
                        tnearx = 1.0;
                    }
                    else if (tneary < 1.0 && (point.x === otherAABB.left - padding.x || point.x === otherAABB.right + padding.x) && delta.y !== 0) {
                        tneary = 1.0;
                    }
                    if (hit.nearTimes.x >= 0 && hit.nearTimes.x < 1) {
                        // Any tilemap objects that made it here are collidable
                        if (overlap.type === "Tilemap" || overlap.other.isCollidable) {
                            node._velocity.x = node._velocity.x * tnearx;
                            node.isColliding = true;
                        }
                    }
                    if (hit.nearTimes.y >= 0 && hit.nearTimes.y < 1) {
                        // Any tilemap objects that made it here are collidable
                        if (overlap.type === "Tilemap" || overlap.other.isCollidable) {
                            node._velocity.y = node._velocity.y * tneary;
                            node.isColliding = true;
                        }
                    }
                }
            }
            /*---------- INFORMATION/TRIGGER PHASE ----------*/
            // Check if we ended up on the ground, ceiling or wall
            // Also check for triggers
            for (let overlap of overlaps) {
                // Check for a trigger. If we care about the trigger, react
                if (overlap.other.isTrigger && (overlap.other.triggerMask & node.group) && node.group != -1) {
                    // Get the bit that this group is represented by
                    let index = Math.floor(Math.log2(node.group));
                    // Extract the triggerEnter event name
                    this.emitter.fireEvent(overlap.other.triggerEnters[index], {
                        node: node.id,
                        other: overlap.other.id
                    });
                }
                // Ignore collision sides for nodes we don't interact with
                if (groupIndex !== -1 && overlap.other.group !== -1 && ((this.collisionMasks[groupIndex] & overlap.other.group) === 0))
                    continue;
                // Only check for direction if the overlap was collidable
                if (overlap.type === "Tilemap" || overlap.other.isCollidable) {
                    let collisionSide = overlap.collider.touchesAABBWithoutCorners(node.collisionShape.getBoundingRect());
                    if (collisionSide !== null) {
                        // If we touch, not including corner cases, check the collision normal
                        if (overlap.hit !== null) {
                            // If we hit a tilemap, keep track of it
                            if (overlap.type == "Tilemap") {
                                node.collidedWithTilemap = true;
                            }
                            if (collisionSide.y === -1) {
                                // Node is on top of overlap, so onGround
                                node.onGround = true;
                            }
                            else if (collisionSide.y === 1) {
                                // Node is on bottom of overlap, so onCeiling
                                node.onCeiling = true;
                            }
                            else {
                                // Node wasn't touching on y, so it is touching on x
                                node.onWall = true;
                            }
                        }
                    }
                }
            }
            // Resolve the collision with the node, and move it
            node.finishMove();
        }
    }
    /**
     * Handles a collision between this node and an orthogonal tilemap
     * @param node The node
     * @param tilemap The tilemap the node may be colliding with
     * @param overlaps The list of overlaps
     */
    collideWithOrthogonalTilemap(node, tilemap, overlaps) {
        // Get the min and max x and y coordinates of the moving node
        let min = new Vec2_1.default(node.sweptRect.left, node.sweptRect.top);
        let max = new Vec2_1.default(node.sweptRect.right, node.sweptRect.bottom);
        // Convert the min/max x/y to the min and max row/col in the tilemap array
        let minIndex = tilemap.getMinColRow(node.sweptRect);
        let maxIndex = tilemap.getMaxColRow(node.sweptRect);
        // Loop over all possible tiles (which isn't many in the scope of the velocity per frame)
        for (let col = minIndex.x; col <= maxIndex.x; col++) {
            for (let row = minIndex.y; row <= maxIndex.y; row++) {
                if (tilemap.isTileCollidable(col, row)) {
                    // Create a new collider for this tile
                    let collider = tilemap.getTileCollider(col, row);
                    // Calculate collision area between the node and the tile
                    let area = node.sweptRect.overlapArea(collider);
                    if (area > 0) {
                        // We had a collision
                        overlaps.push(new AreaCollision_1.default(area, collider, tilemap, "Tilemap", new Vec2_1.default(col, row)));
                    }
                }
            }
        }
    }
}
exports.default = BasicPhysicsManager;

},{"../DataTypes/Physics/AreaCollision":17,"../DataTypes/Vec2":26,"../Nodes/Tilemaps/OrthogonalTilemap":53,"./PhysicsManager":68}],68:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Receiver_1 = __importDefault(require("../Events/Receiver"));
const Emitter_1 = __importDefault(require("../Events/Emitter"));
const Map_1 = __importDefault(require("../DataTypes/Collections/Map"));
/**
 * An abstract physics manager.
 * This class exposes functions for subclasses to implement that should allow for a working physics system to be created.
 */
class PhysicsManager {
    constructor() {
        this.receiver = new Receiver_1.default();
        this.emitter = new Emitter_1.default();
        // The creation and implementation of layers is deferred to the subclass
        this.groupMap = new Map_1.default();
        this.groupNames = new Array();
    }
    destroy() {
        this.receiver.destroy();
    }
    /**
     * Sets the physics layer of the GameNode
     * @param node The GameNode
     * @param group The group that the GameNode should be on
     */
    setGroup(node, group) {
        node.group = this.groupMap.get(group);
    }
    /**
     * Retrieves the layer number associated with the provided name
     * @param layer The name of the layer
     * @returns The layer number, or 0 if there is not a layer with that name registered
     */
    getGroupNumber(group) {
        if (this.groupMap.has(group)) {
            return this.groupMap.get(group);
        }
        else {
            return 0;
        }
    }
    /**
     * Gets all group names associated with the number provided
     * @param groups A mask of groups
     * @returns All groups contained in the mask
     */
    getGroupNames(groups) {
        if (groups === -1) {
            return [PhysicsManager.DEFAULT_GROUP];
        }
        else {
            let g = 1;
            let names = [];
            for (let i = 0; i < 32; i++) {
                if (g & groups) {
                    // This group is in the groups number
                    names.push(this.groupNames[i]);
                }
                // Shift the bit over
                g = g << 1;
            }
        }
    }
}
exports.default = PhysicsManager;
/** The default group name */
PhysicsManager.DEFAULT_GROUP = "Default";

},{"../DataTypes/Collections/Map":8,"../Events/Emitter":29,"../Events/Receiver":33}],69:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const GameEventType_1 = require("../Events/GameEventType");
const Receiver_1 = __importDefault(require("../Events/Receiver"));
class PlaybackManager {
    constructor() {
        this.recording = false;
        this.playing = false;
        this.receiver = new Receiver_1.default();
        this.receiver.subscribe([GameEventType_1.GameEventType.START_RECORDING, GameEventType_1.GameEventType.STOP_RECORDING, GameEventType_1.GameEventType.PLAY_RECORDING]);
    }
    update(deltaT) {
        while (this.receiver.hasNextEvent()) {
            this.handleEvent(this.receiver.getNextEvent());
        }
        if (this.recorder !== undefined) {
            this.recorder.update(deltaT);
            this.recording = this.recorder.active();
        }
        if (this.replayer !== undefined) {
            this.replayer.update(deltaT);
            this.playing = this.replayer.active();
        }
    }
    handleEvent(event) {
        switch (event.type) {
            case GameEventType_1.GameEventType.START_RECORDING: {
                this.handleStartRecordingEvent(event);
                break;
            }
            case GameEventType_1.GameEventType.STOP_RECORDING: {
                this.handleStopRecordingEvent();
                break;
            }
            case GameEventType_1.GameEventType.PLAY_RECORDING: {
                this.handlePlayRecordingEvent(event);
                break;
            }
        }
    }
    handleStartRecordingEvent(event) {
        let recording = event.data.get("recording");
        if (!this.playing && !this.recording && recording !== undefined) {
            this.lastRecording = recording;
            let Recorder = this.lastRecording.recorder();
            if (this.recorder === undefined || this.recorder.constructor !== Recorder) {
                this.recorder = new Recorder();
            }
            this.recorder.start(this.lastRecording);
            this.recording = this.recorder.active();
        }
    }
    handleStopRecordingEvent() {
        this.recorder.stop();
        this.recording = this.recorder.active();
    }
    handlePlayRecordingEvent(event) {
        if (!this.recording && this.lastRecording !== undefined) {
            let Replayer = this.lastRecording.replayer();
            if (this.replayer === undefined || this.replayer.constructor !== Replayer) {
                this.replayer = new Replayer();
            }
            this.replayer.start(this.lastRecording, event.data.get("onEnd"));
            this.playing = this.replayer.active();
        }
    }
}
exports.default = PlaybackManager;

},{"../Events/GameEventType":32,"../Events/Receiver":33}],70:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = __importDefault(require("../../DataTypes/Collections/Map"));
/** */
class Registry extends Map_1.default {
}
exports.default = Registry;

},{"../../DataTypes/Collections/Map":8}],71:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const LabelShaderType_1 = __importDefault(require("../../Rendering/WebGLRendering/ShaderTypes/LabelShaderType"));
const PointShaderType_1 = __importDefault(require("../../Rendering/WebGLRendering/ShaderTypes/PointShaderType"));
const RectShaderType_1 = __importDefault(require("../../Rendering/WebGLRendering/ShaderTypes/RectShaderType"));
const SpriteShaderType_1 = __importDefault(require("../../Rendering/WebGLRendering/ShaderTypes/SpriteShaderType"));
const ResourceManager_1 = __importDefault(require("../../ResourceManager/ResourceManager"));
const Registry_1 = __importDefault(require("./Registry"));
/**
 * A registry that handles shaders
 */
class ShaderRegistry extends Registry_1.default {
    constructor() {
        super(...arguments);
        this.registryItems = new Array();
    }
    /**
     * Preloads all built-in shaders
     */
    preload() {
        // Get the resourceManager and queue all built-in shaders for preloading
        const rm = ResourceManager_1.default.getInstance();
        // Queue a load for the point shader
        this.registerAndPreloadItem(ShaderRegistry.POINT_SHADER, PointShaderType_1.default, "builtin/shaders/point.vshader", "builtin/shaders/point.fshader");
        // Queue a load for the rect shader
        this.registerAndPreloadItem(ShaderRegistry.RECT_SHADER, RectShaderType_1.default, "builtin/shaders/rect.vshader", "builtin/shaders/rect.fshader");
        // Queue a load for the sprite shader
        this.registerAndPreloadItem(ShaderRegistry.SPRITE_SHADER, SpriteShaderType_1.default, "builtin/shaders/sprite.vshader", "builtin/shaders/sprite.fshader");
        // Queue a load for the label shader
        this.registerAndPreloadItem(ShaderRegistry.LABEL_SHADER, LabelShaderType_1.default, "builtin/shaders/label.vshader", "builtin/shaders/label.fshader");
        // Queue a load for any preloaded items
        for (let item of this.registryItems) {
            const shader = new item.constr(item.key);
            shader.initBufferObject();
            this.add(item.key, shader);
            // Load if desired
            if (item.preload !== undefined) {
                rm.shader(item.key, item.preload.vshaderLocation, item.preload.fshaderLocation);
            }
        }
    }
    /**
     * Registers a shader in the registry and loads it before the game begins
     * @param key The key you wish to assign to the shader
     * @param constr The constructor of the ShaderType
     * @param vshaderLocation The location of the vertex shader
     * @param fshaderLocation the location of the fragment shader
     */
    registerAndPreloadItem(key, constr, vshaderLocation, fshaderLocation) {
        let shaderPreload = new ShaderPreload();
        shaderPreload.vshaderLocation = vshaderLocation;
        shaderPreload.fshaderLocation = fshaderLocation;
        let registryItem = new ShaderRegistryItem();
        registryItem.key = key;
        registryItem.constr = constr;
        registryItem.preload = shaderPreload;
        this.registryItems.push(registryItem);
    }
    /**
     * Registers a shader in the registry. NOTE: If you use this, you MUST load the shader before use.
     * If you wish to preload the shader, use registerAndPreloadItem()
     * @param key The key you wish to assign to the shader
     * @param constr The constructor of the ShaderType
     */
    registerItem(key, constr) {
        let registryItem = new ShaderRegistryItem();
        registryItem.key = key;
        registryItem.constr = constr;
        this.registryItems.push(registryItem);
    }
}
exports.default = ShaderRegistry;
// Shader names
ShaderRegistry.POINT_SHADER = "point";
ShaderRegistry.RECT_SHADER = "rect";
ShaderRegistry.SPRITE_SHADER = "sprite";
ShaderRegistry.LABEL_SHADER = "label";
class ShaderRegistryItem {
}
class ShaderPreload {
}

},{"../../Rendering/WebGLRendering/ShaderTypes/LabelShaderType":85,"../../Rendering/WebGLRendering/ShaderTypes/PointShaderType":86,"../../Rendering/WebGLRendering/ShaderTypes/RectShaderType":88,"../../Rendering/WebGLRendering/ShaderTypes/SpriteShaderType":89,"../../ResourceManager/ResourceManager":90,"./Registry":70}],72:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = __importDefault(require("../DataTypes/Collections/Map"));
const ShaderRegistry_1 = __importDefault(require("./Registries/ShaderRegistry"));
/**
 * The Registry is the system's way of converting classes and types into string
 * representations for use elsewhere in the application.
 * It allows classes to be accessed without explicitly using constructors in code,
 * and for resources to be loaded at Game creation time.
 */
class RegistryManager {
    static preload() {
        this.shaders.preload();
        this.registries.forEach((key) => this.registries.get(key).preload());
    }
    static addCustomRegistry(name, registry) {
        this.registries.add(name, registry);
    }
    static getRegistry(key) {
        return this.registries.get(key);
    }
}
exports.default = RegistryManager;
RegistryManager.shaders = new ShaderRegistry_1.default();
/** Additional custom registries to add to the registry manager */
RegistryManager.registries = new Map_1.default();

},{"../DataTypes/Collections/Map":8,"./Registries/ShaderRegistry":71}],73:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = __importDefault(require("../../DataTypes/Collections/Map"));
const Emitter_1 = __importDefault(require("../../Events/Emitter"));
const AnimationTypes_1 = require("./AnimationTypes");
/**
 * An animation manager class for an animated CanvasNode.
 * This class keeps track of the possible animations, as well as the current animation state,
 * and abstracts all interactions with playing, pausing, and stopping animations as well as
 * creating new animations from the CanvasNode.
 */
class AnimationManager {
    /**
     * Creates a new AnimationManager
     * @param owner The owner of the AnimationManager
     */
    constructor(owner) {
        this.owner = owner;
        this.animationState = AnimationTypes_1.AnimationState.STOPPED;
        this.currentAnimation = "";
        this.currentFrame = 0;
        this.frameProgress = 0;
        this.loop = false;
        this.animations = new Map_1.default();
        this.onEndEvent = null;
        this.emitter = new Emitter_1.default();
    }
    /**
     * Add an animation to this sprite
     * @param key The unique key of the animation
     * @param animation The animation data
     */
    add(key, animation) {
        this.animations.add(key, animation);
    }
    /**
     * Gets the index specified by the current animation and current frame
     * @returns The index in the current animation
     */
    getIndex() {
        if (this.animations.has(this.currentAnimation)) {
            return this.animations.get(this.currentAnimation).frames[this.currentFrame].index;
        }
        else {
            // No current animation, warn the user
            console.warn(`Animation index was requested, but the current animation: ${this.currentAnimation} was invalid`);
            return 0;
        }
    }
    /**
     * Determines whether the specified animation is currently playing
     * @param key The key of the animation to check
     * @returns true if the specified animation is playing, false otherwise
     */
    isPlaying(key) {
        return this.currentAnimation === key && this.animationState === AnimationTypes_1.AnimationState.PLAYING;
    }
    /**
     * Retrieves the current animation index and advances the animation frame
     * @returns The index of the animation frame
     */
    getIndexAndAdvanceAnimation() {
        // If we aren't playing, we won't be advancing the animation
        if (!(this.animationState === AnimationTypes_1.AnimationState.PLAYING)) {
            return this.getIndex();
        }
        if (this.animations.has(this.currentAnimation)) {
            let currentAnimation = this.animations.get(this.currentAnimation);
            let index = currentAnimation.frames[this.currentFrame].index;
            // Advance the animation
            this.frameProgress += 1;
            if (this.frameProgress >= currentAnimation.frames[this.currentFrame].duration) {
                // We have been on this frame for its whole duration, go to the next one
                this.frameProgress = 0;
                this.currentFrame += 1;
                if (this.currentFrame >= currentAnimation.frames.length) {
                    // We have reached the end of this animation
                    if (this.loop) {
                        this.currentFrame = 0;
                        this.frameProgress = 0;
                    }
                    else {
                        this.endCurrentAnimation();
                    }
                }
            }
            // Return the current index
            return index;
        }
        else {
            // No current animation, can't advance. Warn the user
            console.warn(`Animation index and advance was requested, but the current animation (${this.currentAnimation}) in node with id: ${this.owner.id} was invalid`);
            return 0;
        }
    }
    /** Ends the current animation and fires any necessary events, as well as starting any new animations */
    endCurrentAnimation() {
        this.currentFrame = 0;
        this.animationState = AnimationTypes_1.AnimationState.STOPPED;
        if (this.onEndEvent !== null) {
            this.emitter.fireEvent(this.onEndEvent, { owner: this.owner.id, animation: this.currentAnimation });
        }
        // If there is a pending animation, play it
        if (this.pendingAnimation !== null) {
            this.play(this.pendingAnimation, this.pendingLoop, this.pendingOnEnd);
        }
    }
    /**
     * Plays the specified animation. Does not restart it if it is already playing
     * @param animation The name of the animation to play
     * @param loop Whether or not to loop the animation. False by default
     * @param onEnd The name of an event to send when this animation naturally stops playing. This only matters if loop is false.
     */
    playIfNotAlready(animation, loop, onEnd) {
        if (this.currentAnimation !== animation) {
            this.play(animation, loop, onEnd);
        }
    }
    /**
     * Plays the specified animation
     * @param animation The name of the animation to play
     * @param loop Whether or not to loop the animation. False by default
     * @param onEnd The name of an event to send when this animation naturally stops playing. This only matters if loop is false.
     */
    play(animation, loop, onEnd) {
        this.currentAnimation = animation;
        this.currentFrame = 0;
        this.frameProgress = 0;
        this.animationState = AnimationTypes_1.AnimationState.PLAYING;
        // If loop arg was provided, use that
        if (loop !== undefined) {
            this.loop = loop;
        }
        else {
            // Otherwise, use what the json file specified
            this.loop = this.animations.get(animation).repeat;
        }
        if (onEnd !== undefined) {
            this.onEndEvent = onEnd;
        }
        else {
            this.onEndEvent = null;
        }
        // Reset pending animation
        this.pendingAnimation = null;
    }
    /**
     * Queues a single animation to be played after the current one. Does NOT stack.
     * Queueing additional animations past 1 will just replace the queued animation
     * @param animation The animation to queue
     * @param loop Whether or not the loop the queued animation
     * @param onEnd The event to fire when the queued animation ends
     */
    queue(animation, loop = false, onEnd) {
        this.pendingAnimation = animation;
        this.pendingLoop = loop;
        if (onEnd !== undefined) {
            this.pendingOnEnd = onEnd;
        }
        else {
            this.pendingOnEnd = null;
        }
    }
    /** Pauses the current animation */
    pause() {
        this.animationState = AnimationTypes_1.AnimationState.PAUSED;
    }
    /** Resumes the current animation if possible */
    resume() {
        if (this.animationState === AnimationTypes_1.AnimationState.PAUSED) {
            this.animationState = AnimationTypes_1.AnimationState.PLAYING;
        }
    }
    /** Stops the current animation. The animation cannot be resumed after this. */
    stop() {
        this.animationState = AnimationTypes_1.AnimationState.STOPPED;
    }
}
exports.default = AnimationManager;

},{"../../DataTypes/Collections/Map":8,"../../Events/Emitter":29,"./AnimationTypes":74}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TweenData = exports.TweenEffect = exports.AnimationData = exports.AnimationState = void 0;
// @ignorePage
var AnimationState;
(function (AnimationState) {
    AnimationState[AnimationState["STOPPED"] = 0] = "STOPPED";
    AnimationState[AnimationState["PAUSED"] = 1] = "PAUSED";
    AnimationState[AnimationState["PLAYING"] = 2] = "PLAYING";
})(AnimationState = exports.AnimationState || (exports.AnimationState = {}));
class AnimationData {
    constructor() {
        this.repeat = false;
    }
}
exports.AnimationData = AnimationData;
class TweenEffect {
}
exports.TweenEffect = TweenEffect;
class TweenData {
}
exports.TweenData = TweenData;

},{}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class ParticleSystemManager {
    constructor() {
        this.particleSystems = new Array();
    }
    static getInstance() {
        if (ParticleSystemManager.instance === null) {
            ParticleSystemManager.instance = new ParticleSystemManager();
        }
        return ParticleSystemManager.instance;
    }
    registerParticleSystem(system) {
        this.particleSystems.push(system);
    }
    deregisterParticleSystem(system) {
        let index = this.particleSystems.indexOf(system);
        this.particleSystems.splice(index, 1);
    }
    clearParticleSystems() {
        this.particleSystems = new Array();
    }
    update(deltaT) {
        for (let particleSystem of this.particleSystems) {
            particleSystem.update(deltaT);
        }
    }
}
exports.default = ParticleSystemManager;
ParticleSystemManager.instance = null;

},{}],76:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = __importDefault(require("../../DataTypes/Collections/Map"));
const AnimationTypes_1 = require("./AnimationTypes");
const EaseFunctions_1 = __importDefault(require("../../Utils/EaseFunctions"));
const MathUtils_1 = __importDefault(require("../../Utils/MathUtils"));
const TweenManager_1 = __importDefault(require("./TweenManager"));
const Emitter_1 = __importDefault(require("../../Events/Emitter"));
/**
 * A manager for the tweens of a GameNode.
 * Tweens are short animations played by interpolating between two properties using an easing function.
 * For a good visual representation of easing functions, check out @link(https://easings.net/)(https://easings.net/).
 * Multiple tween can be played at the same time, as long as they don't change the same property.
 * This allows for some interesting polishes or animations that may be very difficult to do with sprite work alone
 * - especially pixel art (such as rotations or scaling).
 */
class TweenController {
    /**
     * Creates a new TweenController
     * @param owner The owner of the TweenController
     */
    constructor(owner) {
        this.owner = owner;
        this.tweens = new Map_1.default();
        this.emitter = new Emitter_1.default();
        // Give ourselves to the TweenManager
        TweenManager_1.default.getInstance().registerTweenController(this);
    }
    /**
     * Destroys this TweenController
     */
    destroy() {
        // Only the gamenode and the tween manager should have a reference to this
        delete this.owner.tweens;
        TweenManager_1.default.getInstance().deregisterTweenController(this);
    }
    /**
     * Add a tween to this game node
     * @param key The name of the tween
     * @param tween The data of the tween
     */
    add(key, tween) {
        let typedTween = tween;
        // Initialize members that we need (and the user didn't provide)
        typedTween.progress = 0;
        typedTween.elapsedTime = 0;
        typedTween.animationState = AnimationTypes_1.AnimationState.STOPPED;
        this.tweens.add(key, typedTween);
    }
    /**
     * Play a tween with a certain name
     * @param key The name of the tween to play
     * @param loop Whether or not the tween should loop
     */
    play(key, loop) {
        if (this.tweens.has(key)) {
            let tween = this.tweens.get(key);
            // Set loop if needed
            if (loop !== undefined) {
                tween.loop = loop;
            }
            // Set the initial values
            for (let effect of tween.effects) {
                if (effect.resetOnComplete) {
                    effect.initialValue = this.owner[effect.property];
                }
            }
            // Start the tween running
            tween.animationState = AnimationTypes_1.AnimationState.PLAYING;
            tween.elapsedTime = 0;
            tween.progress = 0;
            tween.reversing = false;
        }
        else {
            console.warn(`Tried to play tween "${key}" on node with id ${this.owner.id}, but no such tween exists`);
        }
    }
    /**
     * Pauses a playing tween. Does not affect tweens that are stopped.
     * @param key The name of the tween to pause.
     */
    pause(key) {
        if (this.tweens.has(key)) {
            this.tweens.get(key).animationState = AnimationTypes_1.AnimationState.PAUSED;
        }
    }
    /**
     * Resumes a paused tween.
     * @param key The name of the tween to resume
     */
    resume(key) {
        if (this.tweens.has(key)) {
            let tween = this.tweens.get(key);
            if (tween.animationState === AnimationTypes_1.AnimationState.PAUSED)
                tween.animationState = AnimationTypes_1.AnimationState.PLAYING;
        }
    }
    /**
     * Stops a currently playing tween
     * @param key The key of the tween
     */
    stop(key) {
        if (this.tweens.has(key)) {
            let tween = this.tweens.get(key);
            tween.animationState = AnimationTypes_1.AnimationState.STOPPED;
            // Return to the initial values
            for (let effect of tween.effects) {
                if (effect.resetOnComplete) {
                    this.owner[effect.property] = effect.initialValue;
                }
            }
        }
    }
    /**
     * The natural stop of a currently playing tween
     * @param key The key of the tween
     */
    end(key) {
        this.stop(key);
        if (this.tweens.has(key)) {
            // Get the tween
            let tween = this.tweens.get(key);
            // If it has an onEnd, send an event
            if (tween.onEnd) {
                let data = { key: key, node: this.owner.id };
                // If it has onEnd event data, add each entry, as long as the key is not named 'key' or 'node'
                if (tween.onEndData) {
                    Object.keys(tween.onEndData).forEach(key => {
                        if (key !== "key" && key !== "node") {
                            data[key] = tween.onEndData[key];
                        }
                    });
                }
                this.emitter.fireEvent(tween.onEnd, data);
            }
        }
    }
    /**
     * Stops all currently playing tweens
     */
    stopAll() {
        this.tweens.forEach(key => this.stop(key));
    }
    update(deltaT) {
        this.tweens.forEach(key => {
            let tween = this.tweens.get(key);
            if (tween.animationState === AnimationTypes_1.AnimationState.PLAYING) {
                // Update the progress of the tween
                tween.elapsedTime += deltaT * 1000;
                // If we're past the startDelay, do the tween
                if (tween.elapsedTime >= tween.startDelay) {
                    if (!tween.reversing && tween.elapsedTime >= tween.startDelay + tween.duration) {
                        // If we're over time, stop the tween, loop, or reverse
                        if (tween.reverseOnComplete) {
                            // If we're over time and can reverse, do so
                            tween.reversing = true;
                        }
                        else if (tween.loop) {
                            // If we can't reverse and can loop, do so
                            tween.elapsedTime -= tween.duration;
                        }
                        else {
                            // We aren't looping and can't reverse, so stop
                            this.end(key);
                        }
                    }
                    // Check for the end of reversing
                    if (tween.reversing && tween.elapsedTime >= tween.startDelay + 2 * tween.duration) {
                        if (tween.loop) {
                            tween.reversing = false;
                            tween.elapsedTime -= 2 * tween.duration;
                        }
                        else {
                            this.end(key);
                        }
                    }
                    // Update the progress, make sure it is between 0 and 1. Errors from this should never be large
                    if (tween.reversing) {
                        tween.progress = MathUtils_1.default.clamp01((2 * tween.duration - (tween.elapsedTime - tween.startDelay)) / tween.duration);
                    }
                    else {
                        tween.progress = MathUtils_1.default.clamp01((tween.elapsedTime - tween.startDelay) / tween.duration);
                    }
                    for (let effect of tween.effects) {
                        // Get the value from the ease function that corresponds to our progress
                        let ease = EaseFunctions_1.default[effect.ease](tween.progress);
                        // Use the value to lerp the property
                        let value = MathUtils_1.default.lerp(effect.start, effect.end, ease);
                        // Assign the value of the property
                        this.owner[effect.property] = value;
                    }
                }
            }
        });
    }
}
exports.default = TweenController;

},{"../../DataTypes/Collections/Map":8,"../../Events/Emitter":29,"../../Utils/EaseFunctions":107,"../../Utils/MathUtils":109,"./AnimationTypes":74,"./TweenManager":77}],77:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class TweenManager {
    constructor() {
        this.tweenControllers = new Array();
    }
    static getInstance() {
        if (TweenManager.instance === null) {
            TweenManager.instance = new TweenManager();
        }
        return TweenManager.instance;
    }
    registerTweenController(controller) {
        this.tweenControllers.push(controller);
    }
    deregisterTweenController(controller) {
        let index = this.tweenControllers.indexOf(controller);
        this.tweenControllers.splice(index, 1);
    }
    clearTweenControllers() {
        this.tweenControllers = new Array();
    }
    update(deltaT) {
        for (let tweenController of this.tweenControllers) {
            tweenController.update(deltaT);
        }
    }
}
exports.default = TweenManager;
TweenManager.instance = null;

},{}],78:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Graphic_1 = __importDefault(require("../Nodes/Graphic"));
const Point_1 = __importDefault(require("../Nodes/Graphics/Point"));
const Rect_1 = __importDefault(require("../Nodes/Graphics/Rect"));
const Sprite_1 = __importDefault(require("../Nodes/Sprites/Sprite"));
const UIElement_1 = __importDefault(require("../Nodes/UIElement"));
const GraphicRenderer_1 = __importDefault(require("./CanvasRendering/GraphicRenderer"));
const RenderingManager_1 = __importDefault(require("./RenderingManager"));
const TilemapRenderer_1 = __importDefault(require("./CanvasRendering/TilemapRenderer"));
const UIElementRenderer_1 = __importDefault(require("./CanvasRendering/UIElementRenderer"));
const Label_1 = __importDefault(require("../Nodes/UIElements/Label"));
const Button_1 = __importDefault(require("../Nodes/UIElements/Button"));
const Slider_1 = __importDefault(require("../Nodes/UIElements/Slider"));
const TextInput_1 = __importDefault(require("../Nodes/UIElements/TextInput"));
const AnimatedSprite_1 = __importDefault(require("../Nodes/Sprites/AnimatedSprite"));
const Vec2_1 = __importDefault(require("../DataTypes/Vec2"));
const Line_1 = __importDefault(require("../Nodes/Graphics/Line"));
const Debug_1 = __importDefault(require("../Debug/Debug"));
/**
 * An implementation of the RenderingManager class using CanvasRenderingContext2D.
 */
class CanvasRenderer extends RenderingManager_1.default {
    constructor() {
        super();
    }
    // @override
    setScene(scene) {
        this.scene = scene;
        this.graphicRenderer.setScene(scene);
        this.tilemapRenderer.setScene(scene);
        this.uiElementRenderer.setScene(scene);
    }
    // @override
    initializeCanvas(canvas, width, height) {
        canvas.width = width;
        canvas.height = height;
        this.worldSize = new Vec2_1.default(width, height);
        this.ctx = canvas.getContext("2d");
        this.graphicRenderer = new GraphicRenderer_1.default(this.ctx);
        this.tilemapRenderer = new TilemapRenderer_1.default(this.ctx);
        this.uiElementRenderer = new UIElementRenderer_1.default(this.ctx);
        // For crisp pixel art
        this.ctx.imageSmoothingEnabled = false;
        return this.ctx;
    }
    // @override
    render(visibleSet, tilemaps, uiLayers) {
        // Sort by depth, then by visible set by y-value
        visibleSet.sort((a, b) => {
            if (a.getLayer().getDepth() === b.getLayer().getDepth()) {
                return (a.boundary.bottom) - (b.boundary.bottom);
            }
            else {
                return a.getLayer().getDepth() - b.getLayer().getDepth();
            }
        });
        let tilemapIndex = 0;
        let tilemapLength = tilemaps.length;
        let visibleSetIndex = 0;
        let visibleSetLength = visibleSet.length;
        while (tilemapIndex < tilemapLength || visibleSetIndex < visibleSetLength) {
            // Check conditions where we've already reached the edge of one list
            if (tilemapIndex >= tilemapLength) {
                // Only render the remaining visible set
                let node = visibleSet[visibleSetIndex++];
                if (node.visible) {
                    this.renderNode(node);
                }
                continue;
            }
            if (visibleSetIndex >= visibleSetLength) {
                // Only render tilemaps
                this.renderTilemap(tilemaps[tilemapIndex++]);
                continue;
            }
            // Render whichever is further down
            if (tilemaps[tilemapIndex].getLayer().getDepth() <= visibleSet[visibleSetIndex].getLayer().getDepth()) {
                this.renderTilemap(tilemaps[tilemapIndex++]);
            }
            else {
                let node = visibleSet[visibleSetIndex++];
                if (node.visible) {
                    this.renderNode(node);
                }
            }
        }
        // Render the uiLayers on top of everything else
        let sortedUILayers = new Array();
        uiLayers.forEach(key => sortedUILayers.push(uiLayers.get(key)));
        sortedUILayers = sortedUILayers.sort((ui1, ui2) => ui1.getDepth() - ui2.getDepth());
        sortedUILayers.forEach(uiLayer => {
            if (!uiLayer.isHidden())
                uiLayer.getItems().forEach(node => {
                    if (node.visible) {
                        this.renderNode(node);
                    }
                });
        });
    }
    /**
     * Renders a specified CanvasNode
     * @param node The CanvasNode to render
     */
    renderNode(node) {
        // Calculate the origin of the viewport according to this sprite
        this.origin = this.scene.getViewTranslation(node);
        // Get the zoom level of the scene
        this.zoom = this.scene.getViewScale();
        // Move the canvas to the position of the node and rotate
        let xScale = 1;
        let yScale = 1;
        if (node instanceof Sprite_1.default) {
            xScale = node.invertX ? -1 : 1;
            yScale = node.invertY ? -1 : 1;
        }
        this.ctx.setTransform(xScale, 0, 0, yScale, (node.position.x - this.origin.x) * this.zoom, (node.position.y - this.origin.y) * this.zoom);
        this.ctx.rotate(-node.rotation);
        let globalAlpha = this.ctx.globalAlpha;
        if (node instanceof Rect_1.default) {
            Debug_1.default.log("node" + node.id, "Node" + node.id + " Alpha: " + node.alpha);
        }
        this.ctx.globalAlpha = node.alpha;
        if (node instanceof AnimatedSprite_1.default) {
            this.renderAnimatedSprite(node);
        }
        else if (node instanceof Sprite_1.default) {
            this.renderSprite(node);
        }
        else if (node instanceof Graphic_1.default) {
            this.renderGraphic(node);
        }
        else if (node instanceof UIElement_1.default) {
            this.renderUIElement(node);
        }
        this.ctx.globalAlpha = globalAlpha;
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    }
    // @override
    renderSprite(sprite) {
        // Get the image from the resource manager
        let image = this.resourceManager.getImage(sprite.imageId);
        /*
            Coordinates in the space of the image:
                image crop start -> x, y
                image crop size  -> w, h
            Coordinates in the space of the world
                image draw start -> x, y
                image draw size  -> w, h
        */
        this.ctx.drawImage(image, sprite.imageOffset.x, sprite.imageOffset.y, sprite.size.x, sprite.size.y, (-sprite.size.x * sprite.scale.x / 2) * this.zoom, (-sprite.size.y * sprite.scale.y / 2) * this.zoom, sprite.size.x * sprite.scale.x * this.zoom, sprite.size.y * sprite.scale.y * this.zoom);
    }
    // @override
    renderAnimatedSprite(sprite) {
        // Get the image from the resource manager
        let image = this.resourceManager.getImage(sprite.imageId);
        let animationIndex = sprite.animation.getIndexAndAdvanceAnimation();
        let animationOffset = sprite.getAnimationOffset(animationIndex);
        /*
            Coordinates in the space of the image:
                image crop start -> x, y
                image crop size  -> w, h
            Coordinates in the space of the world (given we moved)
                image draw start -> -w/2, -h/2
                image draw size  -> w, h
        */
        this.ctx.drawImage(image, sprite.imageOffset.x + animationOffset.x, sprite.imageOffset.y + animationOffset.y, sprite.size.x, sprite.size.y, (-sprite.size.x * sprite.scale.x / 2) * this.zoom, (-sprite.size.y * sprite.scale.y / 2) * this.zoom, sprite.size.x * sprite.scale.x * this.zoom, sprite.size.y * sprite.scale.y * this.zoom);
    }
    // @override
    renderGraphic(graphic) {
        if (graphic instanceof Point_1.default) {
            this.graphicRenderer.renderPoint(graphic, this.zoom);
        }
        else if (graphic instanceof Line_1.default) {
            this.graphicRenderer.renderLine(graphic, this.origin, this.zoom);
        }
        else if (graphic instanceof Rect_1.default) {
            this.graphicRenderer.renderRect(graphic, this.zoom);
        }
    }
    // @override
    renderTilemap(tilemap) {
        this.tilemapRenderer.renderTilemap(tilemap);
    }
    // @override
    renderUIElement(uiElement) {
        if (uiElement instanceof Label_1.default) {
            this.uiElementRenderer.renderLabel(uiElement);
        }
        else if (uiElement instanceof Button_1.default) {
            this.uiElementRenderer.renderButton(uiElement);
        }
        else if (uiElement instanceof Slider_1.default) {
            this.uiElementRenderer.renderSlider(uiElement);
        }
        else if (uiElement instanceof TextInput_1.default) {
            this.uiElementRenderer.renderTextInput(uiElement);
        }
    }
    clear(clearColor) {
        this.ctx.clearRect(0, 0, this.worldSize.x, this.worldSize.y);
        this.ctx.fillStyle = clearColor.toString();
        this.ctx.fillRect(0, 0, this.worldSize.x, this.worldSize.y);
    }
}
exports.default = CanvasRenderer;

},{"../DataTypes/Vec2":26,"../Debug/Debug":27,"../Nodes/Graphic":43,"../Nodes/Graphics/Line":45,"../Nodes/Graphics/Point":47,"../Nodes/Graphics/Rect":48,"../Nodes/Sprites/AnimatedSprite":49,"../Nodes/Sprites/Sprite":50,"../Nodes/UIElement":55,"../Nodes/UIElements/Button":56,"../Nodes/UIElements/Label":57,"../Nodes/UIElements/Slider":58,"../Nodes/UIElements/TextInput":59,"./CanvasRendering/GraphicRenderer":79,"./CanvasRendering/TilemapRenderer":80,"./CanvasRendering/UIElementRenderer":81,"./RenderingManager":82}],79:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = __importDefault(require("../../ResourceManager/ResourceManager"));
/**
 * A utility class to help the @reference[CanvasRenderer] render @reference[Graphic]s
 */
class GraphicRenderer {
    constructor(ctx) {
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.ctx = ctx;
    }
    /**
     * Sets the scene of this GraphicRenderer
     * @param scene The current scene
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * Renders a point
     * @param point The point to render
     * @param zoom The zoom level
     */
    renderPoint(point, zoom) {
        this.ctx.fillStyle = point.color.toStringRGBA();
        this.ctx.fillRect((-point.size.x / 2) * zoom, (-point.size.y / 2) * zoom, point.size.x * zoom, point.size.y * zoom);
    }
    renderLine(line, origin, zoom) {
        this.ctx.strokeStyle = line.color.toStringRGBA();
        this.ctx.lineWidth = line.thickness;
        this.ctx.beginPath();
        this.ctx.moveTo(0, 0);
        this.ctx.lineTo((line.end.x - line.start.x) * zoom, (line.end.y - line.start.y) * zoom);
        this.ctx.closePath();
        this.ctx.stroke();
    }
    /**
     * Renders a rect
     * @param rect The rect to render
     * @param zoom The zoom level
     */
    renderRect(rect, zoom) {
        // Draw the interior of the rect
        if (rect.color.a !== 0) {
            this.ctx.fillStyle = rect.color.toStringRGB();
            this.ctx.fillRect((-rect.size.x / 2) * zoom, (-rect.size.y / 2) * zoom, rect.size.x * zoom, rect.size.y * zoom);
        }
        // Draw the border of the rect if it isn't transparent
        if (rect.borderColor.a !== 0) {
            this.ctx.strokeStyle = rect.getBorderColor().toStringRGB();
            this.ctx.lineWidth = rect.getBorderWidth();
            this.ctx.strokeRect((-rect.size.x / 2) * zoom, (-rect.size.y / 2) * zoom, rect.size.x * zoom, rect.size.y * zoom);
        }
    }
}
exports.default = GraphicRenderer;

},{"../../ResourceManager/ResourceManager":90}],80:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = __importDefault(require("../../ResourceManager/ResourceManager"));
const Vec2_1 = __importDefault(require("../../DataTypes/Vec2"));
/**
 * A utility class for the @reference[CanvasRenderer] to render @reference[Tilemap]s
 */
class TilemapRenderer {
    constructor(ctx) {
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.ctx = ctx;
    }
    /**
     * Sets the scene of this TilemapRenderer
     * @param scene The current scene
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * Renders an orthogonal tilemap
     * @param tilemap The tilemap to render
     */
    renderTilemap(tilemap) {
        let previousAlpha = this.ctx.globalAlpha;
        this.ctx.globalAlpha = tilemap.getLayer().getAlpha();
        let origin = this.scene.getViewTranslation(tilemap);
        let size = this.scene.getViewport().getHalfSize();
        let zoom = this.scene.getViewScale();
        let bottomRight = origin.clone().add(size.scaled(2 * zoom));
        if (tilemap.visible) {
            let minColRow = tilemap.getMinColRow(this.scene.getViewport().getView());
            let maxColRow = tilemap.getMaxColRow(this.scene.getViewport().getView());
            for (let row = minColRow.y; row <= maxColRow.y; row++) {
                for (let col = minColRow.x; col <= maxColRow.x; col++) {
                    // Get the tile at this position
                    let tile = tilemap.getTile(col, row);
                    // Extract the rot/flip parameters if there are any
                    const mask = (0xE << 28);
                    const rotFlip = ((mask & tile) >> 28) & 0xF;
                    tile = tile & ~mask;
                    // Find the tileset that owns this tile index and render
                    for (let tileset of tilemap.getTilesets()) {
                        if (tileset.hasTile(tile)) {
                            this.renderTile(tilemap, tileset, tile, col, row, origin, tilemap.scale, zoom, rotFlip);
                        }
                    }
                }
            }
        }
        this.ctx.globalAlpha = previousAlpha;
    }
    /**
     * Renders a tile
     * @param tileset The tileset this tile belongs to
     * @param tileIndex The index of the tile
     * @param tilemapRow The row of the tile in the tilemap
     * @param tilemapCol The column of the tile in the tilemap
     * @param origin The origin of the viewport
     * @param scale The scale of the tilemap
     * @param zoom The zoom level of the viewport
     */
    renderTile(tilemap, tileset, tileIndex, tilemapCol, tilemapRow, origin, scale, zoom, rotFlip) {
        let image = this.resourceManager.getImage(tileset.getImageKey());
        // Get the size of the tile to render
        let tileSize = tileset.getTileSize();
        let width = tileSize.x;
        let height = tileSize.y;
        // Calculate the position to start a crop in the tileset image
        let imagePosition = tileset.getImageOffsetForTile(tileIndex);
        let left = imagePosition.x;
        let top = imagePosition.y;
        // Calculate the position in the world to render the tile
        let worldPosition = tilemap.getWorldPosition(tilemapCol, tilemapRow);
        let worldX = Math.floor((worldPosition.x - origin.x) * zoom);
        let worldY = Math.floor((worldPosition.y - origin.y) * zoom);
        // Calculate the size of the world to render the tile in
        let worldWidth = Math.ceil(width * scale.x * zoom);
        let worldHeight = Math.ceil(height * scale.y * zoom);
        if (rotFlip !== 0) {
            let scaleX = 1;
            let scaleY = 1;
            let shearX = 0;
            let shearY = 0;
            // Flip on the x-axis
            if (rotFlip & 8) {
                scaleX = -1;
            }
            // Flip on the y-axis
            if (rotFlip & 4) {
                scaleY = -1;
            }
            // Flip over the line y=x
            if (rotFlip & 2) {
                shearX = scaleY;
                shearY = scaleX;
                scaleX = 0;
                scaleY = 0;
            }
            this.ctx.setTransform(scaleX, shearX, shearY, scaleY, worldX + worldWidth / 2, worldY + worldHeight / 2);
            // Render the tile
            this.ctx.drawImage(image, left, top, width, height, -worldWidth / 2, -worldHeight / 2, worldWidth, worldHeight);
            if (rotFlip !== 0) {
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            }
        }
        else {
            // No rotations, don't do the calculations, just render the tile
            // Render the tile
            this.ctx.drawImage(image, left, top, width, height, worldX, worldY, worldWidth, worldHeight);
        }
    }
    getOrthogonalTileDrawPos(map, set, col, row) {
        let imgsize = set.getTileSize().mult(map.scale);
        let mapsize = map.getScaledTileSize();
        return map.getWorldPosition(col, row).sub(imgsize.sub(mapsize));
    }
    getIsometricTileDrawPos(map, set, col, row) {
        let size = set.getTileSize();
        let drawPos = map.getScaledTileSize().sub(new Vec2_1.default(size.x * map.scale.x, size.y * map.scale.y));
        drawPos.inc(-size.x * map.scale.x / 2, 0);
        drawPos.add(map.getWorldPosition(col, row));
        return drawPos;
    }
}
exports.default = TilemapRenderer;

},{"../../DataTypes/Vec2":26,"../../ResourceManager/ResourceManager":90}],81:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../../DataTypes/Vec2"));
const ResourceManager_1 = __importDefault(require("../../ResourceManager/ResourceManager"));
const MathUtils_1 = __importDefault(require("../../Utils/MathUtils"));
/**
 * A utility class to help the @reference[CanvasRenderer] render @reference[UIElement]s
 */
class UIElementRenderer {
    constructor(ctx) {
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.ctx = ctx;
    }
    /**
     * Sets the scene of this UIElementRenderer
     * @param scene The current scene
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * Renders a label
     * @param label The label to render
     */
    renderLabel(label) {
        // If the size is unassigned (by the user or automatically) assign it
        label.handleInitialSizing(this.ctx);
        // Grab the global alpha so we can adjust it for this render
        let previousAlpha = this.ctx.globalAlpha;
        // Get the font and text position in label
        this.ctx.font = label.getFontString();
        let offset = label.calculateTextOffset(this.ctx);
        // Stroke and fill a rounded rect and give it text
        this.ctx.globalAlpha = label.backgroundColor.a;
        this.ctx.fillStyle = label.calculateBackgroundColor().toStringRGBA();
        this.ctx.fillRoundedRect(-label.size.x / 2, -label.size.y / 2, label.size.x, label.size.y, label.borderRadius);
        this.ctx.strokeStyle = label.calculateBorderColor().toStringRGBA();
        this.ctx.globalAlpha = label.borderColor.a;
        this.ctx.lineWidth = label.borderWidth;
        this.ctx.strokeRoundedRect(-label.size.x / 2, -label.size.y / 2, label.size.x, label.size.y, label.borderRadius);
        this.ctx.fillStyle = label.calculateTextColor();
        this.ctx.globalAlpha = label.textColor.a;
        this.ctx.fillText(label.text, offset.x - label.size.x / 2, offset.y - label.size.y / 2);
        this.ctx.globalAlpha = previousAlpha;
    }
    /**
     * Renders a button
     * @param button The button to render
     */
    renderButton(button) {
        this.renderLabel(button);
    }
    /**
     * Renders a slider
     * @param slider The slider to render
     */
    renderSlider(slider) {
        // Grab the global alpha so we can adjust it for this render
        let previousAlpha = this.ctx.globalAlpha;
        this.ctx.globalAlpha = slider.getLayer().getAlpha();
        // Calcualate the slider size
        let sliderSize = new Vec2_1.default(slider.size.x, 2);
        // Draw the slider
        this.ctx.fillStyle = slider.sliderColor.toString();
        this.ctx.fillRoundedRect(-sliderSize.x / 2, -sliderSize.y / 2, sliderSize.x, sliderSize.y, slider.borderRadius);
        // Calculate the nib size and position
        let x = MathUtils_1.default.lerp(-slider.size.x / 2, slider.size.x / 2, slider.getValue());
        // Draw the nib
        this.ctx.fillStyle = slider.nibColor.toString();
        this.ctx.fillRoundedRect(x - slider.nibSize.x / 2, -slider.nibSize.y / 2, slider.nibSize.x, slider.nibSize.y, slider.borderRadius);
        // Reset the alpha
        this.ctx.globalAlpha = previousAlpha;
    }
    /**
     * Renders a textInput
     * @param textInput The textInput to render
     */
    renderTextInput(textInput) {
        // Show a cursor sometimes
        if (textInput.focused && textInput.cursorCounter % 60 > 30) {
            textInput.text += "|";
        }
        this.renderLabel(textInput);
        if (textInput.focused) {
            if (textInput.cursorCounter % 60 > 30) {
                textInput.text = textInput.text.substring(0, textInput.text.length - 1);
            }
            textInput.cursorCounter += 1;
            if (textInput.cursorCounter >= 60) {
                textInput.cursorCounter = 0;
            }
        }
    }
}
exports.default = UIElementRenderer;

},{"../../DataTypes/Vec2":26,"../../ResourceManager/ResourceManager":90,"../../Utils/MathUtils":109}],82:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = __importDefault(require("../ResourceManager/ResourceManager"));
/**
 * An abstract framework to put all rendering in once place in the application
 */
class RenderingManager {
    constructor() {
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    /**
     * Sets the scene currently being rendered
     * @param scene The current Scene
     */
    setScene(scene) {
        this.scene = scene;
    }
}
exports.default = RenderingManager;

},{"../ResourceManager/ResourceManager":90}],83:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../DataTypes/Vec2"));
const Graphic_1 = __importDefault(require("../Nodes/Graphic"));
const Point_1 = __importDefault(require("../Nodes/Graphics/Point"));
const Rect_1 = __importDefault(require("../Nodes/Graphics/Rect"));
const AnimatedSprite_1 = __importDefault(require("../Nodes/Sprites/AnimatedSprite"));
const Sprite_1 = __importDefault(require("../Nodes/Sprites/Sprite"));
const UIElement_1 = __importDefault(require("../Nodes/UIElement"));
const Label_1 = __importDefault(require("../Nodes/UIElements/Label"));
const ShaderRegistry_1 = __importDefault(require("../Registry/Registries/ShaderRegistry"));
const RegistryManager_1 = __importDefault(require("../Registry/RegistryManager"));
const ResourceManager_1 = __importDefault(require("../ResourceManager/ResourceManager"));
const ParallaxLayer_1 = __importDefault(require("../Scene/Layers/ParallaxLayer"));
const RenderingManager_1 = __importDefault(require("./RenderingManager"));
class WebGLRenderer extends RenderingManager_1.default {
    initializeCanvas(canvas, width, height) {
        canvas.width = width;
        canvas.height = height;
        this.worldSize = Vec2_1.default.ZERO;
        this.worldSize.x = width;
        this.worldSize.y = height;
        // Get the WebGL context
        this.gl = canvas.getContext("webgl");
        this.gl.viewport(0, 0, canvas.width, canvas.height);
        this.gl.disable(this.gl.DEPTH_TEST);
        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
        this.gl.enable(this.gl.CULL_FACE);
        // Tell the resource manager we're using WebGL
        ResourceManager_1.default.getInstance().useWebGL(true, this.gl);
        // Show the text canvas and get its context
        let textCanvas = document.getElementById("text-canvas");
        textCanvas.hidden = false;
        this.textCtx = textCanvas.getContext("2d");
        // Size the text canvas to be the same as the game canvas
        textCanvas.height = height;
        textCanvas.width = width;
        return this.gl;
    }
    render(visibleSet, tilemaps, uiLayers) {
        for (let node of visibleSet) {
            this.renderNode(node);
        }
        uiLayers.forEach(key => {
            if (!uiLayers.get(key).isHidden())
                uiLayers.get(key).getItems().forEach(node => this.renderNode(node));
        });
    }
    clear(color) {
        this.gl.clearColor(color.r, color.g, color.b, color.a);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
        this.textCtx.clearRect(0, 0, this.worldSize.x, this.worldSize.y);
    }
    renderNode(node) {
        // Calculate the origin of the viewport according to this sprite
        this.origin = this.scene.getViewTranslation(node);
        // Get the zoom level of the scene
        this.zoom = this.scene.getViewScale();
        if (node.hasCustomShader) {
            // If the node has a custom shader, render using that
            this.renderCustom(node);
        }
        else if (node instanceof Graphic_1.default) {
            this.renderGraphic(node);
        }
        else if (node instanceof Sprite_1.default) {
            if (node instanceof AnimatedSprite_1.default) {
                this.renderAnimatedSprite(node);
            }
            else {
                this.renderSprite(node);
            }
        }
        else if (node instanceof UIElement_1.default) {
            this.renderUIElement(node);
        }
    }
    renderSprite(sprite) {
        let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.SPRITE_SHADER);
        let options = this.addOptions(shader.getOptions(sprite), sprite);
        shader.render(this.gl, options);
    }
    renderAnimatedSprite(sprite) {
        let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.SPRITE_SHADER);
        let options = this.addOptions(shader.getOptions(sprite), sprite);
        shader.render(this.gl, options);
    }
    renderGraphic(graphic) {
        if (graphic instanceof Point_1.default) {
            let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.POINT_SHADER);
            let options = this.addOptions(shader.getOptions(graphic), graphic);
            shader.render(this.gl, options);
        }
        else if (graphic instanceof Rect_1.default) {
            let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.RECT_SHADER);
            let options = this.addOptions(shader.getOptions(graphic), graphic);
            shader.render(this.gl, options);
        }
    }
    renderTilemap(tilemap) {
        throw new Error("Method not implemented.");
    }
    renderUIElement(uiElement) {
        if (uiElement instanceof Label_1.default) {
            let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.LABEL_SHADER);
            let options = this.addOptions(shader.getOptions(uiElement), uiElement);
            shader.render(this.gl, options);
            this.textCtx.setTransform(1, 0, 0, 1, (uiElement.position.x - this.origin.x) * this.zoom, (uiElement.position.y - this.origin.y) * this.zoom);
            this.textCtx.rotate(-uiElement.rotation);
            let globalAlpha = this.textCtx.globalAlpha;
            this.textCtx.globalAlpha = uiElement.alpha;
            // Render text
            this.textCtx.font = uiElement.getFontString();
            let offset = uiElement.calculateTextOffset(this.textCtx);
            this.textCtx.fillStyle = uiElement.calculateTextColor();
            this.textCtx.globalAlpha = uiElement.textColor.a;
            this.textCtx.fillText(uiElement.text, offset.x - uiElement.size.x / 2, offset.y - uiElement.size.y / 2);
            this.textCtx.globalAlpha = globalAlpha;
            this.textCtx.setTransform(1, 0, 0, 1, 0, 0);
        }
    }
    renderCustom(node) {
        let shader = RegistryManager_1.default.shaders.get(node.customShaderKey);
        let options = this.addOptions(shader.getOptions(node), node);
        shader.render(this.gl, options);
    }
    addOptions(options, node) {
        // Give the shader access to the world size
        options.worldSize = this.worldSize;
        // Adjust the origin position to the parallax
        let layer = node.getLayer();
        let parallax = new Vec2_1.default(1, 1);
        if (layer instanceof ParallaxLayer_1.default) {
            parallax = layer.parallax;
        }
        options.origin = this.origin.clone().mult(parallax);
        return options;
    }
}
exports.default = WebGLRenderer;

},{"../DataTypes/Vec2":26,"../Nodes/Graphic":43,"../Nodes/Graphics/Point":47,"../Nodes/Graphics/Rect":48,"../Nodes/Sprites/AnimatedSprite":49,"../Nodes/Sprites/Sprite":50,"../Nodes/UIElement":55,"../Nodes/UIElements/Label":57,"../Registry/Registries/ShaderRegistry":71,"../Registry/RegistryManager":72,"../ResourceManager/ResourceManager":90,"../Scene/Layers/ParallaxLayer":95,"./RenderingManager":82}],84:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = __importDefault(require("../../ResourceManager/ResourceManager"));
/**
 * A wrapper class for WebGL shaders.
 * This class is a singleton, and there is only one for each shader type.
 * All objects that use this shader type will refer to and modify this same type.
 */
class ShaderType {
    constructor(programKey) {
        this.programKey = programKey;
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    /**
     * Extracts the options from the CanvasNode and gives them to the render function
     * @param node The node to get options from
     * @returns An object containing the options that should be passed to the render function
     */
    getOptions(node) { return {}; }
}
exports.default = ShaderType;

},{"../../ResourceManager/ResourceManager":90}],85:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Mat4x4_1 = __importDefault(require("../../../DataTypes/Mat4x4"));
const Vec2_1 = __importDefault(require("../../../DataTypes/Vec2"));
const ResourceManager_1 = __importDefault(require("../../../ResourceManager/ResourceManager"));
const QuadShaderType_1 = __importDefault(require("./QuadShaderType"));
/** */
class LabelShaderType extends QuadShaderType_1.default {
    constructor(programKey) {
        super(programKey);
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    initBufferObject() {
        this.bufferObjectKey = "label";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    }
    render(gl, options) {
        const backgroundColor = options.backgroundColor.toWebGL();
        const borderColor = options.borderColor.toWebGL();
        const program = this.resourceManager.getShaderProgram(this.programKey);
        const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        gl.useProgram(program);
        const vertexData = this.getVertices(options.size.x, options.size.y);
        const FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        const a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 2 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        // Uniforms
        const u_BackgroundColor = gl.getUniformLocation(program, "u_BackgroundColor");
        gl.uniform4fv(u_BackgroundColor, backgroundColor);
        const u_BorderColor = gl.getUniformLocation(program, "u_BorderColor");
        gl.uniform4fv(u_BorderColor, borderColor);
        const u_MaxSize = gl.getUniformLocation(program, "u_MaxSize");
        gl.uniform2f(u_MaxSize, -vertexData[0], vertexData[1]);
        // Get transformation matrix
        // We want a square for our rendering space, so get the maximum dimension of our quad
        let maxDimension = Math.max(options.size.x, options.size.y);
        const u_BorderWidth = gl.getUniformLocation(program, "u_BorderWidth");
        gl.uniform1f(u_BorderWidth, options.borderWidth / maxDimension);
        const u_BorderRadius = gl.getUniformLocation(program, "u_BorderRadius");
        gl.uniform1f(u_BorderRadius, options.borderRadius / maxDimension);
        // The size of the rendering space will be a square with this maximum dimension
        let size = new Vec2_1.default(maxDimension, maxDimension).scale(2 / options.worldSize.x, 2 / options.worldSize.y);
        // Center our translations around (0, 0)
        const translateX = (options.position.x - options.origin.x - options.worldSize.x / 2) / maxDimension;
        const translateY = -(options.position.y - options.origin.y - options.worldSize.y / 2) / maxDimension;
        // Create our transformation matrix
        this.translation.translate(new Float32Array([translateX, translateY]));
        this.scale.scale(size);
        this.rotation.rotate(options.rotation);
        let transformation = Mat4x4_1.default.MULT(this.translation, this.scale, this.rotation);
        // Pass the translation matrix to our shader
        const u_Transform = gl.getUniformLocation(program, "u_Transform");
        gl.uniformMatrix4fv(u_Transform, false, transformation.toArray());
        // Draw the quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
    /**
     * The rendering space always has to be a square, so make sure its square w.r.t to the largest dimension
     * @param w The width of the quad in pixels
     * @param h The height of the quad in pixels
     * @returns An array of the vertices of the quad
     */
    getVertices(w, h) {
        let x, y;
        if (h > w) {
            y = 0.5;
            x = w / (2 * h);
        }
        else {
            x = 0.5;
            y = h / (2 * w);
        }
        return new Float32Array([
            -x, y,
            -x, -y,
            x, y,
            x, -y
        ]);
    }
    getOptions(rect) {
        let options = {
            position: rect.position,
            backgroundColor: rect.calculateBackgroundColor(),
            borderColor: rect.calculateBorderColor(),
            borderWidth: rect.borderWidth,
            borderRadius: rect.borderRadius,
            size: rect.size,
            rotation: rect.rotation
        };
        return options;
    }
}
exports.default = LabelShaderType;

},{"../../../DataTypes/Mat4x4":16,"../../../DataTypes/Vec2":26,"../../../ResourceManager/ResourceManager":90,"./QuadShaderType":87}],86:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const RenderingUtils_1 = __importDefault(require("../../../Utils/RenderingUtils"));
const ShaderType_1 = __importDefault(require("../ShaderType"));
class PointShaderType extends ShaderType_1.default {
    constructor(programKey) {
        super(programKey);
    }
    initBufferObject() {
        this.bufferObjectKey = "point";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    }
    render(gl, options) {
        let position = RenderingUtils_1.default.toWebGLCoords(options.position, options.origin, options.worldSize);
        let color = RenderingUtils_1.default.toWebGLColor(options.color);
        const program = this.resourceManager.getShaderProgram(this.programKey);
        const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        gl.useProgram(program);
        const vertexData = position;
        const FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        const a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 2 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        // Uniforms
        const u_Color = gl.getUniformLocation(program, "u_Color");
        gl.uniform4fv(u_Color, color);
        const u_PointSize = gl.getUniformLocation(program, "u_PointSize");
        gl.uniform1f(u_PointSize, options.pointSize);
        gl.drawArrays(gl.POINTS, 0, 1);
    }
    getOptions(point) {
        let options = {
            position: point.position,
            color: point.color,
            pointSize: point.size,
        };
        return options;
    }
}
exports.default = PointShaderType;

},{"../../../Utils/RenderingUtils":112,"../ShaderType":84}],87:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Mat4x4_1 = __importDefault(require("../../../DataTypes/Mat4x4"));
const ShaderType_1 = __importDefault(require("../ShaderType"));
/** Represents any WebGL objects that have a quad mesh (i.e. a rectangular game object composed of only two triangles) */
class QuadShaderType extends ShaderType_1.default {
    constructor(programKey) {
        super(programKey);
        this.scale = Mat4x4_1.default.IDENTITY;
        this.rotation = Mat4x4_1.default.IDENTITY;
        this.translation = Mat4x4_1.default.IDENTITY;
    }
}
exports.default = QuadShaderType;

},{"../../../DataTypes/Mat4x4":16,"../ShaderType":84}],88:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Mat4x4_1 = __importDefault(require("../../../DataTypes/Mat4x4"));
const Vec2_1 = __importDefault(require("../../../DataTypes/Vec2"));
const ResourceManager_1 = __importDefault(require("../../../ResourceManager/ResourceManager"));
const QuadShaderType_1 = __importDefault(require("./QuadShaderType"));
/** */
class RectShaderType extends QuadShaderType_1.default {
    constructor(programKey) {
        super(programKey);
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    initBufferObject() {
        this.bufferObjectKey = "rect";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    }
    render(gl, options) {
        const color = options.color.toWebGL();
        const program = this.resourceManager.getShaderProgram(this.programKey);
        const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        gl.useProgram(program);
        const vertexData = this.getVertices(options.size.x, options.size.y);
        const FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        const a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 2 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        // Uniforms
        const u_Color = gl.getUniformLocation(program, "u_Color");
        gl.uniform4fv(u_Color, color);
        // Get transformation matrix
        // We want a square for our rendering space, so get the maximum dimension of our quad
        let maxDimension = Math.max(options.size.x, options.size.y);
        // The size of the rendering space will be a square with this maximum dimension
        let size = new Vec2_1.default(maxDimension, maxDimension).scale(2 / options.worldSize.x, 2 / options.worldSize.y);
        // Center our translations around (0, 0)
        const translateX = (options.position.x - options.origin.x - options.worldSize.x / 2) / maxDimension;
        const translateY = -(options.position.y - options.origin.y - options.worldSize.y / 2) / maxDimension;
        // Create our transformation matrix
        this.translation.translate(new Float32Array([translateX, translateY]));
        this.scale.scale(size);
        this.rotation.rotate(options.rotation);
        let transformation = Mat4x4_1.default.MULT(this.translation, this.scale, this.rotation);
        // Pass the translation matrix to our shader
        const u_Transform = gl.getUniformLocation(program, "u_Transform");
        gl.uniformMatrix4fv(u_Transform, false, transformation.toArray());
        // Draw the quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
    /*
        So as it turns out, WebGL has an issue with non-square quads.
        It doesn't like when you don't have a 1-1 scale, and rotations are entirely messed up if this is not the case.
        To solve this, I used the scale of the LARGEST dimension of the quad to make a square, then adjusted the vertex coordinates inside of that.
        A diagram of the solution follows.

        There is a bounding square for the quad with dimensions hxh (in this case, since height is the largest dimension).
        The offset in the vertical direction is therefore 0.5, as it is normally.
        However, the offset in the horizontal direction is not so straightforward, but isn't conceptually hard.
        All we really have to do is a range change from [0, height/2] to [0, 0.5], where our value is t = width/2, and 0 <= t <= height/2.

        So now we have our rect, in a space scaled with respect to the largest dimension.
        Rotations work as you would expect, even for long rectangles.

                    0.5
            __ __ __ __ __ __ __
            |	|88888888888|	|
            |	|88888888888|	|
            |	|88888888888|	|
        -0.5|_ _|88888888888|_ _|0.5
            |	|88888888888|	|
            |	|88888888888|	|
            |	|88888888888|	|
            |___|88888888888|___|
                    -0.5

        The getVertices function below does as described, and converts the range
    */
    /**
     * The rendering space always has to be a square, so make sure its square w.r.t to the largest dimension
     * @param w The width of the quad in pixels
     * @param h The height of the quad in pixels
     * @returns An array of the vertices of the quad
     */
    getVertices(w, h) {
        let x, y;
        if (h > w) {
            y = 0.5;
            x = w / (2 * h);
        }
        else {
            x = 0.5;
            y = h / (2 * w);
        }
        return new Float32Array([
            -x, y,
            -x, -y,
            x, y,
            x, -y
        ]);
    }
    getOptions(rect) {
        let options = {
            position: rect.position,
            color: rect.color,
            size: rect.size,
            rotation: rect.rotation
        };
        return options;
    }
}
exports.default = RectShaderType;

},{"../../../DataTypes/Mat4x4":16,"../../../DataTypes/Vec2":26,"../../../ResourceManager/ResourceManager":90,"./QuadShaderType":87}],89:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Mat4x4_1 = __importDefault(require("../../../DataTypes/Mat4x4"));
const Vec2_1 = __importDefault(require("../../../DataTypes/Vec2"));
const AnimatedSprite_1 = __importDefault(require("../../../Nodes/Sprites/AnimatedSprite"));
const ResourceManager_1 = __importDefault(require("../../../ResourceManager/ResourceManager"));
const QuadShaderType_1 = __importDefault(require("./QuadShaderType"));
/** A shader for sprites and animated sprites */
class SpriteShaderType extends QuadShaderType_1.default {
    constructor(programKey) {
        super(programKey);
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    initBufferObject() {
        this.bufferObjectKey = "sprite";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    }
    render(gl, options) {
        const program = this.resourceManager.getShaderProgram(this.programKey);
        const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        const texture = this.resourceManager.getTexture(options.imageKey);
        gl.useProgram(program);
        const vertexData = this.getVertices(options.size.x, options.size.y, options.scale);
        const FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        const a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 4 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        const a_TexCoord = gl.getAttribLocation(program, "a_TexCoord");
        gl.vertexAttribPointer(a_TexCoord, 2, gl.FLOAT, false, 4 * FSIZE, 2 * FSIZE);
        gl.enableVertexAttribArray(a_TexCoord);
        // Uniforms
        // Get transformation matrix
        // We want a square for our rendering space, so get the maximum dimension of our quad
        let maxDimension = Math.max(options.size.x, options.size.y);
        // The size of the rendering space will be a square with this maximum dimension
        let size = new Vec2_1.default(maxDimension, maxDimension).scale(2 / options.worldSize.x, 2 / options.worldSize.y);
        // Center our translations around (0, 0)
        const translateX = (options.position.x - options.origin.x - options.worldSize.x / 2) / maxDimension;
        const translateY = -(options.position.y - options.origin.y - options.worldSize.y / 2) / maxDimension;
        // Create our transformation matrix
        this.translation.translate(new Float32Array([translateX, translateY]));
        this.scale.scale(size);
        this.rotation.rotate(options.rotation);
        let transformation = Mat4x4_1.default.MULT(this.translation, this.scale, this.rotation);
        // Pass the translation matrix to our shader
        const u_Transform = gl.getUniformLocation(program, "u_Transform");
        gl.uniformMatrix4fv(u_Transform, false, transformation.toArray());
        // Set up our sampler with our assigned texture unit
        const u_Sampler = gl.getUniformLocation(program, "u_Sampler");
        gl.uniform1i(u_Sampler, texture);
        // Pass in texShift
        const u_texShift = gl.getUniformLocation(program, "u_texShift");
        gl.uniform2fv(u_texShift, options.texShift);
        // Pass in texScale
        const u_texScale = gl.getUniformLocation(program, "u_texScale");
        gl.uniform2fv(u_texScale, options.texScale);
        // Draw the quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
    /**
     * The rendering space always has to be a square, so make sure its square w.r.t to the largest dimension
     * @param w The width of the quad in pixels
     * @param h The height of the quad in pixels
     * @returns An array of the vertices of the quad
     */
    getVertices(w, h, scale) {
        let x, y;
        if (h > w) {
            y = 0.5;
            x = w / (2 * h);
        }
        else {
            x = 0.5;
            y = h / (2 * w);
        }
        // Scale the rendering space if needed
        x *= scale[0];
        y *= scale[1];
        return new Float32Array([
            -x, y, 0.0, 0.0,
            -x, -y, 0.0, 1.0,
            x, y, 1.0, 0.0,
            x, -y, 1.0, 1.0
        ]);
    }
    getOptions(sprite) {
        let texShift;
        let texScale;
        if (sprite instanceof AnimatedSprite_1.default) {
            let animationIndex = sprite.animation.getIndexAndAdvanceAnimation();
            let offset = sprite.getAnimationOffset(animationIndex);
            texShift = new Float32Array([offset.x / (sprite.cols * sprite.size.x), offset.y / (sprite.rows * sprite.size.y)]);
            texScale = new Float32Array([1 / (sprite.cols), 1 / (sprite.rows)]);
        }
        else {
            texShift = new Float32Array([0, 0]);
            texScale = new Float32Array([1, 1]);
        }
        let options = {
            position: sprite.position,
            rotation: sprite.rotation,
            size: sprite.size,
            scale: sprite.scale.toArray(),
            imageKey: sprite.imageId,
            texShift,
            texScale
        };
        return options;
    }
}
exports.default = SpriteShaderType;

},{"../../../DataTypes/Mat4x4":16,"../../../DataTypes/Vec2":26,"../../../Nodes/Sprites/AnimatedSprite":49,"../../../ResourceManager/ResourceManager":90,"./QuadShaderType":87}],90:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = __importDefault(require("../DataTypes/Collections/Map"));
const Queue_1 = __importDefault(require("../DataTypes/Collections/Queue"));
const StringUtils_1 = __importDefault(require("../Utils/StringUtils"));
const AudioManager_1 = __importDefault(require("../Sound/AudioManager"));
const WebGLProgramType_1 = __importDefault(require("../DataTypes/Rendering/WebGLProgramType"));
/**
 * The resource manager for the game engine.
 * The resource manager interfaces with the loadable assets of a game such as images, data files,
 * and sounds, which are all found in the dist folder.
 * This class controls loading and updates the @reference[Scene] with the loading progress, so that the scene does
 * not start before all necessary assets are loaded.
 */
class ResourceManager {
    constructor() {
        this.loading = false;
        this.justLoaded = false;
        this.loadonly_imagesLoaded = 0;
        this.loadonly_imagesToLoad = 0;
        this.loadonly_imageLoadingQueue = new Queue_1.default();
        this.images = new Map_1.default();
        this.loadonly_spritesheetsLoaded = 0;
        this.loadonly_spritesheetsToLoad = 0;
        this.loadonly_spritesheetLoadingQueue = new Queue_1.default();
        this.spritesheets = new Map_1.default();
        this.loadonly_tilemapsLoaded = 0;
        this.loadonly_tilemapsToLoad = 0;
        this.loadonly_tilemapLoadingQueue = new Queue_1.default();
        this.tilemaps = new Map_1.default();
        this.loadonly_audioLoaded = 0;
        this.loadonly_audioToLoad = 0;
        this.loadonly_audioLoadingQueue = new Queue_1.default();
        this.audioBuffers = new Map_1.default();
        this.loadonly_jsonLoaded = 0;
        this.loadonly_jsonToLoad = 0;
        this.loadonly_jsonLoadingQueue = new Queue_1.default();
        this.jsonObjects = new Map_1.default();
        this.loadonly_gl_ShaderProgramsLoaded = 0;
        this.loadonly_gl_ShaderProgramsToLoad = 0;
        this.loadonly_gl_ShaderLoadingQueue = new Queue_1.default();
        this.gl_ShaderPrograms = new Map_1.default();
        this.gl_Textures = new Map_1.default();
        this.gl_NextTextureID = 0;
        this.gl_Buffers = new Map_1.default();
        this.resourcesToUnload = new Array();
        this.resourcesToKeep = new Array();
    }
    ;
    /* ######################################## SINGLETON ########################################*/
    /**
     * Returns the current instance of this class or a new instance if none exist
     * @returns The resource manager
     */
    static getInstance() {
        if (!this.instance) {
            this.instance = new ResourceManager();
        }
        return this.instance;
    }
    /* ######################################## PUBLIC FUNCTION ########################################*/
    /**
     * Activates or deactivates the use of WebGL
     * @param flag True if WebGL should be used, false otherwise
     * @param gl The instance of the graphics context, if applicable
     */
    useWebGL(flag, gl) {
        this.gl_WebGLActive = flag;
        if (this.gl_WebGLActive) {
            this.gl = gl;
        }
    }
    /**
     * Loads an image from file
     * @param key The key to associate the loaded image with
     * @param path The path to the image to load
     */
    image(key, path) {
        this.loadonly_imageLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepImage(key) {
        this.keepResource(key, ResourceType.IMAGE);
    }
    /**
     * Retrieves a loaded image
     * @param key The key of the loaded image
     * @returns The image element associated with this key
     */
    getImage(key) {
        let image = this.images.get(key);
        if (image === undefined) {
            throw `There is no image associated with key "${key}"`;
        }
        return image;
    }
    /**
     * Loads a spritesheet from file
     * @param key The key to associate the loaded spritesheet with
     * @param path The path to the spritesheet to load
     */
    spritesheet(key, path) {
        this.loadonly_spritesheetLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepSpritesheet(key) {
        this.keepResource(key, ResourceType.SPRITESHEET);
    }
    /**
     * Retrieves a loaded spritesheet
     * @param key The key of the spritesheet to load
     * @returns The loaded Spritesheet
     */
    getSpritesheet(key) {
        return this.spritesheets.get(key);
    }
    /**
     * Loads an audio file
     * @param key The key to associate with the loaded audio file
     * @param path The path to the audio file to load
     */
    audio(key, path) {
        this.loadonly_audioLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepAudio(key) {
        this.keepResource(key, ResourceType.AUDIO);
    }
    /**
     * Retrieves a loaded audio file
     * @param key The key of the audio file to load
     * @returns The AudioBuffer created from the loaded audio fle
     */
    getAudio(key) {
        return this.audioBuffers.get(key);
    }
    /**
     * Load a tilemap from a json file. Automatically loads related images
     * @param key The key to associate with the loaded tilemap
     * @param path The path to the tilemap to load
     */
    tilemap(key, path) {
        this.loadonly_tilemapLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepTilemap(key) {
        this.keepResource(key, ResourceType.TILEMAP);
    }
    /**
     * Retreives a loaded tilemap
     * @param key The key of the loaded tilemap
     * @returns The tilemap data associated with the key
     */
    getTilemap(key) {
        return this.tilemaps.get(key);
    }
    /**
     * Loads an object from a json file.
     * @param key The key to associate with the loaded object
     * @param path The path to the json file to load
     */
    object(key, path) {
        this.loadonly_jsonLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepObject(key) {
        this.keepResource(key, ResourceType.JSON);
    }
    /**
     * Retreives a loaded object
     * @param key The key of the loaded object
     * @returns The object data associated with the key
     */
    getObject(key) {
        return this.jsonObjects.get(key);
    }
    /* ######################################## LOAD FUNCTION ########################################*/
    /**
     * Loads all resources currently in the queue
     * @param callback The function to cal when the resources are finished loading
     */
    loadResourcesFromQueue(callback) {
        this.loadonly_typesToLoad = 5;
        this.loading = true;
        // Load everything in the queues. Tilemaps have to come before images because they will add new images to the queue
        this.loadTilemapsFromQueue(() => {
            console.log("Loaded Tilemaps");
            this.loadSpritesheetsFromQueue(() => {
                console.log("Loaded Spritesheets");
                this.loadImagesFromQueue(() => {
                    console.log("Loaded Images");
                    this.loadAudioFromQueue(() => {
                        console.log("Loaded Audio");
                        this.loadObjectsFromQueue(() => {
                            console.log("Loaded Objects");
                            if (this.gl_WebGLActive) {
                                this.gl_LoadShadersFromQueue(() => {
                                    console.log("Loaded Shaders");
                                    this.finishLoading(callback);
                                });
                            }
                            else {
                                this.finishLoading(callback);
                            }
                        });
                    });
                });
            });
        });
    }
    finishLoading(callback) {
        // Done loading
        this.loading = false;
        this.justLoaded = true;
        callback();
    }
    /* ######################################## UNLOAD FUNCTION ########################################*/
    keepResource(key, type) {
        console.log("Keep resource...");
        for (let i = 0; i < this.resourcesToUnload.length; i++) {
            let resource = this.resourcesToUnload[i];
            if (resource.key === key && resource.resourceType === type) {
                console.log("Found resource " + key + " of type " + type + ". Keeping.");
                let resourceToMove = this.resourcesToUnload.splice(i, 1);
                this.resourcesToKeep.push(...resourceToMove);
                return;
            }
        }
    }
    /**
     * Deletes references to all resources in the resource manager
     */
    unloadAllResources() {
        this.loading = false;
        this.justLoaded = false;
        for (let resource of this.resourcesToUnload) {
            // Unload the resource
            this.unloadResource(resource);
        }
    }
    unloadResource(resource) {
        // Delete the resource itself
        switch (resource.resourceType) {
            case ResourceType.IMAGE:
                this.images.delete(resource.key);
                if (this.gl_WebGLActive) {
                    this.gl_Textures.delete(resource.key);
                }
                break;
            case ResourceType.TILEMAP:
                this.tilemaps.delete(resource.key);
                break;
            case ResourceType.SPRITESHEET:
                this.spritesheets.delete(resource.key);
                break;
            case ResourceType.AUDIO:
                this.audioBuffers.delete(resource.key);
                break;
            case ResourceType.JSON:
                this.jsonObjects.delete(resource.key);
                break;
            /*case ResourceType.SHADER:
                this.gl_ShaderPrograms.get(resource.key).delete(this.gl);
                this.gl_ShaderPrograms.delete(resource.key);
                break;*/
        }
        // Delete any dependencies
        for (let dependency of resource.dependencies) {
            this.unloadResource(dependency);
        }
    }
    /* ######################################## WORK FUNCTIONS ########################################*/
    /**
     * Loads all tilemaps currently in the tilemap loading queue
     * @param onFinishLoading The function to call when loading is complete
     */
    loadTilemapsFromQueue(onFinishLoading) {
        this.loadonly_tilemapsToLoad = this.loadonly_tilemapLoadingQueue.getSize();
        this.loadonly_tilemapsLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_tilemapsToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_tilemapLoadingQueue.hasItems()) {
            let tilemap = this.loadonly_tilemapLoadingQueue.dequeue();
            this.loadTilemap(tilemap.key, tilemap.path, onFinishLoading);
        }
    }
    /**
     * Loads a singular tilemap
     * @param key The key of the tilemap
     * @param pathToTilemapJSON The path to the tilemap JSON file
     * @param callbackIfLast The function to call if this is the last tilemap to load
     */
    loadTilemap(key, pathToTilemapJSON, callbackIfLast) {
        this.loadTextFile(pathToTilemapJSON, (fileText) => {
            let tilemapObject = JSON.parse(fileText);
            // We can parse the object later - it's much faster than loading
            this.tilemaps.add(key, tilemapObject);
            let resource = new ResourceReference(key, ResourceType.TILEMAP);
            // Grab the tileset images we need to load and add them to the imageloading queue
            for (let tileset of tilemapObject.tilesets) {
                if (tileset.image) {
                    let key = tileset.image;
                    let path = StringUtils_1.default.getPathFromFilePath(pathToTilemapJSON) + key;
                    this.loadonly_imageLoadingQueue.enqueue({ key: key, path: path, isDependency: true });
                    // Add this image as a dependency to the tilemap
                    resource.addDependency(new ResourceReference(key, ResourceType.IMAGE));
                }
                else if (tileset.tiles) {
                    for (let tile of tileset.tiles) {
                        let key = tile.image;
                        let path = StringUtils_1.default.getPathFromFilePath(pathToTilemapJSON) + key;
                        this.loadonly_imageLoadingQueue.enqueue({ key: key, path: path, isDependency: true });
                        // Add this image as a dependency to the tilemap
                        resource.addDependency(new ResourceReference(key, ResourceType.IMAGE));
                    }
                }
            }
            // Add the resource reference to the list of resource to unload
            this.resourcesToUnload.push(resource);
            // Finish loading
            this.finishLoadingTilemap(callbackIfLast);
        });
    }
    /**
     * Finish loading a tilemap. Calls the callback function if this is the last tilemap being loaded
     * @param callback The function to call if this is the last tilemap to load
     */
    finishLoadingTilemap(callback) {
        this.loadonly_tilemapsLoaded += 1;
        if (this.loadonly_tilemapsLoaded === this.loadonly_tilemapsToLoad) {
            // We're done loading tilemaps
            callback();
        }
    }
    /**
     * Loads all spritesheets currently in the spritesheet loading queue
     * @param onFinishLoading The function to call when the spritesheets are done loading
     */
    loadSpritesheetsFromQueue(onFinishLoading) {
        this.loadonly_spritesheetsToLoad = this.loadonly_spritesheetLoadingQueue.getSize();
        this.loadonly_spritesheetsLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_spritesheetsToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_spritesheetLoadingQueue.hasItems()) {
            let spritesheet = this.loadonly_spritesheetLoadingQueue.dequeue();
            this.loadSpritesheet(spritesheet.key, spritesheet.path, onFinishLoading);
        }
    }
    /**
     * Loads a singular spritesheet
     * @param key The key of the spritesheet to load
     * @param pathToSpritesheetJSON The path to the spritesheet JSON file
     * @param callbackIfLast The function to call if this is the last spritesheet
     */
    loadSpritesheet(key, pathToSpritesheetJSON, callbackIfLast) {
        this.loadTextFile(pathToSpritesheetJSON, (fileText) => {
            let spritesheet = JSON.parse(fileText);
            // We can parse the object later - it's much faster than loading
            this.spritesheets.add(key, spritesheet);
            let resource = new ResourceReference(key, ResourceType.SPRITESHEET);
            // Grab the image we need to load and add it to the imageloading queue
            let path = StringUtils_1.default.getPathFromFilePath(pathToSpritesheetJSON) + spritesheet.spriteSheetImage;
            this.loadonly_imageLoadingQueue.enqueue({ key: spritesheet.name, path: path, isDependency: true });
            resource.addDependency(new ResourceReference(spritesheet.name, ResourceType.IMAGE));
            this.resourcesToUnload.push(resource);
            // Finish loading
            this.finishLoadingSpritesheet(callbackIfLast);
        });
    }
    /**
     * Finish loading a spritesheet. Calls the callback function if this is the last spritesheet being loaded
     * @param callback The function to call if this is the last spritesheet to load
     */
    finishLoadingSpritesheet(callback) {
        this.loadonly_spritesheetsLoaded += 1;
        if (this.loadonly_spritesheetsLoaded === this.loadonly_spritesheetsToLoad) {
            // We're done loading spritesheets
            callback();
        }
    }
    /**
     * Loads all images currently in the image loading queue
     * @param onFinishLoading The function to call when there are no more images to load
     */
    loadImagesFromQueue(onFinishLoading) {
        this.loadonly_imagesToLoad = this.loadonly_imageLoadingQueue.getSize();
        this.loadonly_imagesLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_imagesToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_imageLoadingQueue.hasItems()) {
            let image = this.loadonly_imageLoadingQueue.dequeue();
            this.loadImage(image.key, image.path, image.isDependency, onFinishLoading);
        }
    }
    /**
     * Loads a singular image
     * @param key The key of the image to load
     * @param path The path to the image to load
     * @param callbackIfLast The function to call if this is the last image
     */
    loadImage(key, path, isDependency, callbackIfLast) {
        var image = new Image();
        image.onload = () => {
            // Add to loaded images
            this.images.add(key, image);
            // If not a dependency, push it to the unload list. Otherwise it's managed by something else
            if (!isDependency) {
                this.resourcesToUnload.push(new ResourceReference(key, ResourceType.IMAGE));
            }
            // If WebGL is active, create a texture
            if (this.gl_WebGLActive) {
                this.createWebGLTexture(key, image);
            }
            // Finish image load
            this.finishLoadingImage(callbackIfLast);
        };
        image.src = path;
    }
    /**
     * Finish loading an image. If this is the last image, it calls the callback function
     * @param callback The function to call if this is the last image
     */
    finishLoadingImage(callback) {
        this.loadonly_imagesLoaded += 1;
        if (this.loadonly_imagesLoaded === this.loadonly_imagesToLoad) {
            // We're done loading images
            callback();
        }
    }
    /**
     * Loads all audio currently in the tilemap loading queue
     * @param onFinishLoading The function to call when tilemaps are done loading
     */
    loadAudioFromQueue(onFinishLoading) {
        this.loadonly_audioToLoad = this.loadonly_audioLoadingQueue.getSize();
        this.loadonly_audioLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_audioToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_audioLoadingQueue.hasItems()) {
            let audio = this.loadonly_audioLoadingQueue.dequeue();
            this.loadAudio(audio.key, audio.path, onFinishLoading);
        }
    }
    /**
     * Load a singular audio file
     * @param key The key to the audio file to load
     * @param path The path to the audio file to load
     * @param callbackIfLast The function to call if this is the last audio file to load
     */
    loadAudio(key, path, callbackIfLast) {
        let audioCtx = AudioManager_1.default.getInstance().getAudioContext();
        let request = new XMLHttpRequest();
        request.open('GET', path, true);
        request.responseType = 'arraybuffer';
        request.onload = () => {
            audioCtx.decodeAudioData(request.response, (buffer) => {
                // Add to list of audio buffers
                this.audioBuffers.add(key, buffer);
                this.resourcesToUnload.push(new ResourceReference(key, ResourceType.AUDIO));
                // Finish loading sound
                this.finishLoadingAudio(callbackIfLast);
            }, (error) => {
                throw "Error loading sound";
            });
        };
        request.send();
    }
    /**
     * Finish loading an audio file. Calls the callback functon if this is the last audio sample being loaded.
     * @param callback The function to call if this is the last audio file to load
     */
    finishLoadingAudio(callback) {
        this.loadonly_audioLoaded += 1;
        if (this.loadonly_audioLoaded === this.loadonly_audioToLoad) {
            // We're done loading audio
            callback();
        }
    }
    /**
     * Loads all objects currently in the object loading queue
     * @param onFinishLoading The function to call when there are no more objects to load
     */
    loadObjectsFromQueue(onFinishLoading) {
        this.loadonly_jsonToLoad = this.loadonly_jsonLoadingQueue.getSize();
        this.loadonly_jsonLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_jsonToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_jsonLoadingQueue.hasItems()) {
            let obj = this.loadonly_jsonLoadingQueue.dequeue();
            this.loadObject(obj.key, obj.path, onFinishLoading);
        }
    }
    /**
     * Loads a singular object
     * @param key The key of the object to load
     * @param path The path to the object to load
     * @param callbackIfLast The function to call if this is the last object
     */
    loadObject(key, path, callbackIfLast) {
        this.loadTextFile(path, (fileText) => {
            let obj = JSON.parse(fileText);
            this.jsonObjects.add(key, obj);
            this.resourcesToUnload.push(new ResourceReference(key, ResourceType.JSON));
            this.finishLoadingObject(callbackIfLast);
        });
    }
    /**
     * Finish loading an object. If this is the last object, it calls the callback function
     * @param callback The function to call if this is the last object
     */
    finishLoadingObject(callback) {
        this.loadonly_jsonLoaded += 1;
        if (this.loadonly_jsonLoaded === this.loadonly_jsonToLoad) {
            // We're done loading objects
            callback();
        }
    }
    /* ########## WEBGL SPECIFIC FUNCTIONS ########## */
    getTexture(key) {
        return this.gl_Textures.get(key);
    }
    getShaderProgram(key) {
        return this.gl_ShaderPrograms.get(key).program;
    }
    getBuffer(key) {
        return this.gl_Buffers.get(key);
    }
    createWebGLTexture(imageKey, image) {
        // Get the texture ID
        const textureID = this.getTextureID(this.gl_NextTextureID);
        // Create the texture
        const texture = this.gl.createTexture();
        // Set up the texture
        // Enable texture0
        this.gl.activeTexture(textureID);
        // Bind our texture to texture 0
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        // Set the texture parameters
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        // Set the texture image
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);
        // Add the texture to our map with the same key as the image
        this.gl_Textures.add(imageKey, this.gl_NextTextureID);
        // Increment the key
        this.gl_NextTextureID += 1;
    }
    getTextureID(id) {
        // Start with 9 cases - this can be expanded if needed, but for the best performance,
        // Textures should be stitched into an atlas
        switch (id) {
            case 0: return this.gl.TEXTURE0;
            case 1: return this.gl.TEXTURE1;
            case 2: return this.gl.TEXTURE2;
            case 3: return this.gl.TEXTURE3;
            case 4: return this.gl.TEXTURE4;
            case 5: return this.gl.TEXTURE5;
            case 6: return this.gl.TEXTURE6;
            case 7: return this.gl.TEXTURE7;
            case 8: return this.gl.TEXTURE8;
            default: return this.gl.TEXTURE9;
        }
    }
    createBuffer(key) {
        if (this.gl_WebGLActive) {
            let buffer = this.gl.createBuffer();
            this.gl_Buffers.add(key, buffer);
        }
    }
    /**
     * Enqueues loading of a new shader program
     * @param key The key of the shader program
     * @param vShaderFilepath
     * @param fShaderFilepath
     */
    shader(key, vShaderFilepath, fShaderFilepath) {
        let splitPath = vShaderFilepath.split(".");
        let end = splitPath[splitPath.length - 1];
        if (end !== "vshader") {
            throw `${vShaderFilepath} is not a valid vertex shader - must end in ".vshader`;
        }
        splitPath = fShaderFilepath.split(".");
        end = splitPath[splitPath.length - 1];
        if (end !== "fshader") {
            throw `${fShaderFilepath} is not a valid vertex shader - must end in ".fshader`;
        }
        let paths = new KeyPath_Shader();
        paths.key = key;
        paths.vpath = vShaderFilepath;
        paths.fpath = fShaderFilepath;
        this.loadonly_gl_ShaderLoadingQueue.enqueue(paths);
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepShader(key) {
        this.keepResource(key, ResourceType.IMAGE);
    }
    gl_LoadShadersFromQueue(onFinishLoading) {
        this.loadonly_gl_ShaderProgramsToLoad = this.loadonly_gl_ShaderLoadingQueue.getSize();
        this.loadonly_gl_ShaderProgramsLoaded = 0;
        // If webGL isn'active or there are no items to load, we're finished
        if (!this.gl_WebGLActive || this.loadonly_gl_ShaderProgramsToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_gl_ShaderLoadingQueue.hasItems()) {
            let shader = this.loadonly_gl_ShaderLoadingQueue.dequeue();
            this.gl_LoadShader(shader.key, shader.vpath, shader.fpath, onFinishLoading);
        }
    }
    gl_LoadShader(key, vpath, fpath, callbackIfLast) {
        this.loadTextFile(vpath, (vFileText) => {
            const vShader = vFileText;
            this.loadTextFile(fpath, (fFileText) => {
                const fShader = fFileText;
                // Extract the program and shaders
                const [shaderProgram, vertexShader, fragmentShader] = this.createShaderProgram(vShader, fShader);
                // Create a wrapper type
                const programWrapper = new WebGLProgramType_1.default();
                programWrapper.program = shaderProgram;
                programWrapper.vertexShader = vertexShader;
                programWrapper.fragmentShader = fragmentShader;
                // Add to our map
                this.gl_ShaderPrograms.add(key, programWrapper);
                this.resourcesToUnload.push(new ResourceReference(key, ResourceType.SHADER));
                // Finish loading
                this.gl_FinishLoadingShader(callbackIfLast);
            });
        });
    }
    gl_FinishLoadingShader(callback) {
        this.loadonly_gl_ShaderProgramsLoaded += 1;
        if (this.loadonly_gl_ShaderProgramsLoaded === this.loadonly_gl_ShaderProgramsToLoad) {
            // We're done loading shaders
            callback();
        }
    }
    createShaderProgram(vShaderSource, fShaderSource) {
        const vertexShader = this.loadVertexShader(vShaderSource);
        const fragmentShader = this.loadFragmentShader(fShaderSource);
        if (vertexShader === null || fragmentShader === null) {
            // We had a problem intializing - error
            return null;
        }
        // Create a shader program
        const program = this.gl.createProgram();
        if (!program) {
            // Error creating
            console.warn("Failed to create program");
            return null;
        }
        // Attach our vertex and fragment shader
        this.gl.attachShader(program, vertexShader);
        this.gl.attachShader(program, fragmentShader);
        // Link
        this.gl.linkProgram(program);
        if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
            // Error linking
            const error = this.gl.getProgramInfoLog(program);
            console.warn("Failed to link program: " + error);
            // Clean up
            this.gl.deleteProgram(program);
            this.gl.deleteShader(vertexShader);
            this.gl.deleteShader(fragmentShader);
            return null;
        }
        // We successfully create a program
        return [program, vertexShader, fragmentShader];
    }
    loadVertexShader(shaderSource) {
        // Create a new vertex shader
        return this.loadShader(this.gl.VERTEX_SHADER, shaderSource);
    }
    loadFragmentShader(shaderSource) {
        // Create a new fragment shader
        return this.loadShader(this.gl.FRAGMENT_SHADER, shaderSource);
    }
    loadShader(type, shaderSource) {
        const shader = this.gl.createShader(type);
        // If we couldn't create the shader, error
        if (shader === null) {
            console.warn("Unable to create shader");
            return null;
        }
        // Add the source to the shader and compile
        this.gl.shaderSource(shader, shaderSource);
        this.gl.compileShader(shader);
        // Make sure there were no errors during this process
        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
            // Not compiled - error
            const error = this.gl.getShaderInfoLog(shader);
            console.warn("Failed to compile shader: " + error);
            // Clean up
            this.gl.deleteShader(shader);
            return null;
        }
        // Sucess, so return the shader
        return shader;
    }
    /* ########## GENERAL LOADING FUNCTIONS ########## */
    loadTextFile(textFilePath, callback) {
        let xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
        xobj.open('GET', textFilePath, true);
        xobj.onreadystatechange = function () {
            if ((xobj.readyState == 4) && (xobj.status == 200)) {
                callback(xobj.responseText);
            }
        };
        xobj.send(null);
    }
    /* ########## LOADING BAR INFO ########## */
    getLoadPercent() {
        return (this.loadonly_tilemapsLoaded / this.loadonly_tilemapsToLoad
            + this.loadonly_spritesheetsLoaded / this.loadonly_spritesheetsToLoad
            + this.loadonly_imagesLoaded / this.loadonly_imagesToLoad
            + this.loadonly_audioLoaded / this.loadonly_audioToLoad)
            / this.loadonly_typesToLoad;
    }
    update(deltaT) {
        if (this.loading) {
            if (this.onLoadProgress) {
                this.onLoadProgress(this.getLoadPercent());
            }
        }
        else if (this.justLoaded) {
            this.justLoaded = false;
            if (this.onLoadComplete) {
                this.onLoadComplete();
            }
        }
    }
}
exports.default = ResourceManager;
/**
 * A class representing a reference to a resource.
 * This is used for the exemption list to assure assets and their dependencies don't get
 * destroyed if they are still needed.
 */
class ResourceReference {
    constructor(key, resourceType) {
        this.key = key;
        this.resourceType = resourceType;
        this.dependencies = new Array();
    }
    addDependency(resource) {
        this.dependencies.push(resource);
    }
}
var ResourceType;
(function (ResourceType) {
    ResourceType["IMAGE"] = "IMAGE";
    ResourceType["TILEMAP"] = "TILEMAP";
    ResourceType["SPRITESHEET"] = "SPRITESHEET";
    ResourceType["AUDIO"] = "AUDIO";
    ResourceType["JSON"] = "JSON";
    ResourceType["SHADER"] = "SHADER";
})(ResourceType || (ResourceType = {}));
/**
 * A pair representing a key and the path of the resource to load
 */
class KeyPathPair {
    constructor() {
        this.isDependency = false;
    }
}
class KeyPath_Shader {
}

},{"../DataTypes/Collections/Map":8,"../DataTypes/Collections/Queue":9,"../DataTypes/Rendering/WebGLProgramType":19,"../Sound/AudioManager":103,"../Utils/StringUtils":113}],91:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Sprite_1 = __importDefault(require("../../Nodes/Sprites/Sprite"));
const GraphicTypes_1 = require("../../Nodes/Graphics/GraphicTypes");
const UIElementTypes_1 = require("../../Nodes/UIElements/UIElementTypes");
const Point_1 = __importDefault(require("../../Nodes/Graphics/Point"));
const Vec2_1 = __importDefault(require("../../DataTypes/Vec2"));
const Button_1 = __importDefault(require("../../Nodes/UIElements/Button"));
const Label_1 = __importDefault(require("../../Nodes/UIElements/Label"));
const Slider_1 = __importDefault(require("../../Nodes/UIElements/Slider"));
const TextInput_1 = __importDefault(require("../../Nodes/UIElements/TextInput"));
const Rect_1 = __importDefault(require("../../Nodes/Graphics/Rect"));
const ResourceManager_1 = __importDefault(require("../../ResourceManager/ResourceManager"));
const Line_1 = __importDefault(require("../../Nodes/Graphics/Line"));
const Particle_1 = __importDefault(require("../../Nodes/Graphics/Particle"));
// @ignorePage
/**
 * A factory that abstracts adding @reference[CanvasNode]s to the @reference[Scene].
 * Access methods in this factory through Scene.add.[methodName]().
 */
class CanvasNodeFactory {
    constructor() {
        /**
         * Adds an instance of a UIElement to the current scene - i.e. any class that extends UIElement
         * @param type The type of UIElement to add
         * @param layerName The layer to add the UIElement to
         * @param options Any additional arguments to feed to the constructor
         * @returns A new UIElement
         */
        this.addUIElement = (type, layerName, options) => {
            // Get the layer
            let layer = this.scene.getLayer(layerName);
            let instance;
            switch (type) {
                case UIElementTypes_1.UIElementType.BUTTON:
                    instance = this.buildButton(options);
                    break;
                case UIElementTypes_1.UIElementType.LABEL:
                    instance = this.buildLabel(options);
                    break;
                case UIElementTypes_1.UIElementType.SLIDER:
                    instance = this.buildSlider(options);
                    break;
                case UIElementTypes_1.UIElementType.TEXT_INPUT:
                    instance = this.buildTextInput(options);
                    break;
                default:
                    throw `UIElementType '${type}' does not exist, or is registered incorrectly.`;
            }
            instance.setScene(this.scene);
            instance.id = this.scene.generateId();
            this.scene.getSceneGraph().addNode(instance);
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
        /**
         * Adds a sprite to the current scene
         * @param key The key of the image the sprite will represent
         * @param layerName The layer on which to add the sprite
         * @returns A new Sprite
         */
        this.addSprite = (key, layerName) => {
            let layer = this.scene.getLayer(layerName);
            let instance = new Sprite_1.default(key);
            // Add instance to scene
            instance.setScene(this.scene);
            instance.id = this.scene.generateId();
            if (!(this.scene.isParallaxLayer(layerName) || this.scene.isUILayer(layerName))) {
                this.scene.getSceneGraph().addNode(instance);
            }
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
        /**
         * Adds an AnimatedSprite to the current scene
         * @param key The key of the image the sprite will represent
         * @param layerName The layer on which to add the sprite
         * @returns A new AnimatedSprite
         */
        this.addAnimatedSprite = (constr, key, layerName) => {
            let layer = this.scene.getLayer(layerName);
            let spritesheet = this.resourceManager.getSpritesheet(key);
            let instance = new constr(spritesheet);
            // Add instance fo scene
            instance.setScene(this.scene);
            instance.id = this.scene.generateId();
            if (!(this.scene.isParallaxLayer(layerName) || this.scene.isUILayer(layerName))) {
                this.scene.getSceneGraph().addNode(instance);
            }
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
        /**
         * Adds a new graphic element to the current Scene
         * @param type The type of graphic to add
         * @param layerName The layer on which to add the graphic
         * @param options Any additional arguments to send to the graphic constructor
         * @returns A new Graphic
         */
        this.addGraphic = (type, layerName, options) => {
            // Get the layer
            let layer = this.scene.getLayer(layerName);
            let instance;
            switch (type) {
                case GraphicTypes_1.GraphicType.POINT:
                    instance = this.buildPoint(options);
                    break;
                case GraphicTypes_1.GraphicType.LINE:
                    instance = this.buildLine(options);
                    break;
                case GraphicTypes_1.GraphicType.RECT:
                    instance = this.buildRect(options);
                    break;
                case GraphicTypes_1.GraphicType.PARTICLE:
                    instance = this.buildParticle(options);
                    break;
                default:
                    throw `GraphicType '${type}' does not exist, or is registered incorrectly.`;
            }
            // Add instance to scene
            instance.setScene(this.scene);
            instance.id = this.scene.generateId();
            if (!(this.scene.isParallaxLayer(layerName) || this.scene.isUILayer(layerName))) {
                this.scene.getSceneGraph().addNode(instance);
            }
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
    }
    init(scene) {
        this.scene = scene;
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    /* ---------- BUILDERS ---------- */
    buildButton(options) {
        this.checkIfPropExists("Button", options, "position", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Button", options, "text", "string");
        return new Button_1.default(options.position, options.text);
    }
    buildLabel(options) {
        this.checkIfPropExists("Label", options, "position", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Label", options, "text", "string");
        return new Label_1.default(options.position, options.text);
    }
    buildSlider(options) {
        this.checkIfPropExists("Slider", options, "position", Vec2_1.default, "Vec2");
        let initValue = 0;
        if (options.value !== undefined) {
            initValue = options.value;
        }
        return new Slider_1.default(options.position, initValue);
    }
    buildTextInput(options) {
        this.checkIfPropExists("TextInput", options, "position", Vec2_1.default, "Vec2");
        return new TextInput_1.default(options.position);
    }
    buildPoint(options) {
        this.checkIfPropExists("Point", options, "position", Vec2_1.default, "Vec2");
        return new Point_1.default(options.position);
    }
    buildParticle(options) {
        this.checkIfPropExists("Particle", options, "position", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Particle", options, "size", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Particle", options, "mass", "number", "number");
        //Changed for testing
        return new Particle_1.default(options.position, options.size, options.mass);
    }
    buildLine(options) {
        this.checkIfPropExists("Line", options, "start", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Line", options, "end", Vec2_1.default, "Vec2");
        return new Line_1.default(options.start, options.end);
    }
    buildRect(options) {
        this.checkIfPropExists("Rect", options, "position", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Rect", options, "size", Vec2_1.default, "Vec2");
        return new Rect_1.default(options.position, options.size);
    }
    /* ---------- ERROR HANDLING ---------- */
    checkIfPropExists(objectName, options, prop, type, typeName) {
        if (!options || options[prop] === undefined) {
            // Check that the options object has the property
            throw `${objectName} object requires argument ${prop} of type ${typeName}, but none was provided.`;
        }
        else {
            // Check that the property has the correct type
            if ((typeof type) === "string") {
                if (!(typeof options[prop] === type)) {
                    throw `${objectName} object requires argument ${prop} of type ${type}, but provided ${prop} was not of type ${type}.`;
                }
            }
            else if (type instanceof Function) {
                // If type is a constructor, check against that
                if (!(options[prop] instanceof type)) {
                    throw `${objectName} object requires argument ${prop} of type ${typeName}, but provided ${prop} was not of type ${typeName}.`;
                }
            }
            else {
                throw `${objectName} object requires argument ${prop} of type ${typeName}, but provided ${prop} was not of type ${typeName}.`;
            }
        }
    }
}
exports.default = CanvasNodeFactory;

},{"../../DataTypes/Vec2":26,"../../Nodes/Graphics/GraphicTypes":44,"../../Nodes/Graphics/Line":45,"../../Nodes/Graphics/Particle":46,"../../Nodes/Graphics/Point":47,"../../Nodes/Graphics/Rect":48,"../../Nodes/Sprites/Sprite":50,"../../Nodes/UIElements/Button":56,"../../Nodes/UIElements/Label":57,"../../Nodes/UIElements/Slider":58,"../../Nodes/UIElements/TextInput":59,"../../Nodes/UIElements/UIElementTypes":60,"../../ResourceManager/ResourceManager":90}],92:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasNodeFactory_1 = __importDefault(require("./CanvasNodeFactory"));
const TilemapFactory_1 = __importDefault(require("./TilemapFactory"));
/**
 * The manager of all factories used for adding @reference[GameNode]s to the @reference[Scene].
 */
class FactoryManager {
    constructor(scene, tilemaps) {
        // Constructors are called here to allow assignment of their functions to functions in this class
        this.canvasNodeFactory = new CanvasNodeFactory_1.default();
        this.tilemapFactory = new TilemapFactory_1.default();
        this.canvasNodeFactory.init(scene);
        this.tilemapFactory.init(scene, tilemaps);
    }
    // Expose all of the factories through the factory manager
    /**
     * Adds an instance of a UIElement to the current scene - i.e. any class that extends UIElement
     * @param type The type of UIElement to add
     * @param layerName The layer to add the UIElement to
     * @param options Any additional arguments to feed to the constructor
     * @returns A new UIElement
     */
    uiElement(type, layerName, options) {
        return this.canvasNodeFactory.addUIElement(type, layerName, options);
    }
    /**
     * Adds a sprite to the current scene
     * @param key The key of the image the sprite will represent
     * @param layerName The layer on which to add the sprite
     * @returns A new Sprite
     */
    sprite(key, layerName) {
        return this.canvasNodeFactory.addSprite(key, layerName);
    }
    /**
     * Adds an AnimatedSprite to the current scene
     * @param key The key of the image the sprite will represent
     * @param layerName The layer on which to add the sprite
     * @returns A new AnimatedSprite
     */
    animatedSprite(constr, key, layerName) {
        return this.canvasNodeFactory.addAnimatedSprite(constr, key, layerName);
    }
    /**
     * Adds a new graphic element to the current Scene
     * @param type The type of graphic to add
     * @param layerName The layer on which to add the graphic
     * @param options Any additional arguments to send to the graphic constructor
     * @returns A new Graphic
     */
    graphic(type, layerName, options) {
        return this.canvasNodeFactory.addGraphic(type, layerName, options);
    }
    /**
     * Adds a tilemap to the scene
     * @param key The key of the loaded tilemap to load
     * @param constr The constructor of the desired tilemap
     * @param args Additional arguments to send to the tilemap constructor
     * @returns An array of Layers, each of which contains a layer of the tilemap as its own Tilemap instance.
     */
    tilemap(key, scale) {
        return this.tilemapFactory.add(key, scale);
    }
}
exports.default = FactoryManager;

},{"./CanvasNodeFactory":91,"./TilemapFactory":93}],93:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TilemapOrientation = void 0;
const ResourceManager_1 = __importDefault(require("../../ResourceManager/ResourceManager"));
const OrthogonalTilemap_1 = __importDefault(require("../../Nodes/Tilemaps/OrthogonalTilemap"));
const Tileset_1 = __importDefault(require("../../DataTypes/Tilesets/Tileset"));
const Vec2_1 = __importDefault(require("../../DataTypes/Vec2"));
const PositionGraph_1 = __importDefault(require("../../DataTypes/Graphs/PositionGraph"));
const Navmesh_1 = __importDefault(require("../../Pathfinding/Navmesh"));
const IsometricTilemap_1 = __importDefault(require("../../Nodes/Tilemaps/IsometricTilemap"));
const StaggeredIsometricTilemap_1 = __importDefault(require("../../Nodes/Tilemaps/StaggeredIsometricTilemap"));
// @ignorePage
var TilemapOrientation;
(function (TilemapOrientation) {
    TilemapOrientation["ORTHOGONAL"] = "orthogonal";
    TilemapOrientation["ISOMETRIC"] = "isometric";
    TilemapOrientation["STAGGERED_ISOMETRIC"] = "staggered";
})(TilemapOrientation = exports.TilemapOrientation || (exports.TilemapOrientation = {}));
/**
 * A factory that abstracts adding @reference[Tilemap]s to the @reference[Scene].
 * Access methods in this factory through Scene.add.[methodName]().
 */
class TilemapFactory {
    constructor() {
        // TODO - This is specifically catered to Tiled tilemaps right now. In the future,
        // it would be good to have a "parseTilemap" function that would convert the tilemap
        // data into a standard format. This could allow for support from other programs
        // or the development of an internal level builder tool
        /**
         * Adds a tilemap to the scene
         * @param key The key of the loaded tilemap to load
         * @param constr The constructor of the desired tilemap
         * @param args Additional arguments to send to the tilemap constructor
         * @returns An array of Layers, each of which contains a layer of the tilemap as its own Tilemap instance.
         */
        this.add = (key, scale = new Vec2_1.default(1, 1)) => {
            // Get Tilemap Data
            let tilemapData = this.resourceManager.getTilemap(key);
            // Set the constructor for this tilemap to either be orthographic or isometric
            let constr;
            switch (tilemapData.orientation) {
                case TilemapOrientation.ORTHOGONAL: {
                    constr = OrthogonalTilemap_1.default;
                    break;
                }
                case TilemapOrientation.ISOMETRIC: {
                    constr = IsometricTilemap_1.default;
                    break;
                }
                case TilemapOrientation.STAGGERED_ISOMETRIC: {
                    constr = StaggeredIsometricTilemap_1.default;
                    break;
                }
                default: {
                    throw new Error(`Unknown Tilemap Orientation "${tilemapData.orientation}"`);
                }
            }
            // Initialize the return value array
            let sceneLayers = new Array();
            // Create all of the tilesets for this tilemap
            let tilesets = new Array();
            let collectionTiles = new Array();
            for (let tileset of tilemapData.tilesets) {
                if (tileset.image) {
                    // If this is a standard tileset and not a collection, create a tileset for it.
                    // TODO - We are ignoring collection tilesets for now. This is likely not a great idea in practice,
                    // as theoretically someone could want to use one for a standard tilemap. We are assuming for now
                    // that we only want to use them for object layers
                    tilesets.push(new Tileset_1.default(tileset));
                }
                else {
                    tileset.tiles.forEach(tile => tile.id += tileset.firstgid);
                    collectionTiles.push(...tileset.tiles);
                }
            }
            // Loop over the layers of the tilemap and create tiledlayers or object layers
            for (let layer of tilemapData.layers) {
                let sceneLayer;
                let isParallaxLayer = false;
                let depth = 0;
                if (layer.properties) {
                    for (let prop of layer.properties) {
                        if (prop.name === "Parallax") {
                            isParallaxLayer = prop.value;
                        }
                        else if (prop.name === "Depth") {
                            depth = prop.value;
                        }
                    }
                }
                if (isParallaxLayer) {
                    sceneLayer = this.scene.addParallaxLayer(layer.name, new Vec2_1.default(1, 1), depth);
                }
                else {
                    sceneLayer = this.scene.addLayer(layer.name, depth);
                }
                if (layer.type === "tilelayer") {
                    // Create a new tilemap object for the layer
                    let tilemap = new constr(tilemapData, layer, tilesets, scale);
                    tilemap.id = this.scene.generateId();
                    tilemap.setScene(this.scene);
                    // Add tilemap to scene
                    this.tilemaps.push(tilemap);
                    sceneLayer.addNode(tilemap);
                    // Register tilemap with physics if it's collidable
                    if (tilemap.isCollidable) {
                        tilemap.addPhysics();
                        if (layer.properties) {
                            for (let item of layer.properties) {
                                if (item.name === "Group") {
                                    tilemap.setGroup(item.value);
                                }
                            }
                        }
                    }
                }
                else {
                    let isNavmeshPoints = false;
                    let navmeshName;
                    let edges;
                    if (layer.properties) {
                        for (let prop of layer.properties) {
                            if (prop.name === "NavmeshPoints") {
                                isNavmeshPoints = true;
                            }
                            else if (prop.name === "name") {
                                navmeshName = prop.value;
                            }
                            else if (prop.name === "edges") {
                                edges = prop.value;
                            }
                        }
                    }
                    if (isNavmeshPoints) {
                        let g = new PositionGraph_1.default();
                        for (let obj of layer.objects) {
                            g.addPositionedNode(new Vec2_1.default(obj.x, obj.y));
                        }
                        for (let edge of edges) {
                            g.addEdge(edge.from, edge.to);
                        }
                        this.scene.getNavigationManager().addNavigableEntity(navmeshName, new Navmesh_1.default(g));
                        continue;
                    }
                    // Layer is an object layer, so add each object as a sprite to a new layer
                    for (let obj of layer.objects) {
                        // Check if obj is collidable
                        let hasPhysics = false;
                        let isCollidable = false;
                        let isTrigger = false;
                        let onEnter = null;
                        let onExit = null;
                        let triggerGroup = null;
                        let group = "";
                        if (obj.properties) {
                            for (let prop of obj.properties) {
                                if (prop.name === "HasPhysics") {
                                    hasPhysics = prop.value;
                                }
                                else if (prop.name === "Collidable") {
                                    isCollidable = prop.value;
                                }
                                else if (prop.name === "Group") {
                                    group = prop.value;
                                }
                                else if (prop.name === "IsTrigger") {
                                    isTrigger = prop.value;
                                }
                                else if (prop.name === "TriggerGroup") {
                                    triggerGroup = prop.value;
                                }
                                else if (prop.name === "TriggerOnEnter") {
                                    onEnter = prop.value;
                                }
                                else if (prop.name === "TriggerOnExit") {
                                    onExit = prop.value;
                                }
                            }
                        }
                        let sprite;
                        // Check if obj is a tile from a tileset
                        for (let tileset of tilesets) {
                            if (tileset.hasTile(obj.gid)) {
                                // The object is a tile from this set
                                let imageKey = tileset.getImageKey();
                                let offset = tileset.getImageOffsetForTile(obj.gid);
                                sprite = this.scene.add.sprite(imageKey, layer.name);
                                let size = tileset.getTileSize().clone();
                                sprite.position.set((obj.x + size.x / 2) * scale.x, (obj.y - size.y / 2) * scale.y);
                                sprite.setImageOffset(offset);
                                sprite.size.copy(size);
                                sprite.scale.set(scale.x, scale.y);
                            }
                        }
                        // Not in a tileset, must correspond to a collection
                        if (!sprite) {
                            for (let tile of collectionTiles) {
                                if (obj.gid === tile.id) {
                                    let imageKey = tile.image;
                                    sprite = this.scene.add.sprite(imageKey, layer.name);
                                    sprite.position.set((obj.x + tile.imagewidth / 2) * scale.x, (obj.y - tile.imageheight / 2) * scale.y);
                                    sprite.scale.set(scale.x, scale.y);
                                }
                            }
                        }
                        // Now we have sprite. Associate it with our physics object if there is one
                        if (hasPhysics) {
                            // Make the sprite a static physics object
                            sprite.addPhysics(sprite.boundary.clone(), Vec2_1.default.ZERO, isCollidable, true);
                            sprite.setGroup(group);
                            if (isTrigger && triggerGroup !== null) {
                                sprite.setTrigger(triggerGroup, onEnter, onExit);
                            }
                        }
                    }
                }
                // Update the return value
                sceneLayers.push(sceneLayer);
            }
            return sceneLayers;
        };
    }
    init(scene, tilemaps) {
        this.scene = scene;
        this.tilemaps = tilemaps;
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
}
exports.default = TilemapFactory;

},{"../../DataTypes/Graphs/PositionGraph":14,"../../DataTypes/Tilesets/Tileset":25,"../../DataTypes/Vec2":26,"../../Nodes/Tilemaps/IsometricTilemap":52,"../../Nodes/Tilemaps/OrthogonalTilemap":53,"../../Nodes/Tilemaps/StaggeredIsometricTilemap":54,"../../Pathfinding/Navmesh":63,"../../ResourceManager/ResourceManager":90}],94:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = __importDefault(require("../Utils/MathUtils"));
/**
 * A layer in the scene. Layers are used for sorting @reference[GameNode]s by depth.
 */
class Layer {
    /**
     * Creates a new layer. To do this in a game, use the addLayer() method in @refrence[Scene]
     * @param scene The scene to add the layer to
     * @param name The name of the layer
     */
    constructor(scene, name) {
        this.scene = scene;
        this.name = name;
        this.paused = false;
        this.hidden = false;
        this.alpha = 1;
        this.items = new Array();
        this.ySort = false;
        this.depth = 0;
    }
    /**
     * Retreives the name of the layer
     * @returns The name of the layer
     */
    getName() {
        return this.name;
    }
    /**
     * Pauses/Unpauses the layer. Affects all elements in this layer
     * @param pauseValue True if the layer should be paused, false if not
     */
    setPaused(pauseValue) {
        this.paused = pauseValue;
    }
    /**
     * Returns whether or not the layer is paused
     */
    isPaused() {
        return this.paused;
    }
    /**
     * Sets the opacity of the layer
     * @param alpha The new opacity value in the range [0, 1]
     */
    setAlpha(alpha) {
        this.alpha = MathUtils_1.default.clamp(alpha, 0, 1);
    }
    /**
     * Gets the opacity of the layer
     * @returns The opacity
     */
    getAlpha() {
        return this.alpha;
    }
    /**
     * Sets the layer's hidden value. If hidden, a layer will not be rendered, but will still update
     * @param hidden The hidden value of the layer
     */
    setHidden(hidden) {
        this.hidden = hidden;
    }
    /**
     * Returns the hideen value of the lyaer
     * @returns True if the scene is hidden, false otherwise
     */
    isHidden() {
        return this.hidden;
    }
    /** Pauses this scene and hides it */
    disable() {
        this.paused = true;
        this.hidden = true;
    }
    /** Unpauses this layer and makes it visible */
    enable() {
        this.paused = false;
        this.hidden = false;
    }
    /**
     * Sets whether or not the scene will ySort automatically.
     * ySorting means that CanvasNodes on this layer will have their depth sorted depending on their y-value.
     * This means that if an object is "higher" in the scene, it will sort behind objects that are "lower".
     * This is useful for 3/4 view games, or similar situations, where you sometimes want to be in front of objects,
     * and other times want to be behind the same objects.
     * @param ySort True if ySorting should be active, false if not
     */
    setYSort(ySort) {
        this.ySort = ySort;
    }
    /**
     * Gets the ySort status of the scene
     * @returns True if ySorting is occurring, false otherwise
     */
    getYSort() {
        return this.ySort;
    }
    /**
     * Sets the depth of the layer compared to other layers. A larger number means the layer will be closer to the screen.
     * @param depth The depth of the layer.
     */
    setDepth(depth) {
        this.depth = depth;
    }
    /**
     * Retrieves the depth of the layer.
     * @returns The depth
     */
    getDepth() {
        return this.depth;
    }
    /**
     * Adds a node to this layer
     * @param node The node to add to this layer.
     */
    addNode(node) {
        this.items.push(node);
        node.setLayer(this);
    }
    /**
     * Removes a node from this layer
     * @param node The node to remove
     * @returns true if the node was removed, false otherwise
     */
    removeNode(node) {
        // Find and remove the node
        let index = this.items.indexOf(node);
        if (index !== -1) {
            this.items.splice(index, 1);
            node.setLayer(undefined);
        }
    }
    /**
     * Retreives all GameNodes from this layer
     * @returns an Array that contains all of the GameNodes in this layer.
     */
    getItems() {
        return this.items;
    }
}
exports.default = Layer;

},{"../Utils/MathUtils":109}],95:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Layer_1 = __importDefault(require("../Layer"));
/**
 * An extension of a Layer that has a parallax value.
 */
class ParallaxLayer extends Layer_1.default {
    /**
     * Creates a new ParallaxLayer.
     * Use addParallaxLayer() in @reference[Scene] to add a layer of this type to your game.
     * @param scene The Scene to add this ParallaxLayer to
     * @param name The name of the ParallaxLayer
     * @param parallax The parallax level
     */
    constructor(scene, name, parallax) {
        super(scene, name);
        this.parallax = parallax;
    }
}
exports.default = ParallaxLayer;

},{"../Layer":94}],96:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../../DataTypes/Vec2"));
const ParallaxLayer_1 = __importDefault(require("./ParallaxLayer"));
/**
 * A Layer strictly to be used for managing UIElements.
 * This is intended to be a Layer that always stays in the same place,
 * and thus renders things like a HUD or an inventory without taking into consideration the \reference[Viewport] scroll.
 */
class UILayer extends ParallaxLayer_1.default {
    /**
     * Creates a new UILayer.
     * Use addUILayer() in @reference[Scene] to add a layer of this type to your game.
     * @param scene The Scene to add this UILayer to
     * @param name The name of the UILayer
     */
    constructor(scene, name) {
        super(scene, name, Vec2_1.default.ZERO);
    }
}
exports.default = UILayer;

},{"../../DataTypes/Vec2":26,"./ParallaxLayer":95}],97:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Layer_1 = __importDefault(require("./Layer"));
const Vec2_1 = __importDefault(require("../DataTypes/Vec2"));
const BasicPhysicsManager_1 = __importDefault(require("../Physics/BasicPhysicsManager"));
const SceneGraphArray_1 = __importDefault(require("../SceneGraph/SceneGraphArray"));
const FactoryManager_1 = __importDefault(require("./Factories/FactoryManager"));
const ResourceManager_1 = __importDefault(require("../ResourceManager/ResourceManager"));
const Receiver_1 = __importDefault(require("../Events/Receiver"));
const Emitter_1 = __importDefault(require("../Events/Emitter"));
const NavigationManager_1 = __importDefault(require("../Pathfinding/NavigationManager"));
const AIManager_1 = __importDefault(require("../AI/AIManager"));
const Map_1 = __importDefault(require("../DataTypes/Collections/Map"));
const ParallaxLayer_1 = __importDefault(require("./Layers/ParallaxLayer"));
const UILayer_1 = __importDefault(require("./Layers/UILayer"));
const CanvasNode_1 = __importDefault(require("../Nodes/CanvasNode"));
const SceneOptions_1 = __importDefault(require("./SceneOptions"));
const Debug_1 = __importDefault(require("../Debug/Debug"));
const TimerManager_1 = __importDefault(require("../Timing/TimerManager"));
const TweenManager_1 = __importDefault(require("../Rendering/Animations/TweenManager"));
const ParticleSystemManager_1 = __importDefault(require("../Rendering/Animations/ParticleSystemManager"));
/**
 * Scenes are the main container in the game engine.
 * Your main scene is the current level or menu of the game, and will contain all of the GameNodes needed.
 * Scenes provide an easy way to load assets, add assets to the game world, and unload assets,
 * and have lifecycle methods exposed for these functions.
 */
class Scene {
    /**
     * Creates a new Scene. To add a new Scene in your game, use changeToScene() in @reference[SceneManager]
     * @param viewport The viewport of the game
     * @param sceneManager The SceneManager that owns this Scene
     * @param renderingManager The RenderingManager that will handle this Scene's rendering
     * @param game The instance of the Game
     * @param options The options for Scene initialization
     */
    constructor(viewport, sceneManager, renderingManager, options) {
        this.sceneOptions = SceneOptions_1.default.parse(options === undefined ? {} : options);
        this.worldSize = new Vec2_1.default(500, 500);
        this.viewport = viewport;
        this.viewport.setBounds(0, 0, 2560, 1280);
        this.running = false;
        this.sceneManager = sceneManager;
        this.receiver = new Receiver_1.default();
        this.emitter = new Emitter_1.default();
        this.tilemaps = new Array();
        this.sceneGraph = new SceneGraphArray_1.default(this.viewport, this);
        this.layers = new Map_1.default();
        this.uiLayers = new Map_1.default();
        this.parallaxLayers = new Map_1.default();
        this.physicsManager = new BasicPhysicsManager_1.default(this.sceneOptions.physics);
        this.navManager = new NavigationManager_1.default();
        this.aiManager = new AIManager_1.default();
        this.renderingManager = renderingManager;
        this.add = new FactoryManager_1.default(this, this.tilemaps);
        this.load = ResourceManager_1.default.getInstance();
        this.resourceManager = this.load;
        // Get the timer manager and clear any existing timers
        TimerManager_1.default.getInstance().clearTimers();
    }
    /** A lifecycle method that gets called immediately after a new scene is created, before anything else. */
    initScene(init) { }
    /** A lifecycle method that gets called when a new scene is created. Load all files you wish to access in the scene here. */
    loadScene() { }
    /** A lifecycle method called strictly after loadScene(). Create any game objects you wish to use in the scene here. */
    startScene() { }
    /**
     * A lifecycle method called every frame of the game. This is where you can dynamically do things like add in new enemies
     * @param delta The time this frame represents
     */
    updateScene(deltaT) { }
    /** A lifecycle method that gets called on scene destruction. Specify which files you no longer need for garbage collection. */
    unloadScene() { }
    update(deltaT) {
        this.updateScene(deltaT);
        // Do time updates
        TimerManager_1.default.getInstance().update(deltaT);
        // Do all AI updates
        this.aiManager.update(deltaT);
        // Update all physics objects
        this.physicsManager.update(deltaT);
        // Update all canvas objects
        this.sceneGraph.update(deltaT);
        // Update all tilemaps
        this.tilemaps.forEach(tilemap => {
            if (!tilemap.getLayer().isPaused()) {
                tilemap.update(deltaT);
            }
        });
        // Update all tweens
        TweenManager_1.default.getInstance().update(deltaT);
        // Update all particle systems
        ParticleSystemManager_1.default.getInstance().update(deltaT);
        // Update viewport
        this.viewport.update(deltaT);
    }
    /**
     * Collects renderable sets and coordinates with the RenderingManager to draw the Scene
     */
    render() {
        // Get the visible set of nodes
        let visibleSet = this.sceneGraph.getVisibleSet();
        // Add parallax layer items to the visible set (we're rendering them all for now)
        this.parallaxLayers.forEach(key => {
            let pLayer = this.parallaxLayers.get(key);
            for (let node of pLayer.getItems()) {
                if (node instanceof CanvasNode_1.default) {
                    visibleSet.push(node);
                }
            }
        });
        // Send the visible set, tilemaps, and uiLayers to the renderer
        this.renderingManager.render(visibleSet, this.tilemaps, this.uiLayers);
        let nodes = this.sceneGraph.getAllNodes();
        this.tilemaps.forEach(tilemap => tilemap.visible ? nodes.push(tilemap) : 0);
        Debug_1.default.setNodes(nodes);
    }
    /**
     * Sets the scene as running or not
     * @param running True if the Scene should be running, false if not
     */
    setRunning(running) {
        this.running = running;
    }
    /**
     * Returns whether or not the Scene is running
     * @returns True if the scene is running, false otherwise
     */
    isRunning() {
        return this.running;
    }
    /**
     * Removes a node from this Scene
     * @param node The node to remove
     */
    remove(node) {
        // Remove from the scene graph
        if (node instanceof CanvasNode_1.default) {
            this.sceneGraph.removeNode(node);
        }
    }
    /** Destroys this scene and all nodes in it */
    destroy() {
        for (let node of this.sceneGraph.getAllNodes()) {
            node.destroy();
        }
        for (let tilemap of this.tilemaps) {
            tilemap.destroy();
        }
        this.receiver.destroy();
        delete this.sceneGraph;
        delete this.physicsManager;
        delete this.navManager;
        delete this.aiManager;
        delete this.receiver;
    }
    /**
     * Adds a new layer to the scene and returns it
     * @param name The name of the new layer
     * @param depth The depth of the layer
     * @returns The newly created Layer
     */
    addLayer(name, depth) {
        if (this.layers.has(name) || this.parallaxLayers.has(name) || this.uiLayers.has(name)) {
            throw `Layer with name ${name} already exists`;
        }
        let layer = new Layer_1.default(this, name);
        this.layers.add(name, layer);
        if (depth) {
            layer.setDepth(depth);
        }
        return layer;
    }
    /**
     * Adds a new parallax layer to this scene and returns it
     * @param name The name of the parallax layer
     * @param parallax The parallax level
     * @param depth The depth of the layer
     * @returns The newly created ParallaxLayer
     */
    addParallaxLayer(name, parallax, depth) {
        if (this.layers.has(name) || this.parallaxLayers.has(name) || this.uiLayers.has(name)) {
            throw `Layer with name ${name} already exists`;
        }
        let layer = new ParallaxLayer_1.default(this, name, parallax);
        this.parallaxLayers.add(name, layer);
        if (depth) {
            layer.setDepth(depth);
        }
        return layer;
    }
    /**
     * Adds a new UILayer to the scene
     * @param name The name of the new UIlayer
     * @returns The newly created UILayer
     */
    addUILayer(name) {
        if (this.layers.has(name) || this.parallaxLayers.has(name) || this.uiLayers.has(name)) {
            throw `Layer with name ${name} already exists`;
        }
        let layer = new UILayer_1.default(this, name);
        this.uiLayers.add(name, layer);
        return layer;
    }
    /**
     * Gets a layer from the scene by name if it exists.
     * This can be a Layer or any of its subclasses
     * @param name The name of the layer
     * @returns The Layer found with that name
     */
    getLayer(name) {
        if (this.layers.has(name)) {
            return this.layers.get(name);
        }
        else if (this.parallaxLayers.has(name)) {
            return this.parallaxLayers.get(name);
        }
        else if (this.uiLayers.has(name)) {
            return this.uiLayers.get(name);
        }
        else {
            throw `Requested layer ${name} does not exist.`;
        }
    }
    /**
     * Returns true if this layer is a ParallaxLayer
     * @param name The name of the layer
     * @returns True if this layer is a ParallaxLayer
     */
    isParallaxLayer(name) {
        return this.parallaxLayers.has(name);
    }
    /**
     * Returns true if this layer is a UILayer
     * @param name The name of the layer
     * @returns True if this layer is ParallaxLayer
     */
    isUILayer(name) {
        return this.uiLayers.has(name);
    }
    /**
     * Returns the translation of this node with respect to camera space (due to the viewport moving).
     * This value is affected by the parallax level of the @reference[Layer] the node is on.
     * @param node The node to check the viewport with respect to
     * @returns A Vec2 containing the translation of viewport with respect to this node.
     */
    getViewTranslation(node) {
        let layer = node.getLayer();
        if (layer instanceof ParallaxLayer_1.default || layer instanceof UILayer_1.default) {
            return this.viewport.getOrigin().mult(layer.parallax);
        }
        else {
            return this.viewport.getOrigin();
        }
    }
    /**
     * Returns the scale level of the view
     * @returns The zoom level of the viewport
    */
    getViewScale() {
        return this.viewport.getZoomLevel();
    }
    /**
     * Returns the Viewport associated with this scene
     * @returns The current Viewport
     */
    getViewport() {
        return this.viewport;
    }
    /**
     * Gets the world size of this Scene
     * @returns The world size in a Vec2
     */
    getWorldSize() {
        return this.worldSize;
    }
    /**
     * Gets the SceneGraph associated with this Scene
     * @returns The SceneGraph
     */
    getSceneGraph() {
        return this.sceneGraph;
    }
    /**
     * Gets the PhysicsManager associated with this Scene
     * @returns The PhysicsManager
     */
    getPhysicsManager() {
        return this.physicsManager;
    }
    /**
     * Gets the NavigationManager associated with this Scene
     * @returns The NavigationManager
     */
    getNavigationManager() {
        return this.navManager;
    }
    /**
     * Gets the AIManager associated with this Scene
     * @returns The AIManager
     */
    getAIManager() {
        return this.aiManager;
    }
    /**
     * Generates an ID for a GameNode
     * @returns The new ID
     */
    generateId() {
        return this.sceneManager.generateId();
    }
    /**
     * Retrieves a Tilemap in this Scene
     * @param name The name of the Tilemap
     * @returns The Tilemap, if one this name exists, otherwise null
     */
    getTilemap(name) {
        for (let tilemap of this.tilemaps) {
            if (tilemap.name === name) {
                return tilemap;
            }
        }
        return null;
    }
}
exports.default = Scene;

},{"../AI/AIManager":2,"../DataTypes/Collections/Map":8,"../DataTypes/Vec2":26,"../Debug/Debug":27,"../Events/Emitter":29,"../Events/Receiver":33,"../Nodes/CanvasNode":41,"../Pathfinding/NavigationManager":61,"../Physics/BasicPhysicsManager":67,"../Rendering/Animations/ParticleSystemManager":75,"../Rendering/Animations/TweenManager":77,"../ResourceManager/ResourceManager":90,"../SceneGraph/SceneGraphArray":101,"../Timing/TimerManager":105,"./Factories/FactoryManager":92,"./Layer":94,"./Layers/ParallaxLayer":95,"./Layers/UILayer":96,"./SceneOptions":99}],98:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = __importDefault(require("../ResourceManager/ResourceManager"));
const Receiver_1 = __importDefault(require("../Events/Receiver"));
const GameEventType_1 = require("../Events/GameEventType");
/**
 * The SceneManager acts as an interface to create Scenes, and handles the lifecycle methods of Scenes.
 * It gives Scenes access to information they need from the @reference[Game] class while keeping a layer of separation.
 */
class SceneManager {
    /**
     * Creates a new SceneManager
     * @param viewport The Viewport of the game
     * @param game The Game instance
     * @param renderingManager The RenderingManager of the game
     */
    constructor(viewport, renderingManager) {
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.viewport = viewport;
        this.renderingManager = renderingManager;
        this.idCounter = 0;
        this.pendingScene = null;
        this.receiver = new Receiver_1.default();
        this.receiver.subscribe(GameEventType_1.GameEventType.CHANGE_SCENE);
    }
    /**
     * Add a scene as the main scene.
     * Use this method if you've created a subclass of Scene, and you want to add it as the main Scene.
     * @param constr The constructor of the scene to add
     * @param init An object to pass to the init function of the new scene
     */
    changeToScene(constr, init, options) {
        console.log("Creating the new scene - change is pending until next update");
        this.pendingScene = new constr(this.viewport, this, this.renderingManager, options);
        this.pendingSceneInit = init;
    }
    doSceneChange() {
        console.log("Performing scene change");
        this.viewport.setCenter(this.viewport.getHalfSize().x, this.viewport.getHalfSize().y);
        if (this.currentScene) {
            console.log("Unloading old scene");
            this.currentScene.unloadScene();
            console.log("Destroying old scene");
            this.currentScene.destroy();
        }
        console.log("Unloading old resources...");
        this.resourceManager.unloadAllResources();
        // Make the pending scene the current one
        this.currentScene = this.pendingScene;
        // Make the pending scene null
        this.pendingScene = null;
        // Init the scene
        this.currentScene.initScene(this.pendingSceneInit);
        // Enqueue all scene asset loads
        this.currentScene.loadScene();
        // Load all assets
        console.log("Starting Scene Load");
        this.resourceManager.loadResourcesFromQueue(() => {
            console.log("Starting Scene");
            this.currentScene.startScene();
            this.currentScene.setRunning(true);
        });
        this.renderingManager.setScene(this.currentScene);
    }
    /**
     * Generates a unique ID
     * @returns A new ID
     */
    generateId() {
        return this.idCounter++;
    }
    /**
     * Renders the current Scene
     */
    render() {
        if (this.currentScene) {
            this.currentScene.render();
        }
    }
    /**
     * Updates the current Scene
     * @param deltaT The timestep of the Scene
     */
    update(deltaT) {
        while (this.receiver.hasNextEvent()) {
            let ev = this.receiver.getNextEvent();
            if (ev.type === GameEventType_1.GameEventType.CHANGE_SCENE)
                this.changeToScene(ev.data.get("scene"), ev.data.get("init"));
        }
        if (this.pendingScene !== null) {
            this.doSceneChange();
        }
        if (this.currentScene && this.currentScene.isRunning()) {
            this.currentScene.update(deltaT);
        }
    }
}
exports.default = SceneManager;

},{"../Events/GameEventType":32,"../Events/Receiver":33,"../ResourceManager/ResourceManager":90}],99:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// @ignorePage
/**
 * The options to give a @reference[Scene] for initialization
 */
class SceneOptions {
    static parse(options) {
        let sOpt = new SceneOptions();
        if (options.physics === undefined) {
            sOpt.physics = { groups: undefined, collisions: undefined };
        }
        else {
            sOpt.physics = options.physics;
        }
        return sOpt;
    }
}
exports.default = SceneOptions;

},{}],100:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../DataTypes/Vec2"));
/**
 * An abstract interface of a SceneGraph.
 * Exposes methods for use by other code, but leaves the implementation up to the subclasses.
 * The SceneGraph manages the positions of all GameNodes, and can easily prune a visible set for rendering.
 */
class SceneGraph {
    /**
     * Creates a new SceneGraph
     * @param viewport The viewport
     * @param scene The Scene this SceneGraph belongs to
     */
    constructor(viewport, scene) {
        this.viewport = viewport;
        this.scene = scene;
        this.nodeMap = new Array();
        this.idCounter = 0;
    }
    /**
     * Add a node to the SceneGraph
     * @param node The CanvasNode to add to the SceneGraph
     * @returns The SceneGraph ID of this newly added CanvasNode
     */
    addNode(node) {
        this.nodeMap[node.id] = node;
        this.addNodeSpecific(node, this.idCounter);
        this.idCounter += 1;
        return this.idCounter - 1;
    }
    ;
    /**
     * Removes a node from the SceneGraph
     * @param node The node to remove
     */
    removeNode(node) {
        // Find and remove node in O(n)
        this.nodeMap[node.id] = undefined;
        this.removeNodeSpecific(node, node.id);
    }
    ;
    /**
     * Get a specific node using its id
     * @param id The id of the CanvasNode to retrieve
     * @returns The node with this ID
     */
    getNode(id) {
        return this.nodeMap[id];
    }
    /**
     * Returns the nodes at specific coordinates
     * @param vecOrX The x-coordinate of the position, or the coordinates in a Vec2
     * @param y The y-coordinate of the position
     * @returns An array of nodes found at the position provided
     */
    getNodesAt(vecOrX, y = null) {
        if (vecOrX instanceof Vec2_1.default) {
            return this.getNodesAtCoords(vecOrX.x, vecOrX.y);
        }
        else {
            return this.getNodesAtCoords(vecOrX, y);
        }
    }
    /**
     * Returns all nodes in the SceneGraph
     * @returns An Array containing all nodes in the SceneGraph
     */
    getAllNodes() {
        let arr = new Array();
        for (let i = 0; i < this.nodeMap.length; i++) {
            if (this.nodeMap[i] !== undefined) {
                arr.push(this.nodeMap[i]);
            }
        }
        return arr;
    }
}
exports.default = SceneGraph;

},{"../DataTypes/Vec2":26}],101:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const SceneGraph_1 = __importDefault(require("./SceneGraph"));
const Stats_1 = __importDefault(require("../Debug/Stats"));
/**
 * An implementation of a SceneGraph that simply stored CanvasNodes in an array.
 */
class SceneGraphArray extends SceneGraph_1.default {
    /**
     * Creates a new SceneGraphArray
     * @param viewport The Viewport
     * @param scene The Scene this SceneGraph belongs to
     */
    constructor(viewport, scene) {
        super(viewport, scene);
        this.nodeList = new Array();
    }
    // @override
    addNodeSpecific(node, id) {
        this.nodeList.push(node);
    }
    // @override
    removeNodeSpecific(node, id) {
        let index = this.nodeList.indexOf(node);
        if (index > -1) {
            this.nodeList.splice(index, 1);
        }
    }
    // @override
    getNodesAtCoords(x, y) {
        let results = [];
        for (let node of this.nodeList) {
            if (node.contains(x, y)) {
                results.push(node);
            }
        }
        return results;
    }
    // @override
    getNodesInRegion(boundary) {
        let t0 = performance.now();
        let results = [];
        for (let node of this.nodeList) {
            if (boundary.overlaps(node.boundary)) {
                results.push(node);
            }
        }
        let t1 = performance.now();
        Stats_1.default.log("sgquery", (t1 - t0));
        return results;
    }
    update(deltaT) {
        let t0 = performance.now();
        for (let node of this.nodeList) {
            if (!node.getLayer().isPaused()) {
                node.update(deltaT);
            }
        }
        let t1 = performance.now();
        Stats_1.default.log("sgupdate", (t1 - t0));
    }
    render(ctx) { }
    // @override
    getVisibleSet() {
        let visibleSet = new Array();
        for (let node of this.nodeList) {
            if (!node.getLayer().isHidden() && node.visible && this.viewport.includes(node)) {
                visibleSet.push(node);
            }
        }
        return visibleSet;
    }
}
exports.default = SceneGraphArray;

},{"../Debug/Stats":28,"./SceneGraph":100}],102:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../DataTypes/Vec2"));
const MathUtils_1 = __importDefault(require("../Utils/MathUtils"));
const Queue_1 = __importDefault(require("../DataTypes/Collections/Queue"));
const AABB_1 = __importDefault(require("../DataTypes/Shapes/AABB"));
const Input_1 = __importDefault(require("../Input/Input"));
const ParallaxLayer_1 = __importDefault(require("../Scene/Layers/ParallaxLayer"));
const UILayer_1 = __importDefault(require("../Scene/Layers/UILayer"));
/**
 * The viewport of the game. Corresponds to the visible window displayed in the browser.
 * The viewport keeps track of its position in the game world, and can act as a camera to follow objects.
 */
class Viewport {
    constructor(canvasSize, zoomLevel) {
        /** The amount that is zoomed in or out. */
        this.ZOOM_FACTOR = 1.2;
        this.view = new AABB_1.default(Vec2_1.default.ZERO, Vec2_1.default.ZERO);
        this.boundary = new AABB_1.default(Vec2_1.default.ZERO, Vec2_1.default.ZERO);
        this.lastPositions = new Queue_1.default();
        this.smoothingFactor = 10;
        this.scrollZoomEnabled = false;
        this.canvasSize = Vec2_1.default.ZERO;
        this.focus = Vec2_1.default.ZERO;
        // Set the size of the canvas
        this.setCanvasSize(canvasSize);
        // Set the size of the viewport
        this.setSize(canvasSize);
        this.setZoomLevel(zoomLevel);
        // Set the center (and make the viewport stay there)
        this.setCenter(this.view.halfSize.clone());
        this.setFocus(this.view.halfSize.clone());
    }
    /** Enables the viewport to zoom in and out */
    enableZoom() {
        this.scrollZoomEnabled = true;
    }
    /**
     * Returns the position of the viewport
     * @returns The center of the viewport as a Vec2
     */
    getCenter() {
        return this.view.center;
    }
    /**
     * Returns a new Vec2 with the origin of the viewport
     * @returns The top left cornder of the Vieport as a Vec2
     */
    getOrigin() {
        return new Vec2_1.default(this.view.left, this.view.top);
    }
    /**
     * Returns the region visible to this viewport
     * @returns The AABB containing the region visible to the viewport
     */
    getView() {
        return this.view;
    }
    /**
     * Set the position of the viewport
     * @param vecOrX The new position or the x-coordinate of the new position
     * @param y The y-coordinate of the new position
     */
    setCenter(vecOrX, y = null) {
        let pos;
        if (vecOrX instanceof Vec2_1.default) {
            pos = vecOrX;
        }
        else {
            pos = new Vec2_1.default(vecOrX, y);
        }
        this.view.center = pos;
    }
    /**
     * Returns the size of the viewport as a Vec2
     * @returns The half-size of the viewport as a Vec2
     */
    getHalfSize() {
        return this.view.getHalfSize();
    }
    /**
     * Sets the size of the viewport
     * @param vecOrX The new width of the viewport or the new size as a Vec2
     * @param y The new height of the viewport
     */
    setSize(vecOrX, y = null) {
        if (vecOrX instanceof Vec2_1.default) {
            this.view.setHalfSize(vecOrX.scaled(1 / 2));
        }
        else {
            this.view.setHalfSize(new Vec2_1.default(vecOrX / 2, y / 2));
        }
    }
    /**
     * Sets the half-size of the viewport
     * @param vecOrX The new half-width of the viewport or the new half-size as a Vec2
     * @param y The new height of the viewport
     */
    setHalfSize(vecOrX, y = null) {
        if (vecOrX instanceof Vec2_1.default) {
            this.view.setHalfSize(vecOrX.clone());
        }
        else {
            this.view.setHalfSize(new Vec2_1.default(vecOrX, y));
        }
    }
    /**
     * Updates the viewport with the size of the current Canvas
     * @param vecOrX The width of the canvas, or the canvas size as a Vec2
     * @param y The height of the canvas
     */
    setCanvasSize(vecOrX, y = null) {
        if (vecOrX instanceof Vec2_1.default) {
            this.canvasSize = vecOrX.clone();
        }
        else {
            this.canvasSize = new Vec2_1.default(vecOrX, y);
        }
    }
    /**
     * Sets the zoom level of the viewport
     * @param zoom The zoom level
     */
    setZoomLevel(zoom) {
        this.view.halfSize.copy(this.canvasSize.scaled(1 / zoom / 2));
    }
    /**
     * Gets the zoom level of the viewport
     * @returns The zoom level
     */
    getZoomLevel() {
        return this.canvasSize.x / this.view.hw / 2;
    }
    /**
     * Sets the smoothing factor for the viewport movement.
     * @param smoothingFactor The smoothing factor for the viewport
     */
    setSmoothingFactor(smoothingFactor) {
        if (smoothingFactor < 1)
            smoothingFactor = 1;
        this.smoothingFactor = smoothingFactor;
    }
    /**
     * Tells the viewport to focus on a point. Overidden by "following".
     * @param focus The point the  viewport should focus on
     */
    setFocus(focus) {
        this.focus.copy(focus);
    }
    /**
     * Returns true if the CanvasNode is inside of the viewport
     * @param node The node to check
     * @returns True if the node is currently visible in the viewport, false if not
     */
    includes(node) {
        let parallax = node.getLayer() instanceof ParallaxLayer_1.default || node.getLayer() instanceof UILayer_1.default ? node.getLayer().parallax : new Vec2_1.default(1, 1);
        let center = this.view.center.clone();
        this.view.center.mult(parallax);
        let overlaps = this.view.overlaps(node.boundary);
        this.view.center = center;
        return overlaps;
    }
    // TODO: Put some error handling on this for trying to make the bounds too small for the viewport
    // TODO: This should probably be done automatically, or should consider the aspect ratio or something
    /**
     * Sets the bounds of the viewport
     * @param lowerX The left edge of the viewport
     * @param lowerY The top edge of the viewport
     * @param upperX The right edge of the viewport
     * @param upperY The bottom edge of the viewport
     */
    setBounds(lowerX, lowerY, upperX, upperY) {
        let hwidth = (upperX - lowerX) / 2;
        let hheight = (upperY - lowerY) / 2;
        let x = lowerX + hwidth;
        let y = lowerY + hheight;
        this.boundary.center.set(x, y);
        this.boundary.halfSize.set(hwidth, hheight);
    }
    /**
     * Make the viewport follow the specified GameNode
     * @param node The GameNode to follow
     */
    follow(node) {
        this.following = node;
    }
    updateView() {
        if (this.lastPositions.getSize() > this.smoothingFactor) {
            this.lastPositions.dequeue();
        }
        // Get the average of the last 10 positions
        let pos = Vec2_1.default.ZERO;
        this.lastPositions.forEach(position => pos.add(position));
        pos.scale(1 / this.lastPositions.getSize());
        // Set this position either to the object or to its bounds
        pos.x = MathUtils_1.default.clamp(pos.x, this.boundary.left + this.view.hw, this.boundary.right - this.view.hw);
        pos.y = MathUtils_1.default.clamp(pos.y, this.boundary.top + this.view.hh, this.boundary.bottom - this.view.hh);
        // Assure there are no lines in the tilemap
        pos.x = Math.floor(pos.x);
        pos.y = Math.floor(pos.y);
        this.view.center.copy(pos);
    }
    update(deltaT) {
        // If zoom is enabled
        if (this.scrollZoomEnabled) {
            if (Input_1.default.didJustScroll()) {
                let currentSize = this.view.getHalfSize().clone();
                if (Input_1.default.getScrollDirection() < 0) {
                    // Zoom in
                    currentSize.scale(1 / this.ZOOM_FACTOR);
                }
                else {
                    // Zoom out
                    currentSize.scale(this.ZOOM_FACTOR);
                }
                if (currentSize.x > this.boundary.hw) {
                    let factor = this.boundary.hw / currentSize.x;
                    currentSize.x = this.boundary.hw;
                    currentSize.y *= factor;
                }
                if (currentSize.y > this.boundary.hh) {
                    let factor = this.boundary.hh / currentSize.y;
                    currentSize.y = this.boundary.hh;
                    currentSize.x *= factor;
                }
                this.view.setHalfSize(currentSize);
            }
        }
        // If viewport is following an object
        if (this.following) {
            // Update our list of previous positions
            this.lastPositions.enqueue(this.following.position.clone());
        }
        else {
            this.lastPositions.enqueue(this.focus);
        }
        this.updateView();
    }
}
exports.default = Viewport;

},{"../DataTypes/Collections/Queue":9,"../DataTypes/Shapes/AABB":20,"../DataTypes/Vec2":26,"../Input/Input":34,"../Scene/Layers/ParallaxLayer":95,"../Scene/Layers/UILayer":96,"../Utils/MathUtils":109}],103:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MAX_AUDIO_CHANNELS = exports.AudioChannelType = void 0;
const Map_1 = __importDefault(require("../DataTypes/Collections/Map"));
const Receiver_1 = __importDefault(require("../Events/Receiver"));
const ResourceManager_1 = __importDefault(require("../ResourceManager/ResourceManager"));
const GameEventType_1 = require("../Events/GameEventType");
/**
 * Manages any sounds or music needed for the game.
 * Through the EventQueue, exposes interface to play sounds so GameNodes can activate sounds without
 * needing direct references to the audio system
 */
class AudioManager {
    constructor() {
        this.initAudio();
        this.receiver = new Receiver_1.default();
        this.receiver.subscribe([
            GameEventType_1.GameEventType.PLAY_SOUND,
            GameEventType_1.GameEventType.STOP_SOUND,
            GameEventType_1.GameEventType.PLAY_MUSIC,
            GameEventType_1.GameEventType.PLAY_SFX,
            GameEventType_1.GameEventType.MUTE_CHANNEL,
            GameEventType_1.GameEventType.UNMUTE_CHANNEL
        ]);
        this.currentSounds = new Map_1.default();
        this.gainNodes = new Array(exports.MAX_AUDIO_CHANNELS);
        this.initGainNodes();
    }
    /**
     * Get the instance of the AudioManager class or create a new one if none exists
     * @returns The AudioManager
     */
    static getInstance() {
        if (!this.instance) {
            this.instance = new AudioManager();
        }
        return this.instance;
    }
    /**
     * Initializes the webAudio context
     */
    initAudio() {
        try {
            window.AudioContext = window.AudioContext; // || window.webkitAudioContext; 
            this.audioCtx = new AudioContext();
            console.log('Web Audio API successfully loaded');
        }
        catch (e) {
            console.warn('Web Audio API is not supported in this browser');
        }
    }
    initGainNodes() {
        for (let i = 0; i < exports.MAX_AUDIO_CHANNELS; i++) {
            this.gainNodes[i] = this.audioCtx.createGain();
        }
    }
    /**
     * Returns the current audio context
     * @returns The AudioContext
     */
    getAudioContext() {
        return this.audioCtx;
    }
    /*
        According to the MDN, create a new sound for every call:

        An AudioBufferSourceNode can only be played once; after each call to start(), you have to create a new node
        if you want to play the same sound again. Fortunately, these nodes are very inexpensive to create, and the
        actual AudioBuffers can be reused for multiple plays of the sound. Indeed, you can use these nodes in a
        "fire and forget" manner: create the node, call start() to begin playing the sound, and don't even bother to
        hold a reference to it. It will automatically be garbage-collected at an appropriate time, which won't be
        until sometime after the sound has finished playing.
    */
    /**
     * Creates a new sound from the key of a loaded audio file
     * @param key The key of the loaded audio file to create a new sound for
     * @returns The newly created AudioBuffer
     */
    createSound(key, holdReference, channel, options) {
        // Get audio buffer
        let buffer = ResourceManager_1.default.getInstance().getAudio(key);
        // Create a sound source
        var source = this.audioCtx.createBufferSource();
        // Tell the source which sound to play
        source.buffer = buffer;
        // Add any additional nodes
        const nodes = [source];
        // Do any additional nodes here?
        // Of course, there aren't any supported yet...
        // Add the gain node for this channel
        nodes.push(this.gainNodes[channel]);
        // Connect any nodes along the path
        for (let i = 1; i < nodes.length; i++) {
            nodes[i - 1].connect(nodes[i]);
        }
        // Connect the source to the context's destination
        nodes[nodes.length - 1].connect(this.audioCtx.destination);
        return source;
    }
    /**
     * Play the sound specified by the key
     * @param key The key of the sound to play
     * @param loop A boolean for whether or not to loop the sound
     * @param holdReference A boolean for whether or not we want to hold on to a reference of the audio node. This is good for playing music on a loop that will eventually need to be stopped.
     */
    playSound(key, loop, holdReference, channel, options) {
        let sound = this.createSound(key, holdReference, channel, options);
        if (loop) {
            sound.loop = true;
        }
        // Add a reference of the new sound to a map. This will allow us to stop a looping or long sound at a later time
        if (holdReference) {
            this.currentSounds.add(key, sound);
        }
        sound.start();
    }
    /**
     * Stop the sound specified by the key
     */
    stopSound(key) {
        let sound = this.currentSounds.get(key);
        if (sound) {
            sound.stop();
            this.currentSounds.delete(key);
        }
    }
    muteChannel(channel) {
        this.gainNodes[channel].gain.setValueAtTime(0, this.audioCtx.currentTime);
    }
    unmuteChannel(channel) {
        this.gainNodes[channel].gain.setValueAtTime(1, this.audioCtx.currentTime);
    }
    /**
     * Sets the volume of a channel using the GainNode for that channel. For more
     * information on GainNodes, see https://developer.mozilla.org/en-US/docs/Web/API/GainNode
     * @param channel The audio channel to set the volume for
     * @param volume The volume of the channel. 0 is muted. Values below zero will be set to zero.
     */
    static setVolume(channel, volume) {
        if (volume < 0) {
            volume = 0;
        }
        const am = AudioManager.getInstance();
        am.gainNodes[channel].gain.setValueAtTime(volume, am.audioCtx.currentTime);
    }
    /**
     * Returns the GainNode for this channel.
     * Learn more about GainNodes here https://developer.mozilla.org/en-US/docs/Web/API/GainNode
     * DON'T USE THIS UNLESS YOU KNOW WHAT YOU'RE DOING
     * @param channel The channel
     * @returns The GainNode for the specified channel
     */
    getChannelGainNode(channel) {
        return this.gainNodes[channel];
    }
    update(deltaT) {
        // Play each audio clip requested
        // TODO - Add logic to merge sounds if there are multiple of the same key
        while (this.receiver.hasNextEvent()) {
            let event = this.receiver.getNextEvent();
            if (event.type === GameEventType_1.GameEventType.PLAY_SOUND || event.type === GameEventType_1.GameEventType.PLAY_MUSIC || event.type === GameEventType_1.GameEventType.PLAY_SFX) {
                let soundKey = event.data.get("key");
                let loop = event.data.get("loop");
                let holdReference = event.data.get("holdReference");
                let channel = AudioChannelType.DEFAULT;
                if (event.type === GameEventType_1.GameEventType.PLAY_MUSIC) {
                    channel = AudioChannelType.MUSIC;
                }
                else if (GameEventType_1.GameEventType.PLAY_SFX) {
                    channel = AudioChannelType.SFX;
                }
                else if (event.data.has("channel")) {
                    channel = event.data.get("channel");
                }
                this.playSound(soundKey, loop, holdReference, channel, event.data);
            }
            if (event.type === GameEventType_1.GameEventType.STOP_SOUND) {
                let soundKey = event.data.get("key");
                this.stopSound(soundKey);
            }
            if (event.type === GameEventType_1.GameEventType.MUTE_CHANNEL) {
                this.muteChannel(event.data.get("channel"));
            }
            if (event.type === GameEventType_1.GameEventType.UNMUTE_CHANNEL) {
                this.unmuteChannel(event.data.get("channel"));
            }
        }
    }
}
exports.default = AudioManager;
var AudioChannelType;
(function (AudioChannelType) {
    AudioChannelType[AudioChannelType["DEFAULT"] = 0] = "DEFAULT";
    AudioChannelType[AudioChannelType["SFX"] = 1] = "SFX";
    AudioChannelType[AudioChannelType["MUSIC"] = 2] = "MUSIC";
    AudioChannelType[AudioChannelType["CUSTOM_1"] = 3] = "CUSTOM_1";
    AudioChannelType[AudioChannelType["CUSTOM_2"] = 4] = "CUSTOM_2";
    AudioChannelType[AudioChannelType["CUSTOM_3"] = 5] = "CUSTOM_3";
    AudioChannelType[AudioChannelType["CUSTOM_4"] = 6] = "CUSTOM_4";
    AudioChannelType[AudioChannelType["CUSTOM_5"] = 7] = "CUSTOM_5";
    AudioChannelType[AudioChannelType["CUSTOM_6"] = 8] = "CUSTOM_6";
    AudioChannelType[AudioChannelType["CUSTOM_7"] = 9] = "CUSTOM_7";
    AudioChannelType[AudioChannelType["CUSTOM_8"] = 10] = "CUSTOM_8";
    AudioChannelType[AudioChannelType["CUSTOM_9"] = 11] = "CUSTOM_9";
})(AudioChannelType = exports.AudioChannelType || (exports.AudioChannelType = {}));
exports.MAX_AUDIO_CHANNELS = 12;

},{"../DataTypes/Collections/Map":8,"../Events/GameEventType":32,"../Events/Receiver":33,"../ResourceManager/ResourceManager":90}],104:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimerState = void 0;
const MathUtils_1 = __importDefault(require("../Utils/MathUtils"));
const TimerManager_1 = __importDefault(require("./TimerManager"));
/** */
class Timer {
    constructor(time, onEnd, loop = false) {
        // Register this timer
        TimerManager_1.default.getInstance().addTimer(this);
        this.totalTime = time;
        this.timeLeft = 0;
        this.onEnd = onEnd;
        this.loop = loop;
        this.state = TimerState.STOPPED;
        this.numRuns = 0;
    }
    isStopped() {
        return this.state === TimerState.STOPPED;
    }
    isPaused() {
        return this.state === TimerState.PAUSED;
    }
    /**
     * Returns whether or not this timer has been run before
     * @returns true if it has been run at least once (after the latest reset), and false otherwise
     */
    hasRun() {
        return this.numRuns > 0;
    }
    start(time) {
        if (time !== undefined) {
            this.totalTime = time;
        }
        this.state = TimerState.ACTIVE;
        this.timeLeft = this.totalTime;
    }
    /** Resets this timer. Sets the progress back to zero, and sets the number of runs back to zero */
    reset() {
        this.timeLeft = this.totalTime;
        this.numRuns = 0;
    }
    pause() {
        this.state = TimerState.PAUSED;
    }
    update(deltaT) {
        if (this.state === TimerState.ACTIVE) {
            this.timeLeft -= deltaT * 1000;
            if (this.timeLeft <= 0) {
                this.timeLeft = MathUtils_1.default.clampLow0(this.timeLeft);
                this.end();
            }
        }
    }
    end() {
        // Update the state
        this.state = TimerState.STOPPED;
        this.numRuns += 1;
        // Call the end function if there is one
        if (this.onEnd) {
            this.onEnd();
        }
        // Loop if we want to
        if (this.loop) {
            this.state = TimerState.ACTIVE;
            this.timeLeft = this.totalTime;
        }
    }
    toString() {
        return "Timer: " + this.state + " - Time Left: " + this.timeLeft + "ms of " + this.totalTime + "ms";
    }
}
exports.default = Timer;
var TimerState;
(function (TimerState) {
    TimerState["ACTIVE"] = "ACTIVE";
    TimerState["PAUSED"] = "PAUSED";
    TimerState["STOPPED"] = "STOPPED";
})(TimerState = exports.TimerState || (exports.TimerState = {}));

},{"../Utils/MathUtils":109,"./TimerManager":105}],105:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class TimerManager {
    constructor() {
        this.timers = new Array();
    }
    static getInstance() {
        if (!this.instance) {
            this.instance = new TimerManager();
        }
        return this.instance;
    }
    addTimer(timer) {
        this.timers.push(timer);
    }
    clearTimers() {
        this.timers = new Array();
    }
    update(deltaT) {
        this.timers.forEach(timer => timer.update(deltaT));
    }
}
exports.default = TimerManager;

},{}],106:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = __importDefault(require("./MathUtils"));
// TODO: This should be moved to the datatypes folder
/**
 * A Color util class that keeps track of colors like a vector, but can be converted into a string format
 */
class Color {
    /**
     * Creates a new color
     * @param r Red
     * @param g Green
     * @param b Blue
     * @param a Alpha
     */
    constructor(r = 0, g = 0, b = 0, a = 1) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }
    /**
     * Transparent color
     * @returns rgba(0, 0, 0, 0)
     */
    static get TRANSPARENT() {
        return new Color(0, 0, 0, 0);
    }
    /**
     * Red color
     * @returns rgb(255, 0, 0)
     */
    static get RED() {
        return new Color(255, 0, 0, 1);
    }
    /**
     * Green color
     * @returns rgb(0, 255, 0)
     */
    static get GREEN() {
        return new Color(0, 255, 0, 1);
    }
    /**
     * Blue color
     * @returns rgb(0, 0, 255)
     */
    static get BLUE() {
        return new Color(0, 0, 255, 1);
    }
    /**
     * Yellow color
     * @returns rgb(255, 255, 0)
     */
    static get YELLOW() {
        return new Color(255, 255, 0, 1);
    }
    /**
     * Magenta color
     * @returns rgb(255, 0, 255)
     */
    static get MAGENTA() {
        return new Color(255, 0, 255, 1);
    }
    /**
     * Cyan color
     * @returns rgb(0, 255, 255)
     */
    static get CYAN() {
        return new Color(0, 255, 255, 1);
    }
    /**
     * White color
     * @returns rgb(255, 255, 255)
     */
    static get WHITE() {
        return new Color(255, 255, 255, 1);
    }
    /**
     * Black color
     * @returns rgb(0, 0, 0)
     */
    static get BLACK() {
        return new Color(0, 0, 0, 1);
    }
    /**
     * Orange color
     * @returns rgb(255, 100, 0)
     */
    static get ORANGE() {
        return new Color(255, 100, 0, 1);
    }
    /**
     * Sets the color to the values provided
     * @param r Red
     * @param g Green
     * @param b Blue
     * @param a Alpha
     */
    set(r, g, b, a = 1) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }
    /**
     * Returns a new color slightly lighter than the current color
     * @returns A new lighter Color
     */
    lighten() {
        return new Color(MathUtils_1.default.clamp(this.r + 40, 0, 255), MathUtils_1.default.clamp(this.g + 40, 0, 255), MathUtils_1.default.clamp(this.b + 40, 0, 255), MathUtils_1.default.clamp(this.a + 10, 0, 255));
    }
    /**
     * Returns a new color slightly darker than the current color
     * @returns A new darker Color
     */
    darken() {
        return new Color(MathUtils_1.default.clamp(this.r - 40, 0, 255), MathUtils_1.default.clamp(this.g - 40, 0, 255), MathUtils_1.default.clamp(this.b - 40, 0, 255), MathUtils_1.default.clamp(this.a + 10, 0, 255));
    }
    /**
     * Returns this color as an array
     * @returns [r, g, b, a]
     */
    toArray() {
        return [this.r, this.g, this.b, this.a];
    }
    /**
     * Returns the color as a string of the form #RRGGBB
     * @returns #RRGGBB
     */
    toString() {
        return "#" + MathUtils_1.default.toHex(this.r, 2) + MathUtils_1.default.toHex(this.g, 2) + MathUtils_1.default.toHex(this.b, 2);
    }
    /**
     * Returns the color as a string of the form rgb(r, g, b)
     * @returns rgb(r, g, b)
     */
    toStringRGB() {
        return "rgb(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ")";
    }
    /**
     * Returns the color as a string of the form rgba(r, g, b, a)
     * @returns rgba(r, g, b, a)
     */
    toStringRGBA() {
        if (this.a === 0) {
            return this.toStringRGB();
        }
        return "rgba(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ", " + this.a.toString() + ")";
    }
    /**
     * Turns this color into a float32Array and changes color range to [0.0, 1.0]
     * @returns a Float32Array containing the color
     */
    toWebGL() {
        return new Float32Array([
            this.r / 255,
            this.g / 255,
            this.b / 255,
            this.a
        ]);
    }
    static fromStringHex(str) {
        let i = 0;
        if (str.charAt(0) == "#")
            i += 1;
        let r = MathUtils_1.default.fromHex(str.substring(i, i + 2));
        let g = MathUtils_1.default.fromHex(str.substring(i + 2, i + 4));
        let b = MathUtils_1.default.fromHex(str.substring(i + 4, i + 6));
        return new Color(r, g, b);
    }
}
exports.default = Color;

},{"./MathUtils":109}],107:[function(require,module,exports){
"use strict";
// @ignorePage
Object.defineProperty(exports, "__esModule", { value: true });
exports.EaseFunctionType = void 0;
class EaseFunctions {
    static easeInOutSine(x) {
        return -(Math.cos(Math.PI * x) - 1) / 2;
    }
    static easeOutInSine(x) {
        return x < 0.5 ? -Math.cos(Math.PI * (x + 0.5)) / 2 : -Math.cos(Math.PI * (x - 0.5)) / 2 + 1;
    }
    static easeOutSine(x) {
        return Math.sin((x * Math.PI) / 2);
    }
    static easeInSine(x) {
        return 1 - Math.cos((x * Math.PI) / 2);
    }
    static easeInOutQuint(x) {
        return x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2;
    }
    static easeInOutQuad(x) {
        return x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2;
    }
    static easeOutInQuad(x) {
        return x < 0.5 ? this.easeOutIn_OutPow(x, 2) : this.easeOutIn_InPow(x, 2);
    }
    static easeOutIn_OutPow(x, pow) {
        return 0.5 - Math.pow(-2 * x + 1, pow) / 2;
    }
    static easeOutIn_InPow(x, pow) {
        return 0.5 + Math.pow(2 * x - 1, pow) / 2;
    }
}
exports.default = EaseFunctions;
var EaseFunctionType;
(function (EaseFunctionType) {
    // SINE
    EaseFunctionType["IN_OUT_SINE"] = "easeInOutSine";
    EaseFunctionType["OUT_IN_SINE"] = "easeOutInSine";
    EaseFunctionType["IN_SINE"] = "easeInSine";
    EaseFunctionType["OUT_SINE"] = "easeOutSine";
    // QUAD
    EaseFunctionType["IN_OUT_QUAD"] = "easeInOutQuad";
    EaseFunctionType["OUT_IN_QUAD"] = "easeOutInQuad";
    // QUINT
    EaseFunctionType["IN_OUT_QUINT"] = "easeInOutQuint";
})(EaseFunctionType = exports.EaseFunctionType || (exports.EaseFunctionType = {}));

},{}],108:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** A class to provides some utility functions for graphs */
class GraphUtils {
    /**
     * An implementation of Djikstra's shortest path algorithm based on the one described in The Algorithm Design Manual.
     * @param g The graph
     * @param start The number to start the shortest path from
     * @returns An array containing the parent of each node of the Graph in the shortest path.
     */
    static djikstra(g, start) {
        let i; // Counter
        let p; // Pointer to edgenode
        let inTree = new Array(g.numVertices);
        let distance = new Array(g.numVertices);
        let parent = new Array(g.numVertices);
        let v; // Current vertex to process
        let w; // Candidate for next vertex
        let weight; // Edge weight
        let dist; // Best current distance from start
        for (i = 0; i < g.numVertices; i++) {
            inTree[i] = false;
            distance[i] = Infinity;
            parent[i] = -1;
        }
        distance[start] = 0;
        v = start;
        while (!inTree[v]) {
            inTree[v] = true;
            p = g.edges[v];
            while (p !== null) {
                w = p.y;
                weight = p.weight;
                if (distance[w] > distance[v] + weight) {
                    distance[w] = distance[v] + weight;
                    parent[w] = v;
                }
                p = p.next;
            }
            v = 0;
            dist = Infinity;
            for (i = 0; i <= g.numVertices; i++) {
                if (!inTree[i] && dist > distance[i]) {
                    dist = distance;
                    v = i;
                }
            }
        }
        return parent;
    }
}
exports.default = GraphUtils;

},{}],109:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** A class containing some utility functions for math operations */
class MathUtils {
    /**
     * Returns the sign of the value provided
     * @param x The value to extract the sign from
     * @returns -1 if the number is less than 0, 1 otherwise
     */
    static sign(x) {
        return x < 0 ? -1 : 1;
    }
    /**
     * Returns whether or not x is between a and b
     * @param a The min bound
     * @param b The max bound
     * @param x The value to check
     * @param exclusive Whether or not a and b are exclusive bounds
     * @returns True if x is between a and b, false otherwise
     */
    static between(a, b, x, exclusive) {
        if (exclusive) {
            return (a < x) && (x < b);
        }
        else {
            return (a <= x) && (x <= b);
        }
    }
    /**
     * Clamps the value x to the range [min, max], rounding up or down if needed
     * @param x The value to be clamped
     * @param min The min of the range
     * @param max The max of the range
     * @returns x, if it is between min and max, or min/max if it exceeds their bounds
     */
    static clamp(x, min, max) {
        if (x < min)
            return min;
        if (x > max)
            return max;
        return x;
    }
    /**
     * Clamps the value x to the range between 0 and 1
     * @param x The value to be clamped
     * @returns x, if it is between 0 and 1, or 0/1 if it exceeds their bounds
     */
    static clamp01(x) {
        return MathUtils.clamp(x, 0, 1);
    }
    /**
     * Clamps the lower end of the value of x to the range to min
     * @param x The value to be clamped
     * @param min The minimum allowed value of x
     * @returns x, if it is greater than min, otherwise min
     */
    static clampLow(x, min) {
        return x < min ? min : x;
    }
    /**
     * Clamps the lower end of the value of x to zero
     * @param x The value to be clamped
     * @returns x, if it is greater than 0, otherwise 0
     */
    static clampLow0(x) {
        return MathUtils.clampLow(x, 0);
    }
    static clampMagnitude(v, m) {
        if (v.magSq() > m * m) {
            return v.scaleTo(m);
        }
        else {
            return v;
        }
    }
    static changeRange(x, min, max, newMin, newMax) {
        return this.lerp(newMin, newMax, this.invLerp(min, max, x));
    }
    /**
     * Linear Interpolation
     * @param a The first value for the interpolation bound
     * @param b The second value for the interpolation bound
     * @param t The time we are interpolating to
     * @returns The value between a and b at time t
     */
    static lerp(a, b, t) {
        return a + t * (b - a);
    }
    /**
     * Inverse Linear Interpolation. Finds the time at which a value between a and b would occur
     * @param a The first value for the interpolation bound
     * @param b The second value for the interpolation bound
     * @param value The current value
     * @returns The time at which the current value occurs between a and b
     */
    static invLerp(a, b, value) {
        return (value - a) / (b - a);
    }
    /**
     * Cuts off decimal points of a number after a specified place
     * @param num The number to floor
     * @param place The last decimal place of the new number
     * @returns The floored number
     */
    static floorToPlace(num, place) {
        if (place === 0) {
            return Math.floor(num);
        }
        let factor = 10;
        while (place > 1) {
            factor != 10;
            place--;
        }
        return Math.floor(num * factor) / factor;
    }
    /**
     * Returns a number from a hex string
     * @param str the string containing the hex number
     * @returns the number in decimal represented by the hex string
     */
    static fromHex(str) {
        return parseInt(str, 16);
    }
    /**
     * Returns the number as a hexadecimal
     * @param num The number to convert to hex
     * @param minLength The length of the returned hex string (adds zero padding if needed)
     * @returns The hex representation of the number as a string
     */
    static toHex(num, minLength = null) {
        let factor = 1;
        while (factor * 16 < num) {
            factor *= 16;
        }
        let hexStr = "";
        while (factor >= 1) {
            let digit = Math.floor(num / factor);
            hexStr += MathUtils.toHexDigit(digit);
            num -= digit * factor;
            factor /= 16;
        }
        if (minLength !== null) {
            while (hexStr.length < minLength) {
                hexStr = "0" + hexStr;
            }
        }
        return hexStr;
    }
    /**
     * Converts a digit to hexadecimal. In this case, a digit is between 0 and 15 inclusive
     * @param num The digit to convert to hexadecimal
     * @returns The hex representation of the digit as a string
     */
    static toHexDigit(num) {
        if (num < 10) {
            return "" + num;
        }
        else {
            return String.fromCharCode(65 + num - 10);
        }
    }
}
exports.default = MathUtils;

},{}],110:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = __importDefault(require("../MathUtils"));
const permutation = [151, 160, 137, 91, 90, 15,
    131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,
    190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,
    88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166,
    77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244,
    102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196,
    135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123,
    5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42,
    223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,
    129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228,
    251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107,
    49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,
    138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180
];
/**
 * A noise generator
 */
class Perlin {
    constructor() {
        this.p = new Int16Array(512);
        for (let i = 0; i < 512; i++) {
            this.p[i] = permutation[i % 256];
        }
        this.repeat = -1;
    }
    /**
     * Returns a random perlin noise value
     * @param x An input value
     * @param y An input value
     * @param z An input value
     * @returns A noise value
     */
    perlin(x, y, z = 0) {
        if (this.repeat > 0) {
            x = x % this.repeat;
            y = y % this.repeat;
            z = z % this.repeat;
        }
        // Get the position of the unit cube of (x, y, z)
        let xi = Math.floor(x) & 255;
        let yi = Math.floor(y) & 255;
        let zi = Math.floor(z) & 255;
        // Get the position of (x, y, z) in that unit cube
        let xf = x - Math.floor(x);
        let yf = y - Math.floor(y);
        let zf = z - Math.floor(z);
        // Use the fade function to relax the coordinates towards a whole value
        let u = this.fade(xf);
        let v = this.fade(yf);
        let w = this.fade(zf);
        // Perlin noise hash function
        let aaa = this.p[this.p[this.p[xi] + yi] + zi];
        let aba = this.p[this.p[this.p[xi] + this.inc(yi)] + zi];
        let aab = this.p[this.p[this.p[xi] + yi] + this.inc(zi)];
        let abb = this.p[this.p[this.p[xi] + this.inc(yi)] + this.inc(zi)];
        let baa = this.p[this.p[this.p[this.inc(xi)] + yi] + zi];
        let bba = this.p[this.p[this.p[this.inc(xi)] + this.inc(yi)] + zi];
        let bab = this.p[this.p[this.p[this.inc(xi)] + yi] + this.inc(zi)];
        let bbb = this.p[this.p[this.p[this.inc(xi)] + this.inc(yi)] + this.inc(zi)];
        // Calculate the value of the perlin noies
        let x1 = MathUtils_1.default.lerp(this.grad(aaa, xf, yf, zf), this.grad(baa, xf - 1, yf, zf), u);
        let x2 = MathUtils_1.default.lerp(this.grad(aba, xf, yf - 1, zf), this.grad(bba, xf - 1, yf - 1, zf), u);
        let y1 = MathUtils_1.default.lerp(x1, x2, v);
        x1 = MathUtils_1.default.lerp(this.grad(aab, xf, yf, zf - 1), this.grad(bab, xf - 1, yf, zf - 1), u);
        x2 = MathUtils_1.default.lerp(this.grad(abb, xf, yf - 1, zf - 1), this.grad(bbb, xf - 1, yf - 1, zf - 1), u);
        let y2 = MathUtils_1.default.lerp(x1, x2, v);
        return (MathUtils_1.default.lerp(y1, y2, w) + 1) / 2;
    }
    grad(hash, x, y, z) {
        switch (hash & 0xF) {
            case 0x0: return x + y;
            case 0x1: return -x + y;
            case 0x2: return x - y;
            case 0x3: return -x - y;
            case 0x4: return x + z;
            case 0x5: return -x + z;
            case 0x6: return x - z;
            case 0x7: return -x - z;
            case 0x8: return y + z;
            case 0x9: return -y + z;
            case 0xA: return y - z;
            case 0xB: return -y - z;
            case 0xC: return y + x;
            case 0xD: return -y + z;
            case 0xE: return y - x;
            case 0xF: return -y - z;
            default: return 0; // never happens
        }
    }
    /**
     * Safe increment that doesn't go beyond the repeat value
     * @param num The number to increment
     */
    inc(num) {
        num++;
        if (this.repeat > 0) {
            num %= this.repeat;
        }
        return num;
    }
    /**
     * The fade function 6t^5 - 15t^4 + 10t^3
     * @param t The value we are applying the fade to
     */
    fade(t) {
        return t * t * t * (t * (t * 6 - 15) + 10);
    }
}
exports.default = Perlin;

},{"../MathUtils":109}],111:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = __importDefault(require("./MathUtils"));
const Color_1 = __importDefault(require("./Color"));
const Perlin_1 = __importDefault(require("./Rand/Perlin"));
const Vec2_1 = __importDefault(require("../DataTypes/Vec2"));
const seed_random_1 = __importDefault(require("seed-random"));
class Noise {
    constructor() {
        this.p = new Perlin_1.default();
    }
    perlin(x, y, z) {
        return this.p.perlin(x, y, z);
    }
}
/** A class that has some random generator utils */
class RandUtils {
    /**
     * The random function for Wolfie2D. The random() method generates a random number using
     * the function exported seed-random. This function does the exact same thing that
     * Math.random() does, except it allows us to use a seed.
     *
     * @returns a random number from the function _rand() that generates random numbers based
     * on the seed, _seed.
     */
    static random() {
        if (RandUtils._rand === undefined || RandUtils._rand === null) {
            RandUtils._rand = (0, seed_random_1.default)(RandUtils.seed);
        }
        return RandUtils._rand();
    }
    static randomSeed() {
        return Math.random().toString();
    }
    /**
     * Gets the seed used by the random number generator. If the seed is null or undefined,
     * a seed is generated using RandUtils.randomSeed().
     * @returns the seed
     */
    static get seed() {
        if (RandUtils._seed === undefined || RandUtils._seed === null) {
            RandUtils._seed = RandUtils.randomSeed();
        }
        return RandUtils._seed;
    }
    /**
     * Sets the seed used by the random number generator. Sets the _rand function used
     * by random() to a new function, seeded with the given seed.
     * @param seed the seed used by the random number generator
     */
    static set seed(seed) {
        RandUtils._seed = seed;
        RandUtils._rand = (0, seed_random_1.default)(seed);
    }
    /**
     * Generates a random integer in the specified range
     * @param min The min of the range (inclusive)
     * @param max The max of the range (exclusive)
     * @returns A random int in the range [min, max)
     */
    static randInt(min, max) {
        return Math.floor(RandUtils.random() * (max - min) + min);
    }
    /**
     * Generates a random float in the specified range
     * @param min The min of the range (inclusive)
     * @param max The max of the range (exclusive)
     * @returns A random float in the range [min, max)
     */
    static randFloat(min, max) {
        return RandUtils.random() * (max - min) + min;
    }
    /**
     * Generates a random hexadecimal number in the specified range
     * @param min The min of the range (inclusive)
     * @param max The max of the range (exclusive)
     * @returns a random hex number in the range [min, max) as a string
     */
    static randHex(min, max) {
        return MathUtils_1.default.toHex(RandUtils.randInt(min, max));
    }
    /**
     * Generates a random color
     * @returns A random Color
     */
    static randColor() {
        let r = RandUtils.randInt(0, 256);
        let g = RandUtils.randInt(0, 256);
        let b = RandUtils.randInt(0, 256);
        return new Color_1.default(r, g, b);
    }
    static randVec(minX, maxX, minY, maxY) {
        return new Vec2_1.default(this.randFloat(minX, maxX), this.randFloat(minY, maxY));
    }
}
exports.default = RandUtils;
/** A noise generator */
RandUtils.noise = new Noise();

},{"../DataTypes/Vec2":26,"./Color":106,"./MathUtils":109,"./Rand/Perlin":110,"seed-random":1}],112:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = __importDefault(require("./MathUtils"));
class RenderingUtils {
    static toWebGLCoords(point, origin, worldSize) {
        return new Float32Array([
            MathUtils_1.default.changeRange(point.x, origin.x, origin.x + worldSize.x, -1, 1),
            MathUtils_1.default.changeRange(point.y, origin.y, origin.y + worldSize.y, 1, -1)
        ]);
    }
    static toWebGLScale(size, worldSize) {
        return new Float32Array([
            2 * size.x / worldSize.x,
            2 * size.y / worldSize.y,
        ]);
    }
    static toWebGLColor(color) {
        return new Float32Array([
            MathUtils_1.default.changeRange(color.r, 0, 255, 0, 1),
            MathUtils_1.default.changeRange(color.g, 0, 255, 0, 1),
            MathUtils_1.default.changeRange(color.b, 0, 255, 0, 1),
            color.a
        ]);
    }
}
exports.default = RenderingUtils;

},{"./MathUtils":109}],113:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** Some utility functions for dealing with strings */
class StringUtils {
    /**
     * Extracts the path from a filepath that includes the file
     * @param filePath the filepath to extract the path from
     * @returns The path portion of the filepath provided
     */
    static getPathFromFilePath(filePath) {
        let splitPath = filePath.split("/");
        splitPath.pop();
        splitPath.push("");
        return splitPath.join("/");
    }
}
exports.default = StringUtils;

},{}],114:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const NPCAction_1 = __importDefault(require("./NPCAction"));
/**
 * An Idle action for the NPCGoapAI. Basically a default action for all of the NPCs
 * to do nothing.
 */
class IdleAction extends NPCAction_1.default {
    performAction(target) {
        this.finished();
    }
    handleInput(event) {
        switch (event.type) {
            default: {
                super.handleInput(event);
                break;
            }
        }
    }
}
exports.default = IdleAction;

},{"./NPCAction":115}],115:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const GoapAction_1 = __importDefault(require("../../../../Wolfie2D/AI/Goap/GoapAction"));
const BasicFinder_1 = __importDefault(require("../../../GameSystems/Searching/BasicFinder"));
/**
 * An abstract GoapAction for an NPC. All NPC actions consist of doing three things:
 *
 *  1. Selecting some target/location
 *  2. Going to or moving within range of the selected target
 *  3. Doing something at the target location
 *
 * The abstract NPC action takes care of the first two parts (selecting the target and moving to the target location). All
 * concrete implementations of the NPCAction will have to implement the abstract method performAction() which
 * gets called when the NPC reaches the target location.
 */
class NPCAction extends GoapAction_1.default {
    constructor(parent, actor) {
        super(parent, actor);
        this.targetFinder = new BasicFinder_1.default();
        this.targets = [];
        this.target = null;
        this.path = null;
    }
    onEnter(options) {
        // Select the target location where the NPC should perform the action
        this.target = this.targetFinder.find(this.targets);
        // If we found a target, set the NPCs target to the target and find a path to the target
        if (this.target !== null) {
            // Set the actors current target to be the target for this action
            this.actor.setTarget(this.target);
            // Construct a path from the actor to the target
            this.path = this.actor.getPath(this.actor.position, this.target.position);
        }
    }
    update(deltaT) {
        // TODO get the NPCs to move on their paths
        if (this.path != null)
            this.actor.moveOnPath(1, this.path);
    }
    onExit() {
        // Clear the actor's current target
        this.actor.clearTarget();
        // Clear the reference to the target and the path in the action
        this.target = null;
        this.path = null;
        return {};
    }
    handleInput(event) {
        switch (event.type) {
            default: {
                throw new Error(`Unhandled event caught in NPCAction! Event type: ${event.type}`);
            }
        }
    }
    get targetFinder() { return this._targetFinder; }
    set targetFinder(finder) { this._targetFinder = finder; }
    get targets() { return this._targets; }
    set targets(targets) { this._targets = targets; }
    get target() { return this._target; }
    set target(target) { this._target = target; }
    set path(path) { this._path = path; }
    get path() { return this._path; }
}
exports.default = NPCAction;

},{"../../../../Wolfie2D/AI/Goap/GoapAction":3,"../../../GameSystems/Searching/BasicFinder":141}],116:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const NPCAction_1 = __importDefault(require("./NPCAction"));
class PickupTargetedItem extends NPCAction_1.default {
    constructor(parent, actor) {
        super(parent, actor);
    }
    performAction(target) {
        if (target.inventory === null) {
            this.actor.inventory.add(target);
        }
        this.finished();
    }
    handleInput(event) {
        switch (event.type) {
            default: {
                super.handleInput(event);
                break;
            }
        }
    }
    get targetFinder() { return this._targetFinder; }
    set targetFinder(finder) { this._targetFinder = finder; }
    get targets() { return this._targets; }
    set targets(targets) { this._targets = targets; }
    get target() { return this._target; }
    set target(target) { this._target = target; }
}
exports.default = PickupTargetedItem;

},{"./NPCAction":115}],117:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const AABB_1 = __importDefault(require("../../../../Wolfie2D/DataTypes/Shapes/AABB"));
const Vec2_1 = __importDefault(require("../../../../Wolfie2D/DataTypes/Vec2"));
const LaserGun_1 = __importDefault(require("../../../GameSystems/ItemSystem/Items/LaserGun"));
const NPCAction_1 = __importDefault(require("./NPCAction"));
const Events_1 = require("../../../Events");
const Timer_1 = __importDefault(require("../../../../Wolfie2D/Timing/Timer"));
class ShootLaserGun extends NPCAction_1.default {
    constructor(parent, actor) {
        super(parent, actor);
        this.lasergun = null;
        this._target = null;
        this.timer = new Timer_1.default(2000);
    }
    performAction(target) {
        this.timer.isStopped() ? console.log("Weapon cooling down!") : console.log("Weapon ready!");
        // If the lasergun is not null and the lasergun is still in the actors inventory; shoot the lasergun
        if (this.timer.isStopped() && this.lasergun !== null && this.lasergun.inventory !== null && this.lasergun.inventory.id === this.actor.inventory.id) {
            // Set the start, direction, and end position to shoot the laser gun
            this.lasergun.laserStart.copy(this.actor.position);
            this.lasergun.direction.copy(this.actor.position.dirTo(target.position));
            this.lasergun.laserEnd.copy(this.getLaserEnd(this.actor.getScene().getWalls(), this.lasergun.laserStart, this.lasergun.direction));
            // Play the shooting animation for the laser gun
            this.lasergun.playShootAnimation();
            // Send a laser fired event
            this.emitter.fireEvent(Events_1.ItemEvent.LASERGUN_FIRED, {
                actorId: this.actor.id,
                to: this.lasergun.laserStart.clone(),
                from: this.lasergun.laserEnd.clone().sub(this.lasergun.laserStart)
            });
            this.timer.start();
        }
        // Finish the action
        this.finished();
    }
    onEnter(options) {
        super.onEnter(options);
        // Find a lasergun in the actors inventory
        let lasergun = this.actor.inventory.find(item => item.constructor === LaserGun_1.default);
        if (lasergun !== null && lasergun.constructor === LaserGun_1.default) {
            this.lasergun = lasergun;
        }
    }
    handleInput(event) {
        switch (event.type) {
            default: {
                super.handleInput(event);
                break;
            }
        }
    }
    update(deltaT) {
        super.update(deltaT);
    }
    onExit() {
        // Clear the reference to the lasergun
        this.lasergun = null;
        return super.onExit();
    }
    getLaserEnd(walls, start, dir) {
        let end = start.clone().add(dir.scaled(900));
        let delta = end.clone().sub(start);
        // Iterate through the tilemap region until we find a collision
        let minX = Math.min(start.x, end.x);
        let maxX = Math.max(start.x, end.x);
        let minY = Math.min(start.y, end.y);
        let maxY = Math.max(start.y, end.y);
        let minIndex = walls.getTilemapPosition(minX, minY);
        let maxIndex = walls.getTilemapPosition(maxX, maxY);
        let tileSize = walls.getScaledTileSize();
        for (let col = minIndex.x; col <= maxIndex.x; col++) {
            for (let row = minIndex.y; row <= maxIndex.y; row++) {
                if (walls.isTileCollidable(col, row)) {
                    // Get the position of this tile
                    let tilePos = new Vec2_1.default(col * tileSize.x + tileSize.x / 2, row * tileSize.y + tileSize.y / 2);
                    // Create a collider for this tile
                    let collider = new AABB_1.default(tilePos, tileSize.scaled(1 / 2));
                    let hit = collider.intersectSegment(start, delta, Vec2_1.default.ZERO);
                    if (hit !== null && start.distanceSqTo(hit.pos) < start.distanceSqTo(end)) {
                        end = hit.pos;
                    }
                }
            }
        }
        return end;
    }
}
exports.default = ShootLaserGun;

},{"../../../../Wolfie2D/DataTypes/Shapes/AABB":20,"../../../../Wolfie2D/DataTypes/Vec2":26,"../../../../Wolfie2D/Timing/Timer":104,"../../../Events":133,"../../../GameSystems/ItemSystem/Items/LaserGun":140,"./NPCAction":115}],118:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const StateMachineGoapAI_1 = __importDefault(require("../../../Wolfie2D/AI/Goap/StateMachineGoapAI"));
const Events_1 = require("../../Events");
/**
 * An abstract implementation of behavior for an NPC. Each concrete implementation of the
 * NPCBehavior class should define some new behavior for an NPCActor.
 */
class NPCBehavior extends StateMachineGoapAI_1.default {
    initializeAI(owner, options) {
        this.owner = owner;
        this.receiver.subscribe(Events_1.ItemEvent.LASERGUN_FIRED);
    }
    activate(options) { }
    update(deltaT) {
        super.update(deltaT);
    }
    /**
     * @param event the game event
     */
    handleEvent(event) {
        switch (event.type) {
            case Events_1.ItemEvent.LASERGUN_FIRED: {
                console.log("Catching and handling lasergun fired event!!!");
                this.handleLasergunFired(event.data.get("actorId"), event.data.get("to"), event.data.get("from"));
                break;
            }
            default: {
                super.handleEvent(event);
                break;
            }
        }
    }
    handleLasergunFired(actorId, to, from) {
        if (actorId !== this.owner.id) {
            this.owner.health -= this.owner.collisionShape.getBoundingRect().intersectSegment(to, from) ? 1 : 0;
        }
    }
}
exports.default = NPCBehavior;

},{"../../../Wolfie2D/AI/Goap/StateMachineGoapAI":6,"../../Events":133}],119:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GuardActions = exports.GuardStatuses = void 0;
const NPCBehavior_1 = __importDefault(require("../NPCBehavior"));
const GotoAction_1 = __importDefault(require("../NPCActions/GotoAction"));
const ShootLaserGun_1 = __importDefault(require("../NPCActions/ShootLaserGun"));
const BasicFinder_1 = __importDefault(require("../../../GameSystems/Searching/BasicFinder"));
const HW4Filters_1 = require("../../../GameSystems/Searching/HW4Filters");
const PickupItem_1 = __importDefault(require("../NPCActions/PickupItem"));
const HW4Reducers_1 = require("../../../GameSystems/Searching/HW4Reducers");
const LaserGun_1 = __importDefault(require("../../../GameSystems/ItemSystem/Items/LaserGun"));
const TargetExists_1 = require("../NPCStatuses/TargetExists");
const HasItem_1 = require("../NPCStatuses/HasItem");
const FalseStatus_1 = __importDefault(require("../NPCStatuses/FalseStatus"));
class GuardBehavior extends NPCBehavior_1.default {
    /** Initialize the NPC AI */
    initializeAI(owner, options) {
        super.initializeAI(owner, options);
        // Initialize the targetable entity the guard should try to protect and the range to the target
        this.target = options.target;
        this.range = options.range;
        // Initialize guard statuses
        this.initializeStatuses();
        // Initialize guard actions
        this.initializeActions();
        // Set the guards goal
        this.goal = exports.GuardStatuses.GOAL;
        // Initialize the guard behavior
        this.initialize();
    }
    handleEvent(event) {
        switch (event.type) {
            default: {
                super.handleEvent(event);
                break;
            }
        }
    }
    update(deltaT) {
        super.update(deltaT);
    }
    initializeStatuses() {
        let scene = this.owner.getScene();
        // A status checking if there are any enemies at target the guard is guarding
        let enemyBattlerFinder = new BasicFinder_1.default(null, (0, HW4Filters_1.BattlerActiveFilter)(), (0, HW4Filters_1.EnemyFilter)(this.owner), (0, HW4Filters_1.RangeFilter)(this.target, 0, this.range * this.range));
        let enemyAtGuardPosition = new TargetExists_1.TargetExists(scene.getBattlers(), enemyBattlerFinder);
        this.addStatus(exports.GuardStatuses.ENEMY_IN_GUARD_POSITION, enemyAtGuardPosition);
        // Add a status to check if a lasergun exists in the scene and it's visible
        this.addStatus(exports.GuardStatuses.LASERGUN_EXISTS, new TargetExists_1.TargetExists(scene.getLaserGuns(), new BasicFinder_1.default(null, (0, HW4Filters_1.ItemFilter)(LaserGun_1.default), (0, HW4Filters_1.VisibleItemFilter)())));
        // Add a status to check if the guard has a lasergun
        this.addStatus(exports.GuardStatuses.HAS_WEAPON, new HasItem_1.HasItem(this.owner, new BasicFinder_1.default(null, (0, HW4Filters_1.ItemFilter)(LaserGun_1.default))));
        // Add the goal status 
        this.addStatus(exports.GuardStatuses.GOAL, new FalseStatus_1.default());
    }
    initializeActions() {
        let scene = this.owner.getScene();
        // An action for shooting an enemy in the guards guard area
        let shootEnemy = new ShootLaserGun_1.default(this, this.owner);
        shootEnemy.targets = scene.getBattlers();
        shootEnemy.targetFinder = new BasicFinder_1.default((0, HW4Reducers_1.ClosestPositioned)(this.owner), (0, HW4Filters_1.BattlerActiveFilter)(), (0, HW4Filters_1.EnemyFilter)(this.owner), (0, HW4Filters_1.RangeFilter)(this.target, 0, this.range * this.range));
        shootEnemy.addPrecondition(exports.GuardStatuses.HAS_WEAPON);
        shootEnemy.addPrecondition(exports.GuardStatuses.ENEMY_IN_GUARD_POSITION);
        shootEnemy.addEffect(exports.GuardStatuses.GOAL);
        shootEnemy.cost = 1;
        this.addState(exports.GuardActions.SHOOT_ENEMY, shootEnemy);
        // An action for picking up a lasergun
        let pickupLaserGun = new PickupItem_1.default(this, this.owner);
        pickupLaserGun.targets = scene.getLaserGuns();
        pickupLaserGun.targetFinder = new BasicFinder_1.default((0, HW4Reducers_1.ClosestPositioned)(this.owner), (0, HW4Filters_1.VisibleItemFilter)(), (0, HW4Filters_1.ItemFilter)(LaserGun_1.default));
        pickupLaserGun.addPrecondition(exports.GuardStatuses.LASERGUN_EXISTS);
        pickupLaserGun.addEffect(exports.GuardStatuses.HAS_WEAPON);
        pickupLaserGun.cost = 5;
        this.addState(exports.GuardActions.PICKUP_LASER_GUN, pickupLaserGun);
        // An action for guarding the guard's guard location
        let guard = new GotoAction_1.default(this, this.owner);
        guard.targets = [this.target];
        guard.targetFinder = new BasicFinder_1.default();
        guard.addPrecondition(exports.GuardStatuses.HAS_WEAPON);
        guard.addEffect(exports.GuardStatuses.GOAL);
        guard.cost = 1000;
        this.addState(exports.GuardActions.GUARD, guard);
    }
    addState(stateName, state) {
        super.addState(stateName, state);
    }
    addStatus(statusName, status) {
        super.addStatus(statusName, status);
    }
}
exports.default = GuardBehavior;
exports.GuardStatuses = {
    ENEMY_IN_GUARD_POSITION: "enemy-at-guard-position",
    HAS_WEAPON: "has-weapon",
    LASERGUN_EXISTS: "laser-gun-exists",
    GOAL: "goal"
};
exports.GuardActions = {
    PICKUP_LASER_GUN: "pickup-lasergun",
    SHOOT_ENEMY: "shoot-enemy",
    GUARD: "guard",
};

},{"../../../GameSystems/ItemSystem/Items/LaserGun":140,"../../../GameSystems/Searching/BasicFinder":141,"../../../GameSystems/Searching/HW4Filters":142,"../../../GameSystems/Searching/HW4Reducers":143,"../NPCActions/GotoAction":114,"../NPCActions/PickupItem":116,"../NPCActions/ShootLaserGun":117,"../NPCBehavior":118,"../NPCStatuses/FalseStatus":121,"../NPCStatuses/HasItem":122,"../NPCStatuses/TargetExists":123}],120:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const NPCBehavior_1 = __importDefault(require("../NPCBehavior"));
const GotoAction_1 = __importDefault(require("../NPCActions/GotoAction"));
const TargetExists_1 = require("../NPCStatuses/TargetExists");
const BasicFinder_1 = __importDefault(require("../../../GameSystems/Searching/BasicFinder"));
const HW4Filters_1 = require("../../../GameSystems/Searching/HW4Filters");
const Healthpack_1 = __importDefault(require("../../../GameSystems/ItemSystem/Items/Healthpack"));
const HasItem_1 = require("../NPCStatuses/HasItem");
const FalseStatus_1 = __importDefault(require("../NPCStatuses/FalseStatus"));
/**
 * When an NPC is acting as a healer, their goal is to try and heal it's teammates by running around, picking up healthpacks,
 * bringing to the healthpacks to their allies and healing them.
 */
class HealerBehavior extends NPCBehavior_1.default {
    /** Initialize the NPC AI */
    initializeAI(owner, opts) {
        super.initializeAI(owner, opts);
        let scene = owner.getScene();
        /* ######### Add all healer statuses ######## */
        this.addStatus(HealerStatuses.GOAL, new FalseStatus_1.default());
        // Check if a healthpack exists in the scene and it's visible
        this.addStatus(HealerStatuses.HPACK_EXISTS, new TargetExists_1.TargetExists(scene.getHealthpacks(), new BasicFinder_1.default(null, (0, HW4Filters_1.ItemFilter)(Healthpack_1.default), (0, HW4Filters_1.VisibleItemFilter)())));
        // Check if a healthpack exists in the actors inventory
        this.addStatus(HealerStatuses.HAS_HPACK, new HasItem_1.HasItem(owner, new BasicFinder_1.default(null, (0, HW4Filters_1.ItemFilter)(Healthpack_1.default))));
        // Check if a lowhealth ally exists in the scene
        let lowhealthAlly = new BasicFinder_1.default(null, (0, HW4Filters_1.BattlerActiveFilter)(), (0, HW4Filters_1.BattlerGroupFilter)([owner.battleGroup]));
        this.addStatus(HealerStatuses.ALLY_EXISTS, new TargetExists_1.TargetExists(scene.getBattlers(), lowhealthAlly));
        /* ######### Add all healer actions ######## */
        // TODO configure the rest of the healer actions
        // Idle action
        let idle = new GotoAction_1.default(this, this.owner);
        idle.addEffect(HealerStatuses.GOAL);
        idle.cost = 100;
        this.addState(HealerActions.IDLE, idle);
        /* ######### Set the healers goal ######## */
        this.goal = HealerStatuses.GOAL;
        this.initialize();
    }
    handleEvent(event) {
        switch (event.type) {
            default: {
                super.handleEvent(event);
                break;
            }
        }
    }
    update(deltaT) {
        super.update(deltaT);
    }
}
exports.default = HealerBehavior;
// World states for the healer
const HealerStatuses = {
    // Whether or not a healthpack exists in the world
    HPACK_EXISTS: "hpack-exists",
    // Whether the healer has a healthpack in their inventory or not
    ALLY_EXISTS: "ally-exists",
    // Whether the healer has any allies in the game world or not
    HAS_HPACK: "has-hpack",
    // Whether the healer has reached it's goal or not
    GOAL: "goal"
};
// Healer actions
const HealerActions = {
    PICKUP_HPACK: "pickup-hpack",
    USE_HPACK: "use-hpack",
    IDLE: "idle",
};

},{"../../../GameSystems/ItemSystem/Items/Healthpack":139,"../../../GameSystems/Searching/BasicFinder":141,"../../../GameSystems/Searching/HW4Filters":142,"../NPCActions/GotoAction":114,"../NPCBehavior":118,"../NPCStatuses/FalseStatus":121,"../NPCStatuses/HasItem":122,"../NPCStatuses/TargetExists":123}],121:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const GoapState_1 = __importDefault(require("../../../../Wolfie2D/AI/Goap/GoapState"));
class FalseStatus extends GoapState_1.default {
    isSatisfied() {
        return false;
    }
}
exports.default = FalseStatus;

},{"../../../../Wolfie2D/AI/Goap/GoapState":5}],122:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HasItem = void 0;
const GoapState_1 = __importDefault(require("../../../../Wolfie2D/AI/Goap/GoapState"));
class HasItem extends GoapState_1.default {
    constructor(actor, finder) {
        super();
        this.actor = actor;
        this.finder = finder;
    }
    isSatisfied() {
        return this.finder.find(Array.from(this.actor.inventory.items())) !== null;
    }
}
exports.HasItem = HasItem;

},{"../../../../Wolfie2D/AI/Goap/GoapState":5}],123:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TargetExists = void 0;
const GoapState_1 = __importDefault(require("../../../../Wolfie2D/AI/Goap/GoapState"));
class TargetExists extends GoapState_1.default {
    constructor(targets, finder) {
        super();
        this.finder = finder;
        this.targets = targets;
    }
    isSatisfied() {
        return this.finder.find(this.targets) !== null;
    }
}
exports.TargetExists = TargetExists;

},{"../../../../Wolfie2D/AI/Goap/GoapState":5}],124:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const StateMachineAI_1 = __importDefault(require("../../../Wolfie2D/AI/StateMachineAI"));
const Events_1 = require("../../Events");
const PlayerController_1 = __importDefault(require("./PlayerController"));
const PlayerState_1 = require("./PlayerStates/PlayerState");
/**
 * The AI that controls the player. The players AI has been configured as a Finite State Machine (FSM)
 * with 4 states; Idle, Moving, Invincible, and Dead.
 */
class PlayerAI extends StateMachineAI_1.default {
    initializeAI(owner, opts) {
        this.owner = owner;
        this.controller = new PlayerController_1.default(owner);
        // Add the players states to it's StateMachine
        this.addState(PlayerState_1.PlayerStateType.IDLE, new PlayerState_1.Idle(this, this.owner));
        this.addState(PlayerState_1.PlayerStateType.INVINCIBLE, new PlayerState_1.Invincible(this, this.owner));
        this.addState(PlayerState_1.PlayerStateType.MOVING, new PlayerState_1.Moving(this, this.owner));
        this.addState(PlayerState_1.PlayerStateType.DEAD, new PlayerState_1.Dead(this, this.owner));
        // Initialize the players state to Idle
        this.initialize(PlayerState_1.PlayerStateType.IDLE);
    }
    activate(options) { }
    update(deltaT) {
        super.update(deltaT);
    }
    destroy() { }
    handleEvent(event) {
        switch (event.type) {
            case Events_1.ItemEvent.LASERGUN_FIRED: {
                this.handleLaserFiredEvent(event.data.get("actorId"), event.data.get("to"), event.data.get("from"));
                break;
            }
            default: {
                super.handleEvent(event);
                break;
            }
        }
    }
    handleLaserFiredEvent(actorId, to, from) {
        if (this.owner.id !== actorId && this.owner.collisionShape !== undefined) {
            if (this.owner.collisionShape.getBoundingRect().intersectSegment(to, from.clone().sub(to)) !== null) {
                this.owner.health -= 1;
            }
        }
    }
}
exports.default = PlayerAI;

},{"../../../Wolfie2D/AI/StateMachineAI":7,"../../Events":133,"./PlayerController":125,"./PlayerStates/PlayerState":130}],125:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlayerInput = void 0;
const Vec2_1 = __importDefault(require("../../../Wolfie2D/DataTypes/Vec2"));
const Input_1 = __importDefault(require("../../../Wolfie2D/Input/Input"));
/**
 * Strings used in the key binding for the player
 */
var PlayerInput;
(function (PlayerInput) {
    PlayerInput["MOVE_UP"] = "MOVE_UP";
    PlayerInput["MOVE_DOWN"] = "MOVE_DOWN";
    PlayerInput["MOVE_LEFT"] = "MOVE_LEFT";
    PlayerInput["MOVE_RIGHT"] = "MOVE_RIGHT";
    PlayerInput["ATTACKING"] = "ATTACKING";
    PlayerInput["PICKUP_ITEM"] = "PICKUP_ITEM";
    PlayerInput["DROP_ITEM"] = "DROP_ITEM";
})(PlayerInput = exports.PlayerInput || (exports.PlayerInput = {}));
/**
 * The PlayerController class handles processing the input recieved from the user and exposes
 * a set of methods to make dealing with the user input a bit simpler.
 */
class PlayerController {
    constructor(owner) {
        this.owner = owner;
    }
    /**
     * Gets the direction the player should move based on input from the keyboard.
     * @returns a Vec2 indicating the direction the player should move.
     */
    get moveDir() {
        let dir = Vec2_1.default.ZERO;
        dir.y = (Input_1.default.isPressed(PlayerInput.MOVE_UP) ? -1 : 0) + (Input_1.default.isPressed(PlayerInput.MOVE_DOWN) ? 1 : 0);
        dir.x = (Input_1.default.isPressed(PlayerInput.MOVE_LEFT) ? -1 : 0) + (Input_1.default.isPressed(PlayerInput.MOVE_RIGHT) ? 1 : 0);
        return dir.normalize();
    }
    /**
     * Gets the direction the player should be facing based on the position of the
     * mouse around the player
     * @return a Vec2 representing the direction the player should face.
     */
    get faceDir() { return this.owner.position.dirTo(Input_1.default.getGlobalMousePosition()); }
    /**
     * Gets the rotation of the players sprite based on the direction the player
     * should be facing.
     * @return a number representing how much the player should be rotated
     */
    get rotation() { return Vec2_1.default.UP.angleToCCW(this.faceDir); }
    /**
     * Checks if the player is attempting to use a held item or not.
     * @return true if the player is attempting to use a held item; false otherwise
     */
    get useItem() { return Input_1.default.isMouseJustPressed(); }
    /**
     * Checks if the player is attempting to pick up an item or not.
     * @return true if the player is attempting to pick up an item; false otherwise.
     */
    get pickingUp() { return Input_1.default.isJustPressed(PlayerInput.PICKUP_ITEM); }
    /**
     * Checks if the player is attempting to drop their held item or not.
     * @return true if the player is attempting to drop their held item; false otherwise.
     */
    get dropping() { return Input_1.default.isJustPressed(PlayerInput.DROP_ITEM); }
}
exports.default = PlayerController;

},{"../../../Wolfie2D/DataTypes/Vec2":26,"../../../Wolfie2D/Input/Input":34}],126:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Events_1 = require("../../../Events");
const PlayerState_1 = __importDefault(require("./PlayerState"));
/**
 * The Dead state for the PlayerAI. While the player is in the "Dead" state, the player does not
 * get updated and all incoming events to the PlayerAI are ignored.
 */
class Dead extends PlayerState_1.default {
    /**
     * When the PlayerAI enters the dead state, an event is fired to alert the system
     * that the player is officially dead.
     */
    onEnter(options) {
        this.emitter.fireEvent(Events_1.PlayerEvent.PLAYER_KILLED);
    }
    /**
     * The input handler for the dead state ignores all incoming events to the player.
     * @param event
     */
    handleInput(event) { }
    /**
     * Similar to the handleInput method, while in the dead state, the PlayerAI doesn't
     * get updated.
     * @param deltaT
     */
    update(deltaT) { }
    onExit() { return {}; }
}
exports.default = Dead;

},{"../../../Events":133,"./PlayerState":130}],127:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../../../../Wolfie2D/DataTypes/Vec2"));
const PlayerState_1 = require("./PlayerState");
const PlayerState_2 = __importDefault(require("./PlayerState"));
class Idle extends PlayerState_2.default {
    onEnter(options) {
        this.parent.owner.animation.playIfNotAlready(PlayerState_1.PlayerAnimationType.IDLE, true);
    }
    handleInput(event) {
        switch (event.type) {
            default: {
                super.handleInput(event);
                break;
            }
        }
    }
    update(deltaT) {
        super.update(deltaT);
        if (!this.parent.controller.moveDir.equals(Vec2_1.default.ZERO)) {
            this.finished(PlayerState_1.PlayerStateType.MOVING);
        }
    }
    onExit() {
        return {};
    }
}
exports.default = Idle;

},{"../../../../Wolfie2D/DataTypes/Vec2":26,"./PlayerState":130}],128:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Timer_1 = __importDefault(require("../../../../Wolfie2D/Timing/Timer"));
const PlayerState_1 = __importStar(require("./PlayerState"));
class Invincible extends PlayerState_1.default {
    constructor(parent, owner) {
        super(parent, owner);
        this.timer = new Timer_1.default(100, () => this.finished(PlayerState_1.PlayerStateType.IDLE));
    }
    update(deltaT) { }
    handleInput(event) {
        switch (event.type) {
            default: {
                super.handleInput(event);
                break;
            }
        }
    }
    onEnter(options) {
        this.timer.start();
    }
    onExit() {
        return {};
    }
}
exports.default = Invincible;

},{"../../../../Wolfie2D/Timing/Timer":104,"./PlayerState":130}],129:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../../../../Wolfie2D/DataTypes/Vec2"));
const PlayerState_1 = require("./PlayerState");
const PlayerState_2 = __importDefault(require("./PlayerState"));
class Moving extends PlayerState_2.default {
    onEnter(options) {
    }
    handleInput(event) {
        switch (event.type) {
            default: {
                super.handleInput(event);
            }
        }
    }
    update(deltaT) {
        super.update(deltaT);
        if (this.parent.controller.moveDir.equals(Vec2_1.default.ZERO)) {
            this.finished(PlayerState_1.PlayerStateType.IDLE);
        }
    }
    onExit() { return {}; }
}
exports.default = Moving;

},{"../../../../Wolfie2D/DataTypes/Vec2":26,"./PlayerState":130}],130:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Dead = exports.Moving = exports.Invincible = exports.Idle = exports.PlayerStateType = exports.PlayerAnimationType = void 0;
const State_1 = __importDefault(require("../../../../Wolfie2D/DataTypes/State/State"));
const Events_1 = require("../../../Events");
var PlayerAnimationType;
(function (PlayerAnimationType) {
    PlayerAnimationType["IDLE"] = "IDLE";
})(PlayerAnimationType = exports.PlayerAnimationType || (exports.PlayerAnimationType = {}));
var PlayerStateType;
(function (PlayerStateType) {
    PlayerStateType["IDLE"] = "IDLE";
    PlayerStateType["INVINCIBLE"] = "INVINCIBLE";
    PlayerStateType["ATTACKING"] = "ATTACKING";
    PlayerStateType["MOVING"] = "MOVING";
    PlayerStateType["DEAD"] = "DEAD";
})(PlayerStateType = exports.PlayerStateType || (exports.PlayerStateType = {}));
class PlayerState extends State_1.default {
    constructor(parent, owner) {
        super(parent);
        this.owner = owner;
    }
    onEnter(options) { }
    onExit() { return {}; }
    update(deltaT) {
        // Adjust the angle the player is facing 
        this.parent.owner.rotation = this.parent.controller.rotation;
        // Move the player
        this.parent.owner.move(this.parent.controller.moveDir);
        // Handle the player trying to pick up an item
        if (this.parent.controller.pickingUp) {
            // Request an item from the scene
            this.emitter.fireEvent(Events_1.ItemEvent.ITEM_REQUEST, { node: this.owner, inventory: this.owner.inventory });
        }
        // Handle the player trying to drop an item
        if (this.parent.controller.dropping) {
        }
        if (this.parent.controller.useItem) {
        }
    }
    handleInput(event) {
        switch (event.type) {
            default: {
                throw new Error(`Unhandled event of type ${event.type} caught in PlayerState!`);
            }
        }
    }
}
exports.default = PlayerState;
const Idle_1 = __importDefault(require("./Idle"));
exports.Idle = Idle_1.default;
const Invincible_1 = __importDefault(require("./Invincible"));
exports.Invincible = Invincible_1.default;
const Moving_1 = __importDefault(require("./Moving"));
exports.Moving = Moving_1.default;
const Dead_1 = __importDefault(require("./Dead"));
exports.Dead = Dead_1.default;

},{"../../../../Wolfie2D/DataTypes/State/State":23,"../../../Events":133,"./Dead":126,"./Idle":127,"./Invincible":128,"./Moving":129}],131:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const AnimatedSprite_1 = __importDefault(require("../../Wolfie2D/Nodes/Sprites/AnimatedSprite"));
const Events_1 = require("../Events");
const BasicTargeting_1 = __importDefault(require("../GameSystems/Targeting/BasicTargeting"));
const BasicBattler_1 = __importDefault(require("../GameSystems/BattleSystem/BasicBattler"));
const Timer_1 = __importDefault(require("../../Wolfie2D/Timing/Timer"));
class NPCActor extends AnimatedSprite_1.default {
    constructor(sheet) {
        super(sheet);
        this._navkey = "navkey";
        this._battler = new BasicBattler_1.default(this);
        this._targeting = new BasicTargeting_1.default(this);
        this.invincibleTimer = new Timer_1.default(1000);
        this.receiver.subscribe("use-hpack");
    }
    /** The TargetingEntity interface */
    clearTarget() { this._targeting.clearTarget(); }
    setTarget(targetable) { this._targeting.setTarget(targetable); }
    hasTarget() { return this._targeting.hasTarget(); }
    getTarget() { return this._targeting.getTarget(); }
    /** The TargetableEntity interface */
    getTargeting() { return this._battler.getTargeting(); }
    addTargeting(targeting) { this._battler.addTargeting(targeting); }
    removeTargeting(targeting) { this._battler.removeTargeting(targeting); }
    atTarget() {
        return this._targeting.getTarget().position.distanceSqTo(this.position) < 625;
    }
    get battlerActive() { return this.battler.battlerActive; }
    set battlerActive(value) {
        this.battler.battlerActive = value;
        this.visible = value;
        this.aiActive = value;
    }
    get battleGroup() { return this.battler.battleGroup; }
    set battleGroup(battleGroup) { this.battler.battleGroup = battleGroup; }
    get maxHealth() { return this.battler.maxHealth; }
    set maxHealth(maxHealth) {
        this.battler.maxHealth = maxHealth;
        this.emitter.fireEvent(Events_1.HudEvent.HEALTH_CHANGE, { id: this.id, curhp: this.health, maxhp: this.maxHealth });
    }
    get health() { return this.battler.health; }
    set health(health) {
        this.battler.health = health;
        if (this.health <= 0 && this.battlerActive) {
            this.emitter.fireEvent(Events_1.BattlerEvent.BATTLER_KILLED, { id: this.id });
        }
    }
    get speed() { return this.battler.speed; }
    set speed(speed) { this.battler.speed = speed; }
    setScene(scene) { this.scene = scene; }
    getScene() { return this.scene; }
    get navkey() { return this._navkey; }
    set navkey(navkey) { this._navkey = navkey; }
    getPath(to, from) {
        return this.scene.getNavigationManager().getPath(this.navkey, to, from);
    }
    get inventory() { return this.battler.inventory; }
    /** Protected getters for the different components */
    get battler() { return this._battler; }
    get targeting() { return this._targeting; }
}
exports.default = NPCActor;

},{"../../Wolfie2D/Nodes/Sprites/AnimatedSprite":49,"../../Wolfie2D/Timing/Timer":104,"../Events":133,"../GameSystems/BattleSystem/BasicBattler":134,"../GameSystems/Targeting/BasicTargeting":145}],132:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const AnimatedSprite_1 = __importDefault(require("../../Wolfie2D/Nodes/Sprites/AnimatedSprite"));
const Events_1 = require("../Events");
const BasicBattler_1 = __importDefault(require("../GameSystems/BattleSystem/BasicBattler"));
const BasicTargetable_1 = __importDefault(require("../GameSystems/Targeting/BasicTargetable"));
class PlayerActor extends AnimatedSprite_1.default {
    constructor(sheet) {
        super(sheet);
        this.battler = new BasicBattler_1.default(this);
        this.targetable = new BasicTargetable_1.default(this);
        this.receiver.subscribe(Events_1.ItemEvent.LASERGUN_FIRED);
    }
    get battlerActive() {
        return this.battler.battlerActive;
    }
    set battlerActive(value) {
        this.battler.battlerActive = value;
        this.visible = value;
    }
    getTargeting() { return this.targetable.getTargeting(); }
    addTargeting(targeting) { this.targetable.addTargeting(targeting); }
    removeTargeting(targeting) { this.targetable.removeTargeting(targeting); }
    setScene(scene) { this.scene = scene; }
    getScene() { return this.scene; }
    get battleGroup() {
        return this.battler.battleGroup;
    }
    set battleGroup(value) {
        this.battler.battleGroup = value;
    }
    get maxHealth() {
        return this.battler.maxHealth;
    }
    set maxHealth(value) {
        this.battler.maxHealth = value;
    }
    get health() {
        return this.battler.health;
    }
    set health(value) {
        this.battler.health = value;
        if (this.health <= 0) {
            this.emitter.fireEvent(Events_1.BattlerEvent.BATTLER_KILLED, { id: this.id });
        }
    }
    get speed() {
        return this.battler.speed;
    }
    set speed(value) {
        this.battler.speed = value;
    }
    get inventory() {
        return this.battler.inventory;
    }
}
exports.default = PlayerActor;

},{"../../Wolfie2D/Nodes/Sprites/AnimatedSprite":49,"../Events":133,"../GameSystems/BattleSystem/BasicBattler":134,"../GameSystems/Targeting/BasicTargetable":144}],133:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlayerEvent = exports.HudEvent = exports.ItemEvent = exports.BattlerEvent = void 0;
var BattlerEvent;
(function (BattlerEvent) {
    BattlerEvent["BATTLER_KILLED"] = "BATTLER_KILLED";
    BattlerEvent["BATTLER_RESPAWN"] = "BATTLER_RESPAWN";
    BattlerEvent["BATTLER_CHANGE"] = "BATTLER_CHANGE";
    BattlerEvent["CONSUME"] = "CONSUME";
    BattlerEvent["HIT"] = "HIT";
})(BattlerEvent = exports.BattlerEvent || (exports.BattlerEvent = {}));
var ItemEvent;
(function (ItemEvent) {
    ItemEvent["ITEM_REQUEST"] = "ITEM_REQUEST";
    ItemEvent["LASERGUN_FIRED"] = "LASERGUN_FIRED";
    ItemEvent["WEAPON_USED"] = "WEAPON_USED";
    ItemEvent["CONSUMABLE_USED"] = "CONSUMABLE_USED";
    ItemEvent["INVENTORY_CHANGED"] = "INVENTORY_CHANGED";
})(ItemEvent = exports.ItemEvent || (exports.ItemEvent = {}));
var HudEvent;
(function (HudEvent) {
    HudEvent["HEALTH_CHANGE"] = "HEALTH_CHANGE";
})(HudEvent = exports.HudEvent || (exports.HudEvent = {}));
var PlayerEvent;
(function (PlayerEvent) {
    PlayerEvent["PLAYER_KILLED"] = "PLAYER_KILLED";
})(PlayerEvent = exports.PlayerEvent || (exports.PlayerEvent = {}));

},{}],134:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Inventory_1 = __importDefault(require("../ItemSystem/Inventory"));
const BasicTargetable_1 = __importDefault(require("../Targeting/BasicTargetable"));
class BasicBattler {
    constructor(owner) {
        this._owner = owner;
        this._targetable = new BasicTargetable_1.default(owner);
        this.inventory = new Inventory_1.default();
        this.maxHealth = 0;
        this.health = 0;
        this.battleGroup = 0;
        this.speed = 0;
        this.battlerActive = true;
    }
    get id() { return this._owner.id; }
    get position() { return this._targetable.position; }
    set position(position) { this._targetable.position = position; }
    get relativePosition() {
        return this._targetable.relativePosition;
    }
    get battleGroup() { return this._battleGroup; }
    set battleGroup(battleGroup) { this._battleGroup = battleGroup; }
    get maxHealth() { return this._maxHealth; }
    set maxHealth(maxHealth) { this._maxHealth = maxHealth; }
    get health() { return this._health; }
    set health(health) { this._health = health; }
    get speed() { return this._speed; }
    set speed(speed) { this._speed = speed; }
    get inventory() { return this._inventory; }
    set inventory(inventory) { this._inventory = inventory; }
    get battlerActive() { return this._active; }
    set battlerActive(value) { this._active = value; }
    getTargeting() { return this._targetable.getTargeting(); }
    addTargeting(targeting) { this._targetable.addTargeting(targeting); }
    removeTargeting(targeting) { this._targetable.removeTargeting(targeting); }
}
exports.default = BasicBattler;

},{"../ItemSystem/Inventory":137,"../Targeting/BasicTargetable":144}],135:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Color_1 = __importDefault(require("../../../Wolfie2D/Utils/Color"));
const UIElementTypes_1 = require("../../../Wolfie2D/Nodes/UIElements/UIElementTypes");
/**
 * A UI component that's suppossed to represent a healthbar
 */
class HealthbarHUD {
    constructor(scene, owner, layer, options) {
        this.scene = scene;
        this.layer = layer;
        this.owner = owner;
        this.size = options.size;
        this.offset = options.offset;
        this.healthBar = this.scene.add.uiElement(UIElementTypes_1.UIElementType.LABEL, layer, { position: this.owner.position.clone().add(this.offset), text: "" });
        this.healthBar.size.copy(this.size);
        this.healthBar.backgroundColor = Color_1.default.RED;
        this.healthBarBg = this.scene.add.uiElement(UIElementTypes_1.UIElementType.LABEL, layer, { position: this.owner.position.clone().add(this.offset), text: "" });
        this.healthBarBg.backgroundColor = Color_1.default.TRANSPARENT;
        this.healthBarBg.borderColor = Color_1.default.BLACK;
        this.healthBarBg.borderWidth = 1;
        this.healthBarBg.size.copy(this.size);
    }
    /**
     * Updates the healthbars position according to the position of it's owner
     * @param deltaT
     */
    update(deltaT) {
        this.healthBar.position.copy(this.owner.position).add(this.offset);
        this.healthBarBg.position.copy(this.owner.position).add(this.offset);
        let scale = this.scene.getViewScale();
        this.healthBar.scale.scale(scale);
        this.healthBarBg.scale.scale(scale);
        let unit = this.healthBarBg.size.x / this.owner.maxHealth;
        this.healthBar.size.set(this.healthBarBg.size.x - unit * (this.owner.maxHealth - this.owner.health), this.healthBarBg.size.y);
        this.healthBar.position.set(this.healthBarBg.position.x - (unit / scale / 2) * (this.owner.maxHealth - this.owner.health), this.healthBarBg.position.y);
        this.healthBar.backgroundColor = this.owner.health < this.owner.maxHealth * 1 / 4 ? Color_1.default.RED : this.owner.health < this.owner.maxHealth * 3 / 4 ? Color_1.default.YELLOW : Color_1.default.GREEN;
    }
    get ownerId() { return this.owner.id; }
    set visible(visible) {
        this.healthBar.visible = visible;
        this.healthBarBg.visible = visible;
    }
}
exports.default = HealthbarHUD;

},{"../../../Wolfie2D/Nodes/UIElements/UIElementTypes":60,"../../../Wolfie2D/Utils/Color":106}],136:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const UIElementTypes_1 = require("../../../Wolfie2D/Nodes/UIElements/UIElementTypes");
const Vec2_1 = __importDefault(require("../../../Wolfie2D/DataTypes/Vec2"));
const Color_1 = __importDefault(require("../../../Wolfie2D/Utils/Color"));
/**
 * Manages the player inventory that is displayed in the UI. Fun fact, I actually managed to port this
 * class from my old CSE-380 project from last semester.
 * @author PeteyLumpkins
 */
class InventoryHUD {
    constructor(scene, inventory, slotSprite, options) {
        this.scene = scene;
        this.inventory = inventory;
        this.slotSprite = slotSprite;
        // Set the size and padding for the item slots
        this.size = this.inventory.capacity;
        this.padding = options.padding;
        this.start = options.start;
        // Init the layers for the items
        this.slotLayer = options.slotLayer;
        this.itemLayer = options.itemLayer;
        // Set up the scales for scaling to the viewport
        let scale = scene.getViewScale();
        let scalar = new Vec2_1.default(scale, scale);
        // Load the item slot sprites
        this.itemSlots = new Array();
        for (let i = 0; i < this.size; i += 1) {
            this.itemSlots[i] = this.scene.add.sprite(this.slotSprite, this.slotLayer);
            this.itemSlots[i].scale.div(scalar);
        }
        // Set the positions of the item slot sprites
        let width = this.itemSlots[0].size.x;
        let height = this.itemSlots[0].size.y;
        for (let i = 0; i < this.size; i += 1) {
            this.itemSlots[i].position.set(this.start.x + i * (width + this.padding), this.start.y).div(scalar);
        }
        // Set the slot numbers in the user interface
        this.itemSlotNums = new Array();
        for (let i = 0; i < this.size; i += 1) {
            this.itemSlotNums[i] = this.scene.add.uiElement(UIElementTypes_1.UIElementType.LABEL, this.slotLayer, { position: new Vec2_1.default(this.start.x + i * (width + this.padding), this.start.y + height / 2 + 8).div(scalar), text: `${i + 1}` });
            this.itemSlotNums[i].fontSize = 12;
            this.itemSlotNums[i].font = "Courier";
            this.itemSlotNums[i].textColor = Color_1.default.WHITE;
        }
    }
    update(deltaT) {
        let index = 0;
        for (let item of this.inventory.items()) {
            item.position.copy(this.itemSlots[index].position);
            item.visible = true;
            index += 1;
        }
    }
}
exports.default = InventoryHUD;

},{"../../../Wolfie2D/DataTypes/Vec2":26,"../../../Wolfie2D/Nodes/UIElements/UIElementTypes":60,"../../../Wolfie2D/Utils/Color":106}],137:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Emitter_1 = __importDefault(require("../../../Wolfie2D/Events/Emitter"));
/**
 * An inventory is a collection of items. All items in the inventory must be registered with
 * the Inventorys ItemManager class.
 */
class Inventory {
    constructor(capacity = 10) {
        this.__id = Inventory.NEXT_ID;
        Inventory.NEXT_ID += 1;
        this.inventory = new Map();
        this._emitter = new Emitter_1.default();
        this.size = 0;
        this.capacity = capacity;
        this.dirty = false;
        this.onChange = null;
    }
    get id() { return this.__id; }
    get dirty() { return this._dirty; }
    set dirty(dirty) { this._dirty = dirty; }
    get size() { return this._size; }
    set size(size) { this._size = size; }
    get capacity() { return this._capacity; }
    set capacity(capacity) { this._capacity = capacity; }
    get onChange() { return this._onChange; }
    set onChange(onChange) { this._onChange = onChange; }
    get inventory() { return this._inventory; }
    set inventory(inventory) { this._inventory = inventory; }
    get emitter() { return this._emitter; }
    set emitter(emitter) { this._emitter = emitter; }
    /**
     * Gets an item from this inventory by id.
     * @param id the id of the item to get
     * @returns the item if it exists; null otherwise
     */
    get(id) {
        if (!this.has(id)) {
            return null;
        }
        return this.inventory.get(id);
    }
    /**
     * Adds an item to this inventory
     * @param item adds an item to the inventory with the key of the items owner
     * @returns if the Item was successfully added to the inventory; null otherwise
     */
    add(item) {
        if (this.has(item.id) || this.size >= this.capacity || item.inventory !== null) {
            return null;
        }
        this.inventory.set(item.id, item);
        this.size += 1;
        this.dirty = true;
        item.inventory = this;
        item.visible = false;
        return item;
    }
    /**
     * Checks if an item with the given id number exists in this inventory.
     * @param id the id of the item in the inventory
     * @returns true if the item with the id exists; false otherwise
     */
    has(id) {
        return this.inventory.has(id);
    }
    /**
     * Removes the item with the given id number from this inventory
     * @param id the id of the item
     * @returns the item that was removed or null
     */
    remove(id) {
        if (!this.has(id)) {
            return null;
        }
        let item = this.get(id);
        this.inventory.delete(id);
        this.size -= 1;
        this.dirty = true;
        item.inventory = null;
        return item;
    }
    items() {
        return this.inventory.values();
    }
    find(func) {
        let item = Array.from(this.inventory.values()).find(func);
        return item === undefined ? null : item;
    }
    clean() {
        this.dirty = false;
        if (this.onChange !== null) {
            this.emitter.fireEvent(this.onChange, { id: this.id, inventory: this });
        }
    }
}
exports.default = Inventory;
/** The id number of the next inventory */
Inventory.NEXT_ID = 0;

},{"../../../Wolfie2D/Events/Emitter":29}],138:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Emitter_1 = __importDefault(require("../../../Wolfie2D/Events/Emitter"));
const BasicTargetable_1 = __importDefault(require("../Targeting/BasicTargetable"));
class Item {
    constructor(sprite) {
        this.sprite = sprite;
        this.emitter = new Emitter_1.default();
        this._inventory = null;
        this._targetable = new BasicTargetable_1.default(this.sprite);
    }
    getTargeting() {
        return this._targetable.getTargeting();
    }
    addTargeting(targeting) {
        this._targetable.addTargeting(targeting);
    }
    removeTargeting(targeting) {
        this._targetable.removeTargeting(targeting);
    }
    get relativePosition() { return this.sprite.relativePosition; }
    get id() { return this.sprite.id; }
    get position() { return this.sprite.position; }
    get visible() { return this.sprite.visible; }
    set visible(value) { this.sprite.visible = value; }
    get inventory() { return this._inventory; }
    set inventory(value) { this._inventory = value; }
}
exports.default = Item;

},{"../../../Wolfie2D/Events/Emitter":29,"../Targeting/BasicTargetable":144}],139:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Item_1 = __importDefault(require("../Item"));
class Healthpack extends Item_1.default {
    constructor(sprite) {
        super(sprite);
        this.hp = 5;
    }
    get health() { return this.hp; }
    set health(hp) { this.hp = hp; }
}
exports.default = Healthpack;

},{"../Item":138}],140:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../../../../Wolfie2D/DataTypes/Vec2"));
const GameNode_1 = require("../../../../Wolfie2D/Nodes/GameNode");
const Color_1 = __importDefault(require("../../../../Wolfie2D/Utils/Color"));
const EaseFunctions_1 = require("../../../../Wolfie2D/Utils/EaseFunctions");
const Item_1 = __importDefault(require("../Item"));
class LaserGun extends Item_1.default {
    constructor(sprite, laser) {
        super(sprite);
        this._laser = laser;
        this._laser.start.copy(Vec2_1.default.ZERO_STATIC);
        this._laser.end.copy(Vec2_1.default.ZERO_STATIC);
        this._laser.color = Color_1.default.GREEN;
        this._laser.tweens.add("fade", {
            startDelay: 0,
            duration: 300,
            effects: [
                {
                    property: GameNode_1.TweenableProperties.alpha,
                    start: 1,
                    end: 0,
                    ease: EaseFunctions_1.EaseFunctionType.OUT_SINE
                }
            ],
            onEnd: "Laser faded"
        });
        this._direction = Vec2_1.default.ZERO;
    }
    static create(sprite, laser) {
        return new LaserGun(sprite, laser);
    }
    get direction() { return this._direction; }
    get laserStart() { return this._laser.start; }
    get laserEnd() { return this._laser.end; }
    playShootAnimation() { this._laser.tweens.play("fade"); }
}
exports.default = LaserGun;

},{"../../../../Wolfie2D/DataTypes/Vec2":26,"../../../../Wolfie2D/Nodes/GameNode":42,"../../../../Wolfie2D/Utils/Color":106,"../../../../Wolfie2D/Utils/EaseFunctions":107,"../Item":138}],141:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class BasicFinder {
    constructor(reducer = null, ...filters) {
        this.reducer = reducer;
        this.filters = filters;
    }
    find(targets) {
        let filtered = targets.filter(target => this.filters.every(filter => filter(target)));
        return filtered.length === 0 ? null : this.reducer === null ? filtered[0] : filtered.reduce(this.reducer);
    }
}
exports.default = BasicFinder;

},{}],142:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VisibleItemFilter = exports.ItemFilter = exports.RangeFilter = exports.EnemyFilter = exports.AllyFilter = exports.BattlerGroupFilter = exports.BattlerHealthFilter = exports.BattlerActiveFilter = void 0;
const MathUtils_1 = __importDefault(require("../../../Wolfie2D/Utils/MathUtils"));
function BattlerActiveFilter() {
    return (b) => b.battlerActive;
}
exports.BattlerActiveFilter = BattlerActiveFilter;
function BattlerHealthFilter(min, max) {
    return (b) => { return MathUtils_1.default.between(min, max, b.health, true); };
}
exports.BattlerHealthFilter = BattlerHealthFilter;
function BattlerGroupFilter(groups, whitelist = true) {
    return whitelist ? (b) => { return groups.includes(b.battleGroup); } : (b) => { return !groups.includes(b.battleGroup); };
}
exports.BattlerGroupFilter = BattlerGroupFilter;
function AllyFilter(battler) {
    return (other) => { return battler.battleGroup === other.battleGroup; };
}
exports.AllyFilter = AllyFilter;
function EnemyFilter(battler) {
    return (other) => { return battler.battleGroup !== other.battleGroup; };
}
exports.EnemyFilter = EnemyFilter;
function RangeFilter(positioned, minDistSq, maxDistSq) {
    return (t) => {
        let distSq = t.position.distanceSqTo(positioned.position);
        return distSq > minDistSq && distSq < maxDistSq;
    };
}
exports.RangeFilter = RangeFilter;
function ItemFilter(constr) {
    return (i) => { return i.constructor === constr; };
}
exports.ItemFilter = ItemFilter;
function VisibleItemFilter() {
    return (i) => i.visible;
}
exports.VisibleItemFilter = VisibleItemFilter;

},{"../../../Wolfie2D/Utils/MathUtils":109}],143:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LowestHealthBattler = exports.ClosestPositioned = void 0;
function ClosestPositioned(positioned) {
    return (p1, p2) => {
        return p1.position.distanceSqTo(positioned.position) < p2.position.distanceSqTo(positioned.position) ? p1 : p2;
    };
}
exports.ClosestPositioned = ClosestPositioned;
function LowestHealthBattler(b1, b2) {
    return b1.health < b2.health ? b1 : b2;
}
exports.LowestHealthBattler = LowestHealthBattler;

},{}],144:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class BasicTargetable {
    constructor(owner) {
        this.owner = owner;
        this.targeting = new Map();
    }
    getTargeting() {
        return Array.from(this.targeting.values());
    }
    addTargeting(targeting) {
        this.targeting.set(targeting.id, targeting);
    }
    removeTargeting(targeting) {
        this.targeting.delete(targeting.id);
    }
    get position() { return this.owner.position; }
    get relativePosition() { return this.owner.relativePosition; }
}
exports.default = BasicTargetable;

},{}],145:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class BasicTargeting {
    constructor(owner) {
        this.owner = owner;
        this.target = null;
    }
    clearTarget() {
        if (this.target !== null) {
            this.target.removeTargeting(this);
        }
        this._target = null;
    }
    setTarget(targetable) {
        if (this.target !== null) {
            this.target.removeTargeting(this);
        }
        this.target = targetable;
        this.target.addTargeting(this);
    }
    getTarget() {
        if (this.target === null) {
            throw new Error("Target not set!");
        }
        return this.target;
    }
    hasTarget() {
        return this.target !== null;
    }
    get id() { return this.owner.id; }
    get target() { return this._target; }
    set target(target) { this._target = target; }
}
exports.default = BasicTargeting;

},{}],146:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../../../Wolfie2D/DataTypes/Vec2"));
/**
 * A wrapper class around a Vec2 implementing the Positioned interface. The point
 * of this class is to let you use an arbitrary position as a TargetableEntity.
 */
class Position {
    constructor(x, y) {
        this._position = new Vec2_1.default(x, y);
    }
    get position() {
        return this._position;
    }
}
exports.default = Position;

},{"../../../Wolfie2D/DataTypes/Vec2":26}],147:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Stack_1 = __importDefault(require("../../Wolfie2D/DataTypes/Collections/Stack"));
const Vec2_1 = __importDefault(require("../../Wolfie2D/DataTypes/Vec2"));
const NavigationPath_1 = __importDefault(require("../../Wolfie2D/Pathfinding/NavigationPath"));
const NavigationStrategy_1 = __importDefault(require("../../Wolfie2D/Pathfinding/Strategies/NavigationStrategy"));
class AstarStrategy extends NavigationStrategy_1.default {
    /**
     * @see NavPathStrat.buildPath()
     */
    buildPath(to, from) {
        let pathStack = new Stack_1.default(this.mesh.graph.numVertices);
        let startNode = { position: from, g: 0, h: from.distanceTo(to), f: from.distanceTo(to), parent: null };
        let openList = new Array(0);
        console.log(openList);
        let closedList = new Array(0);
        console.log(closedList);
        openList.push(startNode);
        console.log(openList);
        let currentNode;
        while (openList.length != 0) {
            currentNode = this.lowestF(openList);
            closedList.push(currentNode);
            openList.splice(openList.indexOf(currentNode), 1);
            console.log(openList);
            console.log("Current Pos: (" + currentNode.position.x + ", " + currentNode.position.y + ")");
            if (currentNode.position.equals(to))
                break;
            let aroundNodes = this.getaroundNodes(currentNode, to, closedList);
            for (let i = 0; i < aroundNodes.length; i++) {
                let existsInOpenList = false;
                for (let j = 0; j < openList.length; j++) {
                    if (openList[j].position.equals(aroundNodes[i].position)) {
                        if (openList[j].g > aroundNodes[i].g) {
                            openList[j].parent = aroundNodes[i].parent;
                            openList[j].g = aroundNodes[i].g;
                            openList[j].h = aroundNodes[i].h;
                            openList[j].f = aroundNodes[i].f;
                        }
                        existsInOpenList = true;
                    }
                }
                if (!existsInOpenList) {
                    openList.push(aroundNodes[i]);
                }
            }
        }
        let trackingNode = currentNode;
        let stack = new Stack_1.default(this.mesh.graph.numVertices);
        while (trackingNode.parent != null) {
            console.log("Tracking Pos: (" + trackingNode.position.x + ", " + trackingNode.position.y + ")");
            pathStack.push(trackingNode.position);
            trackingNode = trackingNode.parent;
        }
        return new NavigationPath_1.default(pathStack);
    }
    wallCheck(pos) {
        for (let i = 0; i < this.mesh.graph.numVertices; i++) {
            if (this.mesh.graph.getNodePosition(i).distanceTo(pos) < 2) {
                return true;
            }
        }
        return false;
    }
    lowestF(nodeList) {
        let lowest = nodeList[0];
        for (let i = 0; i < nodeList.length; i++) {
            let temp = nodeList[i];
            if (lowest.f > temp.f)
                lowest = temp;
        }
        return lowest;
    }
    listCheck(node, checklist) {
        for (let i = 0; i < checklist.length; i++) {
            if (checklist[i].position.equals(node.position)) {
                return true;
            }
        }
        return false;
    }
    getaroundNodes(currentNode, to, closed) {
        let aroundNodes = new Array;
        let currentPos = currentNode.position;
        let leftMiddlePos = new Vec2_1.default(currentPos.x - 1, currentPos.y);
        let leftUpPos = new Vec2_1.default(currentPos.x - 1, currentPos.y - 1);
        let leftDownPos = new Vec2_1.default(currentPos.x - 1, currentPos.y + 1);
        let middleUpPos = new Vec2_1.default(currentPos.x, currentPos.y - 1);
        let middleDownPos = new Vec2_1.default(currentPos.x, currentPos.y + 1);
        let rightMiddlePos = new Vec2_1.default(currentPos.x + 1, currentPos.y);
        let rightUpPos = new Vec2_1.default(currentPos.x + 1, currentPos.y - 1);
        let rightDownPos = new Vec2_1.default(currentPos.x + 1, currentPos.y + 1);
        let leftMiddleNode = { position: leftMiddlePos,
            g: currentNode.g + currentPos.distanceTo(leftMiddlePos),
            h: leftMiddlePos.distanceTo(to),
            f: currentNode.g + currentPos.distanceTo(leftMiddlePos) + leftMiddlePos.distanceTo(to),
            parent: currentNode };
        let leftUpNode = { position: leftUpPos,
            g: currentNode.g + currentPos.distanceTo(leftUpPos),
            h: leftMiddlePos.distanceTo(to),
            f: currentNode.g + currentPos.distanceTo(leftUpPos) + leftMiddlePos.distanceTo(to),
            parent: currentNode };
        let leftDownNode = { position: leftDownPos,
            g: currentNode.g + currentPos.distanceTo(leftDownPos),
            h: leftMiddlePos.distanceTo(to),
            f: currentNode.g + currentPos.distanceTo(leftDownPos) + leftMiddlePos.distanceTo(to),
            parent: currentNode };
        let middleUpNode = { position: middleUpPos,
            g: currentNode.g + currentPos.distanceTo(middleUpPos),
            h: leftMiddlePos.distanceTo(to),
            f: currentNode.g + currentPos.distanceTo(middleUpPos) + leftMiddlePos.distanceTo(to),
            parent: currentNode };
        let middleDownNode = { position: middleDownPos,
            g: currentNode.g + currentPos.distanceTo(middleDownPos),
            h: leftMiddlePos.distanceTo(to),
            f: currentNode.g + currentPos.distanceTo(middleDownPos) + leftMiddlePos.distanceTo(to),
            parent: currentNode };
        let rightMiddleNode = { position: rightMiddlePos,
            g: currentNode.g + currentPos.distanceTo(rightMiddlePos),
            h: leftMiddlePos.distanceTo(to),
            f: currentNode.g + currentPos.distanceTo(rightMiddlePos) + leftMiddlePos.distanceTo(to),
            parent: currentNode };
        let rightUpNode = { position: rightUpPos,
            g: currentNode.g + currentPos.distanceTo(rightUpPos),
            h: leftMiddlePos.distanceTo(to),
            f: currentNode.g + currentPos.distanceTo(rightUpPos) + leftMiddlePos.distanceTo(to),
            parent: currentNode };
        let rightDownNode = { position: rightDownPos,
            g: currentNode.g + currentPos.distanceTo(rightDownPos),
            h: leftMiddlePos.distanceTo(to),
            f: currentNode.g + currentPos.distanceTo(rightDownPos) + leftMiddlePos.distanceTo(to),
            parent: currentNode };
        if (this.wallCheck(leftMiddlePos) == false
            && this.listCheck(leftMiddleNode, closed) == false
            && leftMiddlePos.x > 0 && leftMiddlePos.y > 0)
            aroundNodes.push(leftMiddleNode);
        if (this.wallCheck(leftUpPos) == false
            && this.listCheck(leftUpNode, closed) == false
            && leftUpPos.x > 0 && leftUpPos.y > 0)
            aroundNodes.push(leftUpNode);
        if (this.wallCheck(middleUpPos) == false
            && !this.listCheck(middleUpNode, closed) == false
            && middleUpPos.x > 0 && middleUpPos.y > 0)
            aroundNodes.push(middleUpNode);
        if (this.wallCheck(rightUpPos) == false
            && this.listCheck(rightUpNode, closed) == false
            && rightUpPos.x > 0 && rightUpPos.y > 0)
            aroundNodes.push(rightUpNode);
        if (this.wallCheck(rightMiddlePos) == false
            && this.listCheck(rightMiddleNode, closed) == false
            && rightMiddlePos.x > 0 && rightMiddlePos.y > 0)
            aroundNodes.push(rightMiddleNode);
        if (this.wallCheck(rightDownPos) == false
            && this.listCheck(rightDownNode, closed) == false
            && rightDownPos.x > 0 && rightDownPos.y > 0)
            aroundNodes.push(rightDownNode);
        if (this.wallCheck(middleDownPos) == false
            && this.listCheck(middleDownNode, closed) == false
            && middleDownPos.x > 0 && middleDownPos.y > 0)
            aroundNodes.push(middleDownNode);
        if (this.wallCheck(leftDownPos) == false
            && this.listCheck(leftDownNode, closed) == false
            && leftDownPos.x > 0 && leftDownPos.y > 0)
            aroundNodes.push(leftDownNode);
        return aroundNodes;
    }
}
exports.default = AstarStrategy;

},{"../../Wolfie2D/DataTypes/Collections/Stack":10,"../../Wolfie2D/DataTypes/Vec2":26,"../../Wolfie2D/Pathfinding/NavigationPath":62,"../../Wolfie2D/Pathfinding/Strategies/NavigationStrategy":66}],148:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const PositionGraph_1 = __importDefault(require("../../Wolfie2D/DataTypes/Graphs/PositionGraph"));
const Vec2_1 = __importDefault(require("../../Wolfie2D/DataTypes/Vec2"));
const GraphicTypes_1 = require("../../Wolfie2D/Nodes/Graphics/GraphicTypes");
const Navmesh_1 = __importDefault(require("../../Wolfie2D/Pathfinding/Navmesh"));
const DirectStrategy_1 = __importDefault(require("../../Wolfie2D/Pathfinding/Strategies/DirectStrategy"));
const DjikstraStrategy_1 = __importDefault(require("../../Wolfie2D/Pathfinding/Strategies/DjikstraStrategy"));
const Scene_1 = __importDefault(require("../../Wolfie2D/Scene/Scene"));
const Color_1 = __importDefault(require("../../Wolfie2D/Utils/Color"));
const MathUtils_1 = __importDefault(require("../../Wolfie2D/Utils/MathUtils"));
const NPCActor_1 = __importDefault(require("../Actors/NPCActor"));
const AstarStrategy_1 = __importDefault(require("../Pathfinding/AstarStrategy"));
const MainMenu_1 = __importDefault(require("./MainMenu"));
/**
 * This is a dummy scene to test if your implementation of A* is working or not. If your implementation
 * is working correctly, you should see the blue npc make it's way to the small blue box in the top-right
 * corner of the screen.
 */
class AStarDemoScene extends Scene_1.default {
    loadScene() {
        this.load.tilemap("level", "hw4_assets/tilemaps/HW4Tilemap.json");
        this.load.spritesheet("BlueEnemy", "hw4_assets/spritesheets/BlueEnemy.json");
    }
    startScene() {
        let tilemapLayers = this.add.tilemap("level");
        let walls = tilemapLayers[1].getItems()[0];
        this.viewport.setBounds(0, 0, walls.size.x, walls.size.y);
        this.viewport.setZoomLevel(2);
        this.addLayer("primary", 10);
        // Initialize a navmesh covering the tilemap
        let navmesh = this.initializeNavmesh(new PositionGraph_1.default(), walls);
        this.navManager.addNavigableEntity("navmesh", navmesh);
        // Register the different pathfinding strategies with the navmesh
        navmesh.registerStrategy("direct", new DirectStrategy_1.default(navmesh));
        navmesh.registerStrategy("astar", new AstarStrategy_1.default(navmesh));
        navmesh.registerStrategy("dijkstra", new DjikstraStrategy_1.default(navmesh));
        // TODO Set the navigation strategy to be A*
        navmesh.setStrategy("astar");
        // Create a dummy NPC
        this.npc = this.add.animatedSprite(NPCActor_1.default, "BlueEnemy", "primary");
        this.npc.addPhysics();
        this.npc.position.copy(new Vec2_1.default(25, 450));
        this.destination = new Vec2_1.default(450, 25);
        // The little blue rectangle in the top-right is where the NPC is trying to get to
        let destination = this.add.graphic(GraphicTypes_1.GraphicType.RECT, "primary", { position: this.destination, size: new Vec2_1.default(20, 20) });
        destination.color = Color_1.default.BLUE;
        destination.color.a = .50;
        // Construct a path using the navmesh from the npc's position to the target destination
        this.path = navmesh.getNavigationPath(this.npc.position, this.destination);
    }
    updateScene(deltaT) {
        // Move the npc along the path
        this.npc.moveOnPath(1, this.path);
        if (this.npc.position.equals(this.destination)) {
            this.sceneManager.changeToScene(MainMenu_1.default);
        }
    }
    /**
     * Initializes the navmesh graph used by the NPCs in the HW4Scene. This method is a little buggy, and
     * and it skips over some of the positions on the tilemap. If you can fix my navmesh generation algorithm,
     * go for it.
     * @author PeteyLumpkins
     */
    initializeNavmesh(graph, walls) {
        let dim = walls.getDimensions();
        for (let i = 0; i < dim.y; i++) {
            for (let j = 0; j < dim.x; j++) {
                let tile = walls.getTileCollider(j, i);
                graph.addPositionedNode(tile.center);
            }
        }
        let rc;
        for (let i = 0; i < graph.numVertices; i++) {
            rc = walls.getTileColRow(i);
            if (!walls.isTileCollidable(rc.x, rc.y) &&
                !walls.isTileCollidable(MathUtils_1.default.clamp(rc.x - 1, 0, dim.x - 1), rc.y) &&
                !walls.isTileCollidable(MathUtils_1.default.clamp(rc.x + 1, 0, dim.x - 1), rc.y) &&
                !walls.isTileCollidable(rc.x, MathUtils_1.default.clamp(rc.y - 1, 0, dim.y - 1)) &&
                !walls.isTileCollidable(rc.x, MathUtils_1.default.clamp(rc.y + 1, 0, dim.y - 1)) &&
                !walls.isTileCollidable(MathUtils_1.default.clamp(rc.x + 1, 0, dim.x - 1), MathUtils_1.default.clamp(rc.y + 1, 0, dim.y - 1)) &&
                !walls.isTileCollidable(MathUtils_1.default.clamp(rc.x - 1, 0, dim.x - 1), MathUtils_1.default.clamp(rc.y + 1, 0, dim.y - 1)) &&
                !walls.isTileCollidable(MathUtils_1.default.clamp(rc.x + 1, 0, dim.x - 1), MathUtils_1.default.clamp(rc.y - 1, 0, dim.y - 1)) &&
                !walls.isTileCollidable(MathUtils_1.default.clamp(rc.x - 1, 0, dim.x - 1), MathUtils_1.default.clamp(rc.y - 1, 0, dim.y - 1))) {
                // Create edge to the left
                rc = walls.getTileColRow(i + 1);
                if ((i + 1) % dim.x !== 0 && !walls.isTileCollidable(rc.x, rc.y)) {
                    graph.addEdge(i, i + 1);
                    // this.add.graphic(GraphicType.LINE, "graph", {start: this.graph.getNodePosition(i), end: this.graph.getNodePosition(i + 1)})
                }
                // Create edge below
                rc = walls.getTileColRow(i + dim.x);
                if (i + dim.x < graph.numVertices && !walls.isTileCollidable(rc.x, rc.y)) {
                    graph.addEdge(i, i + dim.x);
                    // this.add.graphic(GraphicType.LINE, "graph", {start: this.graph.getNodePosition(i), end: this.graph.getNodePosition(i + dim.x)})
                }
            }
        }
        // Set this graph as a navigable entity
        return new Navmesh_1.default(graph);
    }
}
exports.default = AStarDemoScene;

},{"../../Wolfie2D/DataTypes/Graphs/PositionGraph":14,"../../Wolfie2D/DataTypes/Vec2":26,"../../Wolfie2D/Nodes/Graphics/GraphicTypes":44,"../../Wolfie2D/Pathfinding/Navmesh":63,"../../Wolfie2D/Pathfinding/Strategies/DirectStrategy":64,"../../Wolfie2D/Pathfinding/Strategies/DjikstraStrategy":65,"../../Wolfie2D/Scene/Scene":97,"../../Wolfie2D/Utils/Color":106,"../../Wolfie2D/Utils/MathUtils":109,"../Actors/NPCActor":131,"../Pathfinding/AstarStrategy":147,"./MainMenu":152}],149:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const PositionGraph_1 = __importDefault(require("../../Wolfie2D/DataTypes/Graphs/PositionGraph"));
const AABB_1 = __importDefault(require("../../Wolfie2D/DataTypes/Shapes/AABB"));
const Vec2_1 = __importDefault(require("../../Wolfie2D/DataTypes/Vec2"));
const GraphicTypes_1 = require("../../Wolfie2D/Nodes/Graphics/GraphicTypes");
const Navmesh_1 = __importDefault(require("../../Wolfie2D/Pathfinding/Navmesh"));
const DirectStrategy_1 = __importDefault(require("../../Wolfie2D/Pathfinding/Strategies/DirectStrategy"));
const MathUtils_1 = __importDefault(require("../../Wolfie2D/Utils/MathUtils"));
const NPCActor_1 = __importDefault(require("../Actors/NPCActor"));
const PlayerActor_1 = __importDefault(require("../Actors/PlayerActor"));
const GaurdBehavior_1 = __importDefault(require("../AI/NPC/NPCBehavior/GaurdBehavior"));
const PlayerAI_1 = __importDefault(require("../AI/Player/PlayerAI"));
const Events_1 = require("../Events");
const HealthbarHUD_1 = __importDefault(require("../GameSystems/HUD/HealthbarHUD"));
const LaserGun_1 = __importDefault(require("../GameSystems/ItemSystem/Items/LaserGun"));
const HW4Reducers_1 = require("../GameSystems/Searching/HW4Reducers");
const BasicTargetable_1 = __importDefault(require("../GameSystems/Targeting/BasicTargetable"));
const Position_1 = __importDefault(require("../GameSystems/Targeting/Position"));
const AstarStrategy_1 = __importDefault(require("../Pathfinding/AstarStrategy"));
const HW4Scene_1 = __importDefault(require("./HW4Scene"));
class GuardDemoScene extends HW4Scene_1.default {
    constructor(viewport, sceneManager, renderingManager, options) {
        super(viewport, sceneManager, renderingManager, options);
        this.battlers = new Array();
        this.healthbars = new Map();
        this.laserguns = new Array();
        this.healthpacks = new Array();
    }
    /**
     * @see Scene.update()
     */
    loadScene() {
        // Load the player and enemy spritesheets
        this.load.spritesheet("player1", "hw4_assets/spritesheets/player1.json");
        // Load in the enemy sprites
        this.load.spritesheet("BlueEnemy", "hw4_assets/spritesheets/BlueEnemy.json");
        this.load.spritesheet("RedEnemy", "hw4_assets/spritesheets/RedEnemy.json");
        this.load.spritesheet("BlueHealer", "hw4_assets/spritesheets/BlueHealer.json");
        this.load.spritesheet("RedHealer", "hw4_assets/spritesheets/RedHealer.json");
        // Load the tilemap
        this.load.tilemap("level", "hw4_assets/tilemaps/HW4Tilemap.json");
        // Load the enemy locations
        this.load.object("red", "hw4_assets/data/enemies/red.json");
        this.load.object("blue", "hw4_assets/data/enemies/blue.json");
        // Load the healthpack and lasergun loactions
        this.load.object("healthpacks", "hw4_assets/data/items/healthpacks.json");
        this.load.object("laserguns", "hw4_assets/data/items/laserguns.json");
        // Load the healthpack, inventory slot, and laser gun sprites
        this.load.image("healthpack", "hw4_assets/sprites/healthpack.png");
        this.load.image("inventorySlot", "hw4_assets/sprites/inventory.png");
        this.load.image("laserGun", "hw4_assets/sprites/laserGun.png");
    }
    /**
     * @see Scene.startScene
     */
    startScene() {
        // Add in the tilemap
        let tilemapLayers = this.add.tilemap("level");
        // Get the wall layer
        this.walls = tilemapLayers[1].getItems()[0];
        // Set the viewport bounds to the tilemap
        let tilemapSize = this.walls.size;
        this.viewport.setBounds(0, 0, tilemapSize.x, tilemapSize.y);
        this.viewport.setZoomLevel(2);
        this.initLayers();
        // Create the player
        this.initializePlayer();
        this.initializeItems();
        this.initializeNavmesh();
        // Create the NPCS
        this.initializeNPCs();
        // Subscribe to relevant events
        this.receiver.subscribe("healthpack");
        this.receiver.subscribe("enemyDied");
        this.receiver.subscribe(Events_1.ItemEvent.ITEM_REQUEST);
        // Add a UI for health
        this.addUILayer("health");
        this.receiver.subscribe(Events_1.PlayerEvent.PLAYER_KILLED);
        this.receiver.subscribe(Events_1.BattlerEvent.BATTLER_KILLED);
        this.receiver.subscribe(Events_1.BattlerEvent.BATTLER_RESPAWN);
    }
    /**
     * @see Scene.updateScene
     */
    updateScene(deltaT) {
        while (this.receiver.hasNextEvent()) {
            this.handleEvent(this.receiver.getNextEvent());
        }
        this.healthbars.forEach(healthbar => healthbar.update(deltaT));
    }
    /**
     * Handle events from the rest of the game
     * @param event a game event
     */
    handleEvent(event) {
        switch (event.type) {
            case Events_1.BattlerEvent.BATTLER_KILLED: {
                break;
            }
            case Events_1.BattlerEvent.BATTLER_RESPAWN: {
                break;
            }
            case Events_1.ItemEvent.ITEM_REQUEST: {
                this.handleItemRequest(event.data.get("node"), event.data.get("inventory"));
                break;
            }
            default: {
                throw new Error(`Unhandled event type "${event.type}" caught in HW4Scene event handler`);
            }
        }
    }
    handleItemRequest(node, inventory) {
        let items = new Array(...this.healthpacks, ...this.laserguns).filter((item) => {
            return item.inventory === null && item.position.distanceTo(node.position) <= 100;
        });
        if (items.length > 0) {
            inventory.add(items.reduce((0, HW4Reducers_1.ClosestPositioned)(node)));
        }
    }
    /** Initializes the layers in the scene */
    initLayers() {
        this.addLayer("primary", 10);
        this.addUILayer("slots");
        this.addUILayer("items");
        this.getLayer("slots").setDepth(1);
        this.getLayer("items").setDepth(2);
    }
    /**
     * Initializes the player in the scene
     */
    initializePlayer() {
        let player = this.add.animatedSprite(PlayerActor_1.default, "player1", "primary");
        player.position.set(40, 40);
        player.battleGroup = 2;
        player.health = 10;
        player.maxHealth = 10;
        player.inventory.onChange = Events_1.ItemEvent.INVENTORY_CHANGED;
        player.addPhysics(new AABB_1.default(Vec2_1.default.ZERO, new Vec2_1.default(8, 8)));
        let healthbar = new HealthbarHUD_1.default(this, player, "primary", { size: player.size.clone().scaled(2, 1 / 2), offset: player.size.clone().scaled(0, -1 / 2) });
        this.healthbars.set(player.id, healthbar);
        player.addAI(PlayerAI_1.default);
        player.animation.play("IDLE");
        this.player = player;
        this.battlers.push(player);
        this.viewport.follow(player);
    }
    /**
     * Initialize the NPCs
     */
    initializeNPCs() {
        // Get the object data for the red enemies
        let red = this.load.getObject("red");
        let npc = this.add.animatedSprite(NPCActor_1.default, "RedEnemy", "primary");
        npc.position.set(red.enemies[0][0], red.enemies[0][1]);
        npc.addPhysics(new AABB_1.default(Vec2_1.default.ZERO, new Vec2_1.default(7, 7)), null, false);
        let healthbar = new HealthbarHUD_1.default(this, npc, "primary", { size: npc.size.clone().scaled(2, 1 / 2), offset: npc.size.clone().scaled(0, -1 / 2) });
        this.healthbars.set(npc.id, healthbar);
        npc.battleGroup = 1;
        npc.speed = 5;
        npc.health = 10;
        npc.maxHealth = 10;
        npc.navkey = "navmesh";
        npc.addAI(GaurdBehavior_1.default, { target: new BasicTargetable_1.default(new Position_1.default(npc.position.x, npc.position.y)), range: 100 });
        npc.animation.play("IDLE");
        this.battlers.push(npc);
        // Setup the followers
        let follower1 = this.add.animatedSprite(NPCActor_1.default, "RedEnemy", "primary");
        follower1.position.set(red.enemies[1][0], red.enemies[1][1]);
        follower1.addPhysics(new AABB_1.default(Vec2_1.default.ZERO, new Vec2_1.default(7, 7)), null, false);
        healthbar = new HealthbarHUD_1.default(this, follower1, "primary", { size: follower1.size.clone().scaled(2, 1 / 2), offset: follower1.size.clone().scaled(0, -1 / 2) });
        this.healthbars.set(follower1.id, healthbar);
        follower1.battleGroup = 2;
        follower1.speed = 5;
        follower1.health = 10;
        follower1.maxHealth = 10;
        follower1.navkey = "navmesh";
        follower1.addAI(GaurdBehavior_1.default, { target: new BasicTargetable_1.default(this.player), range: 100 });
        follower1.animation.play("IDLE");
        this.battlers.push(npc);
        let follower2 = this.add.animatedSprite(NPCActor_1.default, "RedEnemy", "primary");
        follower2.position.set(red.enemies[0][0], red.enemies[0][1]);
        follower2.addPhysics(new AABB_1.default(Vec2_1.default.ZERO, new Vec2_1.default(7, 7)), null, false);
        healthbar = new HealthbarHUD_1.default(this, follower2, "primary", { size: follower2.size.clone().scaled(2, 1 / 2), offset: follower2.size.clone().scaled(0, -1 / 2) });
        this.healthbars.set(follower2.id, healthbar);
        follower2.battleGroup = 2;
        follower2.speed = 5;
        follower2.health = 10;
        follower2.maxHealth = 10;
        follower2.navkey = "navmesh";
        follower2.addAI(GaurdBehavior_1.default, { target: new BasicTargetable_1.default(follower1), range: 100 });
        follower2.animation.play("IDLE");
        this.battlers.push(follower2);
    }
    /**
     * Initialize the items in the scene (healthpacks and laser guns)
     */
    initializeItems() {
        let laserguns = this.load.getObject("laserguns");
        this.laserguns = new Array(laserguns.items.length);
        for (let i = 0; i < laserguns.items.length; i++) {
            let sprite = this.add.sprite("laserGun", "primary");
            let line = this.add.graphic(GraphicTypes_1.GraphicType.LINE, "primary", { start: Vec2_1.default.ZERO, end: Vec2_1.default.ZERO });
            this.laserguns[i] = LaserGun_1.default.create(sprite, line);
            this.laserguns[i].position.set(laserguns.items[i][0], laserguns.items[i][1]);
        }
    }
    /**
     * Initializes the navmesh graph used by the NPCs in the HW4Scene. This method is a little buggy, and
     * and it skips over some of the positions on the tilemap. If you can fix my navmesh generation algorithm,
     * go for it.
     *
     * - Peter
     */
    initializeNavmesh() {
        // Create the graph
        this.graph = new PositionGraph_1.default();
        let dim = this.walls.getDimensions();
        for (let i = 0; i < dim.y; i++) {
            for (let j = 0; j < dim.x; j++) {
                let tile = this.walls.getTileCollider(j, i);
                this.graph.addPositionedNode(tile.center);
            }
        }
        let rc;
        for (let i = 0; i < this.graph.numVertices; i++) {
            rc = this.walls.getTileColRow(i);
            if (!this.walls.isTileCollidable(rc.x, rc.y) &&
                !this.walls.isTileCollidable(MathUtils_1.default.clamp(rc.x - 1, 0, dim.x - 1), rc.y) &&
                !this.walls.isTileCollidable(MathUtils_1.default.clamp(rc.x + 1, 0, dim.x - 1), rc.y) &&
                !this.walls.isTileCollidable(rc.x, MathUtils_1.default.clamp(rc.y - 1, 0, dim.y - 1)) &&
                !this.walls.isTileCollidable(rc.x, MathUtils_1.default.clamp(rc.y + 1, 0, dim.y - 1)) &&
                !this.walls.isTileCollidable(MathUtils_1.default.clamp(rc.x + 1, 0, dim.x - 1), MathUtils_1.default.clamp(rc.y + 1, 0, dim.y - 1)) &&
                !this.walls.isTileCollidable(MathUtils_1.default.clamp(rc.x - 1, 0, dim.x - 1), MathUtils_1.default.clamp(rc.y + 1, 0, dim.y - 1)) &&
                !this.walls.isTileCollidable(MathUtils_1.default.clamp(rc.x + 1, 0, dim.x - 1), MathUtils_1.default.clamp(rc.y - 1, 0, dim.y - 1)) &&
                !this.walls.isTileCollidable(MathUtils_1.default.clamp(rc.x - 1, 0, dim.x - 1), MathUtils_1.default.clamp(rc.y - 1, 0, dim.y - 1))) {
                // Create edge to the left
                rc = this.walls.getTileColRow(i + 1);
                if ((i + 1) % dim.x !== 0 && !this.walls.isTileCollidable(rc.x, rc.y)) {
                    this.graph.addEdge(i, i + 1);
                    // this.add.graphic(GraphicType.LINE, "graph", {start: this.graph.getNodePosition(i), end: this.graph.getNodePosition(i + 1)})
                }
                // Create edge below
                rc = this.walls.getTileColRow(i + dim.x);
                if (i + dim.x < this.graph.numVertices && !this.walls.isTileCollidable(rc.x, rc.y)) {
                    this.graph.addEdge(i, i + dim.x);
                    // this.add.graphic(GraphicType.LINE, "graph", {start: this.graph.getNodePosition(i), end: this.graph.getNodePosition(i + dim.x)})
                }
            }
        }
        // Set this graph as a navigable entity
        let navmesh = new Navmesh_1.default(this.graph);
        // Add different strategies to use for this navmesh
        navmesh.registerStrategy("direct", new DirectStrategy_1.default(navmesh));
        navmesh.registerStrategy("astar", new AstarStrategy_1.default(navmesh));
        // Select A* as our navigation strategy
        navmesh.setStrategy("astar");
        // Add this navmesh to the navigation manager
        this.navManager.addNavigableEntity("navmesh", navmesh);
    }
    getBattlers() { return this.battlers; }
    getWalls() { return this.walls; }
    getHealthpacks() { return this.healthpacks; }
    getLaserGuns() { return this.laserguns; }
    isTargetVisible(position, target) {
        // Get the new player location
        let start = position.clone();
        let delta = target.clone().sub(start);
        // Iterate through the tilemap region until we find a collision
        let minX = Math.min(start.x, target.x);
        let maxX = Math.max(start.x, target.x);
        let minY = Math.min(start.y, target.y);
        let maxY = Math.max(start.y, target.y);
        // Get the wall tilemap
        let walls = this.getWalls();
        let minIndex = walls.getTilemapPosition(minX, minY);
        let maxIndex = walls.getTilemapPosition(maxX, maxY);
        let tileSize = walls.getScaledTileSize();
        for (let col = minIndex.x; col <= maxIndex.x; col++) {
            for (let row = minIndex.y; row <= maxIndex.y; row++) {
                if (walls.isTileCollidable(col, row)) {
                    // Get the position of this tile
                    let tilePos = new Vec2_1.default(col * tileSize.x + tileSize.x / 2, row * tileSize.y + tileSize.y / 2);
                    // Create a collider for this tile
                    let collider = new AABB_1.default(tilePos, tileSize.scaled(1 / 2));
                    let hit = collider.intersectSegment(start, delta, Vec2_1.default.ZERO);
                    if (hit !== null && start.distanceSqTo(hit.pos) < start.distanceSqTo(target)) {
                        // We hit a wall, we can't see the player
                        return false;
                    }
                }
            }
        }
        return true;
    }
}
exports.default = GuardDemoScene;

},{"../../Wolfie2D/DataTypes/Graphs/PositionGraph":14,"../../Wolfie2D/DataTypes/Shapes/AABB":20,"../../Wolfie2D/DataTypes/Vec2":26,"../../Wolfie2D/Nodes/Graphics/GraphicTypes":44,"../../Wolfie2D/Pathfinding/Navmesh":63,"../../Wolfie2D/Pathfinding/Strategies/DirectStrategy":64,"../../Wolfie2D/Utils/MathUtils":109,"../AI/NPC/NPCBehavior/GaurdBehavior":119,"../AI/Player/PlayerAI":124,"../Actors/NPCActor":131,"../Actors/PlayerActor":132,"../Events":133,"../GameSystems/HUD/HealthbarHUD":135,"../GameSystems/ItemSystem/Items/LaserGun":140,"../GameSystems/Searching/HW4Reducers":143,"../GameSystems/Targeting/BasicTargetable":144,"../GameSystems/Targeting/Position":146,"../Pathfinding/AstarStrategy":147,"./HW4Scene":150}],150:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Scene_1 = __importDefault(require("../../Wolfie2D/Scene/Scene"));
class HW4Scene extends Scene_1.default {
}
exports.default = HW4Scene;

},{"../../Wolfie2D/Scene/Scene":97}],151:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const PositionGraph_1 = __importDefault(require("../../Wolfie2D/DataTypes/Graphs/PositionGraph"));
const AABB_1 = __importDefault(require("../../Wolfie2D/DataTypes/Shapes/AABB"));
const Vec2_1 = __importDefault(require("../../Wolfie2D/DataTypes/Vec2"));
const GraphicTypes_1 = require("../../Wolfie2D/Nodes/Graphics/GraphicTypes");
const Navmesh_1 = __importDefault(require("../../Wolfie2D/Pathfinding/Navmesh"));
const DirectStrategy_1 = __importDefault(require("../../Wolfie2D/Pathfinding/Strategies/DirectStrategy"));
const DjikstraStrategy_1 = __importDefault(require("../../Wolfie2D/Pathfinding/Strategies/DjikstraStrategy"));
const MathUtils_1 = __importDefault(require("../../Wolfie2D/Utils/MathUtils"));
const RandUtils_1 = __importDefault(require("../../Wolfie2D/Utils/RandUtils"));
const NPCActor_1 = __importDefault(require("../Actors/NPCActor"));
const PlayerActor_1 = __importDefault(require("../Actors/PlayerActor"));
const GaurdBehavior_1 = __importDefault(require("../AI/NPC/NPCBehavior/GaurdBehavior"));
const HealerBehavior_1 = __importDefault(require("../AI/NPC/NPCBehavior/HealerBehavior"));
const PlayerAI_1 = __importDefault(require("../AI/Player/PlayerAI"));
const Events_1 = require("../Events");
const HealthbarHUD_1 = __importDefault(require("../GameSystems/HUD/HealthbarHUD"));
const InventoryHUD_1 = __importDefault(require("../GameSystems/HUD/InventoryHUD"));
const Healthpack_1 = __importDefault(require("../GameSystems/ItemSystem/Items/Healthpack"));
const LaserGun_1 = __importDefault(require("../GameSystems/ItemSystem/Items/LaserGun"));
const HW4Reducers_1 = require("../GameSystems/Searching/HW4Reducers");
const BasicTargetable_1 = __importDefault(require("../GameSystems/Targeting/BasicTargetable"));
const Position_1 = __importDefault(require("../GameSystems/Targeting/Position"));
const AstarStrategy_1 = __importDefault(require("../Pathfinding/AstarStrategy"));
const HW4Scene_1 = __importDefault(require("./HW4Scene"));
const BattlerGroups = {
    RED: 1,
    BLUE: 2
};
class MainHW4Scene extends HW4Scene_1.default {
    constructor(viewport, sceneManager, renderingManager, options) {
        super(viewport, sceneManager, renderingManager, options);
        this.battlers = new Array();
        this.healthbars = new Map();
        this.laserguns = new Array();
        this.healthpacks = new Array();
    }
    /**
     * @see Scene.update()
     */
    loadScene() {
        // Load the player and enemy spritesheets
        this.load.spritesheet("player1", "hw4_assets/spritesheets/player1.json");
        // Load in the enemy sprites
        this.load.spritesheet("BlueEnemy", "hw4_assets/spritesheets/BlueEnemy.json");
        this.load.spritesheet("RedEnemy", "hw4_assets/spritesheets/RedEnemy.json");
        this.load.spritesheet("BlueHealer", "hw4_assets/spritesheets/BlueHealer.json");
        this.load.spritesheet("RedHealer", "hw4_assets/spritesheets/RedHealer.json");
        // Load the tilemap
        this.load.tilemap("level", "hw4_assets/tilemaps/HW4CustomTilemap.json");
        // Load the enemy locations
        this.load.object("red", "hw4_assets/data/enemies/red.json");
        this.load.object("blue", "hw4_assets/data/enemies/blue.json");
        // Load the healthpack and lasergun loactions
        this.load.object("healthpacks", "hw4_assets/data/items/healthpacks.json");
        this.load.object("laserguns", "hw4_assets/data/items/laserguns.json");
        // Load the healthpack, inventory slot, and laser gun sprites
        this.load.image("healthpack", "hw4_assets/sprites/healthpack.png");
        this.load.image("inventorySlot", "hw4_assets/sprites/inventory.png");
        this.load.image("laserGun", "hw4_assets/sprites/laserGun.png");
    }
    /**
     * @see Scene.startScene
     */
    startScene() {
        // Add in the tilemap
        let tilemapLayers = this.add.tilemap("level");
        // Get the wall layer
        this.walls = tilemapLayers[1].getItems()[0];
        // Set the viewport bounds to the tilemap
        let tilemapSize = this.walls.size;
        this.viewport.setBounds(0, 0, tilemapSize.x, tilemapSize.y);
        this.viewport.setZoomLevel(2);
        this.initLayers();
        // Create the player
        this.initializePlayer();
        this.initializeItems();
        this.initializeNavmesh();
        // Create the NPCS
        this.initializeNPCs();
        // Subscribe to relevant events
        this.receiver.subscribe("healthpack");
        this.receiver.subscribe("enemyDied");
        this.receiver.subscribe(Events_1.ItemEvent.ITEM_REQUEST);
        // Add a UI for health
        this.addUILayer("health");
        this.receiver.subscribe(Events_1.PlayerEvent.PLAYER_KILLED);
        this.receiver.subscribe(Events_1.BattlerEvent.BATTLER_KILLED);
        this.receiver.subscribe(Events_1.BattlerEvent.BATTLER_RESPAWN);
    }
    /**
     * @see Scene.updateScene
     */
    updateScene(deltaT) {
        while (this.receiver.hasNextEvent()) {
            this.handleEvent(this.receiver.getNextEvent());
        }
        this.inventoryHud.update(deltaT);
        this.healthbars.forEach(healthbar => healthbar.update(deltaT));
    }
    /**
     * Handle events from the rest of the game
     * @param event a game event
     */
    handleEvent(event) {
        switch (event.type) {
            case Events_1.BattlerEvent.BATTLER_KILLED: {
                this.handleBattlerKilled(event);
                break;
            }
            case Events_1.BattlerEvent.BATTLER_RESPAWN: {
                break;
            }
            case Events_1.ItemEvent.ITEM_REQUEST: {
                this.handleItemRequest(event.data.get("node"), event.data.get("inventory"));
                break;
            }
            default: {
                throw new Error(`Unhandled event type "${event.type}" caught in HW4Scene event handler`);
            }
        }
    }
    handleItemRequest(node, inventory) {
        let items = new Array(...this.healthpacks, ...this.laserguns).filter((item) => {
            return item.inventory === null && item.position.distanceTo(node.position) <= 100;
        });
        if (items.length > 0) {
            inventory.add(items.reduce((0, HW4Reducers_1.ClosestPositioned)(node)));
        }
    }
    /**
     * Handles an NPC being killed by unregistering the NPC from the scenes subsystems
     * @param event an NPC-killed event
     */
    handleBattlerKilled(event) {
        let id = event.data.get("id");
        let battler = this.battlers.find(b => b.id === id);
        if (battler) {
            battler.battlerActive = false;
            this.healthbars.get(id).visible = false;
        }
    }
    /** Initializes the layers in the scene */
    initLayers() {
        this.addLayer("primary", 10);
        this.addUILayer("slots");
        this.addUILayer("items");
        this.getLayer("slots").setDepth(1);
        this.getLayer("items").setDepth(2);
    }
    /**
     * Initializes the player in the scene
     */
    initializePlayer() {
        let player = this.add.animatedSprite(PlayerActor_1.default, "player1", "primary");
        player.position.set(40, 40);
        player.battleGroup = 2;
        player.health = 10;
        player.maxHealth = 10;
        player.inventory.onChange = Events_1.ItemEvent.INVENTORY_CHANGED;
        this.inventoryHud = new InventoryHUD_1.default(this, player.inventory, "inventorySlot", {
            start: new Vec2_1.default(232, 24),
            slotLayer: "slots",
            padding: 8,
            itemLayer: "items"
        });
        // Give the player physics
        player.addPhysics(new AABB_1.default(Vec2_1.default.ZERO, new Vec2_1.default(8, 8)));
        // Give the player a healthbar
        let healthbar = new HealthbarHUD_1.default(this, player, "primary", { size: player.size.clone().scaled(2, 1 / 2), offset: player.size.clone().scaled(0, -1 / 2) });
        this.healthbars.set(player.id, healthbar);
        // Give the player PlayerAI
        player.addAI(PlayerAI_1.default);
        // Start the player in the "IDLE" animation
        player.animation.play("IDLE");
        this.battlers.push(player);
        this.viewport.follow(player);
    }
    /**
     * Initialize the NPCs
     */
    initializeNPCs() {
        // Get the object data for the red enemies
        let red = this.load.getObject("red");
        // Initialize the red healers
        for (let i = 0; i < red.healers.length; i++) {
            let npc = this.add.animatedSprite(NPCActor_1.default, "RedHealer", "primary");
            // npc.position.set(red.healers[i][0], red.healers[i][1]);
            npc.position.set(RandUtils_1.default.randInt(9, this.viewport.getHalfSize().x - 8), RandUtils_1.default.randFloat(9, this.viewport.getHalfSize().y - 8));
            for (let j = 0; j < this.walls.getTilesets().length; j++) {
                if (npc.position.
                    distanceTo(this.walls.getWorldPosition(this.walls.getTileColRow(j).x, this.walls.getTileColRow(j).y)) <= 200) {
                    npc.position.set(RandUtils_1.default.randInt(9, this.viewport.getHalfSize().x - 8), RandUtils_1.default.randFloat(9, this.viewport.getHalfSize().y - 8));
                    j = 0;
                }
            }
            npc.addPhysics(new AABB_1.default(Vec2_1.default.ZERO, new Vec2_1.default(7, 7)), null, false);
            npc.battleGroup = 1;
            npc.speed = 10;
            npc.health = 10;
            npc.maxHealth = 10;
            npc.navkey = "navmesh";
            // Give the NPC a healthbar
            let healthbar = new HealthbarHUD_1.default(this, npc, "primary", { size: npc.size.clone().scaled(2, 1 / 2), offset: npc.size.clone().scaled(0, -1 / 2) });
            this.healthbars.set(npc.id, healthbar);
            npc.addAI(HealerBehavior_1.default);
            npc.animation.play("IDLE");
            this.battlers.push(npc);
        }
        for (let i = 0; i < red.enemies.length; i++) {
            let npc = this.add.animatedSprite(NPCActor_1.default, "RedEnemy", "primary");
            // npc.position.set(red.enemies[i][0], red.enemies[i][1]);
            npc.position.set(RandUtils_1.default.randInt(9, this.viewport.getHalfSize().x - 8), RandUtils_1.default.randFloat(9, this.viewport.getHalfSize().y - 8));
            for (let j = 0; j < this.walls.getTilesets().length; j++) {
                if (npc.position.
                    distanceTo(this.walls.getWorldPosition(this.walls.getTileColRow(j).x, this.walls.getTileColRow(j).y)) <= 200) {
                    npc.position.set(RandUtils_1.default.randInt(9, this.viewport.getHalfSize().x - 8), RandUtils_1.default.randFloat(9, this.viewport.getHalfSize().y - 8));
                    j = 0;
                }
            }
            npc.addPhysics(new AABB_1.default(Vec2_1.default.ZERO, new Vec2_1.default(7, 7)), null, false);
            // Give the NPC a healthbar
            let healthbar = new HealthbarHUD_1.default(this, npc, "primary", { size: npc.size.clone().scaled(2, 1 / 2), offset: npc.size.clone().scaled(0, -1 / 2) });
            this.healthbars.set(npc.id, healthbar);
            // Set the NPCs stats
            npc.battleGroup = 1;
            npc.speed = 10;
            npc.health = 1;
            npc.maxHealth = 10;
            npc.navkey = "navmesh";
            npc.addAI(GaurdBehavior_1.default, { target: new BasicTargetable_1.default(new Position_1.default(npc.position.x, npc.position.y)), range: 100 });
            // Play the NPCs "IDLE" animation 
            npc.animation.play("IDLE");
            // Add the NPC to the battlers array
            this.battlers.push(npc);
        }
        // Get the object data for the blue enemies
        let blue = this.load.getObject("blue");
        // Initialize the blue enemies
        for (let i = 0; i < blue.enemies.length; i++) {
            let npc = this.add.animatedSprite(NPCActor_1.default, "BlueEnemy", "primary");
            // npc.position.set(blue.enemies[i][0], blue.enemies[i][1]);
            npc.position.set(RandUtils_1.default.randInt(this.viewport.getHalfSize().x, 2 * this.viewport.getHalfSize().x - 8), RandUtils_1.default.randFloat(this.viewport.getHalfSize().y, 2 * this.viewport.getHalfSize().y - 8));
            for (let j = 0; j < this.walls.getTilesets().length; j++) {
                if (npc.position.
                    distanceTo(this.walls.getWorldPosition(this.walls.getTileColRow(j).x, this.walls.getTileColRow(j).y)) <= 200) {
                    npc.position.set(RandUtils_1.default.randInt(this.viewport.getHalfSize().x + 9, 2 * this.viewport.getHalfSize().x - 8), RandUtils_1.default.randFloat(this.viewport.getHalfSize().y + 9, 2 * this.viewport.getHalfSize().y - 8));
                    j = 0;
                }
            }
            npc.addPhysics(new AABB_1.default(Vec2_1.default.ZERO, new Vec2_1.default(7, 7)), null, false);
            // Give the NPCS their healthbars
            let healthbar = new HealthbarHUD_1.default(this, npc, "primary", { size: npc.size.clone().scaled(2, 1 / 2), offset: npc.size.clone().scaled(0, -1 / 2) });
            this.healthbars.set(npc.id, healthbar);
            npc.battleGroup = 2;
            npc.speed = 10;
            npc.health = 1;
            npc.maxHealth = 10;
            npc.navkey = "navmesh";
            // Give the NPCs their AI
            npc.addAI(GaurdBehavior_1.default, { target: this.battlers[0], range: 100 });
            // Play the NPCs "IDLE" animation 
            npc.animation.play("IDLE");
            this.battlers.push(npc);
        }
        // Initialize the blue healers
        for (let i = 0; i < blue.healers.length; i++) {
            let npc = this.add.animatedSprite(NPCActor_1.default, "BlueHealer", "primary");
            // npc.position.set(blue.healers[i][0], blue.healers[i][1]);
            npc.position.set(RandUtils_1.default.randInt(this.viewport.getHalfSize().x, 2 * this.viewport.getHalfSize().x - 8), RandUtils_1.default.randFloat(this.viewport.getHalfSize().y, 2 * this.viewport.getHalfSize().y - 8));
            for (let j = 0; j < this.walls.getTilesets().length; j++) {
                if (npc.position.
                    distanceTo(this.walls.getWorldPosition(this.walls.getTileColRow(j).x, this.walls.getTileColRow(j).y)) <= 200) {
                    npc.position.set(RandUtils_1.default.randInt(this.viewport.getHalfSize().x, 2 * this.viewport.getHalfSize().x - 8), RandUtils_1.default.randFloat(this.viewport.getHalfSize().y, 2 * this.viewport.getHalfSize().y - 8));
                    j = 0;
                }
            }
            npc.addPhysics(new AABB_1.default(Vec2_1.default.ZERO, new Vec2_1.default(7, 7)), null, false);
            npc.battleGroup = 2;
            npc.speed = 10;
            npc.health = 1;
            npc.maxHealth = 10;
            npc.navkey = "navmesh";
            let healthbar = new HealthbarHUD_1.default(this, npc, "primary", { size: npc.size.clone().scaled(2, 1 / 2), offset: npc.size.clone().scaled(0, -1 / 2) });
            this.healthbars.set(npc.id, healthbar);
            npc.addAI(HealerBehavior_1.default);
            npc.animation.play("IDLE");
            this.battlers.push(npc);
        }
    }
    /**
     * Initialize the items in the scene (healthpacks and laser guns)
     */
    initializeItems() {
        let laserguns = this.load.getObject("laserguns");
        this.laserguns = new Array(laserguns.items.length);
        for (let i = 0; i < laserguns.items.length; i++) {
            let sprite = this.add.sprite("laserGun", "primary");
            let line = this.add.graphic(GraphicTypes_1.GraphicType.LINE, "primary", { start: Vec2_1.default.ZERO, end: Vec2_1.default.ZERO });
            this.laserguns[i] = LaserGun_1.default.create(sprite, line);
            // this.laserguns[i].position.set(laserguns.items[i][0], laserguns.items[i][1]);
            this.laserguns[i].position.set(RandUtils_1.default.randInt(9, 2 * this.viewport.getHalfSize().x - 8), RandUtils_1.default.randFloat(9, 2 * this.viewport.getHalfSize().y - 8));
            for (let j = 0; j < this.walls.getTileSize().x * this.walls.getTileSize().y; j++) {
                if (this.laserguns[i].position.
                    distanceTo(this.walls.getWorldPosition(this.walls.getTileColRow(j).x, this.walls.getTileColRow(j).y)) <= 200) {
                    this.laserguns[i].position.set(RandUtils_1.default.randInt(9, 2 * this.viewport.getHalfSize().x - 8), RandUtils_1.default.randInt(9, 2 * this.viewport.getHalfSize().y - 8));
                    j = 0;
                }
            }
        }
        let healthpacks = this.load.getObject("healthpacks");
        this.healthpacks = new Array(healthpacks.items.length);
        for (let i = 0; i < healthpacks.items.length; i++) {
            let sprite = this.add.sprite("healthpack", "primary");
            this.healthpacks[i] = new Healthpack_1.default(sprite);
            this.healthpacks[i].position.set(healthpacks.items[i][0], healthpacks.items[i][1]);
        }
    }
    /**
     * Initializes the navmesh graph used by the NPCs in the HW4Scene. This method is a little buggy, and
     * and it skips over some of the positions on the tilemap. If you can fix my navmesh generation algorithm,
     * go for it.
     *
     * - Peter
     */
    initializeNavmesh() {
        // Create the graph
        this.graph = new PositionGraph_1.default();
        let dim = this.walls.getDimensions();
        for (let i = 0; i < dim.y; i++) {
            for (let j = 0; j < dim.x; j++) {
                let tile = this.walls.getTileCollider(j, i);
                this.graph.addPositionedNode(tile.center);
            }
        }
        let rc;
        for (let i = 0; i < this.graph.numVertices; i++) {
            rc = this.walls.getTileColRow(i);
            if (!this.walls.isTileCollidable(rc.x, rc.y) &&
                !this.walls.isTileCollidable(MathUtils_1.default.clamp(rc.x - 1, 0, dim.x - 1), rc.y) &&
                !this.walls.isTileCollidable(MathUtils_1.default.clamp(rc.x + 1, 0, dim.x - 1), rc.y) &&
                !this.walls.isTileCollidable(rc.x, MathUtils_1.default.clamp(rc.y - 1, 0, dim.y - 1)) &&
                !this.walls.isTileCollidable(rc.x, MathUtils_1.default.clamp(rc.y + 1, 0, dim.y - 1)) &&
                !this.walls.isTileCollidable(MathUtils_1.default.clamp(rc.x + 1, 0, dim.x - 1), MathUtils_1.default.clamp(rc.y + 1, 0, dim.y - 1)) &&
                !this.walls.isTileCollidable(MathUtils_1.default.clamp(rc.x - 1, 0, dim.x - 1), MathUtils_1.default.clamp(rc.y + 1, 0, dim.y - 1)) &&
                !this.walls.isTileCollidable(MathUtils_1.default.clamp(rc.x + 1, 0, dim.x - 1), MathUtils_1.default.clamp(rc.y - 1, 0, dim.y - 1)) &&
                !this.walls.isTileCollidable(MathUtils_1.default.clamp(rc.x - 1, 0, dim.x - 1), MathUtils_1.default.clamp(rc.y - 1, 0, dim.y - 1))) {
                // Create edge to the left
                rc = this.walls.getTileColRow(i + 1);
                if ((i + 1) % dim.x !== 0 && !this.walls.isTileCollidable(rc.x, rc.y)) {
                    this.graph.addEdge(i, i + 1);
                    // this.add.graphic(GraphicType.LINE, "graph", {start: this.graph.getNodePosition(i), end: this.graph.getNodePosition(i + 1)})
                }
                // Create edge below
                rc = this.walls.getTileColRow(i + dim.x);
                if (i + dim.x < this.graph.numVertices && !this.walls.isTileCollidable(rc.x, rc.y)) {
                    this.graph.addEdge(i, i + dim.x);
                    // this.add.graphic(GraphicType.LINE, "graph", {start: this.graph.getNodePosition(i), end: this.graph.getNodePosition(i + dim.x)})
                }
            }
        }
        // Set this graph as a navigable entity
        let navmesh = new Navmesh_1.default(this.graph);
        // Add different strategies to use for this navmesh
        navmesh.registerStrategy("direct", new DirectStrategy_1.default(navmesh));
        navmesh.registerStrategy("astar", new AstarStrategy_1.default(navmesh));
        navmesh.registerStrategy("dijkstra", new DjikstraStrategy_1.default(navmesh));
        // TODO set the strategy to use A* pathfinding
        navmesh.setStrategy("direct");
        // Add this navmesh to the navigation manager
        this.navManager.addNavigableEntity("navmesh", navmesh);
    }
    getBattlers() { return this.battlers; }
    getWalls() { return this.walls; }
    getHealthpacks() { return this.healthpacks; }
    getLaserGuns() { return this.laserguns; }
    /**
     * Checks if the given target position is visible from the given position.
     * @param position
     * @param target
     * @returns
     */
    isTargetVisible(position, target) {
        // Get the new player location
        let start = position.clone();
        let delta = target.clone().sub(start);
        // Iterate through the tilemap region until we find a collision
        let minX = Math.min(start.x, target.x);
        let maxX = Math.max(start.x, target.x);
        let minY = Math.min(start.y, target.y);
        let maxY = Math.max(start.y, target.y);
        // Get the wall tilemap
        let walls = this.getWalls();
        let minIndex = walls.getTilemapPosition(minX, minY);
        let maxIndex = walls.getTilemapPosition(maxX, maxY);
        let tileSize = walls.getScaledTileSize();
        for (let col = minIndex.x; col <= maxIndex.x; col++) {
            for (let row = minIndex.y; row <= maxIndex.y; row++) {
                if (walls.isTileCollidable(col, row)) {
                    // Get the position of this tile
                    let tilePos = new Vec2_1.default(col * tileSize.x + tileSize.x / 2, row * tileSize.y + tileSize.y / 2);
                    // Create a collider for this tile
                    let collider = new AABB_1.default(tilePos, tileSize.scaled(1 / 2));
                    let hit = collider.intersectSegment(start, delta, Vec2_1.default.ZERO);
                    if (hit !== null && start.distanceSqTo(hit.pos) < start.distanceSqTo(target)) {
                        // We hit a wall, we can't see the player
                        return false;
                    }
                }
            }
        }
        return true;
    }
}
exports.default = MainHW4Scene;

},{"../../Wolfie2D/DataTypes/Graphs/PositionGraph":14,"../../Wolfie2D/DataTypes/Shapes/AABB":20,"../../Wolfie2D/DataTypes/Vec2":26,"../../Wolfie2D/Nodes/Graphics/GraphicTypes":44,"../../Wolfie2D/Pathfinding/Navmesh":63,"../../Wolfie2D/Pathfinding/Strategies/DirectStrategy":64,"../../Wolfie2D/Pathfinding/Strategies/DjikstraStrategy":65,"../../Wolfie2D/Utils/MathUtils":109,"../../Wolfie2D/Utils/RandUtils":111,"../AI/NPC/NPCBehavior/GaurdBehavior":119,"../AI/NPC/NPCBehavior/HealerBehavior":120,"../AI/Player/PlayerAI":124,"../Actors/NPCActor":131,"../Actors/PlayerActor":132,"../Events":133,"../GameSystems/HUD/HealthbarHUD":135,"../GameSystems/HUD/InventoryHUD":136,"../GameSystems/ItemSystem/Items/Healthpack":139,"../GameSystems/ItemSystem/Items/LaserGun":140,"../GameSystems/Searching/HW4Reducers":143,"../GameSystems/Targeting/BasicTargetable":144,"../GameSystems/Targeting/Position":146,"../Pathfinding/AstarStrategy":147,"./HW4Scene":150}],152:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../../Wolfie2D/DataTypes/Vec2"));
const UIElementTypes_1 = require("../../Wolfie2D/Nodes/UIElements/UIElementTypes");
const Scene_1 = __importDefault(require("../../Wolfie2D/Scene/Scene"));
const Color_1 = __importDefault(require("../../Wolfie2D/Utils/Color"));
const MainHW4Scene_1 = __importDefault(require("./MainHW4Scene"));
const AstarDemoScene_1 = __importDefault(require("./AstarDemoScene"));
const GuardDemoScene_1 = __importDefault(require("./GuardDemoScene"));
class MainMenu extends Scene_1.default {
    loadScene() { }
    startScene() {
        const center = this.viewport.getCenter();
        // The main menu
        this.mainMenu = this.addUILayer("mainMenu");
        const play = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "mainMenu", { position: new Vec2_1.default(center.x, center.y - 100), text: "Play" });
        play.size.set(200, 50);
        play.borderWidth = 2;
        play.borderColor = Color_1.default.WHITE;
        play.backgroundColor = Color_1.default.TRANSPARENT;
        play.onClickEventId = "play";
        const astar = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "mainMenu", { position: new Vec2_1.default(center.x, center.y), text: "A* Test Scene" });
        astar.size.set(200, 50);
        astar.borderWidth = 2;
        astar.borderColor = Color_1.default.WHITE;
        astar.backgroundColor = Color_1.default.TRANSPARENT;
        astar.onClickEventId = "astar";
        const guard = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "mainMenu", { position: new Vec2_1.default(center.x, center.y + 100), text: "Guard demo" });
        guard.size.set(200, 50);
        guard.borderWidth = 2;
        guard.borderColor = Color_1.default.WHITE;
        guard.backgroundColor = Color_1.default.TRANSPARENT;
        guard.onClickEventId = "guard";
        // Subscribe to the button events
        this.receiver.subscribe("play");
        this.receiver.subscribe("astar");
        this.receiver.subscribe("guard");
    }
    updateScene() {
        while (this.receiver.hasNextEvent()) {
            this.handleEvent(this.receiver.getNextEvent());
        }
    }
    handleEvent(event) {
        switch (event.type) {
            case "play": {
                this.sceneManager.changeToScene(MainHW4Scene_1.default);
                break;
            }
            case "astar": {
                this.sceneManager.changeToScene(AstarDemoScene_1.default);
                break;
            }
            case "guard": {
                this.sceneManager.changeToScene(GuardDemoScene_1.default);
                break;
            }
        }
    }
}
exports.default = MainMenu;

},{"../../Wolfie2D/DataTypes/Vec2":26,"../../Wolfie2D/Nodes/UIElements/UIElementTypes":60,"../../Wolfie2D/Scene/Scene":97,"../../Wolfie2D/Utils/Color":106,"./AstarDemoScene":148,"./GuardDemoScene":149,"./MainHW4Scene":151}],153:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Game_1 = __importDefault(require("./Wolfie2D/Loop/Game"));
const MainMenu_1 = __importDefault(require("./hw4/Scenes/MainMenu"));
const PlayerController_1 = require("./hw4/AI/Player/PlayerController");
// The main function is your entrypoint into Wolfie2D. Specify your first scene and any options here.
(function main() {
    // Run any tests
    runTests();
    // Set up options for our game
    let options = {
        canvasSize: { x: 1024, y: 1024 },
        clearColor: { r: 0.1, g: 0.1, b: 0.1 },
        inputs: [
            { name: PlayerController_1.PlayerInput.MOVE_UP, keys: ["w"] },
            { name: PlayerController_1.PlayerInput.MOVE_DOWN, keys: ["s"] },
            { name: PlayerController_1.PlayerInput.MOVE_LEFT, keys: ["a"] },
            { name: PlayerController_1.PlayerInput.MOVE_RIGHT, keys: ["d"] },
            { name: PlayerController_1.PlayerInput.PICKUP_ITEM, keys: ["e"] },
            { name: PlayerController_1.PlayerInput.DROP_ITEM, keys: ["q"] },
            { name: "slot1", keys: ["1"] },
            { name: "slot2", keys: ["2"] },
        ],
        useWebGL: false,
        showDebug: false // Whether to show debug messages. You can change this to true if you want
    };
    // Set up custom registries
    // Create a game with the options specified
    const game = new Game_1.default(options);
    // Start our game
    game.start(MainMenu_1.default, {});
})();
function runTests() { }
;

},{"./Wolfie2D/Loop/Game":38,"./hw4/AI/Player/PlayerController":125,"./hw4/Scenes/MainMenu":152}]},{},[153])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvc2VlZC1yYW5kb20vaW5kZXguanMiLCJzcmMvV29sZmllMkQvQUkvQUlNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL0FJL0dvYXAvR29hcEFjdGlvbi50cyIsInNyYy9Xb2xmaWUyRC9BSS9Hb2FwL0dvYXBBY3Rpb25QbGFubmVyLnRzIiwic3JjL1dvbGZpZTJEL0FJL0dvYXAvR29hcFN0YXRlLnRzIiwic3JjL1dvbGZpZTJEL0FJL0dvYXAvU3RhdGVNYWNoaW5lR29hcEFJLnRzIiwic3JjL1dvbGZpZTJEL0FJL1N0YXRlTWFjaGluZUFJLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9Db2xsZWN0aW9ucy9NYXAudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL0NvbGxlY3Rpb25zL1F1ZXVlLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9Db2xsZWN0aW9ucy9TdGFjay50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvRnVuY3Rpb25zL051bGxGdW5jLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9HcmFwaHMvRWRnZU5vZGUudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL0dyYXBocy9HcmFwaC50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvR3JhcGhzL1Bvc2l0aW9uR3JhcGgudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL0ludGVyZmFjZXMvUmVnaW9uLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9NYXQ0eDQudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL1BoeXNpY3MvQXJlYUNvbGxpc2lvbi50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvUGh5c2ljcy9IaXQudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL1JlbmRlcmluZy9XZWJHTFByb2dyYW1UeXBlLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9TaGFwZXMvQUFCQi50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvU2hhcGVzL0NpcmNsZS50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvU2hhcGVzL1NoYXBlLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9TdGF0ZS9TdGF0ZS50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvU3RhdGUvU3RhdGVNYWNoaW5lLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlc2V0LnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyLnRzIiwic3JjL1dvbGZpZTJEL0RlYnVnL0RlYnVnLnRzIiwic3JjL1dvbGZpZTJEL0RlYnVnL1N0YXRzLnRzIiwic3JjL1dvbGZpZTJEL0V2ZW50cy9FbWl0dGVyLnRzIiwic3JjL1dvbGZpZTJEL0V2ZW50cy9FdmVudFF1ZXVlLnRzIiwic3JjL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnQudHMiLCJzcmMvV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFR5cGUudHMiLCJzcmMvV29sZmllMkQvRXZlbnRzL1JlY2VpdmVyLnRzIiwic3JjL1dvbGZpZTJEL0lucHV0L0lucHV0LnRzIiwic3JjL1dvbGZpZTJEL0lucHV0L0lucHV0SGFuZGxlci50cyIsInNyYy9Xb2xmaWUyRC9Mb29wL0Vudmlyb25tZW50SW5pdGlhbGl6ZXIudHMiLCJzcmMvV29sZmllMkQvTG9vcC9GaXhlZFVwZGF0ZUdhbWVMb29wLnRzIiwic3JjL1dvbGZpZTJEL0xvb3AvR2FtZS50cyIsInNyYy9Xb2xmaWUyRC9Mb29wL0dhbWVMb29wLnRzIiwic3JjL1dvbGZpZTJEL0xvb3AvR2FtZU9wdGlvbnMudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvQ2FudmFzTm9kZS50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9HYW1lTm9kZS50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL0dyYXBoaWNUeXBlcy50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljcy9MaW5lLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL1BhcnRpY2xlLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL1BvaW50LnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL1JlY3QudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZS50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZS50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9UaWxlbWFwLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1RpbGVtYXBzL0lzb21ldHJpY1RpbGVtYXAudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvVGlsZW1hcHMvT3J0aG9nb25hbFRpbGVtYXAudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvVGlsZW1hcHMvU3RhZ2dlcmVkSXNvbWV0cmljVGlsZW1hcC50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnQudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9CdXR0b24udHMiLCJzcmMvV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9MYWJlbC50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL1NsaWRlci50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL1RleHRJbnB1dC50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL1VJRWxlbWVudFR5cGVzLnRzIiwic3JjL1dvbGZpZTJEL1BhdGhmaW5kaW5nL05hdmlnYXRpb25NYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1BhdGhmaW5kaW5nL05hdmlnYXRpb25QYXRoLnRzIiwic3JjL1dvbGZpZTJEL1BhdGhmaW5kaW5nL05hdm1lc2gudHMiLCJzcmMvV29sZmllMkQvUGF0aGZpbmRpbmcvU3RyYXRlZ2llcy9EaXJlY3RTdHJhdGVneS50cyIsInNyYy9Xb2xmaWUyRC9QYXRoZmluZGluZy9TdHJhdGVnaWVzL0RqaWtzdHJhU3RyYXRlZ3kudHMiLCJzcmMvV29sZmllMkQvUGF0aGZpbmRpbmcvU3RyYXRlZ2llcy9OYXZpZ2F0aW9uU3RyYXRlZ3kudHMiLCJzcmMvV29sZmllMkQvUGh5c2ljcy9CYXNpY1BoeXNpY3NNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1BoeXNpY3MvUGh5c2ljc01hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvUGxheWJhY2svUGxheWJhY2tNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1JlZ2lzdHJ5L1JlZ2lzdHJpZXMvUmVnaXN0cnkudHMiLCJzcmMvV29sZmllMkQvUmVnaXN0cnkvUmVnaXN0cmllcy9TaGFkZXJSZWdpc3RyeS50cyIsInNyYy9Xb2xmaWUyRC9SZWdpc3RyeS9SZWdpc3RyeU1hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0FuaW1hdGlvbnMvQW5pbWF0aW9uTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvQW5pbWF0aW9ucy9BbmltYXRpb25UeXBlcy50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvQW5pbWF0aW9ucy9QYXJ0aWNsZVN5c3RlbU1hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0FuaW1hdGlvbnMvVHdlZW5Db250cm9sbGVyLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9BbmltYXRpb25zL1R3ZWVuTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvQ2FudmFzUmVuZGVyZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0NhbnZhc1JlbmRlcmluZy9HcmFwaGljUmVuZGVyZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0NhbnZhc1JlbmRlcmluZy9UaWxlbWFwUmVuZGVyZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0NhbnZhc1JlbmRlcmluZy9VSUVsZW1lbnRSZW5kZXJlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvUmVuZGVyaW5nTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvV2ViR0xSZW5kZXJlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZS50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZXMvTGFiZWxTaGFkZXJUeXBlLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9Qb2ludFNoYWRlclR5cGUudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVzL1F1YWRTaGFkZXJUeXBlLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9SZWN0U2hhZGVyVHlwZS50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZXMvU3ByaXRlU2hhZGVyVHlwZS50cyIsInNyYy9Xb2xmaWUyRC9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL0ZhY3Rvcmllcy9DYW52YXNOb2RlRmFjdG9yeS50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZS9GYWN0b3JpZXMvRmFjdG9yeU1hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvU2NlbmUvRmFjdG9yaWVzL1RpbGVtYXBGYWN0b3J5LnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL0xheWVyLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL0xheWVycy9QYXJhbGxheExheWVyLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL0xheWVycy9VSUxheWVyLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL1NjZW5lLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL1NjZW5lTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZS9TY2VuZU9wdGlvbnMudHMiLCJzcmMvV29sZmllMkQvU2NlbmVHcmFwaC9TY2VuZUdyYXBoLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lR3JhcGgvU2NlbmVHcmFwaEFycmF5LnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lR3JhcGgvVmlld3BvcnQudHMiLCJzcmMvV29sZmllMkQvU291bmQvQXVkaW9NYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1RpbWluZy9UaW1lci50cyIsInNyYy9Xb2xmaWUyRC9UaW1pbmcvVGltZXJNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1V0aWxzL0NvbG9yLnRzIiwic3JjL1dvbGZpZTJEL1V0aWxzL0Vhc2VGdW5jdGlvbnMudHMiLCJzcmMvV29sZmllMkQvVXRpbHMvR3JhcGhVdGlscy50cyIsInNyYy9Xb2xmaWUyRC9VdGlscy9NYXRoVXRpbHMudHMiLCJzcmMvV29sZmllMkQvVXRpbHMvUmFuZC9QZXJsaW4udHMiLCJzcmMvV29sZmllMkQvVXRpbHMvUmFuZFV0aWxzLnRzIiwic3JjL1dvbGZpZTJEL1V0aWxzL1JlbmRlcmluZ1V0aWxzLnRzIiwic3JjL1dvbGZpZTJEL1V0aWxzL1N0cmluZ1V0aWxzLnRzIiwic3JjL2h3NC9BSS9OUEMvTlBDQWN0aW9ucy9Hb3RvQWN0aW9uLnRzIiwic3JjL2h3NC9BSS9OUEMvTlBDQWN0aW9ucy9OUENBY3Rpb24udHMiLCJzcmMvaHc0L0FJL05QQy9OUENBY3Rpb25zL1BpY2t1cEl0ZW0udHMiLCJzcmMvaHc0L0FJL05QQy9OUENBY3Rpb25zL1Nob290TGFzZXJHdW4udHMiLCJzcmMvaHc0L0FJL05QQy9OUENCZWhhdmlvci50cyIsInNyYy9odzQvQUkvTlBDL05QQ0JlaGF2aW9yL0dhdXJkQmVoYXZpb3IudHMiLCJzcmMvaHc0L0FJL05QQy9OUENCZWhhdmlvci9IZWFsZXJCZWhhdmlvci50cyIsInNyYy9odzQvQUkvTlBDL05QQ1N0YXR1c2VzL0ZhbHNlU3RhdHVzLnRzIiwic3JjL2h3NC9BSS9OUEMvTlBDU3RhdHVzZXMvSGFzSXRlbS50cyIsInNyYy9odzQvQUkvTlBDL05QQ1N0YXR1c2VzL1RhcmdldEV4aXN0cy50cyIsInNyYy9odzQvQUkvUGxheWVyL1BsYXllckFJLnRzIiwic3JjL2h3NC9BSS9QbGF5ZXIvUGxheWVyQ29udHJvbGxlci50cyIsInNyYy9odzQvQUkvUGxheWVyL1BsYXllclN0YXRlcy9EZWFkLnRzIiwic3JjL2h3NC9BSS9QbGF5ZXIvUGxheWVyU3RhdGVzL0lkbGUudHMiLCJzcmMvaHc0L0FJL1BsYXllci9QbGF5ZXJTdGF0ZXMvSW52aW5jaWJsZS50cyIsInNyYy9odzQvQUkvUGxheWVyL1BsYXllclN0YXRlcy9Nb3ZpbmcudHMiLCJzcmMvaHc0L0FJL1BsYXllci9QbGF5ZXJTdGF0ZXMvUGxheWVyU3RhdGUudHMiLCJzcmMvaHc0L0FjdG9ycy9OUENBY3Rvci50cyIsInNyYy9odzQvQWN0b3JzL1BsYXllckFjdG9yLnRzIiwic3JjL2h3NC9FdmVudHMudHMiLCJzcmMvaHc0L0dhbWVTeXN0ZW1zL0JhdHRsZVN5c3RlbS9CYXNpY0JhdHRsZXIudHMiLCJzcmMvaHc0L0dhbWVTeXN0ZW1zL0hVRC9IZWFsdGhiYXJIVUQudHMiLCJzcmMvaHc0L0dhbWVTeXN0ZW1zL0hVRC9JbnZlbnRvcnlIVUQudHMiLCJzcmMvaHc0L0dhbWVTeXN0ZW1zL0l0ZW1TeXN0ZW0vSW52ZW50b3J5LnRzIiwic3JjL2h3NC9HYW1lU3lzdGVtcy9JdGVtU3lzdGVtL0l0ZW0udHMiLCJzcmMvaHc0L0dhbWVTeXN0ZW1zL0l0ZW1TeXN0ZW0vSXRlbXMvSGVhbHRocGFjay50cyIsInNyYy9odzQvR2FtZVN5c3RlbXMvSXRlbVN5c3RlbS9JdGVtcy9MYXNlckd1bi50cyIsInNyYy9odzQvR2FtZVN5c3RlbXMvU2VhcmNoaW5nL0Jhc2ljRmluZGVyLnRzIiwic3JjL2h3NC9HYW1lU3lzdGVtcy9TZWFyY2hpbmcvSFc0RmlsdGVycy50cyIsInNyYy9odzQvR2FtZVN5c3RlbXMvU2VhcmNoaW5nL0hXNFJlZHVjZXJzLnRzIiwic3JjL2h3NC9HYW1lU3lzdGVtcy9UYXJnZXRpbmcvQmFzaWNUYXJnZXRhYmxlLnRzIiwic3JjL2h3NC9HYW1lU3lzdGVtcy9UYXJnZXRpbmcvQmFzaWNUYXJnZXRpbmcudHMiLCJzcmMvaHc0L0dhbWVTeXN0ZW1zL1RhcmdldGluZy9Qb3NpdGlvbi50cyIsInNyYy9odzQvUGF0aGZpbmRpbmcvQXN0YXJTdHJhdGVneS50cyIsInNyYy9odzQvU2NlbmVzL0FzdGFyRGVtb1NjZW5lLnRzIiwic3JjL2h3NC9TY2VuZXMvR3VhcmREZW1vU2NlbmUudHMiLCJzcmMvaHc0L1NjZW5lcy9IVzRTY2VuZS50cyIsInNyYy9odzQvU2NlbmVzL01haW5IVzRTY2VuZS50cyIsInNyYy9odzQvU2NlbmVzL01haW5NZW51LnRzIiwic3JjL21haW4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUN6S0EsdUVBQStDO0FBRS9DOzs7R0FHRztBQUNILE1BQXFCLFNBQVM7SUFNN0I7UUFDQyxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7UUFDMUIsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLGFBQUcsRUFBRSxDQUFDO0lBQy9CLENBQUM7SUFFRDs7O09BR0c7SUFDSCxhQUFhLENBQUMsS0FBWTtRQUN6QixJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN6QixDQUFDO0lBRUQsV0FBVyxDQUFDLEtBQVk7UUFDdkIsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFdkMsSUFBRyxLQUFLLEtBQUssQ0FBQyxDQUFDLEVBQUM7WUFDZixJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7U0FDN0I7SUFDRixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILFVBQVUsQ0FBQyxJQUFZLEVBQUUsTUFBMEM7UUFDbEUsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsVUFBVSxDQUFDLElBQVk7UUFDdEIsSUFBRyxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBQztZQUM5QixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUM7U0FDM0M7YUFBTTtZQUNOLE1BQU0sOEJBQThCLElBQUksc0NBQXNDLENBQUM7U0FDL0U7SUFDRixDQUFDO0lBRUQsTUFBTSxDQUFDLE1BQWM7UUFDcEIsb0NBQW9DO1FBQ3BDLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFLEdBQUcsSUFBRyxLQUFLLENBQUMsUUFBUTtZQUFFLEtBQUssQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFBLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDOUUsQ0FBQztDQUNEO0FBckRELDRCQXFEQzs7Ozs7Ozs7O0FDOURELHdFQUFnRDtBQUdoRCxNQUE4QixVQUFXLFNBQVEsZUFBSztJQVNsRCxZQUFtQixNQUFzQyxFQUFFLEtBQVk7UUFDbkUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2QsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLEdBQUcsRUFBVSxDQUFDO1FBQ3hDLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxHQUFHLEVBQVUsQ0FBQztRQUNsQyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQztJQUNuQixDQUFDO0lBRUQsNENBQTRDO0lBQzVDLElBQUksSUFBSSxLQUFhLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDekMsSUFBSSxJQUFJLENBQUMsSUFBWSxJQUFJLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUU3QyxzRUFBc0U7SUFDdEUsSUFBSSxhQUFhLEtBQWUsT0FBTyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFBQSxDQUFDO0lBRW5GLHFEQUFxRDtJQUNyRCxJQUFJLE9BQU8sS0FBZSxPQUFPLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUUvRCxrQkFBa0IsQ0FBQyxNQUFnQjtRQUN0QyxPQUFPLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQztJQUN6RyxDQUFDO0lBRU0sZUFBZSxDQUFDLE1BQWM7UUFDakMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUNNLFNBQVMsQ0FBQyxNQUFjO1FBQzNCLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFFZSxRQUFRO1FBQ3BCLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDOUIsQ0FBQztDQUVKO0FBMUNELDZCQTBDQztBQUVELElBQVksZ0JBSVg7QUFKRCxXQUFZLGdCQUFnQjtJQUN4Qiw2REFBVyxDQUFBO0lBQ1gsNkRBQVcsQ0FBQTtJQUNYLDZEQUFXLENBQUE7QUFDZixDQUFDLEVBSlcsZ0JBQWdCLEdBQWhCLHdCQUFnQixLQUFoQix3QkFBZ0IsUUFJM0I7Ozs7Ozs7O0FDcERELHlFQUFpRDtBQUVqRCw4RUFBc0Q7QUFDdEQsd0VBQWdEO0FBR2hELE1BQXFCLGlCQUFpQjtJQUUzQixNQUFNLENBQUMsSUFBSSxDQUF1QixNQUFnQixFQUFFLElBQVksRUFBRSxPQUFpQjtRQUN0RixJQUFJLEtBQUssR0FBVSxJQUFJLGVBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNuQyxJQUFJLE9BQU8sR0FBNEIsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUVqRCxlQUFlO1FBQ2YsS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ2hCLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3ZCLGVBQWU7UUFDZixLQUFLLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDaEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUMsTUFBTSxDQUFDLENBQUM7UUFDdEIsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1FBRTVDLHdCQUF3QjtRQUN4QixJQUFJLENBQUMsU0FBUyxDQUFJLE1BQU0sRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFNUQsb0NBQW9DO1FBQ3BDLElBQUksSUFBSSxHQUFrQixvQkFBVSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFFeEQsK0JBQStCO1FBQy9CLElBQUksSUFBSSxHQUFHLElBQUksZUFBSyxFQUFLLENBQUM7UUFFaEMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1YsT0FBTSxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUM7WUFDWCxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUM7Z0JBQ3ZCLElBQUksQ0FBQyxJQUFJLENBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQzdCO1lBQ1YsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNaO1FBRUssT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztJQUVPLE1BQU0sQ0FBQyxTQUFTLENBQTBCLE1BQWdCLEVBQUUsT0FBaUIsRUFBRSxJQUFZLEVBQUUsSUFBWSxFQUFFLE9BQWdDLEVBQUUsS0FBWTtRQUM3SiwyQkFBMkI7UUFDM0IsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUNyQixzQkFBc0I7WUFDdEIsSUFBSSxNQUFNLENBQUMsa0JBQWtCLENBQUMsTUFBTSxDQUFDLEVBQUM7Z0JBQ2xDLDhCQUE4QjtnQkFDOUIsOEJBQThCO2dCQUM5QixJQUFJLFNBQVMsR0FBRyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUM7Z0JBQzVCLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBRWxDLG1DQUFtQztnQkFDbkMsSUFBSSxTQUFTLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFDO29CQUN6QixJQUFJLE9BQU8sR0FBRyxLQUFLLENBQUMsT0FBTyxFQUFFLENBQUM7b0JBQzlCLE9BQU8sQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxDQUFDO29CQUM3QixLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO29CQUMxQyxLQUFLLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7b0JBQzdCLE9BQU87aUJBQ1Y7Z0JBRUQsNkJBQTZCO2dCQUM3QixJQUFJLE9BQU8sR0FBRyxLQUFLLENBQUMsT0FBTyxFQUFFLENBQUM7Z0JBQzlCLE9BQU8sQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxDQUFDO2dCQUM3QixLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUUxQyxnQkFBZ0I7Z0JBQ2hCLElBQUksVUFBVSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssTUFBTSxDQUFDLENBQUE7Z0JBQ3RELElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQzthQUN4RTtRQUNMLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztDQUNKO0FBaEVELG9DQWdFQzs7Ozs7QUNwRUQ7O0dBRUc7QUFDSCxNQUE4QixTQUFTO0NBSXRDO0FBSkQsNEJBSUM7Ozs7Ozs7O0FDVEQsOEVBQXNEO0FBRXRELDRFQUFtRDtBQUluRCwwRUFBa0Q7QUFHbEQsdUVBQStDO0FBRS9DOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUNILE1BQThCLGtCQUF5QyxTQUFRLHdCQUFjO0lBWXpGO1FBQ0ksS0FBSyxFQUFFLENBQUM7UUFDUixJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksYUFBRyxFQUFhLENBQUM7UUFDckMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLGFBQUcsRUFBSyxDQUFDO1FBQzdCLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxlQUFLLEVBQUssQ0FBQztRQUM1QixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztJQUNyQixDQUFDO0lBR00sTUFBTSxDQUFDLE1BQWM7UUFDeEIsS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN6QixDQUFDO0lBRWUsVUFBVTtRQUN0QixvRUFBb0U7UUFDcEUsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDOUIsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ3RDLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQzlCLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDekIsQ0FBQztJQUVELHFGQUFxRjtJQUNyRSxXQUFXO1FBQ3ZCLHlCQUF5QjtRQUN6QixJQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBRXpDLDRCQUE0QjtRQUM1QixJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBRWpCLHlDQUF5QztRQUN6QyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLEVBQUU7WUFDdEIsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7U0FDakM7UUFFRCx5QkFBeUI7UUFDekIsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDO1FBRXRDLDZCQUE2QjtRQUM3QixJQUFHLElBQUksQ0FBQyxzQkFBc0IsRUFBQztZQUMzQixJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsb0JBQW9CLEVBQUUsRUFBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFlBQVksRUFBQyxDQUFDLENBQUM7U0FDakY7UUFFRCx1QkFBdUI7UUFDdkIsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDdkMsQ0FBQztJQUVTLFNBQVM7UUFDZiwrQkFBK0I7UUFDL0IsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBQ3BDLDhCQUE4QjtRQUM5QixJQUFJLE9BQU8sR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ2xGLGtCQUFrQjtRQUNsQixPQUFPLDJCQUFpQixDQUFDLElBQUksQ0FBSSxRQUFRLEVBQUUsSUFBSSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztJQUNuRSxDQUFDO0lBRU0sYUFBYTtRQUNoQixPQUFPLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7SUFDbEcsQ0FBQztJQUVNLE9BQU8sQ0FBQyxJQUFZO1FBQ3ZCLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUMxQixNQUFNLElBQUksS0FBSyxDQUFDLHNFQUFzRSxDQUFDLENBQUE7U0FDMUY7UUFDRCxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztJQUNyQixDQUFDO0lBRU0sU0FBUyxDQUFDLFVBQWtCLEVBQUUsTUFBaUI7UUFDbEQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQzFDLENBQUM7SUFFTSxRQUFRLENBQUMsU0FBaUIsRUFBRSxLQUFpQjtRQUNoRCxLQUFLLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNyQyxDQUFDO0NBR0o7QUF2RkQscUNBdUZDOzs7Ozs7OztBQ2pIRCxtRkFBMkQ7QUFHM0Q7O0dBRUc7QUFDSCxNQUFxQixjQUFlLFNBQVEsc0JBQVk7SUFJdkQsZUFBZTtJQUNmLFlBQVksQ0FBQyxLQUFlLEVBQUUsTUFBMkIsSUFBVSxDQUFDO0lBRXBFLGVBQWU7SUFDZixPQUFPO1FBQ04sd0NBQXdDO1FBQ3hDLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQztRQUNsQixJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQ3pCLENBQUM7SUFFRCxlQUFlO0lBQ2YsUUFBUSxDQUFDLE9BQTRCLElBQVMsQ0FBQztDQUMvQztBQWhCRCxpQ0FnQkM7Ozs7O0FDckJEOztHQUVHO0FBQ0gsTUFBcUIsR0FBRztJQUd2Qix3QkFBd0I7SUFDeEI7UUFDQyxJQUFJLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQztJQUNmLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsR0FBRyxDQUFDLEdBQVcsRUFBRSxLQUFRO1FBQ3hCLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDO0lBQ3ZCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsR0FBRyxDQUFDLEdBQVc7UUFDZCxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDdEIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxHQUFHLENBQUMsR0FBVyxFQUFFLEtBQVE7UUFDeEIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDdEIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxHQUFHLENBQUMsR0FBVztRQUNkLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxTQUFTLENBQUM7SUFDcEMsQ0FBQztJQUVEOzs7T0FHRztJQUNILElBQUk7UUFDSCxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFFRCxlQUFlO0lBQ2YsT0FBTyxDQUFDLElBQTJCO1FBQ2xDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ2pELENBQUM7SUFFRDs7O09BR0c7SUFDSCxNQUFNLENBQUMsR0FBVztRQUNqQixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDdEIsQ0FBQztJQUVELGVBQWU7SUFDZixLQUFLO1FBQ0osSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQzNDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxRQUFRO1FBQ1AsSUFBSSxHQUFHLEdBQUcsRUFBRSxDQUFDO1FBRWIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsR0FBRyxJQUFJLEdBQUcsR0FBRyxNQUFNLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQztRQUU3RSxPQUFPLEdBQUcsQ0FBQztJQUNaLENBQUM7Q0FDRDtBQWpGRCxzQkFpRkM7Ozs7O0FDcEZEOztHQUVHO0FBQ0gsTUFBcUIsS0FBSztJQWdCdEI7OztPQUdHO0lBQ0gsWUFBWSxjQUFzQixHQUFHO1FBQ2pDLElBQUksQ0FBQyxZQUFZLEdBQUcsV0FBVyxDQUFDO1FBQ2hDLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQ3RDLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO1FBQ2QsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7UUFDZCxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztJQUNsQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsT0FBTyxDQUFDLElBQU87UUFDWCxJQUFHLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsWUFBWSxLQUFLLElBQUksQ0FBQyxJQUFJLEVBQUM7WUFDakQsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDO1NBQ3REO1FBRUQsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUM7UUFDZixJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUM7UUFDekIsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQztJQUNwRCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsT0FBTztRQUNILElBQUcsSUFBSSxDQUFDLElBQUksS0FBSyxJQUFJLENBQUMsSUFBSSxFQUFDO1lBQ3ZCLE1BQU0sSUFBSSxLQUFLLENBQUMscUNBQXFDLENBQUMsQ0FBQztTQUMxRDtRQUdELElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDO1FBQ2YsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDN0Isc0JBQXNCO1FBQ3RCLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDekIsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQztRQUVoRCxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsUUFBUTtRQUNKLElBQUcsSUFBSSxDQUFDLElBQUksS0FBSyxJQUFJLENBQUMsSUFBSSxFQUFDO1lBQ3ZCLE1BQU0sa0NBQWtDLENBQUE7U0FDM0M7UUFFRCxJQUFJLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUU3QixPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsUUFBUTtRQUNKLE9BQU8sSUFBSSxDQUFDLElBQUksS0FBSyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQ25DLENBQUM7SUFFRDs7O09BR0c7SUFDSCxPQUFPO1FBQ0gsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQ3JCLENBQUM7SUFFRCxlQUFlO0lBQ2YsS0FBSztRQUNELElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLEVBQUUsQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUNwRCxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztRQUNkLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztJQUMxQixDQUFDO0lBRUQsZUFBZTtJQUNmLE9BQU8sQ0FBQyxJQUF1QztRQUMzQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO1FBQ2xCLE9BQU0sQ0FBQyxLQUFLLElBQUksQ0FBQyxJQUFJLEVBQUM7WUFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDbkIsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUM7U0FDbkM7SUFDTCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsUUFBUTtRQUNKLElBQUksTUFBTSxHQUFHLEVBQUUsQ0FBQztRQUVoQixJQUFJLENBQUMsT0FBTyxDQUFFLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFO1lBQzFCLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQTtZQUN6QixJQUFHLEtBQUssS0FBSyxDQUFDLEVBQUM7Z0JBQ1gsR0FBRyxJQUFJLE1BQU0sQ0FBQTthQUNoQjtZQUNELE1BQU0sR0FBRyxHQUFHLEdBQUcsTUFBTSxDQUFDO1FBQzFCLENBQUMsQ0FBQyxDQUFDO1FBRUgsT0FBTyxTQUFTLEdBQUcsTUFBTSxDQUFDO0lBQzlCLENBQUM7Q0FDSjtBQTVIRCx3QkE0SEM7Ozs7O0FDL0hEOztHQUVHO0FBQ0gsTUFBcUIsS0FBSztJQVV0Qjs7O09BR0c7SUFDSCxZQUFZLGNBQXNCLEdBQUc7UUFDakMsSUFBSSxDQUFDLFlBQVksR0FBRyxXQUFXLENBQUM7UUFDaEMsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLEtBQUssQ0FBSSxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDN0MsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQztJQUNuQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsSUFBSSxDQUFDLElBQU87UUFDUixJQUFHLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxLQUFLLElBQUksQ0FBQyxZQUFZLEVBQUM7WUFDbkMsTUFBTSxpQ0FBaUMsQ0FBQztTQUMzQztRQUNELElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDO1FBQ2YsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDO0lBQ2pDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxHQUFHO1FBQ0MsSUFBRyxJQUFJLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxFQUFDO1lBQ2hCLE1BQU0scUNBQXFDLENBQUM7U0FDL0M7UUFDRCxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQztRQUNmLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxJQUFJO1FBQ0EsSUFBRyxJQUFJLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxFQUFDO1lBQ2hCLE1BQU0sa0NBQWtDLENBQUM7U0FDNUM7UUFDRCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2pDLENBQUM7SUFFRDs7TUFFRTtJQUNGLE9BQU87UUFDSCxPQUFPLElBQUksQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDNUIsQ0FBQztJQUVELGVBQWU7SUFDZixLQUFLO1FBQ0QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUFDLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQ3hELElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDbkIsQ0FBQztJQUVEOzs7T0FHRztJQUNILElBQUk7UUFDQSxPQUFPLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0lBQ3pCLENBQUM7SUFFRCxlQUFlO0lBQ2YsT0FBTyxDQUFDLElBQXVDO1FBQzNDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNWLE9BQU0sQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUM7WUFDakIsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDdkIsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNWO0lBQ0wsQ0FBQztJQUVEOzs7T0FHRztJQUNILFFBQVE7UUFDSixJQUFJLE1BQU0sR0FBRyxFQUFFLENBQUM7UUFFaEIsSUFBSSxDQUFDLE9BQU8sQ0FBRSxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsRUFBRTtZQUMxQixJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUE7WUFDekIsSUFBRyxLQUFLLEtBQUssQ0FBQyxFQUFDO2dCQUNYLEdBQUcsSUFBSSxNQUFNLENBQUE7YUFDaEI7WUFDRCxNQUFNLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQztRQUMxQixDQUFDLENBQUMsQ0FBQztRQUVILE9BQU8sU0FBUyxHQUFHLE1BQU0sQ0FBQztJQUM5QixDQUFDO0NBQ0o7QUF0R0Qsd0JBc0dDOzs7O0FDM0dELGNBQWM7O0FBRWQ7O0dBRUc7QUFDSCxNQUFNLFFBQVEsR0FBRyxHQUFHLEVBQUUsR0FBRSxDQUFDLENBQUM7QUFFMUIsa0JBQWUsUUFBUSxDQUFDOzs7OztBQ1B4Qjs7R0FFRztBQUNILE1BQXFCLFFBQVE7SUFRekI7Ozs7T0FJRztJQUNOLFlBQVksS0FBYSxFQUFFLE1BQWU7UUFDekMsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7UUFDZixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUNqQixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbkMsQ0FBQztDQUNEO0FBbEJELDJCQWtCQzs7Ozs7Ozs7O0FDckJELDBEQUFrQztBQUVyQixRQUFBLEtBQUssR0FBRyxLQUFLLENBQUM7QUFFM0I7O0dBRUc7QUFDSCxNQUFxQixLQUFLO0lBY3pCOzs7T0FHRztJQUNILFlBQVksV0FBb0IsS0FBSztRQUNwQyxJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixJQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQztRQUV0QixJQUFJLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQztRQUNyQixJQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQztRQUVsQixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksS0FBSyxDQUFDLGFBQUssQ0FBQyxDQUFDO1FBQzlCLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxLQUFLLENBQUMsYUFBSyxDQUFDLENBQUM7SUFDaEMsQ0FBQztJQUVEOztNQUVFO0lBQ0YsT0FBTztRQUNOLE9BQU8sSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQzNCLENBQUM7SUFFRDs7OztNQUlFO0lBQ0YsT0FBTyxDQUFDLENBQVMsRUFBRSxDQUFTLEVBQUUsTUFBZTtRQUM1QyxJQUFJLElBQUksR0FBRyxJQUFJLGtCQUFRLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBSW5DLElBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBQztZQUNoQixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDMUI7UUFFRCxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztRQUVyQixJQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBQztZQUNqQixJQUFJLEdBQUcsSUFBSSxrQkFBUSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQztZQUUvQixJQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUM7Z0JBQ2hCLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUMxQjtZQUVELElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO1NBQ3JCO1FBRUQsSUFBSSxDQUFDLFFBQVEsSUFBSSxDQUFDLENBQUM7SUFDcEIsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILFVBQVUsQ0FBQyxDQUFTLEVBQUUsQ0FBUztRQUM5QixJQUFJLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRXpCLE9BQU0sSUFBSSxLQUFLLElBQUksRUFBQztZQUNuQixJQUFHLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFDO2dCQUNmLE9BQU8sSUFBSSxDQUFDO2FBQ1o7WUFDRCxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztTQUNqQjtJQUNGLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsUUFBUSxDQUFDLENBQVM7UUFDakIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3RCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxTQUFTLENBQUMsQ0FBUztRQUNsQixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7O09BSUc7SUFDTyxZQUFZLENBQUMsS0FBYTtRQUNuQyxPQUFPLE9BQU8sR0FBRyxLQUFLLENBQUM7SUFDeEIsQ0FBQztJQUVEOzs7T0FHRztJQUNILFFBQVE7UUFDUCxJQUFJLE1BQU0sR0FBRyxFQUFFLENBQUM7UUFFaEIsS0FBSSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxFQUFFLEVBQUM7WUFDeEMsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN6QixJQUFJLE9BQU8sR0FBRyxFQUFFLENBQUM7WUFDakIsT0FBTSxJQUFJLEtBQUssU0FBUyxJQUFJLElBQUksS0FBSyxJQUFJLEVBQUM7Z0JBQ3pDLE9BQU8sSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDO2dCQUM3QixJQUFHLElBQUksQ0FBQyxRQUFRLEVBQUM7b0JBQ2hCLE9BQU8sSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLE1BQU0sR0FBRyxHQUFHLENBQUM7aUJBQ3BDO2dCQUNELElBQUcsSUFBSSxDQUFDLElBQUksS0FBSyxJQUFJLEVBQUM7b0JBQ3JCLE9BQU8sSUFBSSxJQUFJLENBQUM7aUJBQ2hCO2dCQUVELElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO2FBQ2pCO1lBRUQsTUFBTSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxHQUFHLE9BQU8sR0FBRyxJQUFJLENBQUM7U0FDdkQ7UUFFRCxPQUFPLE1BQU0sQ0FBQztJQUNmLENBQUM7Q0FDRDtBQXhJRCx3QkF3SUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvSUQsaURBQXVDO0FBSXZDOzs7RUFHRTtBQUNGLE1BQXFCLGFBQWMsU0FBUSxlQUFLO0lBSS9DOzs7T0FHRztJQUNILFlBQVksV0FBb0IsS0FBSztRQUNwQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7UUE2RmpCLGdCQUFXLEdBQUcsR0FBUyxFQUFFO1lBQ3hCLG9DQUFvQztZQUNwQyxxRkFBcUY7WUFDckYsSUFBSTtRQUNMLENBQUMsQ0FBQTtRQWhHQSxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksS0FBSyxDQUFDLGFBQUssQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsaUJBQWlCLENBQUMsUUFBYztRQUMvQixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxRQUFRLENBQUM7UUFDNUMsT0FBTyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILGVBQWUsQ0FBQyxLQUFhLEVBQUUsUUFBYztRQUM1QyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxHQUFHLFFBQVEsQ0FBQztRQUVqQyxxREFBcUQ7UUFDckQsS0FBSSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxFQUFFLEVBQUM7WUFFckMsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUV6QixPQUFNLElBQUksS0FBSyxJQUFJLEVBQUM7Z0JBQ25CLGlFQUFpRTtnQkFDakUsSUFBRyxDQUFDLEtBQUssS0FBSyxJQUFJLElBQUksQ0FBQyxDQUFDLEtBQUssS0FBSyxFQUFDO29CQUNsQyxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7aUJBQ25FO2dCQUVELElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO2FBQ2pCO1NBQ0Q7SUFDRixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILGVBQWUsQ0FBQyxLQUFhO1FBQzVCLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxPQUFPLENBQUMsQ0FBUyxFQUFFLENBQVM7UUFDM0IsSUFBRyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFDO1lBQzNDLE1BQU0sdUNBQXVDLENBQUM7U0FDOUM7UUFFRCwyQ0FBMkM7UUFDM0MsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRTdELEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRUQsWUFBWTtJQUNGLFlBQVksQ0FBQyxLQUFhO1FBQ25DLE9BQU8sT0FBTyxHQUFHLEtBQUssR0FBRyxLQUFLLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNuRSxDQUFDO0lBRUU7Ozs7T0FJRztJQUNJLElBQUksQ0FBQyxRQUFjO1FBQ3RCLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUM7UUFDL0IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1YsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO1FBQ2QsSUFBSSxJQUFJLEdBQUcsUUFBUSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDcEQsT0FBTSxDQUFDLEdBQUcsQ0FBQyxFQUFDO1lBQ1gsSUFBSSxDQUFDLEdBQUcsUUFBUSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDakQsSUFBRyxDQUFDLEdBQUcsSUFBSSxFQUFDO2dCQUNYLElBQUksR0FBRyxDQUFDLENBQUM7Z0JBQ1QsS0FBSyxHQUFHLENBQUMsQ0FBQzthQUNWO1lBQ0QsQ0FBQyxFQUFFLENBQUM7U0FDSjtRQUVELE9BQU8sS0FBSyxDQUFDO0lBQ1gsQ0FBQztDQU9KO0FBM0dELGdDQTJHQzs7Ozs7O0FDakdELFNBQWdCLFFBQVEsQ0FBQyxHQUFRO0lBQzdCLE9BQU8sR0FBRyxJQUFJLEdBQUcsQ0FBQyxJQUFJLElBQUksR0FBRyxDQUFDLEtBQUssSUFBSSxHQUFHLENBQUMsUUFBUSxDQUFDO0FBQ3hELENBQUM7QUFGRCw0QkFFQzs7Ozs7Ozs7QUNwQkQsa0RBQTBCO0FBRTFCLG9CQUFvQjtBQUNwQixNQUFxQixNQUFNO0lBRzFCO1FBQ0MsSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLFlBQVksQ0FBQztZQUMzQixDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO1lBQ1YsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztZQUNWLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7WUFDVixDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO1NBQ1YsQ0FBQyxDQUFDO0lBQ0osQ0FBQztJQUVELGlCQUFpQjtJQUNqQixNQUFNLEtBQUssUUFBUTtRQUNsQixPQUFPLElBQUksTUFBTSxFQUFFLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDaEMsQ0FBQztJQUVELE1BQU0sS0FBSyxJQUFJO1FBQ2QsT0FBTyxJQUFJLE1BQU0sRUFBRSxDQUFDLElBQUksRUFBRSxDQUFDO0lBQzVCLENBQUM7SUFFRCxZQUFZO0lBQ1osSUFBSSxHQUFHLENBQUMsQ0FBUztRQUNoQixJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNqQixDQUFDO0lBRUQsR0FBRyxDQUFDLEdBQVcsRUFBRSxHQUFXLEVBQUUsS0FBYTtRQUMxQyxJQUFHLEdBQUcsR0FBRyxDQUFDLElBQUksR0FBRyxHQUFHLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDLEVBQUM7WUFDM0MsTUFBTSxrQkFBa0IsR0FBRyxLQUFLLEdBQUcsK0JBQStCLENBQUE7U0FDbEU7UUFDRCxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDO1FBRTlCLE9BQU8sSUFBSSxDQUFDO0lBQ2IsQ0FBQztJQUVELEdBQUcsQ0FBQyxHQUFXLEVBQUUsR0FBVztRQUMzQixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRUQsTUFBTSxDQUFDLEdBQUcsS0FBb0I7UUFDN0IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDcEIsT0FBTyxJQUFJLENBQUM7SUFDYixDQUFDO0lBRUQsUUFBUTtRQUNQLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FDakIsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUNWLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFDVixDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQ1YsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUNWLENBQUE7SUFDRixDQUFDO0lBRUQsSUFBSTtRQUNILE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FDakIsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUNWLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFDVixDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQ1YsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUNWLENBQUM7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILE1BQU0sQ0FBQyxRQUFnQjtRQUN0QixPQUFPLElBQUksQ0FBQyxNQUFNLENBQ2pCLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFHLENBQUMsRUFBRSxDQUFDLEVBQzlDLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsRUFBRyxDQUFDLEVBQUUsQ0FBQyxFQUM3QyxDQUFDLEVBQU8sQ0FBQyxFQUFRLENBQUMsRUFBRSxDQUFDLEVBQ3JCLENBQUMsRUFBTyxDQUFDLEVBQVEsQ0FBQyxFQUFFLENBQUMsQ0FDckIsQ0FBQztJQUNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsU0FBUyxDQUFDLFdBQWdDO1FBQ3pDLHlDQUF5QztRQUN6QyxJQUFHLFdBQVcsWUFBWSxjQUFJLEVBQUM7WUFDOUIsV0FBVyxHQUFHLFdBQVcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztTQUNwQztRQUVELE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FDakIsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQyxFQUN2QixDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFDLEVBQ3ZCLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFDVixDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQ1YsQ0FBQztJQUNILENBQUM7SUFFRCxLQUFLLENBQUMsS0FBbUM7UUFDeEMsb0NBQW9DO1FBQ3BDLElBQUcsS0FBSyxZQUFZLGNBQUksRUFBQztZQUN4QixLQUFLLEdBQUcsS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDO1NBQ3hCO2FBQU0sSUFBRyxDQUFDLENBQUMsS0FBSyxZQUFZLFlBQVksQ0FBQyxFQUFDO1lBQzFDLEtBQUssR0FBRyxJQUFJLFlBQVksQ0FBQyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO1NBQ3pDO1FBRUQsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUNqQixLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFJLENBQUMsRUFBRSxDQUFDLEVBQ25CLENBQUMsRUFBTSxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFDckIsQ0FBQyxFQUFNLENBQUMsRUFBRyxDQUFDLEVBQUUsQ0FBQyxFQUNmLENBQUMsRUFBTSxDQUFDLEVBQUcsQ0FBQyxFQUFFLENBQUMsQ0FDZixDQUFDO0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxJQUFJLENBQUMsS0FBYSxFQUFFLEdBQVk7UUFDL0IsSUFBSSxJQUFJLEdBQUcsSUFBSSxZQUFZLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFaEMsS0FBSSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBQztZQUN6QixLQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFDO2dCQUN6QixJQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7Z0JBQ2QsS0FBSSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBQztvQkFDekIsS0FBSyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2lCQUMxQztnQkFDRCxJQUFJLENBQUMsQ0FBQyxHQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBSSxLQUFLLENBQUM7YUFDdkI7U0FDRDtRQUVELElBQUcsR0FBRyxLQUFLLFNBQVMsRUFBQztZQUNwQixPQUFPLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztTQUMzQjthQUFNO1lBQ04sT0FBTyxJQUFJLE1BQU0sRUFBRSxDQUFDLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO1NBQ3BDO0lBQ0YsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBbUI7UUFDakMscUJBQXFCO1FBQ3JCLElBQUksSUFBSSxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUM7UUFFM0IsNkNBQTZDO1FBQzdDLEtBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFDO1lBQ25DLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQ3pCO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDYixDQUFDO0lBRUQsT0FBTztRQUNOLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQztJQUNqQixDQUFDO0lBRUQsUUFBUTtRQUNQLE9BQVEsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSztZQUN0SCxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLO1lBQ2hILElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUs7WUFDbEgsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO0lBQ3RILENBQUM7Q0FDRDtBQW5LRCx5QkFtS0M7Ozs7O0FDaktEOztHQUVHO0FBQ0gsTUFBcUIsYUFBYTtJQW1COUI7Ozs7T0FJRztJQUNOLFlBQVksSUFBWSxFQUFFLFFBQWMsRUFBRSxLQUFlLEVBQUUsSUFBWSxFQUFFLElBQVU7UUFDbEYsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFDWCxJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUNqQixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztJQUN4QixDQUFDO0NBQ0Q7QUEvQkQsZ0NBK0JDOzs7Ozs7OztBQ3ZDRCxtREFBMkI7QUFFM0I7OztHQUdHO0FBQ0gsTUFBcUIsR0FBRztJQUF4QjtRQUdJLHNDQUFzQztRQUN0QyxjQUFTLEdBQVMsY0FBSSxDQUFDLElBQUksQ0FBQztRQUM1QixvQ0FBb0M7UUFDcEMsUUFBRyxHQUFTLGNBQUksQ0FBQyxJQUFJLENBQUM7UUFDdEIsc0NBQXNDO1FBQ3RDLFVBQUssR0FBUyxjQUFJLENBQUMsSUFBSSxDQUFDO1FBQ3hCLG1DQUFtQztRQUNuQyxXQUFNLEdBQVMsY0FBSSxDQUFDLElBQUksQ0FBQztJQUM3QixDQUFDO0NBQUE7QUFYRCxzQkFXQzs7Ozs7QUNqQkQsd0RBQXdEO0FBQ3hELE1BQXFCLGdCQUFnQjtJQVVwQzs7T0FFRztJQUNILE1BQU0sQ0FBQyxFQUF5QjtRQUMvQix1Q0FBdUM7UUFDdkMsSUFBRyxJQUFJLENBQUMsT0FBTyxFQUFDO1lBQ2YsRUFBRSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDL0I7UUFFRCxJQUFHLElBQUksQ0FBQyxZQUFZLEVBQUM7WUFDcEIsRUFBRSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7U0FDbkM7UUFFRCxJQUFHLElBQUksQ0FBQyxjQUFjLEVBQUM7WUFDdEIsRUFBRSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7U0FDckM7SUFDRixDQUFDO0NBQ0Q7QUEzQkQsbUNBMkJDOzs7Ozs7OztBQzVCRCxvREFBNEI7QUFDNUIsbURBQTJCO0FBQzNCLHNFQUE4QztBQUM5QyxzREFBOEI7QUFDOUIseURBQWlDO0FBRWpDOzs7R0FHRztBQUNILE1BQXFCLElBQUssU0FBUSxlQUFLO0lBSW5DOzs7O09BSUc7SUFDSCxZQUFZLE1BQWEsRUFBRSxRQUFlO1FBQ3RDLEtBQUssRUFBRSxDQUFDO1FBQ1IsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxjQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQy9DLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksY0FBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBRUQsbUVBQW1FO0lBQ25FLElBQUksT0FBTztRQUNQLE9BQU8sSUFBSSxjQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUE7SUFDeEMsQ0FBQztJQUVELG9FQUFvRTtJQUNwRSxJQUFJLFFBQVE7UUFDUixPQUFPLElBQUksY0FBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFBO0lBQ3pDLENBQUM7SUFFRCxzRUFBc0U7SUFDdEUsSUFBSSxVQUFVO1FBQ1YsT0FBTyxJQUFJLGNBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQTtJQUMzQyxDQUFDO0lBRUQsdUVBQXVFO0lBQ3ZFLElBQUksV0FBVztRQUNYLE9BQU8sSUFBSSxjQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUE7SUFDNUMsQ0FBQztJQUVELFlBQVk7SUFDWixlQUFlO1FBQ1gsT0FBTyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDeEIsQ0FBQztJQUVELFlBQVk7SUFDWixpQkFBaUI7UUFDYixJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFBO1FBQ2xDLE9BQU8sSUFBSSxnQkFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDOUMsQ0FBQztJQUVELGNBQWM7SUFDZCxXQUFXO1FBQ1AsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQ3pCLENBQUM7SUFFRCxjQUFjO0lBQ2QsV0FBVyxDQUFDLFFBQWM7UUFDdEIsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7SUFDN0IsQ0FBQztJQUVELDJDQUEyQztJQUMzQzs7OztPQUlHO0lBQ0gsYUFBYSxDQUFDLEtBQVc7UUFDckIsT0FBTyxLQUFLLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsSUFBSSxLQUFLLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUU7ZUFDMUQsS0FBSyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLElBQUksS0FBSyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUE7SUFDckUsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxjQUFjLENBQUMsS0FBVztRQUN0QixJQUFJLEVBQUUsR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDMUIsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRWhDLElBQUcsRUFBRSxJQUFJLENBQUMsRUFBQztZQUNQLE9BQU8sS0FBSyxDQUFDO1NBQ2hCO1FBRUQsSUFBSSxFQUFFLEdBQUcsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQzFCLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUVoQyxJQUFHLEVBQUUsSUFBSSxDQUFDLEVBQUM7WUFDUCxPQUFPLEtBQUssQ0FBQztTQUNoQjtRQUVELE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILGlCQUFpQixDQUFDLEtBQVc7UUFDekIsT0FBTyxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsSUFBSSxLQUFLLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUU7ZUFDekQsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLElBQUksS0FBSyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUE7SUFDcEUsQ0FBQztJQUdEOzs7Ozs7T0FNRztJQUNILGdCQUFnQixDQUFDLEtBQVcsRUFBRSxLQUFXLEVBQUUsT0FBYztRQUNyRCxJQUFJLFFBQVEsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN2QyxJQUFJLFFBQVEsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUV2QyxJQUFJLE1BQU0sR0FBRyxDQUFDLEdBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUN2QixJQUFJLE1BQU0sR0FBRyxDQUFDLEdBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUV2QixJQUFJLEtBQUssR0FBRyxtQkFBUyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNuQyxJQUFJLEtBQUssR0FBRyxtQkFBUyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUVuQyxJQUFJLE1BQU0sR0FBRyxNQUFNLEdBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssR0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsUUFBUSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3BFLElBQUksTUFBTSxHQUFHLE1BQU0sR0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxHQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxRQUFRLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDcEUsSUFBSSxLQUFLLEdBQUcsTUFBTSxHQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLEdBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLFFBQVEsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNuRSxJQUFJLEtBQUssR0FBRyxNQUFNLEdBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssR0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsUUFBUSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRW5FLElBQUcsTUFBTSxHQUFHLEtBQUssSUFBSSxNQUFNLEdBQUcsS0FBSyxFQUFDO1lBQ2hDLHNFQUFzRTtZQUN0RSxPQUFPLElBQUksQ0FBQztTQUNmO1FBRUQsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFFckMsd0JBQXdCO1FBQ3hCLElBQUcsTUFBTSxLQUFLLE1BQU0sRUFBQztZQUNqQixLQUFLLEdBQUcsTUFBTSxDQUFDO1NBQ2xCO2FBQU0sSUFBSSxNQUFNLEtBQUssTUFBTSxFQUFDO1lBQ3pCLEtBQUssR0FBRyxNQUFNLENBQUM7U0FDbEI7UUFFRCxJQUFJLElBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztRQUVsQyxJQUFHLEtBQUssS0FBSyxDQUFDLFFBQVEsRUFBQztZQUNuQixPQUFPLElBQUksQ0FBQztTQUNmO1FBRUQsSUFBRyxLQUFLLElBQUksQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLEVBQUM7WUFDdkIsT0FBTyxJQUFJLENBQUM7U0FDZjtRQUVELG1CQUFtQjtRQUNuQixJQUFJLEdBQUcsR0FBRyxJQUFJLGFBQUcsRUFBRSxDQUFDO1FBQ3BCLEdBQUcsQ0FBQyxJQUFJLEdBQUcsbUJBQVMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDcEMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDO1FBQ3pCLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQztRQUV6QixJQUFHLE1BQU0sR0FBRyxNQUFNLEVBQUM7WUFDZixtQ0FBbUM7WUFDbkMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUM7WUFDdEIsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3BCO2FBQU0sSUFBRyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsR0FBRyxNQUFNLEVBQUM7WUFDekMsdUJBQXVCO1lBQ3ZCLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDO1lBQ3RCLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDO1lBQ3RCLEdBQUcsQ0FBQyxNQUFNLENBQUMsU0FBUyxFQUFFLENBQUM7U0FDMUI7YUFBTTtZQUNILDhCQUE4QjtZQUM5QixHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDakIsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUM7U0FDekI7UUFFRCxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQzFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDMUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUM7UUFDekMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUM7UUFFekMsT0FBTyxHQUFHLENBQUM7SUFDZixDQUFDO0lBRUQsWUFBWTtJQUNaLFFBQVEsQ0FBQyxLQUFZO1FBQ2pCLElBQUcsS0FBSyxZQUFZLElBQUksRUFBQztZQUNyQixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDbkM7UUFDRCxNQUFNLDJDQUEyQyxDQUFBO0lBQ3JELENBQUM7SUFFRDs7OztPQUlHO0lBQ08sWUFBWSxDQUFDLEtBQVc7UUFDOUIsSUFBSSxFQUFFLEdBQUcsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQzFCLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFLEdBQUcsS0FBSyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRTNDLElBQUcsRUFBRSxJQUFJLENBQUMsRUFBQztZQUNQLE9BQU8sS0FBSyxDQUFDO1NBQ2hCO1FBRUQsSUFBSSxFQUFFLEdBQUcsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQzFCLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFLEdBQUcsS0FBSyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRTNDLElBQUcsRUFBRSxJQUFJLENBQUMsRUFBQztZQUNQLE9BQU8sS0FBSyxDQUFDO1NBQ2hCO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILFdBQVcsQ0FBQyxLQUFXO1FBQ25CLElBQUksRUFBRSxHQUFHLEtBQUssQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUMxQixJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxHQUFHLEtBQUssQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUUzQyxJQUFJLEVBQUUsR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDMUIsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxLQUFLLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFM0Msa0VBQWtFO1FBQ2xFLElBQUcsQ0FBQyxFQUFFLEtBQUssQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBSyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFDO1lBQzlDLElBQUksR0FBRyxHQUFHLElBQUksY0FBSSxFQUFFLENBQUM7WUFFckIsSUFBRyxFQUFFLEtBQUssQ0FBQyxFQUFDO2dCQUNSLEdBQUcsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3JDO1lBRUQsSUFBRyxFQUFFLEtBQUssQ0FBQyxFQUFDO2dCQUNSLEdBQUcsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3JDO1lBRUQsT0FBTyxHQUFHLENBQUM7U0FDZDthQUFNO1lBQ0gsT0FBTyxJQUFJLENBQUM7U0FDZjtJQUNMLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0gseUJBQXlCLENBQUMsS0FBVztRQUNqQyxJQUFJLEVBQUUsR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDMUIsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxLQUFLLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFM0MsSUFBSSxFQUFFLEdBQUcsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQzFCLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFLEdBQUcsS0FBSyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRTNDLGlFQUFpRTtRQUNqRSxJQUFHLENBQUMsRUFBRSxLQUFLLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLEtBQUssQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBQztZQUM1QyxJQUFJLEdBQUcsR0FBRyxJQUFJLGNBQUksRUFBRSxDQUFDO1lBRXJCLElBQUcsRUFBRSxLQUFLLENBQUMsRUFBQztnQkFDUixHQUFHLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUNyQztpQkFBTTtnQkFDSCxHQUFHLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUNyQztZQUVELE9BQU8sR0FBRyxDQUFDO1NBRWQ7YUFBTTtZQUNILE9BQU8sSUFBSSxDQUFDO1NBQ2Y7SUFDTCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILFdBQVcsQ0FBQyxLQUFXO1FBQ25CLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQzNELElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQzVELElBQUksRUFBRSxHQUFHLE1BQU0sR0FBRyxLQUFLLENBQUM7UUFFeEIsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDM0QsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDNUQsSUFBSSxFQUFFLEdBQUcsTUFBTSxHQUFHLEtBQUssQ0FBQztRQUV4QixJQUFHLEVBQUUsR0FBRyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUM7WUFBRSxPQUFPLENBQUMsQ0FBQztRQUU5QixPQUFPLEVBQUUsR0FBQyxFQUFFLENBQUM7SUFDakIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsS0FBSyxDQUFDLFFBQWMsRUFBRSxZQUFtQixFQUFFLFFBQWU7UUFDdEQsSUFBRyxDQUFDLFlBQVksRUFBQztZQUNiLFlBQVksR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO1NBQzlCO1FBRUQsSUFBRyxDQUFDLFFBQVEsRUFBQztZQUNULFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO1NBQzVCO1FBRUQsSUFBSSxPQUFPLEdBQUcsWUFBWSxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQztRQUM1QyxJQUFJLE9BQU8sR0FBRyxZQUFZLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDO1FBRTVDLElBQUksSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxFQUFFLFlBQVksQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDM0YsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLEVBQUUsWUFBWSxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUUzRixJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDbEMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsT0FBTyxHQUFHLElBQUksRUFBRSxPQUFPLEdBQUcsSUFBSSxDQUFDLENBQUM7SUFDdEQsQ0FBQztJQUVELFlBQVk7SUFDWixLQUFLO1FBQ0QsT0FBTyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztJQUNoRSxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsUUFBUTtRQUNKLE9BQU8sV0FBVyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLEdBQUcsZUFBZSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFLEdBQUcsR0FBRyxDQUFBO0lBQ2xHLENBQUM7Q0FDSjtBQXhVRCx1QkF3VUM7Ozs7Ozs7O0FDbFZELG1EQUEyQjtBQUMzQixrREFBMEI7QUFDMUIsb0RBQTRCO0FBRTVCOztHQUVHO0FBQ0gsTUFBcUIsTUFBTyxTQUFRLGVBQUs7SUFJeEM7Ozs7T0FJRztJQUNILFlBQVksTUFBWSxFQUFFLE1BQWM7UUFDdkMsS0FBSyxFQUFFLENBQUM7UUFDRixJQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLGNBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDaEQsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3pDLENBQUM7SUFFRCxJQUFJLE1BQU07UUFDVCxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUM7SUFDckIsQ0FBQztJQUVELElBQUksTUFBTSxDQUFDLE1BQVk7UUFDdEIsSUFBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7SUFDdkIsQ0FBQztJQUVELElBQUksUUFBUTtRQUNYLE9BQU8sSUFBSSxjQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDM0MsQ0FBQztJQUVELElBQUksQ0FBQztRQUNKLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUNwQixDQUFDO0lBRUQsSUFBSSxDQUFDLENBQUMsTUFBYztRQUNuQixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztJQUN0QixDQUFDO0lBRUQsWUFBWTtJQUNaOzs7O09BSU07SUFDSCxhQUFhLENBQUMsS0FBVztRQUNyQixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxJQUFJLElBQUksQ0FBQyxNQUFNLEdBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUN0RSxDQUFDO0lBRUosWUFBWTtJQUNaLGVBQWU7UUFDZCxPQUFPLElBQUksY0FBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUUsSUFBSSxjQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUMzRSxDQUFDO0lBRUQsWUFBWTtJQUNaLGlCQUFpQjtRQUNoQixPQUFPLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUNyQixDQUFDO0lBRUQsWUFBWTtJQUNaLFFBQVEsQ0FBQyxLQUFZO1FBQ3BCLE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBRUQsWUFBWTtJQUNaLEtBQUs7UUFDSixPQUFPLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3RELENBQUM7SUFFRCxRQUFRO1FBQ1AsT0FBTyxXQUFXLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsR0FBRyxZQUFZLEdBQUcsSUFBSSxDQUFDLE1BQU0sR0FBRyxHQUFHLENBQUM7SUFDaEYsQ0FBQztDQUNEO0FBcEVELHlCQW9FQzs7Ozs7Ozs7QUMzRUQsbURBQTJCO0FBQzNCLGtEQUEwQjtBQUcxQjs7R0FFRztBQUNILE1BQThCLEtBQUs7SUFPL0IsSUFBSSxDQUFDO1FBQ0QsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUN6QixDQUFDO0lBRUQsSUFBSSxDQUFDO1FBQ0QsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUN6QixDQUFDO0lBRUQsSUFBSSxFQUFFO1FBQ0YsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztJQUMzQixDQUFDO0lBRUQsSUFBSSxFQUFFO1FBQ0YsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztJQUMzQixDQUFDO0lBRUQsSUFBSSxHQUFHO1FBQ0gsT0FBTyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUM7SUFDNUIsQ0FBQztJQUVELElBQUksTUFBTTtRQUNOLE9BQU8sSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDO0lBQzVCLENBQUM7SUFFRCxJQUFJLElBQUk7UUFDSixPQUFPLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQztJQUM1QixDQUFDO0lBRUQsSUFBSSxLQUFLO1FBQ0wsT0FBTyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUM7SUFDNUIsQ0FBQztJQW9DRCxNQUFNLENBQUMsa0JBQWtCLENBQUMsQ0FBUSxFQUFFLElBQVUsRUFBRSxDQUFRLEVBQUUsSUFBVTtRQUN0RSxJQUFHLENBQUMsWUFBWSxjQUFJLElBQUksQ0FBQyxZQUFZLGNBQUksRUFBQztZQUN6QyxPQUFPLEtBQUssQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztTQUM1RDtJQUNDLENBQUM7SUFFTyxNQUFNLENBQUMsNEJBQTRCLENBQUMsQ0FBTyxFQUFFLElBQVUsRUFBRSxDQUFRLEVBQUUsSUFBVTtRQUNqRixJQUFJLFVBQVUsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDO1FBQzFCLElBQUksU0FBUyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUM7UUFFekIsSUFBSSxXQUFXLEdBQUcsQ0FBQyxDQUFDLFFBQVEsQ0FBQztRQUM3QixJQUFJLFVBQVUsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDO1FBRTVCLElBQUksWUFBWSxHQUFHLElBQUksY0FBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNsQyxJQUFJLFdBQVcsR0FBRyxJQUFJLGNBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFFakMsSUFBSSxVQUFVLEdBQUcsS0FBSyxDQUFDO1FBQ3ZCLElBQUksVUFBVSxHQUFHLEtBQUssQ0FBQztRQUV2QixtQkFBbUI7UUFDbkIsSUFBRyxTQUFTLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDLEVBQUM7WUFDMUIscURBQXFEO1lBQ3JELElBQUksSUFBVSxDQUFDO1lBQ2YsSUFBSSxHQUFHLFdBQVcsQ0FBQztZQUNuQixXQUFXLEdBQUcsVUFBVSxDQUFDO1lBQ3pCLFVBQVUsR0FBRyxJQUFJLENBQUM7WUFFbEIsSUFBSSxHQUFHLFVBQVUsQ0FBQztZQUNsQixVQUFVLEdBQUcsU0FBUyxDQUFDO1lBQ3ZCLFNBQVMsR0FBRyxJQUFJLENBQUM7WUFFakIsSUFBSSxHQUFHLElBQUksQ0FBQztZQUNaLElBQUksR0FBRyxJQUFJLENBQUM7WUFDWixJQUFJLEdBQUcsSUFBSSxDQUFDO1NBQ2Y7UUFFRCx3QkFBd0I7UUFDeEIsWUFBWSxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUM7UUFDMUIsV0FBVyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUM7UUFFekIsSUFBSSxTQUFTLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDLElBQUksVUFBVSxDQUFDLENBQUMsR0FBRyxXQUFXLENBQUMsQ0FBQyxFQUFDO1lBQzNELG1DQUFtQztZQUNuQyxJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7WUFFN0IsSUFBRyxNQUFNLEdBQUcsQ0FBQyxFQUFDO2dCQUNWLHdDQUF3QztnQkFDeEMsWUFBWSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFDLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQzFGLFdBQVcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQzVGO1NBQ0o7YUFBTTtZQUNILFVBQVUsR0FBRyxJQUFJLENBQUM7U0FDckI7UUFFRCxJQUFHLFNBQVMsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUMsRUFBQztZQUMxQixrREFBa0Q7WUFDbEQsSUFBSSxJQUFVLENBQUM7WUFDZixJQUFJLEdBQUcsV0FBVyxDQUFDO1lBQ25CLFdBQVcsR0FBRyxVQUFVLENBQUM7WUFDekIsVUFBVSxHQUFHLElBQUksQ0FBQztZQUVsQixJQUFJLEdBQUcsVUFBVSxDQUFDO1lBQ2xCLFVBQVUsR0FBRyxTQUFTLENBQUM7WUFDdkIsU0FBUyxHQUFHLElBQUksQ0FBQztZQUVqQixJQUFJLEdBQUcsSUFBSSxDQUFDO1lBQ1osSUFBSSxHQUFHLElBQUksQ0FBQztZQUNaLElBQUksR0FBRyxJQUFJLENBQUM7U0FDZjtRQUVELHdCQUF3QjtRQUN4QixZQUFZLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQztRQUMxQixXQUFXLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQztRQUV6QixJQUFJLFNBQVMsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUMsSUFBSSxVQUFVLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDLEVBQUM7WUFDM0QsbUNBQW1DO1lBQ25DLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQztZQUU3QixJQUFHLE1BQU0sR0FBRyxDQUFDLEVBQUM7Z0JBQ1Ysd0NBQXdDO2dCQUN4QyxZQUFZLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDMUYsV0FBVyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFDLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDNUY7U0FDSjthQUFNO1lBQ0gsVUFBVSxHQUFHLElBQUksQ0FBQztTQUNyQjtRQUVELE9BQU8sQ0FBQyxZQUFZLEVBQUUsV0FBVyxFQUFFLFVBQVUsRUFBRSxVQUFVLENBQUMsQ0FBQztJQUMvRCxDQUFDO0NBQ0o7QUFqS0Qsd0JBaUtDOzs7Ozs7OztBQ3hLRCxtRUFBMkM7QUFLM0M7OztHQUdHO0FBQ0gsTUFBOEIsS0FBSztJQU8vQjs7O09BR0c7SUFDSCxZQUFZLE1BQW9CO1FBQzVCLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxpQkFBTyxFQUFFLENBQUM7SUFDakMsQ0FBQztJQWlCRDs7O09BR0c7SUFDTyxRQUFRLENBQUMsU0FBaUI7UUFDaEMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDdkMsQ0FBQztDQU9KO0FBNUNELHdCQTRDQzs7Ozs7Ozs7QUNyREQsaUVBQXlDO0FBRXpDLDZEQUFxQztBQUVyQyxxRUFBNkM7QUFDN0MsbUVBQTJDO0FBRzNDOzs7R0FHRztBQUNILE1BQXFCLFlBQVk7SUFrQjdCOztPQUVHO0lBQ0g7UUFDSSxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksZUFBSyxFQUFFLENBQUM7UUFDekIsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLGFBQUcsRUFBRSxDQUFDO1FBQzFCLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxrQkFBUSxFQUFFLENBQUM7UUFDL0IsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLGlCQUFPLEVBQUUsQ0FBQztRQUM3QixJQUFJLENBQUMsc0JBQXNCLEdBQUcsS0FBSyxDQUFDO0lBQ3hDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxTQUFTLENBQUMsSUFBYTtRQUNuQixJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQztJQUN2QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gseUJBQXlCLENBQUMsb0JBQTRCO1FBQ2xELElBQUksQ0FBQyxzQkFBc0IsR0FBRyxJQUFJLENBQUM7UUFDbkMsSUFBSSxDQUFDLG9CQUFvQixHQUFHLG9CQUFvQixDQUFDO0lBQ3JELENBQUM7SUFFRDs7T0FFRztJQUNILDRCQUE0QjtRQUN4QixJQUFJLENBQUMsc0JBQXNCLEdBQUcsS0FBSyxDQUFDO0lBQ3hDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxVQUFVLENBQUMsWUFBb0IsRUFBRSxPQUE2QjtRQUMxRCxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO1FBQ2pELElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUN0QyxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNuQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3pCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsUUFBUSxDQUFDLFNBQWlCLEVBQUUsS0FBWTtRQUNwQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDeEMsQ0FBQztJQUVEOzs7T0FHRztJQUNILFdBQVcsQ0FBQyxLQUFhO1FBQ3JCLHlCQUF5QjtRQUN6QixJQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBRXpDLHlEQUF5RDtRQUN6RCxJQUFHLEtBQUssS0FBSyxVQUFVLEVBQUM7WUFDcEIsc0NBQXNDO1lBQ3RDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUM7U0FDcEI7YUFBTTtZQUNILDhFQUE4RTtZQUM5RSxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQ2pCLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7U0FDN0M7UUFFRCx3Q0FBd0M7UUFDeEMsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDO1FBRXRDLDZCQUE2QjtRQUM3QixJQUFHLElBQUksQ0FBQyxzQkFBc0IsRUFBQztZQUMzQixJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsb0JBQW9CLEVBQUUsRUFBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFlBQVksRUFBQyxDQUFDLENBQUM7U0FDakY7UUFFRCxzQkFBc0I7UUFDdEIsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDdkMsQ0FBQztJQUVEOzs7T0FHRztJQUNILFdBQVcsQ0FBQyxLQUFnQjtRQUN4QixJQUFHLElBQUksQ0FBQyxNQUFNLEVBQUM7WUFDWCxJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUN4QztJQUNMLENBQUM7SUFFRCxlQUFlO0lBQ2YsTUFBTSxDQUFDLE1BQWM7UUFDakIsb0JBQW9CO1FBQ3BCLE9BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLEVBQUUsRUFBQztZQUMvQixJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRSxDQUFDO1lBQ3pDLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDM0I7UUFFRCwyQ0FBMkM7UUFDM0MsSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDckMsQ0FBQztDQUNKO0FBNUhELCtCQTRIQzs7Ozs7Ozs7QUN4SUQsNEZBQW9FO0FBQ3BFLG1EQUEyQjtBQUczQjs7O0dBR0c7QUFDSCxNQUFxQixPQUFPO0lBZ0J4QiwyRUFBMkU7SUFDM0UsWUFBWSxXQUE2QjtRQUNyQywrQ0FBK0M7UUFDL0MsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxpQkFBaUIsQ0FBQyxTQUEyQjtRQUN6QyxJQUFJLENBQUMsT0FBTyxHQUFHLFNBQVMsQ0FBQyxTQUFTLEdBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQztRQUNyRCxJQUFJLENBQUMsT0FBTyxHQUFHLFNBQVMsQ0FBQyxPQUFPLENBQUM7UUFDakMsSUFBSSxDQUFDLFVBQVUsR0FBRyxTQUFTLENBQUMsUUFBUSxDQUFDO1FBQ3JDLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLFVBQVUsR0FBRyxTQUFTLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQztRQUMxRCxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksY0FBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLEVBQUUsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ25FLElBQUksQ0FBQyxRQUFRLEdBQUcsU0FBUyxDQUFDLEtBQUssQ0FBQztRQUNoQyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksY0FBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLEVBQUUsU0FBUyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQzNFLENBQUM7SUFFRDs7O09BR0c7SUFDSCxXQUFXO1FBQ1AsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQ3pCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gscUJBQXFCLENBQUMsU0FBaUI7UUFDbkMscUJBQXFCO1FBQ3JCLElBQUksS0FBSyxHQUFHLFNBQVMsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDO1FBQ3hDLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUMzQyxJQUFJLEdBQUcsR0FBRyxLQUFLLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQztRQUMvQixJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUM1QixJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUU3Qiw4REFBOEQ7UUFDOUQsSUFBSSxJQUFJLEdBQUcsR0FBRyxHQUFHLEtBQUssQ0FBQztRQUN2QixJQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsTUFBTSxDQUFDO1FBRXZCLE9BQU8sSUFBSSxjQUFJLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQy9CLENBQUM7SUFFRDs7O09BR0c7SUFDSCxhQUFhO1FBQ1QsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDO0lBQzNCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxXQUFXO1FBQ1AsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQ3pCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxVQUFVO1FBQ04sT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO0lBQ3hCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxVQUFVO1FBQ04sT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO0lBQ3hCLENBQUM7SUFFRCxZQUFZO1FBQ1IsT0FBTyxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDO0lBQy9DLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsT0FBTyxDQUFDLFNBQWlCO1FBQ3JCLE9BQU8sU0FBUyxJQUFJLElBQUksQ0FBQyxVQUFVLElBQUksU0FBUyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUM7SUFDdEUsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ0gsVUFBVSxDQUFDLEdBQTZCLEVBQUUsU0FBaUIsRUFBRSxTQUFpQixFQUFFLE9BQWUsRUFBRSxNQUFZLEVBQUUsS0FBVyxFQUFFLElBQVk7UUFDcEksSUFBSSxLQUFLLEdBQUcseUJBQWUsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRWxFLHFCQUFxQjtRQUNyQixJQUFJLEtBQUssR0FBRyxTQUFTLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQztRQUN4QyxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDM0MsSUFBSSxHQUFHLEdBQUcsS0FBSyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUM7UUFDL0IsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDNUIsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFFN0IsOERBQThEO1FBQzlELElBQUksSUFBSSxHQUFHLEdBQUcsR0FBRyxLQUFLLENBQUM7UUFDdkIsSUFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQztRQUV2Qix5REFBeUQ7UUFDekQsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUMsR0FBRyxLQUFLLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzVELElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDLEdBQUcsTUFBTSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN2RSxHQUFHLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDNUwsQ0FBQztDQUNKO0FBeklELDBCQXlJQzs7Ozs7Ozs7QUNqSkQsbUVBQTJDO0FBRTNDOztHQUVHO0FBQ0gsTUFBcUIsSUFBSTtJQVd4Qjs7OztPQUlHO0lBQ0gsWUFBWSxJQUFZLENBQUMsRUFBRSxJQUFZLENBQUM7UUFWeEM7O1dBRUc7UUFDSyxhQUFRLEdBQWEsR0FBRyxFQUFFLEdBQUUsQ0FBQyxDQUFDO1FBUXJDLElBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDL0IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDaEIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDakIsQ0FBQztJQUVELDBDQUEwQztJQUMxQyxJQUFJLENBQUM7UUFDSixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDcEIsQ0FBQztJQUVELElBQUksQ0FBQyxDQUFDLENBQVM7UUFDZCxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUVoQixJQUFHLElBQUksQ0FBQyxRQUFRLEVBQUM7WUFDaEIsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1NBQ2hCO0lBQ0YsQ0FBQztJQUVELElBQUksQ0FBQztRQUNKLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNwQixDQUFDO0lBRUQsSUFBSSxDQUFDLENBQUMsQ0FBUztRQUNkLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRWhCLElBQUcsSUFBSSxDQUFDLFFBQVEsRUFBQztZQUNoQixJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7U0FDaEI7SUFDRixDQUFDO0lBRUQsTUFBTSxLQUFLLElBQUk7UUFDZCxPQUFPLElBQUksSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBSUQsTUFBTSxLQUFLLEdBQUc7UUFDYixPQUFPLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQsTUFBTSxLQUFLLEVBQUU7UUFDWixPQUFPLElBQUksSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3hCLENBQUM7SUFFRCxNQUFNLEtBQUssSUFBSTtRQUNkLE9BQU8sSUFBSSxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3ZCLENBQUM7SUFFRCxNQUFNLEtBQUssSUFBSTtRQUNkLE9BQU8sSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDeEIsQ0FBQztJQUVELE1BQU0sS0FBSyxLQUFLO1FBQ2YsT0FBTyxJQUFJLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxLQUFLO1FBQ0osT0FBTyxJQUFJLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxHQUFHO1FBQ0YsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO0lBQ2hDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxTQUFTO1FBQ1IsSUFBRyxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUM7WUFBRSxPQUFPLElBQUksQ0FBQztRQUM3QyxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDckIsSUFBSSxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUM7UUFDZCxJQUFJLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQztRQUNkLE9BQU8sSUFBSSxDQUFDO0lBQ2IsQ0FBQztJQUVEOzs7T0FHRztJQUNILFVBQVU7UUFDVCxJQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsRUFBQztZQUNoQixPQUFPLElBQUksQ0FBQztTQUNaO1FBRUQsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ3JCLE9BQU8sSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBQyxHQUFHLENBQUMsQ0FBQztJQUN6QyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsSUFBSTtRQUNILE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsVUFBVSxDQUFDLEtBQWEsRUFBRSxTQUFpQixDQUFDO1FBQzNDLElBQUksQ0FBQyxDQUFDLEdBQUcsbUJBQVMsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDM0QsSUFBSSxDQUFDLENBQUMsR0FBRyxtQkFBUyxDQUFDLFlBQVksQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQzVELE9BQU8sSUFBSSxDQUFDO0lBQ2IsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxLQUFLLENBQUMsS0FBVztRQUNoQixPQUFPLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNyRCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyxLQUFXO1FBQ2hCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxTQUFTLEVBQUUsQ0FBQztJQUN0QyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILE9BQU8sQ0FBQyxTQUFpQjtRQUN4QixPQUFPLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDMUMsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsS0FBSyxDQUFDLE1BQWMsRUFBRSxVQUFrQixJQUFJO1FBQzNDLElBQUcsT0FBTyxLQUFLLElBQUksRUFBQztZQUNuQixJQUFJLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQztZQUNqQixJQUFJLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQztZQUNsQixPQUFPLElBQUksQ0FBQztTQUNaO1FBQ0QsSUFBSSxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUM7UUFDakIsSUFBSSxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUM7UUFDakIsT0FBTyxJQUFJLENBQUM7SUFDYixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxNQUFNLENBQUMsTUFBYyxFQUFFLFVBQWtCLElBQUk7UUFDNUMsT0FBTyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILFNBQVMsQ0FBQyxLQUFhO1FBQ3RCLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDekIsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN6QixJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFDLEVBQUUsQ0FBQztRQUNsQyxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFDLEVBQUUsQ0FBQztRQUNsQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQztRQUNmLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDO1FBQ2YsT0FBTyxJQUFJLENBQUM7SUFDYixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxHQUFHLENBQUMsQ0FBUyxFQUFFLENBQVM7UUFDdkIsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDWCxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNYLE9BQU8sSUFBSSxDQUFDO0lBQ2IsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxJQUFJLENBQUMsS0FBVztRQUNmLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNuQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEdBQUcsQ0FBQyxLQUFXO1FBQ2QsSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQ2xCLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQztRQUNsQixPQUFPLElBQUksQ0FBQztJQUNiLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILEdBQUcsQ0FBQyxDQUFTLEVBQUUsQ0FBVTtRQUN4QixJQUFHLENBQUMsS0FBSyxTQUFTLEVBQUM7WUFDbEIsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDWixJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNaO2FBQU07WUFDTixJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNaLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ1o7UUFDRCxPQUFPLElBQUksQ0FBQztJQUNiLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsR0FBRyxDQUFDLEtBQVc7UUFDZCxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDbEIsSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQ2xCLE9BQU8sSUFBSSxDQUFDO0lBQ2IsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxJQUFJLENBQUMsS0FBVztRQUNmLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQztRQUNsQixJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDbEIsT0FBTyxJQUFJLENBQUM7SUFDYixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEdBQUcsQ0FBQyxLQUFXO1FBQ2QsSUFBRyxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUM7WUFBRSxNQUFNLHNCQUFzQixDQUFDO1FBQ2hFLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQztRQUNsQixJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDbEIsT0FBTyxJQUFJLENBQUM7SUFDYixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILFNBQVMsQ0FBQyxLQUFXO1FBQ3BCLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQzFCLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQzFCLE9BQU8sSUFBSSxDQUFDO0lBQ2IsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxZQUFZLENBQUMsS0FBVztRQUN2QixPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdEYsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxVQUFVLENBQUMsS0FBVztRQUNyQixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQzVDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsR0FBRyxDQUFDLEtBQVc7UUFDZCxPQUFPLElBQUksQ0FBQyxDQUFDLEdBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDeEMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxVQUFVLENBQUMsS0FBVztRQUNyQixJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzFCLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDMUMsSUFBSSxLQUFLLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUVsQyxJQUFHLEtBQUssR0FBRyxDQUFDLEVBQUM7WUFDWixLQUFLLElBQUksQ0FBQyxHQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7U0FDbkI7UUFFRCxPQUFPLEtBQUssQ0FBQztJQUNkLENBQUM7SUFFRDs7O09BR0c7SUFDSCxRQUFRO1FBQ1AsT0FBTyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxPQUFPLENBQUMsbUJBQTJCLENBQUM7UUFDbkMsT0FBTyxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxHQUFHLENBQUM7SUFDL0YsQ0FBQztJQUVEOzs7T0FHRztJQUNILEtBQUs7UUFDSixPQUFPLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2pDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsWUFBWSxDQUFDLEtBQVc7UUFDdkIsT0FBTyxJQUFJLENBQUMsQ0FBQyxLQUFLLEtBQUssQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ2pELENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsTUFBTSxDQUFDLEtBQVc7UUFDakIsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxTQUFTLENBQUM7UUFDakQsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxTQUFTLENBQUM7UUFFakQsT0FBTyxHQUFHLElBQUksR0FBRyxDQUFDO0lBQ25CLENBQUM7SUFFRDs7O09BR0c7SUFDSCxZQUFZO1FBQ1gsT0FBTyxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsTUFBTTtRQUNMLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsU0FBUyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLFNBQVMsQ0FBQztJQUNyRSxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsV0FBVyxDQUFDLENBQVc7UUFDdEIsSUFBSSxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUM7SUFDbkIsQ0FBQztJQUVELE9BQU87UUFDTixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUM7SUFDakIsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBTyxFQUFFLENBQU8sRUFBRSxDQUFTO1FBQ3RDLE9BQU8sSUFBSSxJQUFJLENBQUMsbUJBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLG1CQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzNFLENBQUM7O0FBemFGLHVCQTBhQztBQXZYZ0IsZ0JBQVcsR0FBRyxJQUFJLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7Ozs7Ozs7O0FDeEQ5Qyx1RUFBK0M7QUFDL0MsNkRBQXFDO0FBRXJDLDJEQUFtQztBQUVuQzs7R0FFRztBQUNILE1BQXFCLEtBQUs7SUFpQnpCOzs7O09BSUc7SUFDSCxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQVUsRUFBRSxHQUFHLFFBQWE7UUFDdEMsb0JBQW9CO1FBQ3BCLDRDQUE0QztRQUM1QyxzQ0FBc0M7UUFDdEMsSUFBSTtRQUNKLGdDQUFnQztRQUNoQyxJQUFJLE9BQU8sR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDL0QsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUFFRDs7O09BR0c7SUFDSCxNQUFNLENBQUMsWUFBWSxDQUFDLEVBQVU7UUFDN0IsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVEOzs7T0FHRztJQUNILE1BQU0sQ0FBQyxRQUFRLENBQUMsS0FBc0I7UUFDckMsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7SUFDcEIsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBWSxFQUFFLFFBQWMsRUFBRSxNQUFlLEVBQUUsS0FBWTtRQUN6RSxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMscUJBQXFCLENBQUMsV0FBVyxDQUFDO1FBQ25ELElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUVqRCxJQUFHLE1BQU0sRUFBQztZQUNULElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ3hELElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQyxHQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxDQUFDO1NBQzlHO2FBQU07WUFDTixJQUFJLFNBQVMsR0FBRyxDQUFDLENBQUM7WUFDbEIsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7WUFDakQsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDMUQsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUM7U0FDaEg7UUFFRCxJQUFJLENBQUMscUJBQXFCLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQztJQUNoRCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsTUFBTSxDQUFDLFVBQVUsQ0FBQyxNQUFZLEVBQUUsTUFBYyxFQUFFLE1BQWUsRUFBRSxLQUFZO1FBQzVFLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxXQUFXLENBQUM7UUFDbkQsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBRWpELElBQUcsTUFBTSxFQUFDO1lBQ1QsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDeEQsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFNBQVMsRUFBRSxDQUFDO1lBQ3ZDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxFQUFFLE1BQU0sRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUMzRSxJQUFJLENBQUMscUJBQXFCLENBQUMsU0FBUyxFQUFFLENBQUM7WUFDdkMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLElBQUksRUFBRSxDQUFDO1NBQ2xDO2FBQU07WUFDTixJQUFJLFNBQVMsR0FBRyxDQUFDLENBQUM7WUFDbEIsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7WUFDakQsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDMUQsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFNBQVMsRUFBRSxDQUFDO1lBQ3ZDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxFQUFFLE1BQU0sRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUMzRSxJQUFJLENBQUMscUJBQXFCLENBQUMsU0FBUyxFQUFFLENBQUM7WUFDdkMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLE1BQU0sRUFBRSxDQUFDO1NBQ3BDO1FBRUQsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUM7SUFDaEQsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFVLEVBQUUsRUFBUSxFQUFFLEtBQVk7UUFDaEQsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUM7UUFDekMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7UUFFMUQsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ3ZDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbEQsSUFBSSxDQUFDLHFCQUFxQixDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM5QyxJQUFJLENBQUMscUJBQXFCLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDdkMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLE1BQU0sRUFBRSxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsTUFBTSxDQUFDLFNBQVMsQ0FBQyxHQUFTLEVBQUUsS0FBWTtRQUN2QyxJQUFJLFNBQVMsR0FBRyxDQUFDLENBQUM7UUFDbEIsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDeEQsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLFNBQVMsR0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxTQUFTLEdBQUMsQ0FBQyxFQUFFLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUNyRyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsTUFBTSxDQUFDLG1CQUFtQixDQUFDLEtBQVk7UUFDdEMsSUFBSSxDQUFDLGdCQUFnQixHQUFHLEtBQUssQ0FBQztJQUMvQixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsTUFBTSxDQUFDLHFCQUFxQixDQUFDLE1BQXlCLEVBQUUsS0FBYSxFQUFFLE1BQWM7UUFDOUUsTUFBTSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDM0IsTUFBTSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFFdkIsSUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLGNBQUksQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFFekMsSUFBSSxDQUFDLHFCQUFxQixHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFckQsT0FBTyxJQUFJLENBQUMscUJBQXFCLENBQUM7SUFDekMsQ0FBQztJQUVELDhCQUE4QjtJQUM5QixNQUFNLENBQUMsV0FBVztRQUNqQixJQUFJLENBQUMscUJBQXFCLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM1RixDQUFDO0lBRUQsMERBQTBEO0lBQzFELE1BQU0sQ0FBQyxNQUFNO1FBQ1osSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ2xCLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUNwQixDQUFDO0lBRUQsZ0RBQWdEO0lBQ2hELE1BQU0sQ0FBQyxVQUFVO1FBQ2hCLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNYLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLEdBQUcsWUFBWSxDQUFDO1FBQy9DLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxDQUFDO1FBRXhFLHVCQUF1QjtRQUN2QixJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQVcsRUFBRSxFQUFFO1lBQ3hDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFBO1lBQ3JFLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDVCxDQUFDLENBQUMsQ0FBQztJQUNKLENBQUM7SUFFRCx5REFBeUQ7SUFDekQsTUFBTSxDQUFDLFdBQVc7UUFDakIsSUFBRyxJQUFJLENBQUMsS0FBSyxFQUFDO1lBQ2IsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQ3pCLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUNwQixDQUFDLENBQUMsQ0FBQztTQUNIO0lBQ0YsQ0FBQzs7QUEzTEYsd0JBNExDO0FBMUxBLHFEQUFxRDtBQUN0QyxpQkFBVyxHQUFnQixJQUFJLGFBQUcsRUFBRSxDQUFDO0FBV3BELG1DQUFtQztBQUNwQixzQkFBZ0IsR0FBVSxlQUFLLENBQUMsS0FBSyxDQUFDOzs7Ozs7OztBQ3ZCdEQsMkRBQW1DO0FBRW5DLGNBQWM7QUFDZCxNQUFxQixLQUFNLFNBQVEsTUFBTTtJQTJCckMsTUFBTSxDQUFDLFNBQVM7UUFDWixJQUFJLE1BQU0sR0FBc0IsUUFBUSxDQUFDLGNBQWMsQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUN4RSxNQUFNLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUM7UUFDakMsTUFBTSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDO1FBQ25DLElBQUksQ0FBQyxHQUFHLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUVuQyxJQUFJLENBQUMsUUFBUSxHQUFtQixRQUFRLENBQUMsY0FBYyxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBRXpFLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxLQUFLLEVBQUUsQ0FBQztRQUUzQixJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7UUFDbEMsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLEtBQUssRUFBRSxDQUFDO1FBQ2hDLElBQUksQ0FBQyxjQUFjLEdBQUcsQ0FBQyxDQUFDO1FBRXhCLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxLQUFLLEVBQUUsQ0FBQztRQUNqQyxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7UUFDL0IsSUFBSSxDQUFDLGFBQWEsR0FBRyxDQUFDLENBQUM7UUFFdkIsSUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLEtBQUssRUFBRSxDQUFDO1FBQ25DLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxLQUFLLEVBQUUsQ0FBQztRQUNqQyxJQUFJLENBQUMsZUFBZSxHQUFHLENBQUMsQ0FBQztRQUV6QixJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7UUFDbEMsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLEtBQUssRUFBRSxDQUFDO1FBQ2hDLElBQUksQ0FBQyxjQUFjLEdBQUcsQ0FBQyxDQUFDO1FBRXhCLElBQUksU0FBUyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDL0MsU0FBUyxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFDeEMsSUFBSSxRQUFRLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM5QyxRQUFRLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztRQUN0QyxJQUFJLFVBQVUsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2hELFVBQVUsQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLFVBQVUsQ0FBQyxDQUFDO1FBQzFDLElBQUksU0FBUyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDL0MsU0FBUyxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFDeEMsSUFBSSxHQUFHLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN2QyxJQUFJLEdBQUcsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3ZDLElBQUksR0FBRyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFdkMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsU0FBUyxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFVBQVUsRUFBRSxHQUFHLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFFaEYsSUFBSSxDQUFDLFlBQVksR0FBc0IsUUFBUSxDQUFDLGNBQWMsQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUMvRSxJQUFJLE9BQU8sR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQy9DLE9BQU8sQ0FBQyxLQUFLLEdBQUcsU0FBUyxDQUFDO1FBQzFCLE9BQU8sQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ3RCLElBQUksT0FBTyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDL0MsT0FBTyxDQUFDLEtBQUssR0FBRyxnQkFBZ0IsQ0FBQztRQUNqQyxPQUFPLENBQUMsS0FBSyxHQUFHLFlBQVksQ0FBQztRQUM3QixJQUFJLE9BQU8sR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQy9DLE9BQU8sQ0FBQyxLQUFLLEdBQUcsZUFBZSxDQUFDO1FBQ2hDLE9BQU8sQ0FBQyxLQUFLLEdBQUcsV0FBVyxDQUFDO1FBQzVCLElBQUksT0FBTyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDL0MsT0FBTyxDQUFDLEtBQUssR0FBRyxpQkFBaUIsQ0FBQztRQUNsQyxPQUFPLENBQUMsS0FBSyxHQUFHLGFBQWEsQ0FBQztRQUM5QixJQUFJLE9BQU8sR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQy9DLE9BQU8sQ0FBQyxLQUFLLEdBQUcsZ0JBQWdCLENBQUM7UUFDakMsT0FBTyxDQUFDLEtBQUssR0FBRyxZQUFZLENBQUM7UUFDN0IsSUFBSSxTQUFTLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNqRCxTQUFTLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUN4QixTQUFTLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUN4QixJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQ3JGLENBQUM7SUFFRCxNQUFNLENBQUMsU0FBUyxDQUFDLEdBQVc7UUFDeEIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDdkIsSUFBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsVUFBVSxFQUFDO1lBQ3RDLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLENBQUM7U0FDeEI7UUFFRCxJQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBQztZQUM1QixJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDOUMsSUFBRyxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsVUFBVSxFQUFDO2dCQUM1QyxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssRUFBRSxDQUFDO2FBQy9CO1NBQ0o7UUFDRCxJQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBQztZQUMzQixJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDNUMsSUFBRyxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsVUFBVSxFQUFDO2dCQUMzQyxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxDQUFDO2FBQzlCO1NBQ0o7UUFDRCxJQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBQztZQUM3QixJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7WUFDaEQsSUFBRyxJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsVUFBVSxFQUFDO2dCQUM3QyxJQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssRUFBRSxDQUFDO2FBQ2hDO1NBQ0o7UUFDRCxJQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBQztZQUM1QixJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDOUMsSUFBRyxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsVUFBVSxFQUFDO2dCQUM1QyxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssRUFBRSxDQUFDO2FBQy9CO1NBQ0o7UUFFRCxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7SUFDekIsQ0FBQztJQUVELE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBVyxFQUFFLElBQVM7UUFDN0IsSUFBRyxHQUFHLEtBQUssU0FBUyxFQUFDO1lBQ2pCLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzdCLElBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLEdBQUcsR0FBRyxFQUFDO2dCQUM5QixJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssRUFBRSxDQUFDO2FBQzdCO1NBQ0o7YUFBTSxJQUFHLEdBQUcsS0FBSyxRQUFRLEVBQUM7WUFDdkIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDNUIsSUFBRyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sR0FBRyxHQUFHLEVBQUM7Z0JBQzdCLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLENBQUM7YUFDNUI7U0FDSjthQUFNLElBQUcsR0FBRyxLQUFLLFVBQVUsRUFBQztZQUN6QixJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUM5QixJQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxHQUFHLEdBQUcsRUFBQztnQkFDL0IsSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUUsQ0FBQzthQUM5QjtTQUNKO2FBQU0sSUFBRyxHQUFHLEtBQUssU0FBUyxFQUFDO1lBQ3hCLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzdCLElBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLEdBQUcsSUFBSSxFQUFDO2dCQUMvQixJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssRUFBRSxDQUFDO2FBQzdCO1NBQ0o7SUFFTCxDQUFDO0lBRUQsTUFBTSxDQUFDLE1BQU07UUFDVCxnQkFBZ0I7UUFDaEIsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO0lBQ3RCLENBQUM7SUFFRCxNQUFNLENBQUMsVUFBVTtRQUNiLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7UUFFaEUsSUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUM7UUFFMUMsSUFBRyxXQUFXLEtBQUssU0FBUyxJQUFJLFdBQVcsS0FBSyxLQUFLLEVBQUM7WUFDbEQsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQztZQUN6QixJQUFJLEtBQUssR0FBRyxlQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ2xDLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO1NBQ2hDO1FBQ0QsSUFBRyxXQUFXLEtBQUssZ0JBQWdCLElBQUksV0FBVyxLQUFLLEtBQUssRUFBQztZQUN6RCxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDO1lBQ2hDLElBQUksS0FBSyxHQUFHLGVBQUssQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDakMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7U0FDaEM7UUFDRCxJQUFHLFdBQVcsS0FBSyxlQUFlLElBQUksV0FBVyxLQUFLLEtBQUssRUFBQztZQUN4RCxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDO1lBQy9CLElBQUksS0FBSyxHQUFHLGVBQUssQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDbkMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7U0FDaEM7UUFDRCxJQUFHLFdBQVcsS0FBSyxpQkFBaUIsSUFBSSxXQUFXLEtBQUssS0FBSyxFQUFDO1lBQzFELElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUM7WUFDakMsSUFBSSxLQUFLLEdBQUcsZUFBSyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUNsQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztTQUNoQztRQUNELElBQUcsV0FBVyxLQUFLLGdCQUFnQixJQUFJLFdBQVcsS0FBSyxLQUFLLEVBQUM7WUFDekQsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQztZQUNoQyxJQUFJLEtBQUssR0FBRyxlQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ3BDLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO1NBQ2hDO0lBQ0wsQ0FBQztJQUVELE1BQU0sQ0FBQyxTQUFTLENBQUMsS0FBb0IsRUFBRSxLQUFhO1FBQ2hELElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxHQUFHLGVBQUssQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDOUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNyQixJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDeEIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxhQUFhLEdBQUcsRUFBRSxDQUFDLENBQUM7UUFDN0MsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNyQixJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ2xCLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDckIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxhQUFhLEdBQUcsRUFBRSxDQUFDLENBQUM7UUFDN0MsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFlBQVksR0FBRyxFQUFFLEVBQUUsSUFBSSxDQUFDLGFBQWEsR0FBRyxFQUFFLENBQUMsQ0FBQztRQUNqRSxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUM7UUFFbEIsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDO1FBQzdCLElBQUksS0FBSyxHQUFHLEVBQUUsQ0FBQztRQUNmLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxhQUFhLEdBQUcsRUFBRSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBQyxHQUFHLEdBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxHQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQzNFLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQztRQUU3QixLQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBQztZQUNqQyxJQUFJLEdBQUcsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbkIsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBQyxDQUFDLElBQUksQ0FBQyxZQUFZLEdBQUcsRUFBRSxDQUFDLEdBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQztZQUN4RCxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsYUFBYSxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUMsR0FBRyxHQUFDLENBQUMsSUFBSSxDQUFDLGFBQWEsR0FBQyxFQUFFLENBQUMsQ0FBQTtZQUNqRSxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxDQUFDO1lBQ3JCLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztZQUM5QixJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDdEIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUNyQixJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBRWxCLEtBQUssR0FBRyxDQUFDLENBQUM7WUFDVixLQUFLLEdBQUcsQ0FBQyxDQUFDO1NBQ2I7SUFDTCxDQUFDO0lBRUQsTUFBTSxDQUFDLGFBQWE7UUFDaEIsSUFBRyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUM7WUFDNUIsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFBRSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsR0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQztTQUNwRztRQUVELElBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFDO1lBQzNCLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEVBQUUsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLEdBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUM7U0FDakc7UUFFRCxJQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBQztZQUNqQyxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxFQUFFLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDO1NBQ25HO1FBRUQsSUFBRyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUM7WUFDNUIsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFBRSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsR0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQztTQUNwRztRQUVELFFBQVEsQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLENBQUMsU0FBUyxHQUFHLHFCQUFxQixHQUFHLElBQUksQ0FBQyxjQUFjLENBQUM7UUFDM0YsUUFBUSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxTQUFTLEdBQUcsb0JBQW9CLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQztRQUN4RixRQUFRLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxDQUFDLFNBQVMsR0FBRyxzQkFBc0IsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDO1FBQzlGLFFBQVEsQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLENBQUMsU0FBUyxHQUFHLHFCQUFxQixHQUFHLElBQUksQ0FBQyxjQUFjLENBQUM7SUFDL0YsQ0FBQzs7QUEvT0wsd0JBZ1BDO0FBN08yQixnQkFBVSxHQUFXLEVBQUUsQ0FBQztBQUVqQyxrQkFBWSxHQUFXLEdBQUcsQ0FBQztBQUMzQixtQkFBYSxHQUFXLEdBQUcsQ0FBQzs7Ozs7Ozs7QUNSL0MsOERBQXNDO0FBQ3RDLDREQUFvQztBQUVwQzs7O0dBR0c7QUFDSCxNQUFxQixPQUFPO0lBSTNCLDRCQUE0QjtJQUM1QjtRQUNDLElBQUksQ0FBQyxVQUFVLEdBQUcsb0JBQVUsQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUM1QyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILFNBQVMsQ0FBQyxTQUFpQixFQUFFLE9BQXVDLElBQUk7UUFDdkUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsSUFBSSxtQkFBUyxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQzFELENBQUM7Q0FDRDtBQWpCRCwwQkFpQkM7Ozs7Ozs7O0FDekJELDJFQUFtRDtBQUNuRCx1RUFBK0M7QUFHL0MsbURBQWdEO0FBRWhEOzs7Ozs7Ozs7Ozs7Ozs7OztHQWlCRztBQUNILE1BQXFCLFVBQVU7SUFZM0I7UUFDSSxJQUFJLENBQUMsUUFBUSxHQUFHLEdBQUcsQ0FBQztRQUNwQixJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksZUFBSyxDQUFZLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM3QyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksYUFBRyxFQUFtQixDQUFDO0lBQ25ELENBQUM7SUFFRSx5REFBeUQ7SUFDNUQsTUFBTSxDQUFDLFdBQVc7UUFDakIsSUFBRyxJQUFJLENBQUMsUUFBUSxLQUFLLElBQUksRUFBQztZQUN6QixJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksVUFBVSxFQUFFLENBQUM7U0FDakM7UUFFRCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7SUFDdEIsQ0FBQztJQUVFOzhGQUMwRjtJQUMxRixRQUFRLENBQUMsS0FBZ0I7UUFDckIsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDMUIsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILFNBQVMsQ0FBQyxRQUFrQixFQUFFLElBQTRCO1FBQ3RELElBQUcsSUFBSSxZQUFZLEtBQUssRUFBQztZQUNyQixrREFBa0Q7WUFDbEQsS0FBSSxJQUFJLENBQUMsSUFBSSxJQUFJLEVBQUM7Z0JBQ2QsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUM7YUFDakM7U0FDSjthQUFNO1lBQ0gsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FDcEM7SUFDUixDQUFDO0lBRUU7Ozs7T0FJRztJQUNILFdBQVcsQ0FBQyxRQUFrQixFQUFFLEdBQUcsTUFBcUI7UUFDcEQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLEVBQUU7WUFDL0Isa0VBQWtFO1lBQ2xFLElBQUcsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQUUsT0FBTztZQUVqRSw4Q0FBOEM7WUFDOUMsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBRTVELDZDQUE2QztZQUM3QyxJQUFHLEtBQUssS0FBSyxDQUFDLENBQUMsRUFBQztnQkFDWixJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO2FBQ2xEO1FBQ0wsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQsc0NBQXNDO0lBQ2pDLFdBQVcsQ0FBQyxRQUFrQixFQUFFLElBQVk7UUFDbkQsSUFBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBQztZQUMzQixJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDeEM7YUFBTTtZQUNOLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7U0FDckM7SUFDRixDQUFDO0lBRUUsTUFBTSxDQUFDLE1BQWM7UUFDakIsT0FBTSxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxFQUFDO1lBQ3BCLHNCQUFzQjtZQUMvQixJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBRXBCLHVEQUF1RDtZQUN2RCxJQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBQztnQkFDOUIsS0FBSSxJQUFJLFFBQVEsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUM7b0JBQy9DLFFBQVEsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7aUJBQzNCO2FBQ2I7WUFFUSwrREFBK0Q7WUFDL0QsSUFBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyw2QkFBYSxDQUFDLEdBQUcsQ0FBQyxFQUFDO2dCQUNyQyxLQUFJLElBQUksUUFBUSxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLDZCQUFhLENBQUMsR0FBRyxDQUFDLEVBQUM7b0JBQ3RELFFBQVEsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7aUJBQzNCO2FBQ0o7U0FDSjtJQUNMLENBQUM7O0FBbkdMLDZCQW9HQztBQW5Ha0IsbUJBQVEsR0FBZSxJQUFJLENBQUM7Ozs7Ozs7O0FDekIvQyx1RUFBOEM7QUFFOUM7O0dBRUc7QUFDSCxNQUFxQixTQUFTO0lBUTFCOzs7OztPQUtHO0lBQ0gsWUFBWSxJQUFZLEVBQUUsT0FBdUMsSUFBSTtRQUNqRSw0QkFBNEI7UUFDNUIsSUFBSSxJQUFJLEtBQUssSUFBSSxFQUFFO1lBQ2YsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLGFBQUcsRUFBTyxDQUFDO1NBQzlCO2FBQU0sSUFBSSxDQUFDLENBQUMsSUFBSSxZQUFZLGFBQUcsQ0FBQyxFQUFDO1lBQzlCLCtCQUErQjtZQUMvQixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksYUFBRyxFQUFPLENBQUM7WUFDM0IsS0FBSSxJQUFJLEdBQUcsSUFBSSxJQUFJLEVBQUM7Z0JBQ2hCLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQzthQUNqQztTQUNKO2FBQU07WUFDSCxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztTQUNwQjtRQUVELElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2pCLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBQzNCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsTUFBTSxDQUFDLElBQVk7UUFDZixPQUFPLElBQUksQ0FBQyxJQUFJLEtBQUssSUFBSSxDQUFDO0lBQzlCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxRQUFRO1FBQ0osT0FBTyxJQUFJLENBQUMsSUFBSSxHQUFHLEtBQUssR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQ3pDLENBQUM7Q0FDSjtBQWhERCw0QkFnREM7Ozs7QUNyREQsY0FBYzs7O0FBRWQsSUFBWSxhQXVHWDtBQXZHRCxXQUFZLGFBQWE7SUFDeEI7O09BRUc7SUFDSCwwQ0FBeUIsQ0FBQTtJQUN6Qjs7T0FFRztJQUNILHNDQUFxQixDQUFBO0lBQ3JCOztPQUVHO0lBQ0gsMENBQXlCLENBQUE7SUFFekI7O09BRUc7SUFDSCxzQ0FBcUIsQ0FBQTtJQUVyQjs7T0FFRztJQUNILGtDQUFpQixDQUFBO0lBRWpCOztPQUVHO0lBQ0gsNENBQTJCLENBQUE7SUFFM0I7O09BRUc7SUFDSCxzQ0FBcUIsQ0FBQTtJQUVyQjs7T0FFRztJQUNILDBDQUF5QixDQUFBO0lBRXpCOztPQUVHO0lBQ0gsb0RBQW1DLENBQUE7SUFFbkM7O09BRUc7SUFDSCxrREFBaUMsQ0FBQTtJQUVqQzs7T0FFRztJQUNILGtEQUFpQyxDQUFBO0lBRWpDOztPQUVHO0lBQ0gsMENBQXlCLENBQUE7SUFFekI7O09BRUc7SUFDSCwwQ0FBeUIsQ0FBQTtJQUV6Qjs7T0FFRztJQUNGLHNDQUFxQixDQUFBO0lBRXJCOztPQUVFO0lBQ0QsMENBQXlCLENBQUE7SUFFM0I7O09BRUc7SUFDSCw4Q0FBNkIsQ0FBQTtJQUU3Qjs7T0FFRztJQUNILGtEQUFpQyxDQUFBO0lBRWpDOztPQUVHO0lBQ0gsNEJBQVcsQ0FBQTtJQUVYOztPQUVHO0lBQ0gsMERBQXlDLENBQUE7SUFFekM7O09BRUc7SUFDSCx3REFBdUMsQ0FBQTtJQUV2Qzs7T0FFRztJQUNILDhDQUE2QixDQUFBO0FBQzlCLENBQUMsRUF2R1csYUFBYSxHQUFiLHFCQUFhLEtBQWIscUJBQWEsUUF1R3hCOzs7Ozs7OztBQ3pHRCwyRUFBbUQ7QUFDbkQsOERBQXNDO0FBR3RDOztHQUVHO0FBQ0gsTUFBcUIsUUFBUTtJQU81Qiw2QkFBNkI7SUFDN0I7UUFDQyxJQUFJLENBQUMsUUFBUSxHQUFHLEdBQUcsQ0FBQztRQUNkLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxlQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3pDLENBQUM7SUFFRCxPQUFPO1FBQ04sb0JBQVUsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUVEOzs7T0FHRztJQUNILFNBQVMsQ0FBQyxVQUFrQztRQUMzQyxvQkFBVSxDQUFDLFdBQVcsRUFBRSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFDckQsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUNoQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsT0FBTyxDQUFDLEtBQWdCO1FBQ3ZCLElBQUc7WUFDSCxJQUFJLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUNyQjtRQUFDLE9BQU0sQ0FBQyxFQUFDO1lBQ1QsT0FBTyxDQUFDLElBQUksQ0FBQyw4QkFBOEIsR0FBRyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztZQUNoRSxNQUFNLENBQUMsQ0FBQztTQUNSO0lBQ0YsQ0FBQztJQUVEOzs7T0FHRztJQUNILFlBQVk7UUFDWCxPQUFPLElBQUksQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDekIsQ0FBQztJQUVEOzs7T0FHRztJQUNILGFBQWE7UUFDWixPQUFPLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUE7SUFDekIsQ0FBQztJQUVEOzs7T0FHRztJQUNILFlBQVk7UUFDWCxPQUFPLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDMUIsQ0FBQztJQUVEOztPQUVHO0lBQ0gsWUFBWTtRQUNYLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDaEIsQ0FBQztDQUNEO0FBckVELDJCQXFFQzs7Ozs7Ozs7QUM1RUQsa0VBQTBDO0FBQzFDLHVFQUErQztBQUMvQyw2REFBcUM7QUFDckMsc0VBQThDO0FBRzlDLDJEQUF3RDtBQUV4RDs7R0FFRztBQUNILE1BQXFCLEtBQUs7SUF1QnpCOzs7T0FHRztJQUNILE1BQU0sQ0FBQyxVQUFVLENBQUMsUUFBa0IsRUFBRSxNQUFrQztRQUN2RSxLQUFLLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUMxQixLQUFLLENBQUMsWUFBWSxHQUFHLEtBQUssQ0FBQztRQUMzQixLQUFLLENBQUMsZ0JBQWdCLEdBQUcsS0FBSyxDQUFDO1FBQy9CLEtBQUssQ0FBQyxRQUFRLEdBQUcsSUFBSSxrQkFBUSxFQUFFLENBQUM7UUFDaEMsS0FBSyxDQUFDLGNBQWMsR0FBRyxJQUFJLGFBQUcsRUFBVyxDQUFDO1FBQzFDLEtBQUssQ0FBQyxVQUFVLEdBQUcsSUFBSSxhQUFHLEVBQVcsQ0FBQztRQUN0QyxLQUFLLENBQUMsYUFBYSxHQUFHLElBQUksY0FBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNyQyxLQUFLLENBQUMsa0JBQWtCLEdBQUcsSUFBSSxjQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQzFDLEtBQUssQ0FBQyxlQUFlLEdBQUcsQ0FBQyxDQUFDO1FBQzFCLEtBQUssQ0FBQyxZQUFZLEdBQUcsS0FBSyxDQUFDO1FBQzNCLEtBQUssQ0FBQyxZQUFZLEdBQUcsS0FBSyxDQUFDO1FBQzNCLEtBQUssQ0FBQyxhQUFhLEdBQUcsS0FBSyxDQUFDO1FBRTVCLHdCQUF3QjtRQUN4QixLQUFLLENBQUMsTUFBTSxHQUFHLElBQUksYUFBRyxFQUFFLENBQUM7UUFFekIsNkJBQTZCO1FBQzdCLEtBQUssSUFBSSxLQUFLLElBQUksTUFBTSxFQUFFO1lBQ3pCLElBQUksSUFBSSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUM7WUFDOUIsSUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQztZQUM5QixLQUFLLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FDN0I7UUFFRCxLQUFLLENBQUMsVUFBVSxHQUFHLG9CQUFVLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDNUMsZ0NBQWdDO1FBQ2hDLEtBQUssQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQyw2QkFBYSxDQUFDLFVBQVUsRUFBRSw2QkFBYSxDQUFDLFFBQVEsRUFBRSw2QkFBYSxDQUFDLFVBQVU7WUFDdEgsNkJBQWEsQ0FBQyxRQUFRLEVBQUUsNkJBQWEsQ0FBQyxNQUFNLEVBQUUsNkJBQWEsQ0FBQyxXQUFXLEVBQUUsNkJBQWEsQ0FBQyxRQUFRLEVBQUUsNkJBQWEsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO0lBQzdILENBQUM7SUFFRCxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQWM7UUFDM0Isd0NBQXdDO1FBQ3hDLEtBQUssQ0FBQyxnQkFBZ0IsR0FBRyxLQUFLLENBQUM7UUFDL0IsS0FBSyxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFXLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQ3BGLEtBQUssQ0FBQyxZQUFZLEdBQUcsS0FBSyxDQUFDO1FBQzNCLEtBQUssQ0FBQyxlQUFlLEdBQUcsQ0FBQyxDQUFDO1FBRTFCLE9BQU8sS0FBSyxDQUFDLFFBQVEsQ0FBQyxZQUFZLEVBQUUsRUFBRTtZQUNyQyxJQUFJLEtBQUssR0FBRyxLQUFLLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRSxDQUFDO1lBRTFDLHlCQUF5QjtZQUN6QixJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssNkJBQWEsQ0FBQyxVQUFVLEVBQUU7Z0JBQzVDLEtBQUssQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUM7Z0JBQzlCLEtBQUssQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDO2dCQUMxQixLQUFLLENBQUMsa0JBQWtCLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7Z0JBQ3RELEtBQUssQ0FBQyxrQkFBa0IsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUNwRDtZQUVELElBQUksS0FBSyxDQUFDLElBQUksS0FBSyw2QkFBYSxDQUFDLFFBQVEsRUFBRTtnQkFDMUMsS0FBSyxDQUFDLFlBQVksR0FBRyxLQUFLLENBQUM7YUFDM0I7WUFFRCxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssNkJBQWEsQ0FBQyxVQUFVLEVBQUU7Z0JBQzVDLEtBQUssQ0FBQyxhQUFhLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7YUFDakQ7WUFFRCxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssNkJBQWEsQ0FBQyxRQUFRLEVBQUU7Z0JBQzFDLElBQUksR0FBRyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUNoQyxtQkFBbUI7Z0JBQ25CLElBQUksR0FBRyxLQUFLLEdBQUcsRUFBRTtvQkFDaEIsR0FBRyxHQUFHLE9BQU8sQ0FBQztpQkFDZDtnQkFDRCxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUU7b0JBQy9CLEtBQUssQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQztvQkFDcEMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO2lCQUNoQzthQUNEO1lBRUQsSUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLDZCQUFhLENBQUMsTUFBTSxFQUFFO2dCQUN4QyxJQUFJLEdBQUcsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDaEMsbUJBQW1CO2dCQUNuQixJQUFJLEdBQUcsS0FBSyxHQUFHLEVBQUU7b0JBQ2hCLEdBQUcsR0FBRyxPQUFPLENBQUM7aUJBQ2Q7Z0JBQ0QsS0FBSyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO2FBQ2pDO1lBRUQsSUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLDZCQUFhLENBQUMsV0FBVyxFQUFFO2dCQUM3QyxLQUFLLENBQUMsZUFBZSxFQUFFLENBQUE7YUFDdkI7WUFFRCxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssNkJBQWEsQ0FBQyxRQUFRLEVBQUU7Z0JBQzFDLEtBQUssQ0FBQyxlQUFlLEdBQUcsQ0FBQyxDQUFDLENBQUM7Z0JBQzNCLEtBQUssQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDO2FBQzFCO2lCQUFNLElBQUksS0FBSyxDQUFDLElBQUksS0FBSyw2QkFBYSxDQUFDLFVBQVUsRUFBRTtnQkFDbkQsS0FBSyxDQUFDLGVBQWUsR0FBRyxDQUFDLENBQUM7Z0JBQzFCLEtBQUssQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDO2FBQzFCO1NBQ0Q7SUFDRixDQUFDO0lBRU8sTUFBTSxDQUFDLGVBQWU7UUFDN0IsS0FBSyxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFXLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQ3BGLEtBQUssQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBVyxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUM3RSxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxNQUFNLENBQUMsZ0JBQWdCLENBQUMsR0FBVztRQUNsQyxJQUFJLEtBQUssQ0FBQyxZQUFZO1lBQUUsT0FBTyxLQUFLLENBQUM7UUFFckMsSUFBSSxLQUFLLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUNsQyxPQUFPLEtBQUssQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFBO1NBQ3BDO2FBQU07WUFDTixPQUFPLEtBQUssQ0FBQztTQUNiO0lBQ0YsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxNQUFNLENBQUMsa0JBQWtCO1FBQ3hCLElBQUksS0FBSyxDQUFDLFlBQVk7WUFBRSxPQUFPLEVBQUUsQ0FBQztRQUVsQyxJQUFJLElBQUksR0FBRyxLQUFLLEVBQVUsQ0FBQztRQUMzQixLQUFLLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUNsQyxJQUFJLEtBQUssQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFO2dCQUNsQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ2Y7UUFDRixDQUFDLENBQUMsQ0FBQztRQUNILE9BQU8sSUFBSSxDQUFDO0lBQ2IsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxNQUFNLENBQUMsWUFBWSxDQUFDLEdBQVc7UUFDOUIsSUFBSSxLQUFLLENBQUMsWUFBWTtZQUFFLE9BQU8sS0FBSyxDQUFDO1FBRXJDLElBQUksS0FBSyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDOUIsT0FBTyxLQUFLLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQTtTQUNoQzthQUFNO1lBQ04sT0FBTyxLQUFLLENBQUM7U0FDYjtJQUNGLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsTUFBTSxDQUFDLGdCQUFnQixDQUFDLFNBQWlCLEVBQUUsSUFBbUI7UUFDN0QsS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUFFRDs7T0FFRztJQUNILE1BQU0sQ0FBQyxtQkFBbUI7UUFDekIsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUN0QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILE1BQU0sQ0FBQyxhQUFhLENBQUMsU0FBaUI7UUFDckMsSUFBSSxLQUFLLENBQUMsWUFBWTtZQUFFLE9BQU8sS0FBSyxDQUFDO1FBRXJDLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLEVBQUU7WUFDaEMsTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDekMsSUFBSSxXQUFXLEdBQUcsS0FBSyxDQUFDO1lBRXhCLEtBQUssSUFBSSxHQUFHLElBQUksSUFBSSxFQUFFO2dCQUNyQixXQUFXLEdBQUcsV0FBVyxJQUFJLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUN6RDtZQUVELE9BQU8sV0FBVyxDQUFDO1NBQ25CO2FBQU07WUFDTixPQUFPLEtBQUssQ0FBQztTQUNiO0lBQ0YsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxNQUFNLENBQUMsU0FBUyxDQUFDLFNBQWlCO1FBQ2pDLElBQUksS0FBSyxDQUFDLFlBQVk7WUFBRSxPQUFPLEtBQUssQ0FBQztRQUVyQyxJQUFJLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxFQUFFO1lBQ2hDLE1BQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ3pDLElBQUksT0FBTyxHQUFHLEtBQUssQ0FBQztZQUVwQixLQUFLLElBQUksR0FBRyxJQUFJLElBQUksRUFBRTtnQkFDckIsT0FBTyxHQUFHLE9BQU8sSUFBSSxLQUFLLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQzdDO1lBRUQsT0FBTyxPQUFPLENBQUM7U0FDZjthQUFNO1lBQ04sT0FBTyxLQUFLLENBQUM7U0FDYjtJQUNGLENBQUM7SUFDRDs7Ozs7O09BTUc7SUFDSCxNQUFNLENBQUMsa0JBQWtCLENBQUMsV0FBb0I7UUFDN0MsSUFBSSxXQUFXLEtBQUssU0FBUyxFQUFFO1lBQzlCLE9BQU8sS0FBSyxDQUFDLGdCQUFnQixJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsSUFBSSxXQUFXLElBQUksSUFBSSxDQUFDLGtCQUFrQixDQUFDO1NBQ2hHO1FBQ0QsT0FBTyxLQUFLLENBQUMsZ0JBQWdCLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDO0lBQ3ZELENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILE1BQU0sQ0FBQyxjQUFjLENBQUMsV0FBb0I7UUFDekMsSUFBSSxXQUFXLEtBQUssU0FBUyxFQUFFO1lBQzlCLE9BQU8sS0FBSyxDQUFDLFlBQVksSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLElBQUksV0FBVyxJQUFJLElBQUksQ0FBQyxrQkFBa0IsQ0FBQztTQUM1RjtRQUNELE9BQU8sS0FBSyxDQUFDLFlBQVksSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUM7SUFDbkQsQ0FBQztJQUVEOzs7T0FHRztJQUNILE1BQU0sQ0FBQyxhQUFhO1FBQ25CLE9BQU8sS0FBSyxDQUFDLFlBQVksSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUM7SUFDbkQsQ0FBQztJQUVEOzs7T0FHRztJQUNILE1BQU0sQ0FBQyxrQkFBa0I7UUFDeEIsT0FBTyxLQUFLLENBQUMsZUFBZSxDQUFDO0lBQzlCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxNQUFNLENBQUMsZ0JBQWdCO1FBQ3RCLE9BQU8sS0FBSyxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQztJQUNyRSxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILE1BQU0sQ0FBQyxzQkFBc0I7UUFDNUIsT0FBTyxLQUFLLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUM7SUFDNUcsQ0FBQztJQUVEOzs7T0FHRztJQUNILE1BQU0sQ0FBQyxxQkFBcUI7UUFDM0IsT0FBTyxLQUFLLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztJQUNqQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILE1BQU0sQ0FBQywyQkFBMkI7UUFDakMsT0FBTyxLQUFLLENBQUMsa0JBQWtCLENBQUMsS0FBSyxFQUFFLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQztJQUN6RSxDQUFDO0lBRUQ7O09BRUc7SUFDSCxNQUFNLENBQUMsWUFBWTtRQUNsQixLQUFLLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztRQUMxQixLQUFLLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQztJQUM1QixDQUFDO0lBRUQ7O09BRUc7SUFDSCxNQUFNLENBQUMsV0FBVztRQUNqQixLQUFLLENBQUMsWUFBWSxHQUFHLEtBQUssQ0FBQztRQUMzQixLQUFLLENBQUMsYUFBYSxHQUFHLEtBQUssQ0FBQztJQUM3QixDQUFDO0NBQ0Q7QUFsVUQsd0JBa1VDOzs7Ozs7Ozs7QUM3VUQsc0VBQThDO0FBQzlDLDZEQUFxQztBQUNyQyxvRUFBNEM7QUFDNUMsMkRBQXdEO0FBRXhELGtFQUEwQztBQUUxQyxJQUFZLGFBU1g7QUFURCxXQUFZLGFBQWE7SUFDckIsNkRBQWMsQ0FBQTtJQUNkLHlEQUFZLENBQUE7SUFDWixpRUFBZ0IsQ0FBQTtJQUNoQiw2REFBYyxDQUFBO0lBQ2QseURBQVksQ0FBQTtJQUNaLHFEQUFVLENBQUE7SUFDVix1REFBVyxDQUFBO0lBQ1gseURBQVksQ0FBQTtBQUNoQixDQUFDLEVBVFcsYUFBYSxHQUFiLHFCQUFhLEtBQWIscUJBQWEsUUFTeEI7QUFFRDs7R0FFRztBQUNILE1BQXFCLFlBQVk7SUFLN0I7OztPQUdHO0lBQ0gsWUFBWSxNQUF5QjtRQStDN0Isb0JBQWUsR0FBRyxDQUFDLEtBQWlCLEVBQUUsTUFBeUIsRUFBUSxFQUFFO1lBQzdFLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUM7Z0JBQUUsT0FBTztZQUMxRCxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBQ3pDLElBQUksTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7WUFDMUIsSUFBSSxTQUFTLEdBQUcsSUFBSSxtQkFBUyxDQUFDLDZCQUFhLENBQUMsVUFBVSxFQUFFLEVBQUMsUUFBUSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFDLENBQUMsQ0FBQztZQUN6RixJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUN4QyxDQUFDLENBQUE7UUFFTyxrQkFBYSxHQUFHLENBQUMsS0FBaUIsRUFBRSxNQUF5QixFQUFRLEVBQUU7WUFDM0UsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQztnQkFBRSxPQUFPO1lBQ3BELElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7WUFDL0MsSUFBSSxTQUFTLEdBQUcsSUFBSSxtQkFBUyxDQUFDLDZCQUFhLENBQUMsUUFBUSxFQUFFLEVBQUMsUUFBUSxFQUFFLEdBQUcsRUFBQyxDQUFDLENBQUM7WUFDdkUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDeEMsQ0FBQyxDQUFBO1FBRU8sb0JBQWUsR0FBRyxDQUFDLEtBQWlCLEVBQUUsTUFBeUIsRUFBUSxFQUFFO1lBQzdFLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUM7Z0JBQUUsT0FBTztZQUNwRCxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBQy9DLElBQUksU0FBUyxHQUFHLElBQUksbUJBQVMsQ0FBQyw2QkFBYSxDQUFDLFVBQVUsRUFBRSxFQUFDLFFBQVEsRUFBRSxHQUFHLEVBQUMsQ0FBQyxDQUFDO1lBQ3pFLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3hDLENBQUMsQ0FBQTtRQUVPLGtCQUFhLEdBQUcsQ0FBQyxLQUFvQixFQUFRLEVBQUU7WUFDbkQsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQztnQkFBRSxPQUFPO1lBQ2xELElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDN0IsSUFBSSxTQUFTLEdBQUcsSUFBSSxtQkFBUyxDQUFDLDZCQUFhLENBQUMsUUFBUSxFQUFFLEVBQUMsR0FBRyxFQUFFLEdBQUcsRUFBQyxDQUFDLENBQUM7WUFDbEUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDeEMsQ0FBQyxDQUFBO1FBRU8sZ0JBQVcsR0FBRyxDQUFDLEtBQW9CLEVBQVEsRUFBRTtZQUNqRCxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDO2dCQUFFLE9BQU87WUFDaEQsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUM3QixJQUFJLFNBQVMsR0FBRyxJQUFJLG1CQUFTLENBQUMsNkJBQWEsQ0FBQyxNQUFNLEVBQUUsRUFBQyxHQUFHLEVBQUUsR0FBRyxFQUFDLENBQUMsQ0FBQztZQUNoRSxJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUN4QyxDQUFDLENBQUE7UUFFTyxlQUFVLEdBQUcsQ0FBQyxLQUFZLEVBQVEsRUFBRTtZQUN4QyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDO2dCQUFFLE9BQU87WUFDakQsSUFBSSxTQUFTLEdBQUcsSUFBSSxtQkFBUyxDQUFDLDZCQUFhLENBQUMsV0FBVyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQzdELElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3hDLENBQUMsQ0FBQTtRQUVPLHNCQUFpQixHQUFHLENBQUMsS0FBWSxFQUFRLEVBQUU7WUFDL0MsS0FBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO1lBQ3ZCLEtBQUssQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUM1QixDQUFDLENBQUE7UUFFTyxnQkFBVyxHQUFHLENBQUMsS0FBaUIsRUFBUSxFQUFFO1lBQzlDLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztZQUN2QixLQUFLLENBQUMsZUFBZSxFQUFFLENBQUM7WUFFeEIsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQztnQkFBRSxPQUFPO1lBRWxELElBQUksU0FBb0IsQ0FBQztZQUN6QixJQUFHLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFDO2dCQUNoQixTQUFTLEdBQUcsSUFBSSxtQkFBUyxDQUFDLDZCQUFhLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxDQUFDO2FBQ3pEO2lCQUFNO2dCQUNILFNBQVMsR0FBRyxJQUFJLG1CQUFTLENBQUMsNkJBQWEsQ0FBQyxVQUFVLEVBQUUsRUFBRSxDQUFDLENBQUM7YUFDM0Q7WUFFRCxJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUN4QyxDQUFDLENBQUE7UUEzR0gsSUFBSSxDQUFDLFVBQVUsR0FBRyxvQkFBVSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ3JDLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxLQUFLLENBQVUsR0FBRyxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBRXZGLE1BQU0sQ0FBQyxXQUFXLEdBQUcsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3BFLE1BQU0sQ0FBQyxTQUFTLEdBQUcsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ2hFLE1BQU0sQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDO1FBQzlDLE1BQU0sQ0FBQyxXQUFXLEdBQUcsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3BFLFFBQVEsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQztRQUN4QyxRQUFRLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUM7UUFDcEMsUUFBUSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDO1FBQ2xDLFFBQVEsQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQztRQUN6QyxRQUFRLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUM7UUFFcEMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLGtCQUFRLEVBQUUsQ0FBQztRQUMvQixJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyw2QkFBYSxDQUFDLGtCQUFrQixDQUFDLENBQUM7UUFDMUQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsNkJBQWEsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBQzdELENBQUM7SUFFTSxNQUFNLENBQUMsTUFBYztRQUN4QixPQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxFQUFFLEVBQUU7WUFDaEMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUM7U0FDbEQ7SUFDTCxDQUFDO0lBQ1MsV0FBVyxDQUFDLEtBQWdCO1FBQ2xDLFFBQU8sS0FBSyxDQUFDLElBQUksRUFBRTtZQUNmLEtBQUssNkJBQWEsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO2dCQUNuQyxJQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7Z0JBQy9DLE1BQU07YUFDVDtZQUNELEtBQUssNkJBQWEsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO2dCQUNsQyxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7Z0JBQzlDLE1BQU07YUFDVDtZQUNELE9BQU8sQ0FBQyxDQUFDO2dCQUNMLE1BQU0sSUFBSSxLQUFLLENBQUMsOEJBQThCLEtBQUssQ0FBQyxJQUFJLDRCQUE0QixDQUFDLENBQUM7YUFDekY7U0FDSjtJQUNMLENBQUM7SUFFTSxjQUFjLENBQUMsUUFBeUI7UUFDM0MsUUFBUSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7SUFDOUQsQ0FBQztJQUNNLGVBQWUsQ0FBQyxRQUF5QjtRQUM1QyxRQUFRLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQztJQUMvRCxDQUFDO0lBaUVPLE1BQU0sQ0FBQyxRQUF1QjtRQUNsQyxPQUFPLFFBQVEsQ0FBQyxHQUFHLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDdEMsQ0FBQztJQUVPLGdCQUFnQixDQUFDLFVBQXNCLEVBQUUsTUFBeUI7UUFDdEUsSUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFDLHFCQUFxQixFQUFFLENBQUM7UUFDMUMsSUFBSSxDQUFDLEdBQUcsVUFBVSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO1FBQ3ZDLElBQUksQ0FBQyxHQUFHLFVBQVUsQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUN0QyxPQUFPLElBQUksY0FBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUMxQixDQUFDO0NBQ0o7QUFqSUQsK0JBaUlDOzs7OztBQ3JKRCxjQUFjO0FBRWQ7O0dBRUc7QUFDSCxNQUFxQixzQkFBc0I7SUFDdkMsTUFBTSxDQUFDLEtBQUs7UUFDUix3QkFBd0IsQ0FBQyxTQUFTLENBQUMsV0FBVyxHQUFHLFVBQVMsQ0FBUyxFQUFFLENBQVMsRUFBRSxDQUFTLEVBQUUsQ0FBUyxFQUFFLENBQVM7WUFDM0csZ0VBQWdFO1lBQ2hFLElBQUcsQ0FBQyxHQUFHLENBQUM7Z0JBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNoQixJQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBRTFDLHdCQUF3QjtZQUN4QixJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7WUFFakIsTUFBTTtZQUNOLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUN0QixJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQzFCLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBRXRDLFFBQVE7WUFDUixJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUM5QixJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBRTlDLFNBQVM7WUFDVCxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQzFCLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBRXRDLE9BQU87WUFDUCxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDdEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFBO1lBRTdCLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNyQixDQUFDLENBQUE7UUFFRCx3QkFBd0IsQ0FBQyxTQUFTLENBQUMsaUJBQWlC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SSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUM7UUFDM0UsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNyRSxPQUFPLElBQUksY0FBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUMxQixDQUFDO0lBQ2Usa0JBQWtCLENBQUMsQ0FBUyxFQUFFLENBQVM7UUFDbkQsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUUsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDbkQsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN0RyxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3RHLElBQUksR0FBRyxHQUFHLENBQUMsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLE9BQU8sSUFBSSxHQUFHLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ2hFLE9BQU8sSUFBSSxDQUFDO1NBQ2Y7UUFDRCxPQUFPLElBQUksY0FBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBR2UsZUFBZSxDQUFDLEdBQVcsRUFBRSxHQUFXO1FBQ3BELE9BQU87SUFDWCxDQUFDO0lBRVMsZ0JBQWdCLENBQUMsV0FBNkIsRUFBRSxLQUFxQjtRQUMzRSx5Q0FBeUM7UUFDekMsSUFBSSxDQUFDLE9BQU8sR0FBRyxXQUFXLENBQUMsS0FBSyxDQUFDO1FBQ2pDLElBQUksQ0FBQyxPQUFPLEdBQUcsV0FBVyxDQUFDLE1BQU0sQ0FBQztRQUVsQyxvQkFBb0I7UUFDcEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLFNBQVMsRUFBRSxXQUFXLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFakUsd0NBQXdDO1FBQ3hDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzlFLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDMUMsSUFBSSxDQUFDLElBQUksR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQztRQUU3QiwyQ0FBMkM7UUFDM0MsSUFBSSxDQUFDLFlBQVksR0FBRyxLQUFLLENBQUM7UUFDMUIsSUFBRyxLQUFLLENBQUMsVUFBVSxFQUFDO1lBQ2hCLEtBQUksSUFBSSxJQUFJLElBQUksS0FBSyxDQUFDLFVBQVUsRUFBQztnQkFDN0IsSUFBRyxJQUFJLENBQUMsSUFBSSxLQUFLLFlBQVksRUFBQztvQkFDMUIsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO29CQUUvQixvREFBb0Q7b0JBQ3BELEtBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBQzt3QkFDN0MsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7cUJBQy9CO2lCQUNKO2FBQ0o7U0FDSjtJQUNMLENBQUM7SUFFZSxXQUFXO1FBQ3ZCLEtBQUssSUFBSSxJQUFJLEdBQUcsQ0FBQyxFQUFFLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUUsRUFBRTtZQUNoRCxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ25DLGVBQUssQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLGVBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNwRTtJQUNMLENBQUM7Q0FDSjtBQXBFRCxtQ0FvRUM7Ozs7Ozs7O0FDN0VELHlEQUFpQztBQUNqQyxnRUFBd0M7QUFFeEMsOERBQXNDO0FBQ3RDLDhEQUFzQztBQUN0Qyx1RUFBK0M7QUFFL0M7O0dBRUc7QUFDSCxNQUFxQixpQkFBa0IsU0FBUSxpQkFBTztJQUVsQyxZQUFZLENBQUMsTUFBWTtRQUNyQyxPQUFPLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3ZFLENBQUM7SUFDZSxZQUFZLENBQUMsTUFBWTtRQUNyQyxPQUFPLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQy9FLENBQUM7SUFFZSxrQkFBa0IsQ0FBQyxDQUFTLEVBQUUsQ0FBUztRQUNuRCxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3pELElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDekQsT0FBTyxJQUFJLGNBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDOUIsQ0FBQztJQUVlLGdCQUFnQixDQUFDLEdBQVcsRUFBRSxHQUFXO1FBQ3JELElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUM3QyxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDN0MsT0FBTyxJQUFJLGNBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDMUIsQ0FBQztJQUVlLGVBQWUsQ0FBQyxHQUFXLEVBQUUsR0FBVztRQUNwRCxJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUV4QyxJQUFJLE9BQU8sR0FBRyxHQUFHLEdBQUcsUUFBUSxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNoRCxJQUFJLE9BQU8sR0FBRyxHQUFHLEdBQUcsUUFBUSxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUVoRCxJQUFJLE1BQU0sR0FBRyxJQUFJLGNBQUksQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDeEMsSUFBSSxRQUFRLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUVwQyxPQUFPLElBQUksY0FBSSxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRVMsZ0JBQWdCLENBQUMsV0FBNkIsRUFBRSxLQUFxQjtRQUMzRSx5Q0FBeUM7UUFDekMsSUFBSSxDQUFDLE9BQU8sR0FBRyxXQUFXLENBQUMsS0FBSyxDQUFDO1FBQ2pDLElBQUksQ0FBQyxPQUFPLEdBQUcsV0FBVyxDQUFDLE1BQU0sQ0FBQztRQUVsQyxvQkFBb0I7UUFDcEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLFNBQVMsRUFBRSxXQUFXLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFakUsd0NBQXdDO1FBQ3hDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzlFLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDMUMsSUFBSSxDQUFDLElBQUksR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQztRQUU3QiwyQ0FBMkM7UUFDM0MsSUFBSSxDQUFDLFlBQVksR0FBRyxLQUFLLENBQUM7UUFDMUIsSUFBRyxLQUFLLENBQUMsVUFBVSxFQUFDO1lBQ2hCLEtBQUksSUFBSSxJQUFJLElBQUksS0FBSyxDQUFDLFVBQVUsRUFBQztnQkFDN0IsSUFBRyxJQUFJLENBQUMsSUFBSSxLQUFLLFlBQVksRUFBQztvQkFDMUIsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO29CQUUvQixvREFBb0Q7b0JBQ3BELEtBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBQzt3QkFDN0MsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7cUJBQy9CO2lCQUNKO2FBQ0o7U0FDSjtJQUNMLENBQUM7SUFFRCxZQUFZO0lBQ1osTUFBTSxDQUFDLE1BQWMsSUFBUyxDQUFDO0lBRS9CLFlBQVk7SUFDSSxXQUFXO1FBQ3ZCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUN2QyxJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksSUFBSSxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUU7Z0JBQ3hELElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzNDLGVBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxHQUFHLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLGVBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUMzSDtTQUNKO0lBQ0wsQ0FBQztDQUNKO0FBNUVELG9DQTRFQzs7Ozs7Ozs7QUN0RkQsdUVBQStDO0FBRy9DLGdFQUF3QztBQUN4Qyw4REFBc0M7QUFDdEMsOERBQXNDO0FBR3RDLHlEQUFpQztBQUdqQyxNQUFxQix5QkFBMEIsU0FBUSxpQkFBTztJQUUxQyxrQkFBa0IsQ0FBQyxDQUFTLEVBQUUsQ0FBUztRQUNuRCxJQUFJLEdBQUcsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDN0MsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDN0QsSUFBSSxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUNmLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztTQUNuRjtRQUNELE9BQU8sSUFBSSxjQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBRWUsZ0JBQWdCLENBQUMsR0FBVyxFQUFFLEdBQVc7UUFDckQsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQzdDLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDakQsSUFBSSxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUNmLENBQUMsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDM0M7UUFDRCxPQUFPLElBQUksY0FBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2xELENBQUM7SUFFZSxlQUFlLENBQUMsR0FBVyxFQUFFLEdBQVc7UUFFcEQsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFFeEMsSUFBSSxPQUFPLEdBQUcsR0FBRyxHQUFHLFFBQVEsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUE7UUFDL0MsSUFBSSxPQUFPLEdBQUcsR0FBRyxHQUFHLFFBQVEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDakUsSUFBSSxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUNmLE9BQU8sSUFBSSxRQUFRLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUM3QjtRQUVELElBQUksTUFBTSxHQUFHLElBQUksY0FBSSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztRQUN4QyxJQUFJLFFBQVEsR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRXBDLE9BQU8sSUFBSSxjQUFJLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFZSxZQUFZLENBQUMsTUFBWTtRQUNyQyxPQUFPLElBQUksY0FBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUMxQixDQUFDO0lBRWUsWUFBWSxDQUFDLE1BQVk7UUFDckMsT0FBTyxJQUFJLGNBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNoRCxDQUFDO0lBRVMsZ0JBQWdCLENBQUMsV0FBNkIsRUFBRSxLQUFxQjtRQUMzRSx5Q0FBeUM7UUFDekMsSUFBSSxDQUFDLE9BQU8sR0FBRyxXQUFXLENBQUMsS0FBSyxDQUFDO1FBQ2pDLElBQUksQ0FBQyxPQUFPLEdBQUcsV0FBVyxDQUFDLE1BQU0sQ0FBQztRQUVsQyxvQkFBb0I7UUFDcEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLFNBQVMsRUFBRSxXQUFXLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFakUsd0NBQXdDO1FBQ3hDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzlFLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDMUMsSUFBSSxDQUFDLElBQUksR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQztRQUU3QiwyQ0FBMkM7UUFDM0MsSUFBSSxDQUFDLFlBQVksR0FBRyxLQUFLLENBQUM7UUFDMUIsSUFBRyxLQUFLLENBQUMsVUFBVSxFQUFDO1lBQ2hCLEtBQUksSUFBSSxJQUFJLElBQUksS0FBSyxDQUFDLFVBQVUsRUFBQztnQkFDN0IsSUFBRyxJQUFJLENBQUMsSUFBSSxLQUFLLFlBQVksRUFBQztvQkFDMUIsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO29CQUUvQixvREFBb0Q7b0JBQ3BELEtBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBQzt3QkFDN0MsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7cUJBQy9CO2lCQUNKO2FBQ0o7U0FDSjtJQUNMLENBQUM7SUFFZSxXQUFXO1FBQ3ZCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUN2QyxJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDM0MsZUFBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMscUJBQXFCLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEdBQUcsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsZUFBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQzNIO0lBQ0wsQ0FBQztDQUNKO0FBakZELDRDQWlGQzs7Ozs7Ozs7QUM1RkQsOERBQXNDO0FBQ3RDLDJEQUFtQztBQUNuQyw2REFBcUM7QUFDckMsMkRBQW1DO0FBRW5DOztHQUVHO0FBQ0gsTUFBOEIsU0FBVSxTQUFRLG9CQUFVO0lBb0N6RCxZQUFZLFFBQWM7UUFDekIsS0FBSyxFQUFFLENBQUM7UUFDUixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUV6QixJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksZUFBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQzdDLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxlQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDekMsSUFBSSxDQUFDLFlBQVksR0FBRyxDQUFDLENBQUM7UUFDdEIsSUFBSSxDQUFDLFdBQVcsR0FBRyxDQUFDLENBQUM7UUFDckIsSUFBSSxDQUFDLE9BQU8sR0FBRyxjQUFJLENBQUMsSUFBSSxDQUFDO1FBRXpCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO1FBQ3BCLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDO1FBQzNCLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDO1FBQ3RCLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUM7UUFFN0IsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7UUFDcEIsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUM7UUFDM0IsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7UUFDcEIsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUM7UUFFM0IsSUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7UUFDdkIsSUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7SUFDeEIsQ0FBQztJQUVELGNBQWM7SUFDZCxrQkFBa0IsQ0FBQyxLQUFZO1FBQzlCLElBQUksQ0FBQyxlQUFlLEdBQUcsS0FBSyxDQUFDO0lBQzlCLENBQUM7SUFFRCxjQUFjO0lBQ2QsVUFBVSxDQUFDLE9BQWE7UUFDdkIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDNUIsQ0FBQztJQUVELE1BQU0sQ0FBQyxNQUFjO1FBQ3BCLEtBQUssQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFckIsc0NBQXNDO1FBQ3RDLElBQUcsZUFBSyxDQUFDLGtCQUFrQixFQUFFLEVBQUM7WUFDN0IsSUFBSSxRQUFRLEdBQUcsZUFBSyxDQUFDLHFCQUFxQixFQUFFLENBQUM7WUFDN0MsSUFBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxFQUFDO2dCQUNsRixJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQztnQkFFdEIsSUFBRyxJQUFJLENBQUMsT0FBTyxLQUFLLElBQUksRUFBQztvQkFDeEIsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO2lCQUNmO2dCQUNELElBQUcsSUFBSSxDQUFDLGNBQWMsS0FBSyxJQUFJLEVBQUM7b0JBQy9CLElBQUksSUFBSSxHQUFHLEVBQUUsQ0FBQztvQkFDZCxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxDQUFDO2lCQUNsRDthQUNEO1NBQ0Q7UUFFRCx1RUFBdUU7UUFDdkUsSUFBRyxDQUFDLGVBQUssQ0FBQyxjQUFjLEVBQUUsRUFBQztZQUMxQixJQUFHLElBQUksQ0FBQyxTQUFTLEVBQUM7Z0JBQ2pCLElBQUksQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDO2FBQ3ZCO1NBQ0Q7UUFFRCxtREFBbUQ7UUFDbkQsSUFBSSxRQUFRLEdBQUcsZUFBSyxDQUFDLGdCQUFnQixFQUFFLENBQUM7UUFDeEMsSUFBRyxRQUFRLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBQztZQUNwRCxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQztZQUV0QixJQUFHLElBQUksQ0FBQyxPQUFPLEtBQUssSUFBSSxFQUFDO2dCQUN4QixJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7YUFDZjtZQUNELElBQUcsSUFBSSxDQUFDLGNBQWMsS0FBSyxJQUFJLEVBQUM7Z0JBQy9CLElBQUksSUFBSSxHQUFHLEVBQUUsQ0FBQztnQkFDZCxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxDQUFDO2FBQ2xEO1NBRUQ7YUFBTSxJQUFHLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDekIsSUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7WUFFdkIsSUFBRyxJQUFJLENBQUMsT0FBTyxLQUFLLElBQUksRUFBQztnQkFDeEIsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO2FBQ2Y7WUFDRCxJQUFHLElBQUksQ0FBQyxjQUFjLEtBQUssSUFBSSxFQUFDO2dCQUMvQixJQUFJLElBQUksR0FBRyxFQUFFLENBQUM7Z0JBQ2QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsQ0FBQzthQUNsRDtTQUNEO2FBQU0sSUFBRyxJQUFJLENBQUMsU0FBUyxFQUFFO1lBQ3pCLDJFQUEyRTtZQUMzRSxJQUFJLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQztTQUN2QjtJQUNGLENBQUM7SUFFRDs7O09BR0c7SUFDSCx3QkFBd0I7UUFDdkIsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDO0lBQzdCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxvQkFBb0I7UUFDbkIsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDO0lBQ3pCLENBQUM7Q0FDRDtBQTVJRCw0QkE0SUM7Ozs7Ozs7O0FDcEpELG9EQUE0QjtBQUM1Qiw4REFBc0M7QUFHdEMsbUNBQW1DO0FBQ25DLE1BQXFCLE1BQU8sU0FBUSxlQUFLO0lBRXhDLFlBQVksUUFBYyxFQUFFLElBQVk7UUFDdkMsS0FBSyxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUV0QixJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksZUFBSyxDQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDL0MsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLGVBQUssQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ3pDLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxlQUFLLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUMzQyxDQUFDO0lBRUQsWUFBWTtJQUNaLHdCQUF3QjtRQUN2QixvREFBb0Q7UUFDcEQsSUFBRyxJQUFJLENBQUMsU0FBUyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBQztZQUNwQyxPQUFPLElBQUksQ0FBQyxlQUFlLENBQUMsT0FBTyxFQUFFLENBQUM7U0FDdEM7YUFBTSxJQUFHLElBQUksQ0FBQyxTQUFTLEVBQUM7WUFDeEIsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sRUFBRSxDQUFDO1NBQ3JDO2FBQU07WUFDTixPQUFPLElBQUksQ0FBQyxlQUFlLENBQUM7U0FDNUI7SUFDRixDQUFDO0NBQ0Q7QUFyQkQseUJBcUJDOzs7Ozs7Ozs7QUMxQkQsZ0VBQXdDO0FBQ3hDLDhEQUFzQztBQUN0Qyw2REFBcUM7QUFFckMsb0NBQW9DO0FBQ3BDLE1BQXFCLEtBQU0sU0FBUSxtQkFBUztJQWlCM0MsWUFBWSxRQUFjLEVBQUUsSUFBWTtRQUN2QyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDaEIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFDakIsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLGVBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN2QyxJQUFJLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQztRQUNwQixJQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQztRQUNuQixJQUFJLENBQUMsTUFBTSxHQUFHLFFBQVEsQ0FBQztRQUN2QixJQUFJLENBQUMsTUFBTSxHQUFHLFFBQVEsQ0FBQztRQUV2QixJQUFJLENBQUMsWUFBWSxHQUFHLEtBQUssQ0FBQztJQUMzQixDQUFDO0lBRUQsY0FBYztJQUNkLE9BQU8sQ0FBQyxJQUFZO1FBQ25CLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0lBQ2xCLENBQUM7SUFFRCxjQUFjO0lBQ2QsWUFBWSxDQUFDLEtBQVk7UUFDeEIsSUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7SUFDeEIsQ0FBQztJQUVEOzs7T0FHRztJQUNILGFBQWE7UUFDWixPQUFPLElBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7SUFDMUMsQ0FBQztJQUVEOzs7T0FHRztJQUNILGtCQUFrQjtRQUNqQixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsWUFBWSxFQUFFLENBQUM7SUFDdEMsQ0FBQztJQUVEOzs7O09BSUc7SUFDTyxrQkFBa0IsQ0FBQyxHQUE2QjtRQUN6RCxHQUFHLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDN0MsT0FBTyxHQUFHLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUM7SUFDekMsQ0FBQztJQUVELFNBQVMsQ0FBQyxLQUFhO1FBQ3RCLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO0lBQ3JCLENBQUM7SUFFRCxTQUFTLENBQUMsS0FBYTtRQUN0QixJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztJQUNyQixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILG1CQUFtQixDQUFDLEdBQTZCO1FBQ2hELElBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUU3QyxJQUFJLE1BQU0sR0FBRyxJQUFJLGNBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFFNUIsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDO1FBQ3BDLElBQUcsSUFBSSxDQUFDLE1BQU0sS0FBSyxNQUFNLENBQUMsTUFBTSxFQUFDO1lBQ2hDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsS0FBSyxHQUFDLENBQUMsQ0FBQztTQUNuQjthQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxNQUFNLENBQUMsS0FBSyxFQUFDO1lBQ3ZDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDO1NBQ2pCO1FBRUQsSUFBRyxJQUFJLENBQUMsTUFBTSxLQUFLLE1BQU0sQ0FBQyxHQUFHLEVBQUM7WUFDN0IsR0FBRyxDQUFDLFlBQVksR0FBRyxLQUFLLENBQUM7WUFDekIsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDYjthQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxNQUFNLENBQUMsTUFBTSxFQUFDO1lBQ3hDLEdBQUcsQ0FBQyxZQUFZLEdBQUcsUUFBUSxDQUFDO1lBQzVCLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7U0FDdkI7YUFBTTtZQUNOLEdBQUcsQ0FBQyxZQUFZLEdBQUcsUUFBUSxDQUFDO1lBQzVCLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDO1NBQ3pCO1FBRUQsT0FBTyxNQUFNLENBQUM7SUFDZixDQUFDO0lBRVMsV0FBVztRQUNwQixLQUFLLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDcEIsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7SUFDMUIsQ0FBQztJQUVEOzs7T0FHRztJQUNPLFFBQVEsQ0FBQyxHQUE2QjtRQUMvQyxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDekMsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQztRQUMzQixJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUMsQ0FBQyxFQUFFLE1BQU0sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsQ0FBQztRQUNuRSxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztJQUMxQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsbUJBQW1CLENBQUMsR0FBNkI7UUFDaEQsSUFBRyxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUM7WUFDckIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUNuQjtJQUNGLENBQUM7SUFFRCw2RkFBNkY7SUFDN0YsVUFBVTtRQUNULElBQUksQ0FBQyxZQUFZLEdBQUcsS0FBSyxDQUFDO0lBQzNCLENBQUM7Q0FDRDtBQXRJRCx3QkFzSUM7QUFFRCxJQUFZLE1BSVg7QUFKRCxXQUFZLE1BQU07SUFDakIscUJBQVcsQ0FBQTtJQUNYLDJCQUFpQixDQUFBO0lBQ2pCLDJCQUFpQixDQUFBO0FBQ2xCLENBQUMsRUFKVyxNQUFNLEdBQU4sY0FBTSxLQUFOLGNBQU0sUUFJakI7QUFFRCxJQUFZLE1BSVg7QUFKRCxXQUFZLE1BQU07SUFDakIsdUJBQWEsQ0FBQTtJQUNiLDJCQUFpQixDQUFBO0lBQ2pCLHlCQUFlLENBQUE7QUFDaEIsQ0FBQyxFQUpXLE1BQU0sR0FBTixjQUFNLEtBQU4sY0FBTSxRQUlqQjs7Ozs7Ozs7QUN2SkQsZ0VBQXdDO0FBQ3hDLDhEQUFzQztBQUN0Qyw4REFBc0M7QUFDdEMsc0VBQThDO0FBQzlDLDZEQUFxQztBQUVyQyx5QkFBeUI7QUFDekIsTUFBcUIsTUFBTyxTQUFRLG1CQUFTO0lBY3pDLFlBQVksUUFBYyxFQUFFLFNBQWlCO1FBQ3pDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUVoQixJQUFJLENBQUMsS0FBSyxHQUFHLFNBQVMsQ0FBQztRQUN2QixJQUFJLENBQUMsUUFBUSxHQUFHLGVBQUssQ0FBQyxHQUFHLENBQUM7UUFDMUIsSUFBSSxDQUFDLFdBQVcsR0FBRyxlQUFLLENBQUMsS0FBSyxDQUFDO1FBQy9CLElBQUksQ0FBQyxlQUFlLEdBQUcsZUFBSyxDQUFDLFdBQVcsQ0FBQztRQUN6QyxJQUFJLENBQUMsV0FBVyxHQUFHLGVBQUssQ0FBQyxXQUFXLENBQUM7UUFDckMsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLGNBQUksQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFFaEMscUJBQXFCO1FBQ3JCLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUMzQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsUUFBUTtRQUNKLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQztJQUN0QixDQUFDO0lBRUQsd0RBQXdEO0lBQzlDLFlBQVk7UUFDbEIsSUFBRyxJQUFJLENBQUMsYUFBYSxFQUFDO1lBQ2xCLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ2xDO1FBRUQsSUFBRyxJQUFJLENBQUMsb0JBQW9CLEVBQUM7WUFDekIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLG9CQUFvQixFQUFFLEVBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBQyxDQUFDLENBQUM7U0FDeEY7SUFDTCxDQUFDO0lBRUQsTUFBTSxDQUFDLE1BQWM7UUFDakIsS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUVyQixJQUFHLElBQUksQ0FBQyxTQUFTLEVBQUM7WUFDZCxJQUFJLEdBQUcsR0FBRyxtQkFBUyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUMsQ0FBQyxFQUFFLGVBQUssQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzFILElBQUksQ0FBQyxLQUFLLEdBQUcsbUJBQVMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDcEMsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1NBQ3ZCO0lBQ0wsQ0FBQztDQUNKO0FBeERELHlCQXdEQzs7Ozs7Ozs7QUM5REQsOERBQXNDO0FBQ3RDLG9EQUE0QjtBQUM1Qiw4REFBc0M7QUFFdEMsNkJBQTZCO0FBQzdCLE1BQXFCLFNBQVUsU0FBUSxlQUFLO0lBTXhDLFlBQVksUUFBYztRQUN0QixLQUFLLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBRXBCLElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1FBQ3JCLElBQUksQ0FBQyxhQUFhLEdBQUcsQ0FBQyxDQUFDO1FBRXZCLG9DQUFvQztRQUNwQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ2xDLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBRXJCLElBQUksQ0FBQyxXQUFXLEdBQUcsZUFBSyxDQUFDLEtBQUssQ0FBQztRQUMvQixJQUFJLENBQUMsZUFBZSxHQUFHLGVBQUssQ0FBQyxLQUFLLENBQUM7SUFDdkMsQ0FBQztJQUVELE1BQU0sQ0FBQyxNQUFjO1FBQ2pCLEtBQUssQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFckIsSUFBRyxlQUFLLENBQUMsa0JBQWtCLEVBQUUsRUFBQztZQUNuQyxJQUFJLFFBQVEsR0FBRyxlQUFLLENBQUMscUJBQXFCLEVBQUUsQ0FBQztZQUM3QyxJQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUM7Z0JBQzVCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO2dCQUNwQixJQUFJLENBQUMsYUFBYSxHQUFHLEVBQUUsQ0FBQzthQUMzQjtpQkFBTTtnQkFDSCxJQUFJLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQzthQUN4QjtTQUNKO1FBRUQsSUFBRyxJQUFJLENBQUMsT0FBTyxFQUFDO1lBQ1osSUFBSSxJQUFJLEdBQUcsZUFBSyxDQUFDLGtCQUFrQixFQUFFLENBQUM7WUFDdEMsSUFBSSxJQUFJLEdBQUcsWUFBWSxDQUFDO1lBQ3hCLElBQUksWUFBWSxHQUFHLG9DQUFvQyxDQUFDO1lBQ3hELElBQUksT0FBTyxHQUFHLDRCQUE0QixDQUFDO1lBQzNDLElBQUksSUFBSSxHQUFHLElBQUksR0FBRyxZQUFZLEdBQUcsT0FBTyxDQUFDO1lBQ3pDLElBQUksR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQzlDLElBQUksWUFBWSxHQUFHLGVBQUssQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDL0MsSUFBSSxnQkFBZ0IsR0FBRyxlQUFLLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxDQUFDLENBQUM7WUFDM0QsSUFBSSxZQUFZLEdBQUcsZUFBSyxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBRW5ELElBQUcsZ0JBQWdCLEVBQUM7Z0JBQ2hCLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO2FBQzVEO2lCQUFNLElBQUcsWUFBWSxFQUFDO2dCQUNuQixJQUFJLENBQUMsSUFBSSxJQUFJLEdBQUcsQ0FBQzthQUNwQjtpQkFBTSxJQUFHLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQUN2QixJQUFHLFlBQVksRUFBQztvQkFDWixJQUFJLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztpQkFDdEM7cUJBQU07b0JBQ0gsSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7aUJBQ3hCO2FBQ0o7U0FDSjtJQUNMLENBQUM7Q0FDSjtBQXpERCw0QkF5REM7Ozs7OztBQy9ERCxJQUFZLGFBS1g7QUFMRCxXQUFZLGFBQWE7SUFDeEIsa0NBQWlCLENBQUE7SUFDakIsZ0NBQWUsQ0FBQTtJQUNmLGtDQUFpQixDQUFBO0lBQ2pCLHlDQUF3QixDQUFBO0FBQ3pCLENBQUMsRUFMVyxhQUFhLEdBQWIscUJBQWEsS0FBYixxQkFBYSxRQUt4Qjs7Ozs7Ozs7QUNKRCx1RUFBK0M7QUFLL0M7Ozs7R0FJRztBQUNILE1BQXFCLGlCQUFpQjtJQUlyQztRQUNDLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLGFBQUcsRUFBRSxDQUFDO0lBQ3BDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsa0JBQWtCLENBQUMsT0FBZSxFQUFFLEdBQVk7UUFDL0MsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDMUMsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxPQUFPLENBQUMsT0FBZSxFQUFFLFlBQWtCLEVBQUUsVUFBZ0I7UUFDNUQsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUM5QyxPQUFPLEdBQUcsQ0FBQyxpQkFBaUIsQ0FBQyxZQUFZLENBQUMsS0FBSyxFQUFFLEVBQUUsVUFBVSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7SUFDeEUsQ0FBQztDQUNEO0FBN0JELG9DQTZCQzs7Ozs7Ozs7QUN0Q0QsNkRBQXFDO0FBR3JDOztHQUVHO0FBQ0gsTUFBcUIsY0FBYztJQVFsQzs7O09BR0c7SUFDSCxZQUFZLElBQWlCO1FBQzVCLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2pCLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxjQUFJLENBQUMsSUFBSSxDQUFDO1FBQ3RDLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxDQUFDLENBQUM7SUFDNUIsQ0FBQztJQUVEOzs7T0FHRztJQUNILE1BQU07UUFDTCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDNUIsQ0FBQztJQUVFLElBQUksS0FBa0IsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBRWhGOzs7O09BSUc7SUFDSCxnQkFBZ0IsQ0FBQyxJQUFjO1FBQzlCLDRDQUE0QztRQUM1QyxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztJQUM5QyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsa0JBQWtCLENBQUMsSUFBYztRQUNoQyxJQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixHQUFDLElBQUksQ0FBQyxpQkFBaUIsRUFBQztZQUN2SCwwREFBMEQ7WUFDMUQsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztTQUNoQjtJQUNGLENBQUM7SUFFRCxRQUFRO1FBQ1AsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFBO0lBQzVCLENBQUM7Q0FDRDtBQXBERCxpQ0FvREM7Ozs7O0FDdEREOztHQUVHO0FBQ0gsTUFBcUIsT0FBTztJQVEzQjs7Ozs7T0FLRztJQUNILFlBQW1CLEtBQW9CO1FBQ3RDLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1FBQ2QsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLEdBQUcsRUFBOEIsQ0FBQztRQUN6RCxJQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztJQUNsQyxDQUFDO0lBRUUsSUFBVyxLQUFLLEtBQW9CLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFFbEQsV0FBVyxDQUFDLFFBQWdCLElBQUksSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFNUYsZUFBZTtJQUNmLGlCQUFpQixDQUFDLFlBQWtCLEVBQUUsVUFBZ0I7UUFDL0MsSUFBSSxJQUFJLENBQUMsU0FBUyxLQUFLLFNBQVMsRUFBRTtZQUM5QixNQUFNLElBQUksS0FBSyxDQUFDLHFEQUFxRCxDQUFDLENBQUM7U0FDMUU7UUFDUCxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLFVBQVUsRUFBRSxZQUFZLENBQUMsQ0FBQztJQUMzRCxDQUFDO0lBRUUsZ0JBQWdCLENBQUMsR0FBVyxFQUFFLFFBQTRCO1FBQ3RELElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUN4QyxDQUFDO0NBRUo7QUFwQ0QsMEJBb0NDOzs7Ozs7OztBQzdDRCw4RUFBc0Q7QUFFdEQsdUVBQStDO0FBQy9DLDhFQUFnRDtBQUVoRDs7Ozs7O0dBTUc7QUFDSCxNQUFxQixlQUFnQixTQUFRLDRCQUFZO0lBRXJEOztPQUVHO0lBQ0ksU0FBUyxDQUFDLEVBQVEsRUFBRSxJQUFVO1FBQ2pDLElBQUksS0FBSyxHQUFHLElBQUksZUFBSyxFQUFRLENBQUM7UUFDOUIsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUN2QixPQUFPLElBQUksd0JBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNyQyxDQUFDO0NBRUo7QUFYRCxrQ0FXQzs7Ozs7Ozs7QUN2QkQsOEVBQXNEO0FBRXRELHdFQUFnRDtBQUNoRCx1RUFBK0M7QUFDL0MsOEVBQWdEO0FBRWhEOzs7O0dBSUc7QUFDSCxNQUFxQixpQkFBa0IsU0FBUSw0QkFBWTtJQUV2RDs7T0FFRztJQUNJLFNBQVMsQ0FBQyxFQUFRLEVBQUUsSUFBVTtRQUNqQyxrRUFBa0U7UUFDbEUsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzdDLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUVuQyxJQUFJLFNBQVMsR0FBRyxJQUFJLGVBQUssQ0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUU3RCw4REFBOEQ7UUFDOUQsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUMzQixTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBRXpDLHNDQUFzQztRQUM1QyxJQUFJLE1BQU0sR0FBRyxvQkFBVSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztRQUV6RCxpQ0FBaUM7UUFDakMsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDO1FBQ1osT0FBTSxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUM7WUFDdEIsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNyRCxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ2Q7UUFFRCxPQUFPLElBQUksd0JBQWMsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNuQyxDQUFDO0NBRUo7QUE3QkQsb0NBNkJDOzs7OztBQ25DRDs7OztHQUlHO0FBQ0gsTUFBOEIsa0JBQWtCO0lBSzVDLFlBQW1CLElBQWE7UUFDNUIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUE7SUFDcEIsQ0FBQztJQUVELElBQWMsSUFBSSxLQUFhLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDbkQsSUFBYyxJQUFJLENBQUMsSUFBYSxJQUFJLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQztDQVMzRDtBQW5CRCxxQ0FtQkM7Ozs7Ozs7O0FDMUJELHNFQUE4QztBQUM5Qyw2REFBcUM7QUFFckMsNEZBQW9FO0FBQ3BFLHVGQUErRDtBQUcvRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBaUNHO0FBQ0gsTUFBcUIsbUJBQW9CLFNBQVEsd0JBQWM7SUFjOUQsWUFBWSxPQUE0QjtRQUN2QyxLQUFLLEVBQUUsQ0FBQztRQUNSLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxLQUFLLEVBQUUsQ0FBQztRQUMvQixJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7UUFDaEMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLEtBQUssRUFBRSxDQUFDO1FBQzVCLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFcEMsZ0JBQWdCO1FBQ2hCLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDNUIsQ0FBQztJQUVEOzs7T0FHRztJQUNPLFlBQVksQ0FBQyxPQUE0QjtRQUNsRCxJQUFHLE9BQU8sQ0FBQyxVQUFVLEtBQUssU0FBUyxJQUFJLE9BQU8sQ0FBQyxVQUFVLEtBQUssU0FBUyxFQUFDO1lBQ3ZFLEtBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBQztnQkFDakQsSUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFFbEMscUNBQXFDO2dCQUNyQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQztnQkFFM0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztnQkFFakMsSUFBSSxhQUFhLEdBQUcsQ0FBQyxDQUFDO2dCQUV0QixLQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUM7b0JBQ3BELElBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBQzt3QkFDM0IsYUFBYSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7cUJBQ3hCO2lCQUNEO2dCQUVELElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLEdBQUcsYUFBYSxDQUFDO2FBQ3ZDO1NBQ0Q7SUFDRixDQUFDO0lBRUQsWUFBWTtJQUNaLGNBQWMsQ0FBQyxJQUFjO1FBQzVCLElBQUcsSUFBSSxDQUFDLFFBQVEsRUFBQztZQUNoQiw0QkFBNEI7WUFDNUIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDNUI7YUFBTTtZQUNOLDZCQUE2QjtZQUM3QixJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUM3QjtJQUNGLENBQUM7SUFFRCxZQUFZO0lBQ1osZ0JBQWdCLENBQUMsSUFBYztRQUM5QixJQUFHLElBQUksQ0FBQyxRQUFRLEVBQUM7WUFDaEIsdUNBQXVDO1lBQ3ZDLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzdDLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztTQUNsQzthQUFNO1lBQ04sd0NBQXdDO1lBQ3hDLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzlDLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztTQUNuQztJQUNGLENBQUM7SUFFRCxZQUFZO0lBQ1osZUFBZSxDQUFDLE9BQWdCO1FBQy9CLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFRCxZQUFZO0lBQ1osaUJBQWlCLENBQUMsT0FBZ0I7UUFDakMsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDN0MsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ2hDLENBQUM7SUFFRCxZQUFZO0lBQ1osTUFBTSxDQUFDLE1BQWM7UUFDcEIsS0FBSSxJQUFJLElBQUksSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFDO1lBQ2pDLDhDQUE4QztZQUM5QyxxREFBcUQ7WUFDckQsSUFBSSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUM7WUFDdEIsSUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7WUFDdkIsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7WUFDcEIsSUFBSSxDQUFDLG1CQUFtQixHQUFHLEtBQUssQ0FBQztZQUNqQyxJQUFJLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQztZQUV6QiwrQ0FBK0M7WUFDL0MsSUFBRyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUM7Z0JBQ2YsU0FBUzthQUNUO1lBRUQsdUNBQXVDO1lBQ3ZDLElBQUcsSUFBSSxDQUFDLE1BQU0sRUFBQztnQkFDZCw2Q0FBNkM7Z0JBQzdDLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUMvRjtpQkFBTTtnQkFDTixtR0FBbUc7Z0JBQ25HLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLENBQUM7Z0JBQ3RCLFNBQVM7YUFDVDtZQUVELHlDQUF5QztZQUN6QywyQkFBMkI7WUFDM0IsSUFBSSxRQUFRLEdBQUcsSUFBSSxLQUFLLEVBQWlCLENBQUM7WUFFMUMsSUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUssS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBRWhFLCtHQUErRztZQUMvRyxLQUFJLElBQUksS0FBSyxJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUM7Z0JBQ2pDLHdCQUF3QjtnQkFDeEIsSUFBRyxDQUFDLEtBQUssQ0FBQyxNQUFNO29CQUFFLFNBQVM7Z0JBRTNCLElBQUksUUFBUSxHQUFHLEtBQUssQ0FBQyxjQUFjLENBQUMsZUFBZSxFQUFFLENBQUM7Z0JBQ3RELElBQUksSUFBSSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUNoRCxJQUFHLElBQUksR0FBRyxDQUFDLEVBQUM7b0JBQ1gscUJBQXFCO29CQUNyQixRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksdUJBQWEsQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztpQkFDMUU7YUFDRDtZQUVELDRDQUE0QztZQUM1QyxLQUFJLElBQUksS0FBSyxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUM7Z0JBQ2xDLG1CQUFtQjtnQkFDbkIsSUFBRyxJQUFJLEtBQUssS0FBSztvQkFBRSxTQUFTO2dCQUU1Qix3QkFBd0I7Z0JBQ3hCLElBQUcsQ0FBQyxLQUFLLENBQUMsTUFBTTtvQkFBRSxTQUFTO2dCQUUzQixJQUFJLFFBQVEsR0FBRyxLQUFLLENBQUMsY0FBYyxDQUFDLGVBQWUsRUFBRSxDQUFDO2dCQUN0RCxJQUFJLElBQUksR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDaEQsSUFBRyxJQUFJLEdBQUcsQ0FBQyxFQUFDO29CQUNYLHFCQUFxQjtvQkFDckIsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLHVCQUFhLENBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7aUJBQzFFO2FBQ0Q7WUFFRCxrREFBa0Q7WUFDbEQsNEVBQTRFO1lBQzVFLEtBQUksSUFBSSxPQUFPLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBQztnQkFDaEMsMkJBQTJCO2dCQUMzQixJQUFHLENBQUMsT0FBTyxDQUFDLE1BQU07b0JBQUUsU0FBUztnQkFFN0IsSUFBRyxPQUFPLFlBQVksMkJBQWlCLEVBQUM7b0JBQ3ZDLElBQUksQ0FBQyw0QkFBNEIsQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFDO2lCQUMzRDthQUNEO1lBRUQsNEJBQTRCO1lBQzVCLFFBQVEsR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFcEQsa0NBQWtDO1lBQ2xDLElBQUksSUFBSSxHQUFHLEVBQUUsQ0FBQztZQUVkLDBDQUEwQztZQUMxQyxzRUFBc0U7WUFDdEUsS0FBSSxJQUFJLE9BQU8sSUFBSSxRQUFRLEVBQUM7Z0JBQzNCLHNDQUFzQztnQkFDdEMsSUFBSSxVQUFVLEtBQUssQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBQUcsU0FBUztnQkFFbEksb0hBQW9IO2dCQUNwSCx5RUFBeUU7Z0JBQ3pFLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDO2dCQUN6QyxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO2dCQUM3QixNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQztnQkFDN0MsTUFBTSxTQUFTLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQztnQkFHbkMsTUFBTSxHQUFHLEdBQUcsU0FBUyxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFFakgsT0FBTyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7Z0JBRWxCLElBQUcsR0FBRyxLQUFLLElBQUksRUFBQztvQkFDZixJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQUVmLHdEQUF3RDtvQkFDeEQsSUFBSSxNQUFNLEdBQUcsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7b0JBQzdCLElBQUksTUFBTSxHQUFHLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO29CQUU3QixzRUFBc0U7b0JBQ3RFLGtIQUFrSDtvQkFDbEgsSUFBRyxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxTQUFTLENBQUMsR0FBRyxHQUFHLE9BQU8sQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLENBQUMsS0FBSyxTQUFTLENBQUMsTUFBTSxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRTt3QkFDeEgsTUFBTSxHQUFHLEdBQUcsQ0FBQztxQkFDYjt5QkFBTSxJQUFHLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLFNBQVMsQ0FBQyxJQUFJLEdBQUcsT0FBTyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxLQUFLLFNBQVMsQ0FBQyxLQUFLLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFO3dCQUMvSCxNQUFNLEdBQUcsR0FBRyxDQUFDO3FCQUNiO29CQUdELElBQUcsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBQzt3QkFDOUMsdURBQXVEO3dCQUN2RCxJQUFHLE9BQU8sQ0FBQyxJQUFJLEtBQUssU0FBUyxJQUFJLE9BQU8sQ0FBQyxLQUFLLENBQUMsWUFBWSxFQUFDOzRCQUMzRCxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUM7NEJBQzdDLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO3lCQUN4QjtxQkFDRDtvQkFFRCxJQUFHLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUM7d0JBQzlDLHVEQUF1RDt3QkFDdkQsSUFBRyxPQUFPLENBQUMsSUFBSSxLQUFLLFNBQVMsSUFBSSxPQUFPLENBQUMsS0FBSyxDQUFDLFlBQVksRUFBQzs0QkFDM0QsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDOzRCQUM3QyxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQzt5QkFDeEI7cUJBQ0Q7aUJBQ0Q7YUFDRDtZQUVELG1EQUFtRDtZQUNuRCxzREFBc0Q7WUFDdEQsMEJBQTBCO1lBQzFCLEtBQUksSUFBSSxPQUFPLElBQUksUUFBUSxFQUFDO2dCQUMzQiwyREFBMkQ7Z0JBQzNELElBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxTQUFTLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsRUFBQztvQkFDMUYsZ0RBQWdEO29CQUNoRCxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7b0JBRTlDLHNDQUFzQztvQkFDdEMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLEVBQUU7d0JBQzFELElBQUksRUFBYSxJQUFLLENBQUMsRUFBRTt3QkFDekIsS0FBSyxFQUFhLE9BQU8sQ0FBQyxLQUFNLENBQUMsRUFBRTtxQkFDbkMsQ0FBQyxDQUFDO2lCQUNIO2dCQUVELDBEQUEwRDtnQkFDMUQsSUFBSSxVQUFVLEtBQUssQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBQUUsU0FBUztnQkFFakkseURBQXlEO2dCQUN6RCxJQUFHLE9BQU8sQ0FBQyxJQUFJLEtBQUssU0FBUyxJQUFJLE9BQU8sQ0FBQyxLQUFLLENBQUMsWUFBWSxFQUFDO29CQUMzRCxJQUFJLGFBQWEsR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLHlCQUF5QixDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsZUFBZSxFQUFFLENBQUMsQ0FBQztvQkFDdEcsSUFBRyxhQUFhLEtBQUssSUFBSSxFQUFDO3dCQUN6QixzRUFBc0U7d0JBQ3RFLElBQUcsT0FBTyxDQUFDLEdBQUcsS0FBSyxJQUFJLEVBQUM7NEJBQ3ZCLHdDQUF3Qzs0QkFDeEMsSUFBRyxPQUFPLENBQUMsSUFBSSxJQUFJLFNBQVMsRUFBQztnQ0FDNUIsSUFBSSxDQUFDLG1CQUFtQixHQUFHLElBQUksQ0FBQzs2QkFDaEM7NEJBRUQsSUFBRyxhQUFhLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFDO2dDQUN6Qix5Q0FBeUM7Z0NBQ3pDLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDOzZCQUNyQjtpQ0FBTSxJQUFHLGFBQWEsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFDO2dDQUMvQiw2Q0FBNkM7Z0NBQzdDLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDOzZCQUN0QjtpQ0FBTTtnQ0FDTixvREFBb0Q7Z0NBQ3BELElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDOzZCQUNuQjt5QkFDRDtxQkFDRDtpQkFDRDthQUNEO1lBRUQsbURBQW1EO1lBQ25ELElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztTQUNsQjtJQUNGLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNPLDRCQUE0QixDQUFDLElBQWMsRUFBRSxPQUEwQixFQUFFLFFBQThCO1FBQ2hILDZEQUE2RDtRQUM3RCxJQUFJLEdBQUcsR0FBRyxJQUFJLGNBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzVELElBQUksR0FBRyxHQUFHLElBQUksY0FBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFaEUsMEVBQTBFO1FBQzFFLElBQUksUUFBUSxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3BELElBQUksUUFBUSxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBRXBELHlGQUF5RjtRQUN6RixLQUFJLElBQUksR0FBRyxHQUFHLFFBQVEsQ0FBQyxDQUFDLEVBQUUsR0FBRyxJQUFJLFFBQVEsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUM7WUFDbEQsS0FBSSxJQUFJLEdBQUcsR0FBRyxRQUFRLENBQUMsQ0FBQyxFQUFFLEdBQUcsSUFBSSxRQUFRLENBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxFQUFDO2dCQUNsRCxJQUFHLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQUM7b0JBQ3JDLHNDQUFzQztvQkFDdEMsSUFBSSxRQUFRLEdBQUcsT0FBTyxDQUFDLGVBQWUsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7b0JBQ2pELHlEQUF5RDtvQkFDekQsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7b0JBQ2hELElBQUcsSUFBSSxHQUFHLENBQUMsRUFBQzt3QkFDWCxxQkFBcUI7d0JBQ3JCLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSx1QkFBYSxDQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxJQUFJLGNBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO3FCQUN6RjtpQkFDRDthQUNEO1NBQ0Q7SUFDRixDQUFDO0NBQ0Q7QUExU0Qsc0NBMFNDOzs7Ozs7OztBQ3BWRCxrRUFBMEM7QUFDMUMsZ0VBQXdDO0FBQ3hDLHVFQUErQztBQUcvQzs7O0dBR0c7QUFDSCxNQUE4QixjQUFjO0lBZTNDO1FBQ0MsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLGtCQUFRLEVBQUUsQ0FBQztRQUMvQixJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksaUJBQU8sRUFBRSxDQUFDO1FBRTdCLHdFQUF3RTtRQUN4RSxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksYUFBRyxFQUFFLENBQUM7UUFDMUIsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLEtBQUssRUFBRSxDQUFDO0lBQy9CLENBQUM7SUFFRCxPQUFPO1FBQ04sSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUN6QixDQUFDO0lBNkJEOzs7O09BSUc7SUFDSCxRQUFRLENBQUMsSUFBYyxFQUFFLEtBQWE7UUFDckMsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN2QyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILGNBQWMsQ0FBQyxLQUFhO1FBQzNCLElBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUM7WUFDM0IsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUNoQzthQUFLO1lBQ0wsT0FBTyxDQUFDLENBQUM7U0FDVDtJQUNGLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsYUFBYSxDQUFDLE1BQWM7UUFDM0IsSUFBRyxNQUFNLEtBQUssQ0FBQyxDQUFDLEVBQUM7WUFDaEIsT0FBTyxDQUFDLGNBQWMsQ0FBQyxhQUFhLENBQUMsQ0FBQztTQUN0QzthQUFNO1lBQ04sSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ1YsSUFBSSxLQUFLLEdBQUcsRUFBRSxDQUFDO1lBRWYsS0FBSSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBQztnQkFDMUIsSUFBRyxDQUFDLEdBQUcsTUFBTSxFQUFDO29CQUNiLHFDQUFxQztvQkFDckMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7aUJBQy9CO2dCQUVELHFCQUFxQjtnQkFDckIsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDWDtTQUNEO0lBQ0YsQ0FBQzs7QUFuR0YsaUNBb0dDO0FBeEZBLDZCQUE2QjtBQUNILDRCQUFhLEdBQVcsU0FBUyxDQUFDOzs7Ozs7OztBQ3RCN0QsMkRBQXdEO0FBQ3hELGtFQUEwQztBQU8xQyxNQUFxQixlQUFlO0lBWWhDO1FBQ0ksSUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7UUFDdkIsSUFBSSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7UUFFckIsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLGtCQUFRLEVBQUUsQ0FBQztRQUMvQixJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDLDZCQUFhLENBQUMsZUFBZSxFQUFFLDZCQUFhLENBQUMsY0FBYyxFQUFFLDZCQUFhLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQztJQUN6SCxDQUFDO0lBRU0sTUFBTSxDQUFDLE1BQWM7UUFDeEIsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRSxFQUFFO1lBQ2pDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDO1NBQ2xEO1FBRUQsSUFBSSxJQUFJLENBQUMsUUFBUSxLQUFLLFNBQVMsRUFBRTtZQUM3QixJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUM3QixJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUM7U0FDM0M7UUFDRCxJQUFJLElBQUksQ0FBQyxRQUFRLEtBQUssU0FBUyxFQUFFO1lBQzdCLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQzdCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQztTQUN6QztJQUNMLENBQUM7SUFFUyxXQUFXLENBQUMsS0FBZ0I7UUFDbEMsUUFBTyxLQUFLLENBQUMsSUFBSSxFQUFFO1lBQ2YsS0FBSyw2QkFBYSxDQUFDLGVBQWUsQ0FBQyxDQUFDO2dCQUNoQyxJQUFJLENBQUMseUJBQXlCLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQ3RDLE1BQU07YUFDVDtZQUNELEtBQUssNkJBQWEsQ0FBQyxjQUFjLENBQUMsQ0FBQztnQkFDL0IsSUFBSSxDQUFDLHdCQUF3QixFQUFFLENBQUM7Z0JBQ2hDLE1BQU07YUFDVDtZQUNELEtBQUssNkJBQWEsQ0FBQyxjQUFjLENBQUMsQ0FBQztnQkFDL0IsSUFBSSxDQUFDLHdCQUF3QixDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUNyQyxNQUFNO2FBQ1Q7U0FDSjtJQUNMLENBQUM7SUFDUyx5QkFBeUIsQ0FBQyxLQUFnQjtRQUNoRCxJQUFJLFNBQVMsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUM1QyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLElBQUksU0FBUyxLQUFLLFNBQVMsRUFBRTtZQUM3RCxJQUFJLENBQUMsYUFBYSxHQUFHLFNBQVMsQ0FBQztZQUMvQixJQUFJLFFBQVEsR0FBa0csSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUM1SSxJQUFJLElBQUksQ0FBQyxRQUFRLEtBQUssU0FBUyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxLQUFLLFFBQVEsRUFBRTtnQkFDdkUsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLFFBQVEsRUFBRSxDQUFDO2FBQ2xDO1lBQ0QsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQ3hDLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQztTQUMzQztJQUNMLENBQUM7SUFDUyx3QkFBd0I7UUFDOUIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUNyQixJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDNUMsQ0FBQztJQUNTLHdCQUF3QixDQUFDLEtBQWdCO1FBQy9DLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxhQUFhLEtBQUssU0FBUyxFQUFFO1lBQ3JELElBQUksUUFBUSxHQUFrRyxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQzVJLElBQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxTQUFTLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEtBQUssUUFBUSxFQUFFO2dCQUN2RSxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksUUFBUSxFQUFFLENBQUM7YUFDbEM7WUFDRCxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7WUFDakUsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDO1NBQ3pDO0lBQ0wsQ0FBQztDQUNKO0FBN0VELGtDQTZFQzs7Ozs7Ozs7QUN2RkQsMEVBQWtEO0FBRWxELE1BQU07QUFDTixNQUE4QixRQUFZLFNBQVEsYUFBTTtDQWtCdkQ7QUFsQkQsMkJBa0JDOzs7Ozs7OztBQ25CRCxpSEFBeUY7QUFDekYsaUhBQXlGO0FBQ3pGLCtHQUF1RjtBQUN2RixtSEFBMkY7QUFDM0YsNEZBQW9FO0FBQ3BFLDBEQUFrQztBQUVsQzs7R0FFRztBQUNILE1BQXFCLGNBQWUsU0FBUSxrQkFBb0I7SUFBaEU7O1FBUVMsa0JBQWEsR0FBOEIsSUFBSSxLQUFLLEVBQUUsQ0FBQztJQW1FaEUsQ0FBQztJQWpFQTs7T0FFRztJQUNJLE9BQU87UUFDYix3RUFBd0U7UUFDeEUsTUFBTSxFQUFFLEdBQUcseUJBQWUsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUV6QyxvQ0FBb0M7UUFDcEMsSUFBSSxDQUFDLHNCQUFzQixDQUFDLGNBQWMsQ0FBQyxZQUFZLEVBQUUseUJBQWUsRUFBRSwrQkFBK0IsRUFBRSwrQkFBK0IsQ0FBQyxDQUFDO1FBRTVJLG1DQUFtQztRQUNuQyxJQUFJLENBQUMsc0JBQXNCLENBQUMsY0FBYyxDQUFDLFdBQVcsRUFBRSx3QkFBYyxFQUFFLDhCQUE4QixFQUFFLDhCQUE4QixDQUFDLENBQUM7UUFFeEkscUNBQXFDO1FBQ3JDLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxjQUFjLENBQUMsYUFBYSxFQUFFLDBCQUFnQixFQUFFLGdDQUFnQyxFQUFFLGdDQUFnQyxDQUFDLENBQUM7UUFFaEosb0NBQW9DO1FBQ3BDLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxjQUFjLENBQUMsWUFBWSxFQUFFLHlCQUFlLEVBQUUsK0JBQStCLEVBQUUsK0JBQStCLENBQUMsQ0FBQztRQUU1SSx1Q0FBdUM7UUFDdkMsS0FBSSxJQUFJLElBQUksSUFBSSxJQUFJLENBQUMsYUFBYSxFQUFDO1lBQ2xDLE1BQU0sTUFBTSxHQUFHLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDekMsTUFBTSxDQUFDLGdCQUFnQixFQUFFLENBQUM7WUFDMUIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBRTNCLGtCQUFrQjtZQUNsQixJQUFHLElBQUksQ0FBQyxPQUFPLEtBQUssU0FBUyxFQUFDO2dCQUM3QixFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxlQUFlLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FBQzthQUNoRjtTQUNEO0lBQ0YsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLHNCQUFzQixDQUFDLEdBQVcsRUFBRSxNQUE4QyxFQUFFLGVBQXVCLEVBQUUsZUFBdUI7UUFDMUksSUFBSSxhQUFhLEdBQUcsSUFBSSxhQUFhLEVBQUUsQ0FBQztRQUN4QyxhQUFhLENBQUMsZUFBZSxHQUFHLGVBQWUsQ0FBQztRQUNoRCxhQUFhLENBQUMsZUFBZSxHQUFHLGVBQWUsQ0FBQztRQUVoRCxJQUFJLFlBQVksR0FBRyxJQUFJLGtCQUFrQixFQUFFLENBQUM7UUFDNUMsWUFBWSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7UUFDdkIsWUFBWSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDN0IsWUFBWSxDQUFDLE9BQU8sR0FBRyxhQUFhLENBQUM7UUFFckMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDdkMsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ksWUFBWSxDQUFDLEdBQVcsRUFBRSxNQUE4QztRQUM5RSxJQUFJLFlBQVksR0FBRyxJQUFJLGtCQUFrQixFQUFFLENBQUM7UUFDNUMsWUFBWSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7UUFDdkIsWUFBWSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFFN0IsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDdkMsQ0FBQzs7QUExRUYsaUNBMkVDO0FBekVBLGVBQWU7QUFDRCwyQkFBWSxHQUFHLE9BQU8sQ0FBQztBQUN2QiwwQkFBVyxHQUFHLE1BQU0sQ0FBQztBQUNyQiw0QkFBYSxHQUFHLFFBQVEsQ0FBQztBQUN6QiwyQkFBWSxHQUFHLE9BQU8sQ0FBQztBQXVFdEMsTUFBTSxrQkFBa0I7Q0FJdkI7QUFFRCxNQUFNLGFBQWE7Q0FHbEI7Ozs7Ozs7O0FDbEdELHVFQUErQztBQUUvQyxpRkFBeUQ7QUFFekQ7Ozs7O0dBS0c7QUFDSCxNQUFxQixlQUFlO0lBT25DLE1BQU0sQ0FBQyxPQUFPO1FBQ2IsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUV2QixJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQVcsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztJQUM5RSxDQUFDO0lBRUQsTUFBTSxDQUFDLGlCQUFpQixDQUFDLElBQVksRUFBRSxRQUF1QjtRQUM3RCxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVELE1BQU0sQ0FBQyxXQUFXLENBQUMsR0FBVztRQUM3QixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2pDLENBQUM7O0FBbkJGLGtDQW9CQztBQWxCYyx1QkFBTyxHQUFHLElBQUksd0JBQWMsRUFBRSxDQUFDO0FBRTdDLGtFQUFrRTtBQUNqRCwwQkFBVSxHQUF1QixJQUFJLGFBQUcsRUFBRSxDQUFDOzs7Ozs7OztBQ2Y3RCwwRUFBa0Q7QUFDbEQsbUVBQTJDO0FBRTNDLHFEQUFpRTtBQUVqRTs7Ozs7R0FLRztBQUNILE1BQXFCLGdCQUFnQjtJQXFDakM7OztPQUdHO0lBQ0gsWUFBWSxLQUFpQjtRQUN6QixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixJQUFJLENBQUMsY0FBYyxHQUFHLCtCQUFjLENBQUMsT0FBTyxDQUFDO1FBQzdDLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxFQUFFLENBQUM7UUFDM0IsSUFBSSxDQUFDLFlBQVksR0FBRyxDQUFDLENBQUM7UUFDdEIsSUFBSSxDQUFDLGFBQWEsR0FBRyxDQUFDLENBQUM7UUFDdkIsSUFBSSxDQUFDLElBQUksR0FBRyxLQUFLLENBQUM7UUFDbEIsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLGFBQUcsRUFBRSxDQUFDO1FBQzVCLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxpQkFBTyxFQUFFLENBQUM7SUFDakMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxHQUFHLENBQUMsR0FBVyxFQUFFLFNBQXdCO1FBQ3JDLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUN4QyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsUUFBUTtRQUNKLElBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEVBQUM7WUFDMUMsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLEtBQUssQ0FBQztTQUNyRjthQUFNO1lBQ0gsc0NBQXNDO1lBQ3RDLE9BQU8sQ0FBQyxJQUFJLENBQUMsNkRBQTZELElBQUksQ0FBQyxnQkFBZ0IsY0FBYyxDQUFDLENBQUM7WUFDL0csT0FBTyxDQUFDLENBQUM7U0FDWjtJQUNMLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsU0FBUyxDQUFDLEdBQVc7UUFDakIsT0FBTyxJQUFJLENBQUMsZ0JBQWdCLEtBQUssR0FBRyxJQUFJLElBQUksQ0FBQyxjQUFjLEtBQUssK0JBQWMsQ0FBQyxPQUFPLENBQUM7SUFDM0YsQ0FBQztJQUVEOzs7T0FHRztJQUNILDJCQUEyQjtRQUN2Qiw0REFBNEQ7UUFDNUQsSUFBRyxDQUFDLENBQUMsSUFBSSxDQUFDLGNBQWMsS0FBSywrQkFBYyxDQUFDLE9BQU8sQ0FBQyxFQUFDO1lBQ2pELE9BQU8sSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1NBQzFCO1FBRUQsSUFBRyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsRUFBQztZQUMxQyxJQUFJLGdCQUFnQixHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1lBQ2xFLElBQUksS0FBSyxHQUFHLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsS0FBSyxDQUFDO1lBRTdELHdCQUF3QjtZQUN4QixJQUFJLENBQUMsYUFBYSxJQUFJLENBQUMsQ0FBQztZQUN4QixJQUFHLElBQUksQ0FBQyxhQUFhLElBQUksZ0JBQWdCLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxRQUFRLEVBQUM7Z0JBQ3pFLHdFQUF3RTtnQkFDeEUsSUFBSSxDQUFDLGFBQWEsR0FBRyxDQUFDLENBQUM7Z0JBQ3ZCLElBQUksQ0FBQyxZQUFZLElBQUksQ0FBQyxDQUFDO2dCQUV2QixJQUFHLElBQUksQ0FBQyxZQUFZLElBQUksZ0JBQWdCLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBQztvQkFDbkQsNENBQTRDO29CQUM1QyxJQUFHLElBQUksQ0FBQyxJQUFJLEVBQUM7d0JBQ1QsSUFBSSxDQUFDLFlBQVksR0FBRyxDQUFDLENBQUM7d0JBQ3RCLElBQUksQ0FBQyxhQUFhLEdBQUcsQ0FBQyxDQUFDO3FCQUMxQjt5QkFBTTt3QkFDSCxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztxQkFDOUI7aUJBQ0o7YUFDSjtZQUVELDJCQUEyQjtZQUMzQixPQUFPLEtBQUssQ0FBQztTQUNoQjthQUFNO1lBQ0gscURBQXFEO1lBQ3JELE9BQU8sQ0FBQyxJQUFJLENBQUMseUVBQXlFLElBQUksQ0FBQyxnQkFBZ0Isc0JBQXNCLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxjQUFjLENBQUMsQ0FBQztZQUM5SixPQUFPLENBQUMsQ0FBQztTQUNaO0lBQ0wsQ0FBQztJQUVELHdHQUF3RztJQUM5RixtQkFBbUI7UUFDekIsSUFBSSxDQUFDLFlBQVksR0FBRyxDQUFDLENBQUM7UUFDdEIsSUFBSSxDQUFDLGNBQWMsR0FBRywrQkFBYyxDQUFDLE9BQU8sQ0FBQztRQUU3QyxJQUFHLElBQUksQ0FBQyxVQUFVLEtBQUssSUFBSSxFQUFDO1lBQ3hCLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsRUFBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsU0FBUyxFQUFFLElBQUksQ0FBQyxnQkFBZ0IsRUFBQyxDQUFDLENBQUM7U0FDckc7UUFFRCwyQ0FBMkM7UUFDM0MsSUFBRyxJQUFJLENBQUMsZ0JBQWdCLEtBQUssSUFBSSxFQUFDO1lBQzlCLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLElBQUksQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1NBQ3pFO0lBQ0wsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsZ0JBQWdCLENBQUMsU0FBaUIsRUFBRSxJQUFjLEVBQUUsS0FBYztRQUM5RCxJQUFHLElBQUksQ0FBQyxnQkFBZ0IsS0FBSyxTQUFTLEVBQUM7WUFDbkMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO1NBQ3JDO0lBQ0wsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsSUFBSSxDQUFDLFNBQWlCLEVBQUUsSUFBYyxFQUFFLEtBQWM7UUFDbEQsSUFBSSxDQUFDLGdCQUFnQixHQUFHLFNBQVMsQ0FBQztRQUNsQyxJQUFJLENBQUMsWUFBWSxHQUFHLENBQUMsQ0FBQztRQUN0QixJQUFJLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztRQUN2QixJQUFJLENBQUMsY0FBYyxHQUFHLCtCQUFjLENBQUMsT0FBTyxDQUFDO1FBRTdDLHFDQUFxQztRQUNyQyxJQUFHLElBQUksS0FBSyxTQUFTLEVBQUM7WUFDbEIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7U0FDcEI7YUFBTTtZQUNILDhDQUE4QztZQUM5QyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztTQUNyRDtRQUVELElBQUcsS0FBSyxLQUFLLFNBQVMsRUFBQztZQUNuQixJQUFJLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQztTQUMzQjthQUFNO1lBQ0gsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUM7U0FDMUI7UUFFRCwwQkFBMEI7UUFDMUIsSUFBSSxDQUFDLGdCQUFnQixHQUFHLElBQUksQ0FBQztJQUNqQyxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsS0FBSyxDQUFDLFNBQWlCLEVBQUUsT0FBZ0IsS0FBSyxFQUFFLEtBQWM7UUFDMUQsSUFBSSxDQUFDLGdCQUFnQixHQUFHLFNBQVMsQ0FBQztRQUNsQyxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQztRQUN4QixJQUFHLEtBQUssS0FBSyxTQUFTLEVBQUM7WUFDbkIsSUFBSSxDQUFDLFlBQVksR0FBRyxLQUFLLENBQUM7U0FDN0I7YUFBTTtZQUNILElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDO1NBQzVCO0lBQ0wsQ0FBQztJQUVELG1DQUFtQztJQUNuQyxLQUFLO1FBQ0QsSUFBSSxDQUFDLGNBQWMsR0FBRywrQkFBYyxDQUFDLE1BQU0sQ0FBQztJQUNoRCxDQUFDO0lBRUQsZ0RBQWdEO0lBQ2hELE1BQU07UUFDRixJQUFHLElBQUksQ0FBQyxjQUFjLEtBQUssK0JBQWMsQ0FBQyxNQUFNLEVBQUM7WUFDN0MsSUFBSSxDQUFDLGNBQWMsR0FBRywrQkFBYyxDQUFDLE9BQU8sQ0FBQztTQUNoRDtJQUNMLENBQUM7SUFFRCwrRUFBK0U7SUFDL0UsSUFBSTtRQUNBLElBQUksQ0FBQyxjQUFjLEdBQUcsK0JBQWMsQ0FBQyxPQUFPLENBQUM7SUFDakQsQ0FBQztDQUNKO0FBeE5ELG1DQXdOQzs7Ozs7O0FDaE9ELGNBQWM7QUFFZCxJQUFZLGNBSVg7QUFKRCxXQUFZLGNBQWM7SUFDdEIseURBQVcsQ0FBQTtJQUNYLHVEQUFVLENBQUE7SUFDVix5REFBVyxDQUFBO0FBQ2YsQ0FBQyxFQUpXLGNBQWMsR0FBZCxzQkFBYyxLQUFkLHNCQUFjLFFBSXpCO0FBRUQsTUFBYSxhQUFhO0lBQTFCO1FBR0ksV0FBTSxHQUFZLEtBQUssQ0FBQztJQUM1QixDQUFDO0NBQUE7QUFKRCxzQ0FJQztBQUVELE1BQWEsV0FBVztDQWtCdkI7QUFsQkQsa0NBa0JDO0FBRUQsTUFBYSxTQUFTO0NBOEJyQjtBQTlCRCw4QkE4QkM7Ozs7O0FDaEVELE1BQXFCLHFCQUFxQjtJQU10QztRQUNJLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxLQUFLLEVBQUUsQ0FBQztJQUN2QyxDQUFDO0lBRUQsTUFBTSxDQUFDLFdBQVc7UUFDZCxJQUFHLHFCQUFxQixDQUFDLFFBQVEsS0FBSyxJQUFJLEVBQUM7WUFDdkMscUJBQXFCLENBQUMsUUFBUSxHQUFHLElBQUkscUJBQXFCLEVBQUUsQ0FBQztTQUNoRTtRQUVELE9BQU8scUJBQXFCLENBQUMsUUFBUSxDQUFDO0lBQzFDLENBQUM7SUFFRCxzQkFBc0IsQ0FBQyxNQUFzQjtRQUN6QyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRUQsd0JBQXdCLENBQUMsTUFBc0I7UUFDM0MsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDakQsSUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQzFDLENBQUM7SUFFRCxvQkFBb0I7UUFDaEIsSUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLEtBQUssRUFBRSxDQUFDO0lBQ3ZDLENBQUM7SUFFRCxNQUFNLENBQUMsTUFBYztRQUNqQixLQUFJLElBQUksY0FBYyxJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUM7WUFDM0MsY0FBYyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUNqQztJQUNMLENBQUM7O0FBbkNMLHdDQW9DQztBQWxDa0IsOEJBQVEsR0FBMEIsSUFBSSxDQUFDOzs7Ozs7OztBQ0wxRCwwRUFBa0Q7QUFFbEQscURBQTZEO0FBQzdELDhFQUFzRDtBQUN0RCxzRUFBOEM7QUFDOUMsa0VBQTBDO0FBQzFDLG1FQUEyQztBQUUzQzs7Ozs7OztHQU9HO0FBQ0gsTUFBcUIsZUFBZTtJQVFoQzs7O09BR0c7SUFDSCxZQUFZLEtBQWU7UUFDdkIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLGFBQUcsRUFBRSxDQUFDO1FBQ3hCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxpQkFBTyxFQUFFLENBQUM7UUFFN0IscUNBQXFDO1FBQ3JDLHNCQUFZLENBQUMsV0FBVyxFQUFFLENBQUMsdUJBQXVCLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDN0QsQ0FBQztJQUVEOztPQUVHO0lBQ0gsT0FBTztRQUNILDBFQUEwRTtRQUMxRSxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDO1FBQ3pCLHNCQUFZLENBQUMsV0FBVyxFQUFFLENBQUMseUJBQXlCLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDL0QsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxHQUFHLENBQUMsR0FBVyxFQUFFLEtBQXNDO1FBQ25ELElBQUksVUFBVSxHQUFjLEtBQUssQ0FBQztRQUVsQyxnRUFBZ0U7UUFDaEUsVUFBVSxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUM7UUFDeEIsVUFBVSxDQUFDLFdBQVcsR0FBRyxDQUFDLENBQUM7UUFDM0IsVUFBVSxDQUFDLGNBQWMsR0FBRywrQkFBYyxDQUFDLE9BQU8sQ0FBQztRQUVuRCxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxJQUFJLENBQUMsR0FBVyxFQUFFLElBQWM7UUFDNUIsSUFBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBQztZQUNwQixJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUVqQyxxQkFBcUI7WUFDckIsSUFBRyxJQUFJLEtBQUssU0FBUyxFQUFDO2dCQUNsQixLQUFLLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQzthQUNyQjtZQUVELHlCQUF5QjtZQUN6QixLQUFJLElBQUksTUFBTSxJQUFJLEtBQUssQ0FBQyxPQUFPLEVBQUM7Z0JBQzVCLElBQUcsTUFBTSxDQUFDLGVBQWUsRUFBQztvQkFDdEIsTUFBTSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztpQkFDckQ7YUFDSjtZQUVELDBCQUEwQjtZQUMxQixLQUFLLENBQUMsY0FBYyxHQUFHLCtCQUFjLENBQUMsT0FBTyxDQUFDO1lBQzlDLEtBQUssQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDO1lBQ3RCLEtBQUssQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDO1lBQ25CLEtBQUssQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDO1NBQzNCO2FBQU07WUFDSCxPQUFPLENBQUMsSUFBSSxDQUFDLHdCQUF3QixHQUFHLHFCQUFxQixJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsNEJBQTRCLENBQUMsQ0FBQztTQUMzRztJQUNMLENBQUM7SUFFRDs7O09BR0c7SUFDSCxLQUFLLENBQUMsR0FBVztRQUNiLElBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUM7WUFDcEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsY0FBYyxHQUFHLCtCQUFjLENBQUMsTUFBTSxDQUFDO1NBQy9EO0lBQ0wsQ0FBQztJQUVEOzs7T0FHRztJQUNILE1BQU0sQ0FBQyxHQUFXO1FBQ2QsSUFBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBQztZQUNwQixJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNqQyxJQUFHLEtBQUssQ0FBQyxjQUFjLEtBQUssK0JBQWMsQ0FBQyxNQUFNO2dCQUM3QyxLQUFLLENBQUMsY0FBYyxHQUFHLCtCQUFjLENBQUMsT0FBTyxDQUFDO1NBQ3JEO0lBQ0wsQ0FBQztJQUVEOzs7T0FHRztJQUNILElBQUksQ0FBQyxHQUFXO1FBQ1osSUFBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBQztZQUNwQixJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNqQyxLQUFLLENBQUMsY0FBYyxHQUFHLCtCQUFjLENBQUMsT0FBTyxDQUFDO1lBRTlDLCtCQUErQjtZQUMvQixLQUFJLElBQUksTUFBTSxJQUFJLEtBQUssQ0FBQyxPQUFPLEVBQUM7Z0JBQzVCLElBQUcsTUFBTSxDQUFDLGVBQWUsRUFBQztvQkFDdEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQztpQkFDckQ7YUFDSjtTQUNKO0lBQ0wsQ0FBQztJQUVEOzs7T0FHRztJQUNPLEdBQUcsQ0FBQyxHQUFXO1FBQ3JCLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDZixJQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFDO1lBQ3BCLGdCQUFnQjtZQUNoQixJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUVqQyxvQ0FBb0M7WUFDcEMsSUFBRyxLQUFLLENBQUMsS0FBSyxFQUFDO2dCQUNYLElBQUksSUFBSSxHQUF3QixFQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFDLENBQUE7Z0JBQy9ELDhGQUE4RjtnQkFDOUYsSUFBSSxLQUFLLENBQUMsU0FBUyxFQUFFO29CQUNqQixNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUU7d0JBQ3ZDLElBQUksR0FBRyxLQUFLLEtBQUssSUFBSSxHQUFHLEtBQUssTUFBTSxFQUFFOzRCQUNqQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQzt5QkFDcEM7b0JBQ0wsQ0FBQyxDQUFDLENBQUE7aUJBQ0w7Z0JBQ0QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQzthQUM3QztTQUNKO0lBQ0wsQ0FBQztJQUVEOztPQUVHO0lBQ0gsT0FBTztRQUNILElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQy9DLENBQUM7SUFFRCxNQUFNLENBQUMsTUFBYztRQUNqQixJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUN0QixJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNqQyxJQUFHLEtBQUssQ0FBQyxjQUFjLEtBQUssK0JBQWMsQ0FBQyxPQUFPLEVBQUM7Z0JBQy9DLG1DQUFtQztnQkFDbkMsS0FBSyxDQUFDLFdBQVcsSUFBSSxNQUFNLEdBQUMsSUFBSSxDQUFDO2dCQUVqQyw2Q0FBNkM7Z0JBQzdDLElBQUcsS0FBSyxDQUFDLFdBQVcsSUFBSSxLQUFLLENBQUMsVUFBVSxFQUFDO29CQUNyQyxJQUFHLENBQUMsS0FBSyxDQUFDLFNBQVMsSUFBSSxLQUFLLENBQUMsV0FBVyxJQUFJLEtBQUssQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDLFFBQVEsRUFBQzt3QkFDMUUsdURBQXVEO3dCQUN2RCxJQUFHLEtBQUssQ0FBQyxpQkFBaUIsRUFBQzs0QkFDdkIsNENBQTRDOzRCQUM1QyxLQUFLLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQzt5QkFDMUI7NkJBQU0sSUFBRyxLQUFLLENBQUMsSUFBSSxFQUFDOzRCQUNqQiwwQ0FBMEM7NEJBQzFDLEtBQUssQ0FBQyxXQUFXLElBQUksS0FBSyxDQUFDLFFBQVEsQ0FBQzt5QkFDdkM7NkJBQU07NEJBQ0gsK0NBQStDOzRCQUMvQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO3lCQUNqQjtxQkFDSjtvQkFFRCxpQ0FBaUM7b0JBQ2pDLElBQUcsS0FBSyxDQUFDLFNBQVMsSUFBSSxLQUFLLENBQUMsV0FBVyxJQUFJLEtBQUssQ0FBQyxVQUFVLEdBQUcsQ0FBQyxHQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUM7d0JBQzNFLElBQUcsS0FBSyxDQUFDLElBQUksRUFBQzs0QkFDVixLQUFLLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQzs0QkFDeEIsS0FBSyxDQUFDLFdBQVcsSUFBSSxDQUFDLEdBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQzt5QkFDekM7NkJBQU07NEJBQ0gsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQzt5QkFDakI7cUJBQ0o7b0JBRUQsK0ZBQStGO29CQUMvRixJQUFHLEtBQUssQ0FBQyxTQUFTLEVBQUM7d0JBQ2YsS0FBSyxDQUFDLFFBQVEsR0FBRyxtQkFBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBQyxLQUFLLENBQUMsUUFBUSxHQUFHLENBQUMsS0FBSyxDQUFDLFdBQVcsR0FBRSxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsR0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7cUJBQ2pIO3lCQUFNO3dCQUNILEtBQUssQ0FBQyxRQUFRLEdBQUcsbUJBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUFLLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQyxVQUFVLENBQUMsR0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7cUJBQzdGO29CQUVELEtBQUksSUFBSSxNQUFNLElBQUksS0FBSyxDQUFDLE9BQU8sRUFBQzt3QkFFNUIsd0VBQXdFO3dCQUN4RSxJQUFJLElBQUksR0FBRyx1QkFBYSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7d0JBRXRELHFDQUFxQzt3QkFDckMsSUFBSSxLQUFLLEdBQUcsbUJBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO3dCQUUzRCxtQ0FBbUM7d0JBQ25DLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEtBQUssQ0FBQztxQkFDdkM7aUJBQ0o7YUFDSjtRQUNMLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztDQUNKO0FBN01ELGtDQTZNQzs7Ozs7QUMxTkQsTUFBcUIsWUFBWTtJQU03QjtRQUNJLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLEtBQUssRUFBRSxDQUFDO0lBQ3hDLENBQUM7SUFFRCxNQUFNLENBQUMsV0FBVztRQUNkLElBQUcsWUFBWSxDQUFDLFFBQVEsS0FBSyxJQUFJLEVBQUM7WUFDOUIsWUFBWSxDQUFDLFFBQVEsR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO1NBQzlDO1FBRUQsT0FBTyxZQUFZLENBQUMsUUFBUSxDQUFDO0lBQ2pDLENBQUM7SUFFRCx1QkFBdUIsQ0FBQyxVQUEyQjtRQUMvQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQzNDLENBQUM7SUFFRCx5QkFBeUIsQ0FBQyxVQUEyQjtRQUNqRCxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ3RELElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQzNDLENBQUM7SUFFRCxxQkFBcUI7UUFDakIsSUFBSSxDQUFDLGdCQUFnQixHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7SUFDeEMsQ0FBQztJQUVELE1BQU0sQ0FBQyxNQUFjO1FBQ2pCLEtBQUksSUFBSSxlQUFlLElBQUksSUFBSSxDQUFDLGdCQUFnQixFQUFDO1lBQzdDLGVBQWUsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDbEM7SUFDTCxDQUFDOztBQW5DTCwrQkFvQ0M7QUFsQ2tCLHFCQUFRLEdBQWlCLElBQUksQ0FBQzs7Ozs7Ozs7QUNIakQsK0RBQXVDO0FBQ3ZDLG9FQUE0QztBQUM1QyxrRUFBMEM7QUFDMUMscUVBQTZDO0FBRzdDLG1FQUEyQztBQUczQyx3RkFBZ0U7QUFDaEUsMEVBQWlEO0FBQ2pELHdGQUFnRTtBQUNoRSw0RkFBb0U7QUFDcEUsc0VBQThDO0FBQzlDLHdFQUFnRDtBQUNoRCx3RUFBZ0Q7QUFDaEQsOEVBQXNEO0FBQ3RELHFGQUE2RDtBQUM3RCw2REFBcUM7QUFFckMsa0VBQTBDO0FBQzFDLDJEQUFtQztBQUluQzs7R0FFRztBQUNILE1BQXFCLGNBQWUsU0FBUSwwQkFBZ0I7SUFXeEQ7UUFDSSxLQUFLLEVBQUUsQ0FBQztJQUNaLENBQUM7SUFFRCxZQUFZO0lBQ1osUUFBUSxDQUFDLEtBQVk7UUFDakIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLGVBQWUsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDckMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDckMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUMzQyxDQUFDO0lBRUQsWUFBWTtJQUNaLGdCQUFnQixDQUFDLE1BQXlCLEVBQUUsS0FBYSxFQUFFLE1BQWM7UUFDckUsTUFBTSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDckIsTUFBTSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFFdkIsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLGNBQUksQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFFekMsSUFBSSxDQUFDLEdBQUcsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRW5DLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSx5QkFBZSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNyRCxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUkseUJBQWUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDckQsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksMkJBQWlCLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFBO1FBRXhELHNCQUFzQjtRQUN0QixJQUFJLENBQUMsR0FBRyxDQUFDLHFCQUFxQixHQUFHLEtBQUssQ0FBQztRQUV2QyxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUM7SUFDcEIsQ0FBQztJQUVELFlBQVk7SUFDWixNQUFNLENBQUMsVUFBd0IsRUFBRSxRQUFtQixFQUFFLFFBQXNCO1FBQ3hFLGdEQUFnRDtRQUNoRCxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ3JCLElBQUcsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxRQUFRLEVBQUUsRUFBQztnQkFDbkQsT0FBTyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQ3BEO2lCQUFNO2dCQUNILE9BQU8sQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQzthQUM1RDtRQUNMLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxZQUFZLEdBQUcsQ0FBQyxDQUFDO1FBQ3JCLElBQUksYUFBYSxHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQUM7UUFFcEMsSUFBSSxlQUFlLEdBQUcsQ0FBQyxDQUFDO1FBQ3hCLElBQUksZ0JBQWdCLEdBQUcsVUFBVSxDQUFDLE1BQU0sQ0FBQztRQUV6QyxPQUFNLFlBQVksR0FBRyxhQUFhLElBQUksZUFBZSxHQUFHLGdCQUFnQixFQUFDO1lBQ3JFLG9FQUFvRTtZQUNwRSxJQUFHLFlBQVksSUFBSSxhQUFhLEVBQUM7Z0JBQzdCLHdDQUF3QztnQkFDeEMsSUFBSSxJQUFJLEdBQUcsVUFBVSxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUM7Z0JBQ3pDLElBQUcsSUFBSSxDQUFDLE9BQU8sRUFBQztvQkFDWixJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO2lCQUN6QjtnQkFDRCxTQUFTO2FBQ1o7WUFFRCxJQUFHLGVBQWUsSUFBSSxnQkFBZ0IsRUFBQztnQkFDbkMsdUJBQXVCO2dCQUN2QixJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLENBQUM7Z0JBQzdDLFNBQVM7YUFDWjtZQUVELG1DQUFtQztZQUNuQyxJQUFHLFFBQVEsQ0FBQyxZQUFZLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxRQUFRLEVBQUUsSUFBSSxVQUFVLENBQUMsZUFBZSxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsUUFBUSxFQUFFLEVBQUM7Z0JBQ2pHLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUMsQ0FBQzthQUNoRDtpQkFBTTtnQkFDSCxJQUFJLElBQUksR0FBRyxVQUFVLENBQUMsZUFBZSxFQUFFLENBQUMsQ0FBQztnQkFDekMsSUFBRyxJQUFJLENBQUMsT0FBTyxFQUFDO29CQUNaLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7aUJBQ3pCO2FBQ0o7U0FDSjtRQUVELGdEQUFnRDtRQUNoRCxJQUFJLGNBQWMsR0FBRyxJQUFJLEtBQUssRUFBVyxDQUFDO1FBRTFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRWhFLGNBQWMsR0FBRyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLFFBQVEsRUFBRSxHQUFHLEdBQUcsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1FBRXBGLGNBQWMsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDdEMsSUFBRyxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUU7Z0JBQ3JCLE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUU7b0JBQ2xCLElBQWdCLElBQUssQ0FBQyxPQUFPLEVBQUM7d0JBQzFCLElBQUksQ0FBQyxVQUFVLENBQWEsSUFBSSxDQUFDLENBQUE7cUJBQ3BDO2dCQUNMLENBQUMsQ0FBQyxDQUFBO1FBQ2hCLENBQUMsQ0FBQyxDQUFDO0lBQ0QsQ0FBQztJQUVEOzs7T0FHRztJQUNPLFVBQVUsQ0FBQyxJQUFnQjtRQUNqQyxnRUFBZ0U7UUFDaEUsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBRWxELGtDQUFrQztRQUNsQyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxFQUFFLENBQUM7UUFFdEMseURBQXlEO1FBQ3pELElBQUksTUFBTSxHQUFHLENBQUMsQ0FBQztRQUNmLElBQUksTUFBTSxHQUFHLENBQUMsQ0FBQztRQUVmLElBQUcsSUFBSSxZQUFZLGdCQUFNLEVBQUM7WUFDdEIsTUFBTSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDL0IsTUFBTSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDbEM7UUFFRCxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxNQUFNLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN0SSxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNoQyxJQUFJLFdBQVcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQztRQUN2QyxJQUFHLElBQUksWUFBWSxjQUFJLEVBQUM7WUFDcEIsZUFBSyxDQUFDLEdBQUcsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLEVBQUUsRUFBRSxNQUFNLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQzNFO1FBQ0QsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztRQUVsQyxJQUFHLElBQUksWUFBWSx3QkFBYyxFQUFDO1lBQzlCLElBQUksQ0FBQyxvQkFBb0IsQ0FBaUIsSUFBSSxDQUFDLENBQUM7U0FDbkQ7YUFBTSxJQUFHLElBQUksWUFBWSxnQkFBTSxFQUFDO1lBQzdCLElBQUksQ0FBQyxZQUFZLENBQVMsSUFBSSxDQUFDLENBQUM7U0FDbkM7YUFBTSxJQUFHLElBQUksWUFBWSxpQkFBTyxFQUFDO1lBQzlCLElBQUksQ0FBQyxhQUFhLENBQVUsSUFBSSxDQUFDLENBQUM7U0FDckM7YUFBTSxJQUFHLElBQUksWUFBWSxtQkFBUyxFQUFDO1lBQ2hDLElBQUksQ0FBQyxlQUFlLENBQVksSUFBSSxDQUFDLENBQUM7U0FDekM7UUFFRCxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7UUFDbkMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBRUQsWUFBWTtJQUNGLFlBQVksQ0FBQyxNQUFjO1FBQ2pDLDBDQUEwQztRQUMxQyxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFMUQ7Ozs7Ozs7VUFPRTtRQUNGLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLEtBQUssRUFDcEIsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLEVBQzFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUM1QixDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLElBQUksRUFDeEYsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDNUYsQ0FBQztJQUVELFlBQVk7SUFDRixvQkFBb0IsQ0FBQyxNQUFzQjtRQUNqRCwwQ0FBMEM7UUFDMUMsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRTFELElBQUksY0FBYyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsMkJBQTJCLEVBQUUsQ0FBQztRQUVwRSxJQUFJLGVBQWUsR0FBRyxNQUFNLENBQUMsa0JBQWtCLENBQUMsY0FBYyxDQUFDLENBQUM7UUFFaEU7Ozs7Ozs7VUFPRTtRQUNGLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLEtBQUssRUFDcEIsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLEdBQUcsZUFBZSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsR0FBRyxlQUFlLENBQUMsQ0FBQyxFQUNsRixNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsRUFDNUIsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxJQUFJLEVBQ3hGLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzVGLENBQUM7SUFFRCxZQUFZO0lBQ0YsYUFBYSxDQUFDLE9BQWdCO1FBQ3BDLElBQUcsT0FBTyxZQUFZLGVBQUssRUFBQztZQUN4QixJQUFJLENBQUMsZUFBZSxDQUFDLFdBQVcsQ0FBUSxPQUFPLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQy9EO2FBQU0sSUFBRyxPQUFPLFlBQVksY0FBSSxFQUFDO1lBQzlCLElBQUksQ0FBQyxlQUFlLENBQUMsVUFBVSxDQUFPLE9BQU8sRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUMxRTthQUFNLElBQUcsT0FBTyxZQUFZLGNBQUksRUFBQztZQUM5QixJQUFJLENBQUMsZUFBZSxDQUFDLFVBQVUsQ0FBTyxPQUFPLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQzdEO0lBQ0wsQ0FBQztJQUVELFlBQVk7SUFDRixhQUFhLENBQUMsT0FBZ0I7UUFDcEMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUM7SUFFaEQsQ0FBQztJQUVELFlBQVk7SUFDRixlQUFlLENBQUMsU0FBb0I7UUFDMUMsSUFBRyxTQUFTLFlBQVksZUFBSyxFQUFDO1lBQzFCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDakQ7YUFBTSxJQUFHLFNBQVMsWUFBWSxnQkFBTSxFQUFDO1lBQ2xDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDbEQ7YUFBTSxJQUFHLFNBQVMsWUFBWSxnQkFBTSxFQUFDO1lBQ2xDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDbEQ7YUFBTSxJQUFHLFNBQVMsWUFBWSxtQkFBUyxFQUFDO1lBQ3JDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxlQUFlLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDckQ7SUFDTCxDQUFDO0lBRUQsS0FBSyxDQUFDLFVBQWlCO1FBQ25CLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM3RCxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsR0FBRyxVQUFVLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDM0MsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2hFLENBQUM7Q0FDSjtBQWpPRCxpQ0FpT0M7Ozs7Ozs7O0FDM1BELDRGQUFvRTtBQUdwRTs7R0FFRztBQUNILE1BQXFCLGVBQWU7SUFRaEMsWUFBWSxHQUE2QjtRQUNyQyxJQUFJLENBQUMsZUFBZSxHQUFHLHlCQUFlLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDckQsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7SUFDbkIsQ0FBQztJQUVEOzs7T0FHRztJQUNILFFBQVEsQ0FBQyxLQUFZO1FBQ2pCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0lBQ3ZCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsV0FBVyxDQUFDLEtBQVksRUFBRSxJQUFZO1FBQ3hDLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDMUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxHQUFDLElBQUksRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLEdBQUMsSUFBSSxFQUNoRSxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLENBQUM7SUFDMUMsQ0FBQztJQUVELFVBQVUsQ0FBQyxJQUFVLEVBQUUsTUFBWSxFQUFFLElBQVk7UUFDN0MsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUNqRCxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO1FBQ3BDLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDckIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3RCLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3BGLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDckIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQztJQUN0QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILFVBQVUsQ0FBQyxJQUFVLEVBQUUsSUFBWTtRQUMvQixnQ0FBZ0M7UUFDaEMsSUFBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUM7WUFDbEIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUM5QyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLEdBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsR0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3ZHO1FBRUQsc0RBQXNEO1FBQ3RELElBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFDO1lBQ3hCLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUMzRCxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7WUFDM0MsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxHQUFDLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLEdBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFDLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsQ0FBQztTQUN6RztJQUNMLENBQUM7Q0FDSjtBQTdERCxrQ0E2REM7Ozs7Ozs7O0FDdkVELDRGQUFvRTtBQUdwRSxnRUFBd0M7QUFNeEM7O0dBRUc7QUFDSCxNQUFxQixlQUFlO0lBS2hDLFlBQVksR0FBNkI7UUFDckMsSUFBSSxDQUFDLGVBQWUsR0FBRyx5QkFBZSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ3JELElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO0lBQ25CLENBQUM7SUFFRDs7O09BR0c7SUFDSCxRQUFRLENBQUMsS0FBWTtRQUNqQixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztJQUN2QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsYUFBYSxDQUFDLE9BQWdCO1FBQzFCLElBQUksYUFBYSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDO1FBQ3pDLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxHQUFHLE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUVyRCxJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGtCQUFrQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3BELElBQUksSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDbEQsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUNyQyxJQUFJLFdBQVcsR0FBRyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFFMUQsSUFBRyxPQUFPLENBQUMsT0FBTyxFQUFDO1lBQ2YsSUFBSSxTQUFTLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7WUFDekUsSUFBSSxTQUFTLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7WUFDekUsS0FBSSxJQUFJLEdBQUcsR0FBRyxTQUFTLENBQUMsQ0FBQyxFQUFFLEdBQUcsSUFBSSxTQUFTLENBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxFQUFDO2dCQUNqRCxLQUFJLElBQUksR0FBRyxHQUFHLFNBQVMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUM7b0JBQ2pELGdDQUFnQztvQkFDaEMsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7b0JBRXJDLG1EQUFtRDtvQkFDbkQsTUFBTSxJQUFJLEdBQUcsQ0FBQyxHQUFHLElBQUksRUFBRSxDQUFDLENBQUM7b0JBQ3pCLE1BQU0sT0FBTyxHQUFHLENBQUMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDO29CQUM1QyxJQUFJLEdBQUcsSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDO29CQUVwQix3REFBd0Q7b0JBQ3hELEtBQUksSUFBSSxPQUFPLElBQUksT0FBTyxDQUFDLFdBQVcsRUFBRSxFQUFDO3dCQUNyQyxJQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUM7NEJBQ3JCLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsT0FBTyxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUM7eUJBQzNGO3FCQUNKO2lCQUNKO2FBQ0o7U0FDSjtRQUVELElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxHQUFHLGFBQWEsQ0FBQztJQUN6QyxDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ08sVUFBVSxDQUFDLE9BQWdCLEVBQUUsT0FBZ0IsRUFBRSxTQUFpQixFQUFFLFVBQWtCLEVBQUUsVUFBa0IsRUFBRSxNQUFZLEVBQUUsS0FBVyxFQUFFLElBQVksRUFBRSxPQUFlO1FBQ3hLLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO1FBRWpFLHFDQUFxQztRQUNyQyxJQUFJLFFBQVEsR0FBRyxPQUFPLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDckMsSUFBSSxLQUFLLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUN2QixJQUFJLE1BQU0sR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBRXhCLDhEQUE4RDtRQUM5RCxJQUFJLGFBQWEsR0FBRyxPQUFPLENBQUMscUJBQXFCLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDN0QsSUFBSSxJQUFJLEdBQUcsYUFBYSxDQUFDLENBQUMsQ0FBQTtRQUMxQixJQUFJLEdBQUcsR0FBRyxhQUFhLENBQUMsQ0FBQyxDQUFDO1FBRTFCLHlEQUF5RDtRQUN6RCxJQUFJLGFBQWEsR0FBRyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxFQUFFLFVBQVUsQ0FBQyxDQUFDO1FBRXJFLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsQ0FBQztRQUMzRCxJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLENBQUM7UUFFM0Qsd0RBQXdEO1FBQ3hELElBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7UUFDbkQsSUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztRQUVyRCxJQUFHLE9BQU8sS0FBSyxDQUFDLEVBQUM7WUFDYixJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUM7WUFDZixJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUM7WUFDZixJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUM7WUFDZixJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUM7WUFFZixxQkFBcUI7WUFDckIsSUFBRyxPQUFPLEdBQUcsQ0FBQyxFQUFDO2dCQUNYLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQzthQUNmO1lBRUQscUJBQXFCO1lBQ3JCLElBQUcsT0FBTyxHQUFHLENBQUMsRUFBQztnQkFDWCxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7YUFDZjtZQUVELHlCQUF5QjtZQUN6QixJQUFHLE9BQU8sR0FBRyxDQUFDLEVBQUM7Z0JBQ1gsTUFBTSxHQUFHLE1BQU0sQ0FBQztnQkFDaEIsTUFBTSxHQUFHLE1BQU0sQ0FBQztnQkFDaEIsTUFBTSxHQUFHLENBQUMsQ0FBQztnQkFDWCxNQUFNLEdBQUcsQ0FBQyxDQUFDO2FBQ2Q7WUFFRCxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxHQUFHLFVBQVUsR0FBQyxDQUFDLEVBQUUsTUFBTSxHQUFHLFdBQVcsR0FBQyxDQUFDLENBQUMsQ0FBQztZQUVyRyxrQkFBa0I7WUFDbEIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUNwQixJQUFJLEVBQUUsR0FBRyxFQUNULEtBQUssRUFBRSxNQUFNLEVBQ2IsQ0FBQyxVQUFVLEdBQUMsQ0FBQyxFQUFFLENBQUMsV0FBVyxHQUFDLENBQUMsRUFDN0IsVUFBVSxFQUFFLFdBQVcsQ0FBQyxDQUFDO1lBRTdCLElBQUcsT0FBTyxLQUFLLENBQUMsRUFBQztnQkFDYixJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2FBQzNDO1NBQ0o7YUFBTTtZQUNILGdFQUFnRTtZQUNoRSxrQkFBa0I7WUFDbEIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUNwQixJQUFJLEVBQUUsR0FBRyxFQUNULEtBQUssRUFBRSxNQUFNLEVBQ2IsTUFBTSxFQUFFLE1BQU0sRUFDZCxVQUFVLEVBQUUsV0FBVyxDQUFDLENBQUM7U0FDaEM7SUFDTCxDQUFDO0lBR1Msd0JBQXdCLENBQUMsR0FBc0IsRUFBRSxHQUFZLEVBQUUsR0FBVyxFQUFFLEdBQVc7UUFDN0YsSUFBSSxPQUFPLEdBQVMsR0FBRyxDQUFDLFdBQVcsRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDdEQsSUFBSSxPQUFPLEdBQVMsR0FBRyxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDNUMsT0FBTyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDcEUsQ0FBQztJQUNTLHVCQUF1QixDQUFDLEdBQVksRUFBRSxHQUFZLEVBQUUsR0FBVyxFQUFFLEdBQVc7UUFDbEYsSUFBSSxJQUFJLEdBQVMsR0FBRyxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ25DLElBQUksT0FBTyxHQUFTLEdBQUcsQ0FBQyxpQkFBaUIsRUFBRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLGNBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2xHLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN0QyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUM1QyxPQUFPLE9BQU8sQ0FBQztJQUNuQixDQUFDO0NBQ0o7QUF0SkQsa0NBc0pDOzs7Ozs7OztBQ2xLRCxnRUFBd0M7QUFLeEMsNEZBQW9FO0FBRXBFLHNFQUE4QztBQUU5Qzs7R0FFRztBQUNILE1BQXFCLGlCQUFpQjtJQUtsQyxZQUFZLEdBQTZCO1FBQ3JDLElBQUksQ0FBQyxlQUFlLEdBQUcseUJBQWUsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUNyRCxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztJQUNuQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsUUFBUSxDQUFDLEtBQVk7UUFDakIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7T0FHRztJQUNILFdBQVcsQ0FBQyxLQUFZO1FBQ3BCLHFFQUFxRTtRQUNyRSxLQUFLLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRTFDLDREQUE0RDtRQUM1RCxJQUFJLGFBQWEsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQztRQUVuQywwQ0FBMEM7UUFDaEQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsS0FBSyxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBQ3RDLElBQUksTUFBTSxHQUFHLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFakQsa0RBQWtEO1FBQ2xELElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDO1FBQy9DLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQyx3QkFBd0IsRUFBRSxDQUFDLFlBQVksRUFBRSxDQUFDO1FBQ3JFLElBQUksQ0FBQyxHQUFHLENBQUMsZUFBZSxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUMsQ0FBQyxFQUN4RCxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUM7UUFFakQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDLG9CQUFvQixFQUFFLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDbkUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7UUFDM0MsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDLFdBQVcsQ0FBQztRQUN2QyxJQUFJLENBQUMsR0FBRyxDQUFDLGlCQUFpQixDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUMsQ0FBQyxFQUMxRCxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUM7UUFFakQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDLGtCQUFrQixFQUFFLENBQUM7UUFDaEQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFDekMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxDQUFDO1FBRXBGLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxHQUFHLGFBQWEsQ0FBQztJQUNuQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsWUFBWSxDQUFDLE1BQWM7UUFDdkIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsWUFBWSxDQUFDLE1BQWM7UUFDN0IsNERBQTREO1FBQzVELElBQUksYUFBYSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDO1FBQ3pDLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxHQUFHLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUU5Qyw2QkFBNkI7UUFDN0IsSUFBSSxVQUFVLEdBQUcsSUFBSSxjQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFFNUMsa0JBQWtCO1FBQ3hCLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDbkQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxHQUFDLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxFQUMvQyxVQUFVLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBRXJELHNDQUFzQztRQUN0QyxJQUFJLENBQUMsR0FBRyxtQkFBUyxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7UUFFN0UsZUFBZTtRQUNyQixJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ2hELElBQUksQ0FBQyxHQUFHLENBQUMsZUFBZSxDQUFDLENBQUMsR0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBQyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBQyxDQUFDLEVBQ3hELE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUU3RCxrQkFBa0I7UUFDbEIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEdBQUcsYUFBYSxDQUFDO0lBQ3pDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxlQUFlLENBQUMsU0FBb0I7UUFDaEMsMEJBQTBCO1FBQzFCLElBQUcsU0FBUyxDQUFDLE9BQU8sSUFBSSxTQUFTLENBQUMsYUFBYSxHQUFHLEVBQUUsR0FBRyxFQUFFLEVBQUM7WUFDdEQsU0FBUyxDQUFDLElBQUksSUFBSSxHQUFHLENBQUM7U0FDekI7UUFFRCxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBRTVCLElBQUcsU0FBUyxDQUFDLE9BQU8sRUFBQztZQUNqQixJQUFHLFNBQVMsQ0FBQyxhQUFhLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFBQztnQkFDakMsU0FBUyxDQUFDLElBQUksR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7YUFDM0U7WUFFRCxTQUFTLENBQUMsYUFBYSxJQUFJLENBQUMsQ0FBQztZQUM3QixJQUFHLFNBQVMsQ0FBQyxhQUFhLElBQUksRUFBRSxFQUFDO2dCQUM3QixTQUFTLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQzthQUMvQjtTQUNKO0lBQ0wsQ0FBQztDQUVKO0FBakhELG9DQWlIQzs7Ozs7Ozs7QUN0SEQseUZBQWlFO0FBS2pFOztHQUVHO0FBQ0gsTUFBOEIsZ0JBQWdCO0lBTzFDO1FBQ0ksSUFBSSxDQUFDLGVBQWUsR0FBRyx5QkFBZSxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQ3pELENBQUM7SUFFRDs7O09BR0c7SUFDSCxRQUFRLENBQUMsS0FBWTtRQUNqQixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztJQUN2QixDQUFDO0NBb0RKO0FBckVELG1DQXFFQzs7Ozs7Ozs7QUNsRkQsNkRBQXFDO0FBR3JDLCtEQUF1QztBQUV2QyxvRUFBNEM7QUFDNUMsa0VBQTBDO0FBQzFDLHFGQUE2RDtBQUM3RCxxRUFBNkM7QUFFN0MsbUVBQTJDO0FBQzNDLHNFQUE4QztBQUM5QywyRkFBbUU7QUFDbkUsa0ZBQTBEO0FBQzFELHlGQUFpRTtBQUNqRSxrRkFBMEQ7QUFJMUQsMEVBQWtEO0FBR2xELE1BQXFCLGFBQWMsU0FBUSwwQkFBZ0I7SUFTMUQsZ0JBQWdCLENBQUMsTUFBeUIsRUFBRSxLQUFhLEVBQUUsTUFBYztRQUN4RSxNQUFNLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNmLE1BQU0sQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBRTdCLElBQUksQ0FBQyxTQUFTLEdBQUcsY0FBSSxDQUFDLElBQUksQ0FBQztRQUMzQixJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7UUFDekIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDO1FBRTFCLHdCQUF3QjtRQUNsQixJQUFJLENBQUMsRUFBRSxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFM0MsSUFBSSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxNQUFNLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUVwRCxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQzlCLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDOUIsSUFBSSxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1FBQ2xFLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFeEMsOENBQThDO1FBQzlDLHlCQUFlLENBQUMsV0FBVyxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFdEQsMkNBQTJDO1FBQzNDLElBQUksVUFBVSxHQUFzQixRQUFRLENBQUMsY0FBYyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQzNFLFVBQVUsQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1FBQzFCLElBQUksQ0FBQyxPQUFPLEdBQUcsVUFBVSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUUzQyx5REFBeUQ7UUFDekQsVUFBVSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDM0IsVUFBVSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFFbkIsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDO0lBQ3RCLENBQUM7SUFFRCxNQUFNLENBQUMsVUFBd0IsRUFBRSxRQUFtQixFQUFFLFFBQXNCO1FBQzNFLEtBQUksSUFBSSxJQUFJLElBQUksVUFBVSxFQUFDO1lBQzFCLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDdEI7UUFFRCxRQUFRLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ3RCLElBQUcsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFFBQVEsRUFBRTtnQkFDL0IsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFhLElBQUksQ0FBQyxDQUFDLENBQUE7UUFDakYsQ0FBQyxDQUFDLENBQUM7SUFDSixDQUFDO0lBRUQsS0FBSyxDQUFDLEtBQVk7UUFDakIsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3ZELElBQUksQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBRW5FLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNsRSxDQUFDO0lBRVMsVUFBVSxDQUFDLElBQWdCO1FBQ3BDLGdFQUFnRTtRQUMxRCxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFbEQsa0NBQWtDO1FBQ2xDLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUU1QyxJQUFHLElBQUksQ0FBQyxlQUFlLEVBQUM7WUFDdkIscURBQXFEO1lBQ3JELElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDeEI7YUFBTSxJQUFHLElBQUksWUFBWSxpQkFBTyxFQUFDO1lBQ2pDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDekI7YUFBTSxJQUFHLElBQUksWUFBWSxnQkFBTSxFQUFDO1lBQ2hDLElBQUcsSUFBSSxZQUFZLHdCQUFjLEVBQUM7Z0JBQ2pDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUNoQztpQkFBTTtnQkFDTixJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3hCO1NBQ0Q7YUFBTSxJQUFHLElBQUksWUFBWSxtQkFBUyxFQUFDO1lBQ25DLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDM0I7SUFDRixDQUFDO0lBRVMsWUFBWSxDQUFDLE1BQWM7UUFDcEMsSUFBSSxNQUFNLEdBQUcseUJBQWUsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLHdCQUFjLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDdkUsSUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ2pFLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUNqQyxDQUFDO0lBRVMsb0JBQW9CLENBQUMsTUFBc0I7UUFDcEQsSUFBSSxNQUFNLEdBQUcseUJBQWUsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLHdCQUFjLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDdkUsSUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ2pFLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUNqQyxDQUFDO0lBRVMsYUFBYSxDQUFDLE9BQWdCO1FBRXZDLElBQUcsT0FBTyxZQUFZLGVBQUssRUFBQztZQUMzQixJQUFJLE1BQU0sR0FBRyx5QkFBZSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsd0JBQWMsQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUN0RSxJQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFDbkUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1NBQ2hDO2FBQU0sSUFBRyxPQUFPLFlBQVksY0FBSSxFQUFFO1lBQ2xDLElBQUksTUFBTSxHQUFHLHlCQUFlLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyx3QkFBYyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQ3JFLElBQUksT0FBTyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQztZQUNuRSxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsT0FBTyxDQUFDLENBQUM7U0FDaEM7SUFDRixDQUFDO0lBRVMsYUFBYSxDQUFDLE9BQWdCO1FBQ3ZDLE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBRVMsZUFBZSxDQUFDLFNBQW9CO1FBQzdDLElBQUcsU0FBUyxZQUFZLGVBQUssRUFBQztZQUM3QixJQUFJLE1BQU0sR0FBRyx5QkFBZSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsd0JBQWMsQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUN0RSxJQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFDdkUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBRWhDLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzFJLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3pDLElBQUksV0FBVyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDO1lBQzNDLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxHQUFHLFNBQVMsQ0FBQyxLQUFLLENBQUM7WUFFM0MsY0FBYztZQUNkLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxHQUFHLFNBQVMsQ0FBQyxhQUFhLEVBQUUsQ0FBQztZQUM5QyxJQUFJLE1BQU0sR0FBRyxTQUFTLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ3pELElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1lBQ3hELElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxHQUFHLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1lBQ2pELElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUMsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsQ0FBQztZQUVwRyxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7WUFDakMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztTQUNsRDtJQUNGLENBQUM7SUFFUyxZQUFZLENBQUMsSUFBZ0I7UUFDdEMsSUFBSSxNQUFNLEdBQUcseUJBQWUsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUMvRCxJQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDN0QsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ2pDLENBQUM7SUFFUyxVQUFVLENBQUMsT0FBNEIsRUFBRSxJQUFnQjtRQUNsRSwyQ0FBMkM7UUFDM0MsT0FBTyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO1FBRW5DLDZDQUE2QztRQUM3QyxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDNUIsSUFBSSxRQUFRLEdBQUcsSUFBSSxjQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQzlCLElBQUcsS0FBSyxZQUFZLHVCQUFhLEVBQUM7WUFDakMsUUFBUSxHQUFtQixLQUFNLENBQUMsUUFBUSxDQUFDO1NBQzNDO1FBRUQsT0FBTyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUVwRCxPQUFPLE9BQU8sQ0FBQztJQUNoQixDQUFDO0NBRUQ7QUE3SkQsZ0NBNkpDOzs7Ozs7OztBQ25MRCw0RkFBb0U7QUFFcEU7Ozs7R0FJRztBQUNILE1BQThCLFVBQVU7SUFVdkMsWUFBWSxVQUFrQjtRQUM3QixJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQztRQUM3QixJQUFJLENBQUMsZUFBZSxHQUFHLHlCQUFlLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDdEQsQ0FBQztJQWVEOzs7O09BSUc7SUFDSCxVQUFVLENBQUMsSUFBZ0IsSUFBd0IsT0FBTyxFQUFFLENBQUMsQ0FBQSxDQUFDO0NBQzlEO0FBbENELDZCQWtDQzs7Ozs7Ozs7QUMzQ0QsdUVBQStDO0FBQy9DLG1FQUEyQztBQUkzQywrRkFBdUU7QUFDdkUsc0VBQThDO0FBRTlDLE1BQU07QUFDTixNQUFxQixlQUFnQixTQUFRLHdCQUFjO0lBRTFELFlBQVksVUFBa0I7UUFDN0IsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ2xCLElBQUksQ0FBQyxlQUFlLEdBQUcseUJBQWUsQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUN0RCxDQUFDO0lBRUQsZ0JBQWdCO1FBQ2YsSUFBSSxDQUFDLGVBQWUsR0FBRyxPQUFPLENBQUM7UUFDL0IsSUFBSSxDQUFDLGVBQWUsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0lBQ3pELENBQUM7SUFFRCxNQUFNLENBQUMsRUFBeUIsRUFBRSxPQUE0QjtRQUM3RCxNQUFNLGVBQWUsR0FBRyxPQUFPLENBQUMsZUFBZSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQzFELE1BQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsT0FBTyxFQUFFLENBQUM7UUFFbEQsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDdkUsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBRXBFLEVBQUUsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFdkIsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRXBFLE1BQU0sS0FBSyxHQUFHLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQztRQUUzQyxrQkFBa0I7UUFDbEIsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsWUFBWSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3ZDLEVBQUUsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLFlBQVksRUFBRSxVQUFVLEVBQUUsRUFBRSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBRTNELGFBQWE7UUFDYixNQUFNLFVBQVUsR0FBRyxFQUFFLENBQUMsaUJBQWlCLENBQUMsT0FBTyxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQy9ELEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLENBQUMsR0FBRyxLQUFLLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDO1FBQzdFLEVBQUUsQ0FBQyx1QkFBdUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUV2QyxXQUFXO1FBQ1gsTUFBTSxpQkFBaUIsR0FBRyxFQUFFLENBQUMsa0JBQWtCLENBQUMsT0FBTyxFQUFFLG1CQUFtQixDQUFDLENBQUM7UUFDOUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxpQkFBaUIsRUFBRSxlQUFlLENBQUMsQ0FBQztRQUU1QyxNQUFNLGFBQWEsR0FBRyxFQUFFLENBQUMsa0JBQWtCLENBQUMsT0FBTyxFQUFFLGVBQWUsQ0FBQyxDQUFDO1FBQzVFLEVBQUUsQ0FBQyxVQUFVLENBQUMsYUFBYSxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBRXBDLE1BQU0sU0FBUyxHQUFHLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLEVBQUUsV0FBVyxDQUFDLENBQUM7UUFDOUQsRUFBRSxDQUFDLFNBQVMsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFN0QsNEJBQTRCO1FBQzVCLHFGQUFxRjtRQUNyRixJQUFJLFlBQVksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFdEQsTUFBTSxhQUFhLEdBQUcsRUFBRSxDQUFDLGtCQUFrQixDQUFDLE9BQU8sRUFBRSxlQUFlLENBQUMsQ0FBQztRQUM1RSxFQUFFLENBQUMsU0FBUyxDQUFDLGFBQWEsRUFBRSxPQUFPLENBQUMsV0FBVyxHQUFDLFlBQVksQ0FBQyxDQUFDO1FBRXhELE1BQU0sY0FBYyxHQUFHLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztRQUM5RSxFQUFFLENBQUMsU0FBUyxDQUFDLGNBQWMsRUFBRSxPQUFPLENBQUMsWUFBWSxHQUFDLFlBQVksQ0FBQyxDQUFDO1FBRWhFLCtFQUErRTtRQUMvRSxJQUFJLElBQUksR0FBRyxJQUFJLGNBQUksQ0FBQyxZQUFZLEVBQUUsWUFBWSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUVwRyx3Q0FBd0M7UUFDeEMsTUFBTSxVQUFVLEdBQUcsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsR0FBQyxZQUFZLENBQUM7UUFDaEcsTUFBTSxVQUFVLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxHQUFDLFlBQVksQ0FBQztRQUVqRyxtQ0FBbUM7UUFDbkMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsSUFBSSxZQUFZLENBQUMsQ0FBQyxVQUFVLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3ZFLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUN2QyxJQUFJLGNBQWMsR0FBRyxnQkFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRTlFLDRDQUE0QztRQUM1QyxNQUFNLFdBQVcsR0FBRyxFQUFFLENBQUMsa0JBQWtCLENBQUMsT0FBTyxFQUFFLGFBQWEsQ0FBQyxDQUFDO1FBQ2xFLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLEVBQUUsS0FBSyxFQUFFLGNBQWMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1FBRWxFLGdCQUFnQjtRQUNoQixFQUFFLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILFdBQVcsQ0FBQyxDQUFTLEVBQUUsQ0FBUztRQUMvQixJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFVCxJQUFHLENBQUMsR0FBRyxDQUFDLEVBQUM7WUFDUixDQUFDLEdBQUcsR0FBRyxDQUFDO1lBQ1IsQ0FBQyxHQUFHLENBQUMsR0FBQyxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsQ0FBQztTQUNaO2FBQU07WUFDTixDQUFDLEdBQUcsR0FBRyxDQUFDO1lBQ1IsQ0FBQyxHQUFHLENBQUMsR0FBQyxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsQ0FBQztTQUNaO1FBRUQsT0FBTyxJQUFJLFlBQVksQ0FBQztZQUN2QixDQUFDLENBQUMsRUFBRyxDQUFDO1lBQ04sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ0wsQ0FBQyxFQUFHLENBQUM7WUFDTCxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQ04sQ0FBQyxDQUFDO0lBQ0osQ0FBQztJQUVELFVBQVUsQ0FBQyxJQUFXO1FBQ3JCLElBQUksT0FBTyxHQUF3QjtZQUNsQyxRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVE7WUFDdkIsZUFBZSxFQUFFLElBQUksQ0FBQyx3QkFBd0IsRUFBRTtZQUN2QyxXQUFXLEVBQUUsSUFBSSxDQUFDLG9CQUFvQixFQUFFO1lBQ3hDLFdBQVcsRUFBRSxJQUFJLENBQUMsV0FBVztZQUM3QixZQUFZLEVBQUUsSUFBSSxDQUFDLFlBQVk7WUFDeEMsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO1lBQ2YsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUFRO1NBQ3ZCLENBQUE7UUFFRCxPQUFPLE9BQU8sQ0FBQztJQUNoQixDQUFDO0NBQ0Q7QUFqSEQsa0NBaUhDOzs7Ozs7OztBQ3ZIRCxtRkFBMkQ7QUFDM0QsK0RBQXVDO0FBRXZDLE1BQXFCLGVBQWdCLFNBQVEsb0JBQVU7SUFJdEQsWUFBWSxVQUFrQjtRQUM3QixLQUFLLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDbkIsQ0FBQztJQUVELGdCQUFnQjtRQUNmLElBQUksQ0FBQyxlQUFlLEdBQUcsT0FBTyxDQUFDO1FBQy9CLElBQUksQ0FBQyxlQUFlLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBRUQsTUFBTSxDQUFDLEVBQXlCLEVBQUUsT0FBNEI7UUFDN0QsSUFBSSxRQUFRLEdBQUcsd0JBQWMsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNqRyxJQUFJLEtBQUssR0FBRyx3QkFBYyxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFdkQsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDdkUsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBRXBFLEVBQUUsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFdkIsTUFBTSxVQUFVLEdBQUcsUUFBUSxDQUFDO1FBRTVCLE1BQU0sS0FBSyxHQUFHLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQztRQUUzQyxrQkFBa0I7UUFDbEIsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsWUFBWSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3ZDLEVBQUUsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLFlBQVksRUFBRSxVQUFVLEVBQUUsRUFBRSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBRTNELGFBQWE7UUFDYixNQUFNLFVBQVUsR0FBRyxFQUFFLENBQUMsaUJBQWlCLENBQUMsT0FBTyxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQy9ELEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLENBQUMsR0FBRyxLQUFLLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDO1FBQzdFLEVBQUUsQ0FBQyx1QkFBdUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUV2QyxXQUFXO1FBQ1gsTUFBTSxPQUFPLEdBQUcsRUFBRSxDQUFDLGtCQUFrQixDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQztRQUMxRCxFQUFFLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQztRQUU5QixNQUFNLFdBQVcsR0FBRyxFQUFFLENBQUMsa0JBQWtCLENBQUMsT0FBTyxFQUFFLGFBQWEsQ0FBQyxDQUFDO1FBQ2xFLEVBQUUsQ0FBQyxTQUFTLENBQUMsV0FBVyxFQUFFLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUU3QyxFQUFFLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ2hDLENBQUM7SUFFRCxVQUFVLENBQUMsS0FBWTtRQUN0QixJQUFJLE9BQU8sR0FBd0I7WUFDbEMsUUFBUSxFQUFFLEtBQUssQ0FBQyxRQUFRO1lBQ3hCLEtBQUssRUFBRSxLQUFLLENBQUMsS0FBSztZQUNsQixTQUFTLEVBQUUsS0FBSyxDQUFDLElBQUk7U0FDckIsQ0FBQTtRQUVELE9BQU8sT0FBTyxDQUFDO0lBQ2hCLENBQUM7Q0FDRDtBQXRERCxrQ0FzREM7Ozs7Ozs7O0FDNURELHVFQUErQztBQUMvQywrREFBdUM7QUFFdkMseUhBQXlIO0FBQ3pILE1BQThCLGNBQWUsU0FBUSxvQkFBVTtJQWE5RCxZQUFZLFVBQWtCO1FBQzdCLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUVsQixJQUFJLENBQUMsS0FBSyxHQUFHLGdCQUFNLENBQUMsUUFBUSxDQUFDO1FBQzdCLElBQUksQ0FBQyxRQUFRLEdBQUcsZ0JBQU0sQ0FBQyxRQUFRLENBQUM7UUFDaEMsSUFBSSxDQUFDLFdBQVcsR0FBRyxnQkFBTSxDQUFDLFFBQVEsQ0FBQztJQUNwQyxDQUFDO0NBQ0Q7QUFwQkQsaUNBb0JDOzs7Ozs7OztBQ3hCRCx1RUFBK0M7QUFDL0MsbUVBQTJDO0FBRTNDLCtGQUF1RTtBQUN2RSxzRUFBOEM7QUFFOUMsTUFBTTtBQUNOLE1BQXFCLGNBQWUsU0FBUSx3QkFBYztJQUV6RCxZQUFZLFVBQWtCO1FBQzdCLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUNsQixJQUFJLENBQUMsZUFBZSxHQUFHLHlCQUFlLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDdEQsQ0FBQztJQUVELGdCQUFnQjtRQUNmLElBQUksQ0FBQyxlQUFlLEdBQUcsTUFBTSxDQUFDO1FBQzlCLElBQUksQ0FBQyxlQUFlLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBRUQsTUFBTSxDQUFDLEVBQXlCLEVBQUUsT0FBNEI7UUFDN0QsTUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUV0QyxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUN2RSxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7UUFFcEUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUV2QixNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFcEUsTUFBTSxLQUFLLEdBQUcsVUFBVSxDQUFDLGlCQUFpQixDQUFDO1FBRTNDLGtCQUFrQjtRQUNsQixFQUFFLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxZQUFZLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDdkMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsWUFBWSxFQUFFLFVBQVUsRUFBRSxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUM7UUFFM0QsYUFBYTtRQUNiLE1BQU0sVUFBVSxHQUFHLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLEVBQUUsWUFBWSxDQUFDLENBQUM7UUFDL0QsRUFBRSxDQUFDLG1CQUFtQixDQUFDLFVBQVUsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsQ0FBQyxHQUFHLEtBQUssRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUM7UUFDN0UsRUFBRSxDQUFDLHVCQUF1QixDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRXZDLFdBQVc7UUFDWCxNQUFNLE9BQU8sR0FBRyxFQUFFLENBQUMsa0JBQWtCLENBQUMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBQzFELEVBQUUsQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBRTlCLDRCQUE0QjtRQUM1QixxRkFBcUY7UUFDckYsSUFBSSxZQUFZLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRTVELCtFQUErRTtRQUMvRSxJQUFJLElBQUksR0FBRyxJQUFJLGNBQUksQ0FBQyxZQUFZLEVBQUUsWUFBWSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUVwRyx3Q0FBd0M7UUFDeEMsTUFBTSxVQUFVLEdBQUcsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsR0FBQyxZQUFZLENBQUM7UUFDaEcsTUFBTSxVQUFVLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxHQUFDLFlBQVksQ0FBQztRQUVqRyxtQ0FBbUM7UUFDbkMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsSUFBSSxZQUFZLENBQUMsQ0FBQyxVQUFVLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3ZFLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUN2QyxJQUFJLGNBQWMsR0FBRyxnQkFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRTlFLDRDQUE0QztRQUM1QyxNQUFNLFdBQVcsR0FBRyxFQUFFLENBQUMsa0JBQWtCLENBQUMsT0FBTyxFQUFFLGFBQWEsQ0FBQyxDQUFDO1FBQ2xFLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLEVBQUUsS0FBSyxFQUFFLGNBQWMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1FBRWxFLGdCQUFnQjtRQUNoQixFQUFFLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFHRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O01BMkJFO0lBQ0Y7Ozs7O09BS0c7SUFDSCxXQUFXLENBQUMsQ0FBUyxFQUFFLENBQVM7UUFDL0IsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRVQsSUFBRyxDQUFDLEdBQUcsQ0FBQyxFQUFDO1lBQ1IsQ0FBQyxHQUFHLEdBQUcsQ0FBQztZQUNSLENBQUMsR0FBRyxDQUFDLEdBQUMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUM7U0FDWjthQUFNO1lBQ04sQ0FBQyxHQUFHLEdBQUcsQ0FBQztZQUNSLENBQUMsR0FBRyxDQUFDLEdBQUMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUM7U0FDWjtRQUVELE9BQU8sSUFBSSxZQUFZLENBQUM7WUFDdkIsQ0FBQyxDQUFDLEVBQUcsQ0FBQztZQUNOLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUNMLENBQUMsRUFBRyxDQUFDO1lBQ0wsQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUNOLENBQUMsQ0FBQztJQUNKLENBQUM7SUFFRCxVQUFVLENBQUMsSUFBVTtRQUNwQixJQUFJLE9BQU8sR0FBd0I7WUFDbEMsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUFRO1lBQ3ZCLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSztZQUNqQixJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUk7WUFDZixRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVE7U0FDdkIsQ0FBQTtRQUVELE9BQU8sT0FBTyxDQUFDO0lBQ2hCLENBQUM7Q0FDRDtBQTlIRCxpQ0E4SEM7Ozs7Ozs7O0FDcklELHVFQUErQztBQUMvQyxtRUFBMkM7QUFFM0MsMkZBQW1FO0FBRW5FLCtGQUF1RTtBQUN2RSxzRUFBOEM7QUFFOUMsZ0RBQWdEO0FBQ2hELE1BQXFCLGdCQUFpQixTQUFRLHdCQUFjO0lBQzNELFlBQVksVUFBa0I7UUFDN0IsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ2xCLElBQUksQ0FBQyxlQUFlLEdBQUcseUJBQWUsQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUN0RCxDQUFDO0lBRUQsZ0JBQWdCO1FBQ2YsSUFBSSxDQUFDLGVBQWUsR0FBRyxRQUFRLENBQUM7UUFDaEMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0lBQ3pELENBQUM7SUFFRCxNQUFNLENBQUMsRUFBeUIsRUFBRSxPQUE0QjtRQUM3RCxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUN2RSxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7UUFDcEUsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRWxFLEVBQUUsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFdkIsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFbkYsTUFBTSxLQUFLLEdBQUcsVUFBVSxDQUFDLGlCQUFpQixDQUFDO1FBRTNDLGtCQUFrQjtRQUNsQixFQUFFLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxZQUFZLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDdkMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsWUFBWSxFQUFFLFVBQVUsRUFBRSxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUM7UUFFM0QsYUFBYTtRQUNiLE1BQU0sVUFBVSxHQUFHLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLEVBQUUsWUFBWSxDQUFDLENBQUM7UUFDL0QsRUFBRSxDQUFDLG1CQUFtQixDQUFDLFVBQVUsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsQ0FBQyxHQUFHLEtBQUssRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUM7UUFDN0UsRUFBRSxDQUFDLHVCQUF1QixDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRXZDLE1BQU0sVUFBVSxHQUFHLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLEVBQUUsWUFBWSxDQUFDLENBQUM7UUFDL0QsRUFBRSxDQUFDLG1CQUFtQixDQUFDLFVBQVUsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsQ0FBQyxHQUFHLEtBQUssRUFBRSxDQUFDLEdBQUMsS0FBSyxDQUFDLENBQUM7UUFDM0UsRUFBRSxDQUFDLHVCQUF1QixDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRXZDLFdBQVc7UUFDWCw0QkFBNEI7UUFDNUIscUZBQXFGO1FBQ3JGLElBQUksWUFBWSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUU1RCwrRUFBK0U7UUFDL0UsSUFBSSxJQUFJLEdBQUcsSUFBSSxjQUFJLENBQUMsWUFBWSxFQUFFLFlBQVksQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFcEcsd0NBQXdDO1FBQ3hDLE1BQU0sVUFBVSxHQUFHLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLEdBQUMsWUFBWSxDQUFDO1FBQ2hHLE1BQU0sVUFBVSxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsR0FBQyxZQUFZLENBQUM7UUFFakcsbUNBQW1DO1FBQ25DLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLElBQUksWUFBWSxDQUFDLENBQUMsVUFBVSxFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN2RSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN2QixJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDdkMsSUFBSSxjQUFjLEdBQUcsZ0JBQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUU5RSw0Q0FBNEM7UUFDNUMsTUFBTSxXQUFXLEdBQUcsRUFBRSxDQUFDLGtCQUFrQixDQUFDLE9BQU8sRUFBRSxhQUFhLENBQUMsQ0FBQztRQUNsRSxFQUFFLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxFQUFFLEtBQUssRUFBRSxjQUFjLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztRQUVsRSxvREFBb0Q7UUFDcEQsTUFBTSxTQUFTLEdBQUcsRUFBRSxDQUFDLGtCQUFrQixDQUFDLE9BQU8sRUFBRSxXQUFXLENBQUMsQ0FBQztRQUM5RCxFQUFFLENBQUMsU0FBUyxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUVqQyxtQkFBbUI7UUFDbkIsTUFBTSxVQUFVLEdBQUcsRUFBRSxDQUFDLGtCQUFrQixDQUFDLE9BQU8sRUFBRSxZQUFZLENBQUMsQ0FBQztRQUNoRSxFQUFFLENBQUMsVUFBVSxDQUFDLFVBQVUsRUFBRSxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFNUMsbUJBQW1CO1FBQ25CLE1BQU0sVUFBVSxHQUFHLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLEVBQUUsWUFBWSxDQUFDLENBQUM7UUFDaEUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxVQUFVLEVBQUUsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRTVDLGdCQUFnQjtRQUNoQixFQUFFLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILFdBQVcsQ0FBQyxDQUFTLEVBQUUsQ0FBUyxFQUFFLEtBQW1CO1FBQ3BELElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUVULElBQUcsQ0FBQyxHQUFHLENBQUMsRUFBQztZQUNSLENBQUMsR0FBRyxHQUFHLENBQUM7WUFDUixDQUFDLEdBQUcsQ0FBQyxHQUFDLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ1o7YUFBTTtZQUNOLENBQUMsR0FBRyxHQUFHLENBQUM7WUFDUixDQUFDLEdBQUcsQ0FBQyxHQUFDLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ1o7UUFFRCxzQ0FBc0M7UUFDdEMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNkLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFZCxPQUFPLElBQUksWUFBWSxDQUFDO1lBQ3ZCLENBQUMsQ0FBQyxFQUFHLENBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRztZQUNoQixDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRztZQUNmLENBQUMsRUFBRyxDQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUc7WUFDZixDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUc7U0FDaEIsQ0FBQyxDQUFDO0lBQ0osQ0FBQztJQUVELFVBQVUsQ0FBQyxNQUFjO1FBQ3hCLElBQUksUUFBUSxDQUFDO1FBQ2IsSUFBSSxRQUFRLENBQUM7UUFFYixJQUFHLE1BQU0sWUFBWSx3QkFBYyxFQUFDO1lBQ25DLElBQUksY0FBYyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsMkJBQTJCLEVBQUUsQ0FBQztZQUNwRSxJQUFJLE1BQU0sR0FBRyxNQUFNLENBQUMsa0JBQWtCLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDdkQsUUFBUSxHQUFHLElBQUksWUFBWSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNsSCxRQUFRLEdBQUcsSUFBSSxZQUFZLENBQUMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNoRTthQUFNO1lBQ04sUUFBUSxHQUFHLElBQUksWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDcEMsUUFBUSxHQUFHLElBQUksWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDcEM7UUFFRCxJQUFJLE9BQU8sR0FBd0I7WUFDbEMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxRQUFRO1lBQ3pCLFFBQVEsRUFBRSxNQUFNLENBQUMsUUFBUTtZQUN6QixJQUFJLEVBQUUsTUFBTSxDQUFDLElBQUk7WUFDakIsS0FBSyxFQUFFLE1BQU0sQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFO1lBQzdCLFFBQVEsRUFBRSxNQUFNLENBQUMsT0FBTztZQUN4QixRQUFRO1lBQ1IsUUFBUTtTQUNSLENBQUE7UUFFRCxPQUFPLE9BQU8sQ0FBQztJQUNoQixDQUFDO0NBQ0Q7QUFoSUQsbUNBZ0lDOzs7Ozs7OztBQ3pJRCx1RUFBK0M7QUFDL0MsMkVBQW1EO0FBRW5ELHVFQUErQztBQUMvQyx5RUFBaUQ7QUFFakQsK0ZBQXVFO0FBRXZFOzs7Ozs7R0FNRztBQUNILE1BQXFCLGVBQWU7SUFtRmhDO1FBQ0ksSUFBSSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7UUFDckIsSUFBSSxDQUFDLFVBQVUsR0FBRyxLQUFLLENBQUM7UUFFeEIsSUFBSSxDQUFDLHFCQUFxQixHQUFHLENBQUMsQ0FBQztRQUMvQixJQUFJLENBQUMscUJBQXFCLEdBQUcsQ0FBQyxDQUFDO1FBQy9CLElBQUksQ0FBQywwQkFBMEIsR0FBRyxJQUFJLGVBQUssRUFBRSxDQUFDO1FBQzlDLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxhQUFHLEVBQUUsQ0FBQztRQUV4QixJQUFJLENBQUMsMkJBQTJCLEdBQUcsQ0FBQyxDQUFDO1FBQ3JDLElBQUksQ0FBQywyQkFBMkIsR0FBRyxDQUFDLENBQUM7UUFDckMsSUFBSSxDQUFDLGdDQUFnQyxHQUFHLElBQUksZUFBSyxFQUFFLENBQUM7UUFDcEQsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLGFBQUcsRUFBRSxDQUFDO1FBRTlCLElBQUksQ0FBQyx1QkFBdUIsR0FBRyxDQUFDLENBQUM7UUFDakMsSUFBSSxDQUFDLHVCQUF1QixHQUFHLENBQUMsQ0FBQztRQUNqQyxJQUFJLENBQUMsNEJBQTRCLEdBQUcsSUFBSSxlQUFLLEVBQUUsQ0FBQztRQUNoRCxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksYUFBRyxFQUFFLENBQUM7UUFFMUIsSUFBSSxDQUFDLG9CQUFvQixHQUFHLENBQUMsQ0FBQztRQUM5QixJQUFJLENBQUMsb0JBQW9CLEdBQUcsQ0FBQyxDQUFDO1FBQzlCLElBQUksQ0FBQywwQkFBMEIsR0FBRyxJQUFJLGVBQUssRUFBRSxDQUFDO1FBQzlDLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxhQUFHLEVBQUUsQ0FBQztRQUU5QixJQUFJLENBQUMsbUJBQW1CLEdBQUcsQ0FBQyxDQUFDO1FBQzdCLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxDQUFDLENBQUM7UUFDN0IsSUFBSSxDQUFDLHlCQUF5QixHQUFHLElBQUksZUFBSyxFQUFFLENBQUM7UUFDN0MsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLGFBQUcsRUFBRSxDQUFDO1FBRTdCLElBQUksQ0FBQyxnQ0FBZ0MsR0FBRyxDQUFDLENBQUM7UUFDMUMsSUFBSSxDQUFDLGdDQUFnQyxHQUFHLENBQUMsQ0FBQztRQUMxQyxJQUFJLENBQUMsOEJBQThCLEdBQUcsSUFBSSxlQUFLLEVBQUUsQ0FBQztRQUVsRCxJQUFJLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxhQUFHLEVBQUUsQ0FBQztRQUVuQyxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksYUFBRyxFQUFFLENBQUM7UUFDN0IsSUFBSSxDQUFDLGdCQUFnQixHQUFHLENBQUMsQ0FBQztRQUMxQixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksYUFBRyxFQUFFLENBQUM7UUFFNUIsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7UUFDckMsSUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLEtBQUssRUFBRSxDQUFDO0lBQ3ZDLENBQUM7SUFBQSxDQUFDO0lBRUYsZ0dBQWdHO0lBQ2hHOzs7T0FHRztJQUNILE1BQU0sQ0FBQyxXQUFXO1FBQ2QsSUFBRyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUM7WUFDZCxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksZUFBZSxFQUFFLENBQUM7U0FDekM7UUFFRCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7SUFDekIsQ0FBQztJQUVELHNHQUFzRztJQUN0Rzs7OztPQUlHO0lBQ0ksUUFBUSxDQUFDLElBQWEsRUFBRSxFQUF5QjtRQUNwRCxJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQztRQUUzQixJQUFHLElBQUksQ0FBQyxjQUFjLEVBQUM7WUFDbkIsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUM7U0FDaEI7SUFDTCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLEtBQUssQ0FBQyxHQUFXLEVBQUUsSUFBWTtRQUNsQyxJQUFJLENBQUMsMEJBQTBCLENBQUMsT0FBTyxDQUFDLEVBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFDLENBQUMsQ0FBQztJQUNwRSxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksU0FBUyxDQUFDLEdBQVc7UUFDeEIsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLEVBQUUsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQy9DLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksUUFBUSxDQUFDLEdBQVc7UUFDdkIsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDakMsSUFBRyxLQUFLLEtBQUssU0FBUyxFQUFDO1lBQ25CLE1BQU0sMENBQTBDLEdBQUcsR0FBRyxDQUFBO1NBQ3pEO1FBQ0QsT0FBTyxLQUFLLENBQUM7SUFDakIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxXQUFXLENBQUMsR0FBVyxFQUFFLElBQVk7UUFDeEMsSUFBSSxDQUFDLGdDQUFnQyxDQUFDLE9BQU8sQ0FBQyxFQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBQyxDQUFDLENBQUM7SUFDMUUsQ0FBQztJQUVEOzs7T0FHRztJQUNJLGVBQWUsQ0FBQyxHQUFXO1FBQzlCLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxFQUFFLFlBQVksQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUNyRCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLGNBQWMsQ0FBQyxHQUFXO1FBQzdCLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDdEMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxLQUFLLENBQUMsR0FBVyxFQUFFLElBQVk7UUFDbEMsSUFBSSxDQUFDLDBCQUEwQixDQUFDLE9BQU8sQ0FBQyxFQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBQyxDQUFDLENBQUM7SUFDcEUsQ0FBQztJQUVEOzs7T0FHRztJQUNLLFNBQVMsQ0FBQyxHQUFXO1FBQ3pCLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxFQUFFLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUMvQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLFFBQVEsQ0FBQyxHQUFXO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDdEMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxPQUFPLENBQUMsR0FBVyxFQUFFLElBQVk7UUFDcEMsSUFBSSxDQUFDLDRCQUE0QixDQUFDLE9BQU8sQ0FBQyxFQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBQyxDQUFDLENBQUM7SUFDdEUsQ0FBQztJQUVEOzs7T0FHRztJQUNLLFdBQVcsQ0FBQyxHQUFXO1FBQzNCLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxFQUFFLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNqRCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLFVBQVUsQ0FBQyxHQUFXO1FBQ3pCLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDbEMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxNQUFNLENBQUMsR0FBVyxFQUFFLElBQVk7UUFDbkMsSUFBSSxDQUFDLHlCQUF5QixDQUFDLE9BQU8sQ0FBQyxFQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBQyxDQUFDLENBQUM7SUFDbkUsQ0FBQztJQUVEOzs7T0FHRztJQUNLLFVBQVUsQ0FBQyxHQUFXO1FBQzFCLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxFQUFFLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM5QyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLFNBQVMsQ0FBQyxHQUFXO1FBQ3hCLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVELG9HQUFvRztJQUNwRzs7O09BR0c7SUFDSCxzQkFBc0IsQ0FBQyxRQUFrQjtRQUNyQyxJQUFJLENBQUMsb0JBQW9CLEdBQUcsQ0FBQyxDQUFDO1FBRTlCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO1FBRXBCLG1IQUFtSDtRQUNuSCxJQUFJLENBQUMscUJBQXFCLENBQUMsR0FBRyxFQUFFO1lBQzVCLE9BQU8sQ0FBQyxHQUFHLENBQUMsaUJBQWlCLENBQUMsQ0FBQztZQUMvQixJQUFJLENBQUMseUJBQXlCLENBQUMsR0FBRyxFQUFFO2dCQUNoQyxPQUFPLENBQUMsR0FBRyxDQUFDLHFCQUFxQixDQUFDLENBQUM7Z0JBQ25DLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxHQUFHLEVBQUU7b0JBQzFCLE9BQU8sQ0FBQyxHQUFHLENBQUMsZUFBZSxDQUFDLENBQUM7b0JBQzdCLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLEVBQUU7d0JBQ3pCLE9BQU8sQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLENBQUM7d0JBQzVCLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxHQUFHLEVBQUU7NEJBQzNCLE9BQU8sQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsQ0FBQzs0QkFFOUIsSUFBRyxJQUFJLENBQUMsY0FBYyxFQUFDO2dDQUNuQixJQUFJLENBQUMsdUJBQXVCLENBQUMsR0FBRyxFQUFFO29DQUM5QixPQUFPLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLENBQUM7b0NBQzlCLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUM7Z0NBQ2pDLENBQUMsQ0FBQyxDQUFDOzZCQUNOO2lDQUFNO2dDQUNILElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUM7NkJBQ2hDO3dCQUNMLENBQUMsQ0FBQyxDQUFBO29CQUNOLENBQUMsQ0FBQyxDQUFDO2dCQUNQLENBQUMsQ0FBQyxDQUFDO1lBQ1AsQ0FBQyxDQUFDLENBQUM7UUFDUCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFTyxhQUFhLENBQUMsUUFBa0I7UUFDcEMsZUFBZTtRQUNmLElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1FBQ3JCLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDO1FBQ3ZCLFFBQVEsRUFBRSxDQUFDO0lBQ2YsQ0FBQztJQUVELHNHQUFzRztJQUU5RixZQUFZLENBQUMsR0FBVyxFQUFFLElBQWtCO1FBQ2hELE9BQU8sQ0FBQyxHQUFHLENBQUMsa0JBQWtCLENBQUMsQ0FBQztRQUNoQyxLQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBQztZQUNsRCxJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDekMsSUFBRyxRQUFRLENBQUMsR0FBRyxLQUFLLEdBQUcsSUFBSSxRQUFRLENBQUMsWUFBWSxLQUFLLElBQUksRUFBQztnQkFDdEQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsR0FBRyxHQUFHLEdBQUcsV0FBVyxHQUFHLElBQUksR0FBRyxZQUFZLENBQUMsQ0FBQztnQkFDekUsSUFBSSxjQUFjLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7Z0JBQ3pELElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLEdBQUcsY0FBYyxDQUFDLENBQUM7Z0JBQzdDLE9BQU87YUFDVjtTQUNKO0lBQ0wsQ0FBQztJQUVEOztPQUVHO0lBQ0gsa0JBQWtCO1FBQ2QsSUFBSSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7UUFDckIsSUFBSSxDQUFDLFVBQVUsR0FBRyxLQUFLLENBQUM7UUFFeEIsS0FBSSxJQUFJLFFBQVEsSUFBSSxJQUFJLENBQUMsaUJBQWlCLEVBQUM7WUFDdkMsc0JBQXNCO1lBQ3RCLElBQUksQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDakM7SUFDTCxDQUFDO0lBRU8sY0FBYyxDQUFDLFFBQTJCO1FBQzlDLDZCQUE2QjtRQUM3QixRQUFPLFFBQVEsQ0FBQyxZQUFZLEVBQUM7WUFDekIsS0FBSyxZQUFZLENBQUMsS0FBSztnQkFDbkIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUNqQyxJQUFHLElBQUksQ0FBQyxjQUFjLEVBQUM7b0JBQ25CLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQztpQkFDekM7Z0JBQ0QsTUFBTTtZQUNWLEtBQUssWUFBWSxDQUFDLE9BQU87Z0JBQ3JCLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDbkMsTUFBTTtZQUNWLEtBQUssWUFBWSxDQUFDLFdBQVc7Z0JBQ3pCLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDdkMsTUFBTTtZQUNWLEtBQUssWUFBWSxDQUFDLEtBQUs7Z0JBQ25CLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDdkMsTUFBTTtZQUNWLEtBQUssWUFBWSxDQUFDLElBQUk7Z0JBQ2xCLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDdEMsTUFBTTtZQUNWOzs7d0JBR1k7U0FDZjtRQUVELDBCQUEwQjtRQUMxQixLQUFJLElBQUksVUFBVSxJQUFJLFFBQVEsQ0FBQyxZQUFZLEVBQUM7WUFDeEMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsQ0FBQztTQUNuQztJQUNMLENBQUM7SUFFRCxxR0FBcUc7SUFDckc7OztPQUdHO0lBQ0sscUJBQXFCLENBQUMsZUFBeUI7UUFDbkQsSUFBSSxDQUFDLHVCQUF1QixHQUFHLElBQUksQ0FBQyw0QkFBNEIsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUMzRSxJQUFJLENBQUMsdUJBQXVCLEdBQUcsQ0FBQyxDQUFDO1FBRWpDLHNDQUFzQztRQUN0QyxJQUFHLElBQUksQ0FBQyx1QkFBdUIsS0FBSyxDQUFDLEVBQUM7WUFDbEMsZUFBZSxFQUFFLENBQUM7WUFDbEIsT0FBTztTQUNWO1FBRUQsT0FBTSxJQUFJLENBQUMsNEJBQTRCLENBQUMsUUFBUSxFQUFFLEVBQUM7WUFDL0MsSUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDLDRCQUE0QixDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQzFELElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxPQUFPLENBQUMsSUFBSSxFQUFFLGVBQWUsQ0FBQyxDQUFDO1NBQ2hFO0lBQ0wsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ssV0FBVyxDQUFDLEdBQVcsRUFBRSxpQkFBeUIsRUFBRSxjQUF3QjtRQUNoRixJQUFJLENBQUMsWUFBWSxDQUFDLGlCQUFpQixFQUFFLENBQUMsUUFBZ0IsRUFBRSxFQUFFO1lBQ3RELElBQUksYUFBYSxHQUFxQixJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBRTNELGdFQUFnRTtZQUNoRSxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsYUFBYSxDQUFDLENBQUM7WUFDdEMsSUFBSSxRQUFRLEdBQUcsSUFBSSxpQkFBaUIsQ0FBQyxHQUFHLEVBQUUsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBRWhFLGlGQUFpRjtZQUNqRixLQUFJLElBQUksT0FBTyxJQUFJLGFBQWEsQ0FBQyxRQUFRLEVBQUM7Z0JBQ3RDLElBQUcsT0FBTyxDQUFDLEtBQUssRUFBQztvQkFDYixJQUFJLEdBQUcsR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDO29CQUN4QixJQUFJLElBQUksR0FBRyxxQkFBVyxDQUFDLG1CQUFtQixDQUFDLGlCQUFpQixDQUFDLEdBQUcsR0FBRyxDQUFDO29CQUNwRSxJQUFJLENBQUMsMEJBQTBCLENBQUMsT0FBTyxDQUFDLEVBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLFlBQVksRUFBRSxJQUFJLEVBQUMsQ0FBQyxDQUFDO29CQUVwRixnREFBZ0Q7b0JBQ2hELFFBQVEsQ0FBQyxhQUFhLENBQUMsSUFBSSxpQkFBaUIsQ0FBQyxHQUFHLEVBQUUsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7aUJBQzFFO3FCQUFNLElBQUcsT0FBTyxDQUFDLEtBQUssRUFBQztvQkFDcEIsS0FBSSxJQUFJLElBQUksSUFBSSxPQUFPLENBQUMsS0FBSyxFQUFDO3dCQUMxQixJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO3dCQUNyQixJQUFJLElBQUksR0FBRyxxQkFBVyxDQUFDLG1CQUFtQixDQUFDLGlCQUFpQixDQUFDLEdBQUcsR0FBRyxDQUFDO3dCQUNwRSxJQUFJLENBQUMsMEJBQTBCLENBQUMsT0FBTyxDQUFDLEVBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLFlBQVksRUFBRSxJQUFJLEVBQUMsQ0FBQyxDQUFDO3dCQUVwRixnREFBZ0Q7d0JBQ2hELFFBQVEsQ0FBQyxhQUFhLENBQUMsSUFBSSxpQkFBaUIsQ0FBQyxHQUFHLEVBQUUsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7cUJBQzFFO2lCQUNKO2FBQ0o7WUFFRCwrREFBK0Q7WUFDL0QsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUV0QyxpQkFBaUI7WUFDakIsSUFBSSxDQUFDLG9CQUFvQixDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQzlDLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVEOzs7T0FHRztJQUNLLG9CQUFvQixDQUFDLFFBQWtCO1FBQzNDLElBQUksQ0FBQyx1QkFBdUIsSUFBSSxDQUFDLENBQUM7UUFFbEMsSUFBRyxJQUFJLENBQUMsdUJBQXVCLEtBQUssSUFBSSxDQUFDLHVCQUF1QixFQUFDO1lBQzdELDhCQUE4QjtZQUM5QixRQUFRLEVBQUUsQ0FBQztTQUNkO0lBQ0wsQ0FBQztJQUVEOzs7T0FHRztJQUNLLHlCQUF5QixDQUFDLGVBQXlCO1FBQ3ZELElBQUksQ0FBQywyQkFBMkIsR0FBRyxJQUFJLENBQUMsZ0NBQWdDLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDbkYsSUFBSSxDQUFDLDJCQUEyQixHQUFHLENBQUMsQ0FBQztRQUVyQyxzQ0FBc0M7UUFDdEMsSUFBRyxJQUFJLENBQUMsMkJBQTJCLEtBQUssQ0FBQyxFQUFDO1lBQ3RDLGVBQWUsRUFBRSxDQUFDO1lBQ2xCLE9BQU87U0FDVjtRQUVELE9BQU0sSUFBSSxDQUFDLGdDQUFnQyxDQUFDLFFBQVEsRUFBRSxFQUFDO1lBQ25ELElBQUksV0FBVyxHQUFHLElBQUksQ0FBQyxnQ0FBZ0MsQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUNsRSxJQUFJLENBQUMsZUFBZSxDQUFDLFdBQVcsQ0FBQyxHQUFHLEVBQUUsV0FBVyxDQUFDLElBQUksRUFBRSxlQUFlLENBQUMsQ0FBQztTQUM1RTtJQUNMLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNLLGVBQWUsQ0FBQyxHQUFXLEVBQUUscUJBQTZCLEVBQUUsY0FBd0I7UUFDeEYsSUFBSSxDQUFDLFlBQVksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLFFBQWdCLEVBQUUsRUFBRTtZQUMxRCxJQUFJLFdBQVcsR0FBZ0IsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUVwRCxnRUFBZ0U7WUFDaEUsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1lBRXhDLElBQUksUUFBUSxHQUFHLElBQUksaUJBQWlCLENBQUMsR0FBRyxFQUFFLFlBQVksQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUVwRSxzRUFBc0U7WUFDdEUsSUFBSSxJQUFJLEdBQUcscUJBQVcsQ0FBQyxtQkFBbUIsQ0FBQyxxQkFBcUIsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxnQkFBZ0IsQ0FBQztZQUNqRyxJQUFJLENBQUMsMEJBQTBCLENBQUMsT0FBTyxDQUFDLEVBQUMsR0FBRyxFQUFFLFdBQVcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxZQUFZLEVBQUUsSUFBSSxFQUFDLENBQUMsQ0FBQztZQUVqRyxRQUFRLENBQUMsYUFBYSxDQUFDLElBQUksaUJBQWlCLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRSxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUNwRixJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBRXRDLGlCQUFpQjtZQUNqQixJQUFJLENBQUMsd0JBQXdCLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDbEQsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ssd0JBQXdCLENBQUMsUUFBa0I7UUFDL0MsSUFBSSxDQUFDLDJCQUEyQixJQUFJLENBQUMsQ0FBQztRQUV0QyxJQUFHLElBQUksQ0FBQywyQkFBMkIsS0FBSyxJQUFJLENBQUMsMkJBQTJCLEVBQUM7WUFDckUsa0NBQWtDO1lBQ2xDLFFBQVEsRUFBRSxDQUFDO1NBQ2Q7SUFDTCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ssbUJBQW1CLENBQUMsZUFBeUI7UUFDakQsSUFBSSxDQUFDLHFCQUFxQixHQUFHLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUN2RSxJQUFJLENBQUMscUJBQXFCLEdBQUcsQ0FBQyxDQUFDO1FBRS9CLHNDQUFzQztRQUN0QyxJQUFHLElBQUksQ0FBQyxxQkFBcUIsS0FBSyxDQUFDLEVBQUM7WUFDaEMsZUFBZSxFQUFFLENBQUM7WUFDbEIsT0FBTztTQUNWO1FBRUQsT0FBTSxJQUFJLENBQUMsMEJBQTBCLENBQUMsUUFBUSxFQUFFLEVBQUM7WUFDN0MsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLDBCQUEwQixDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ3RELElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxZQUFZLEVBQUUsZUFBZSxDQUFDLENBQUM7U0FDOUU7SUFDTCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxTQUFTLENBQUMsR0FBVyxFQUFFLElBQVksRUFBRSxZQUFxQixFQUFFLGNBQXdCO1FBQ3ZGLElBQUksS0FBSyxHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7UUFFeEIsS0FBSyxDQUFDLE1BQU0sR0FBRyxHQUFHLEVBQUU7WUFDaEIsdUJBQXVCO1lBQ3ZCLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztZQUU1Qiw0RkFBNEY7WUFDNUYsSUFBRyxDQUFDLFlBQVksRUFBQztnQkFDYixJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLElBQUksaUJBQWlCLENBQUMsR0FBRyxFQUFFLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO2FBQy9FO1lBRUQsdUNBQXVDO1lBQ3ZDLElBQUcsSUFBSSxDQUFDLGNBQWMsRUFBQztnQkFDbkIsSUFBSSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQzthQUN2QztZQUVELG9CQUFvQjtZQUNwQixJQUFJLENBQUMsa0JBQWtCLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDNUMsQ0FBQyxDQUFBO1FBRUQsS0FBSyxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUM7SUFDckIsQ0FBQztJQUVEOzs7T0FHRztJQUNLLGtCQUFrQixDQUFDLFFBQWtCO1FBQ3pDLElBQUksQ0FBQyxxQkFBcUIsSUFBSSxDQUFDLENBQUM7UUFFaEMsSUFBRyxJQUFJLENBQUMscUJBQXFCLEtBQUssSUFBSSxDQUFDLHFCQUFxQixFQUFFO1lBQzFELDRCQUE0QjtZQUM1QixRQUFRLEVBQUUsQ0FBQztTQUNkO0lBQ0wsQ0FBQztJQUVEOzs7T0FHRztJQUNLLGtCQUFrQixDQUFDLGVBQXlCO1FBQ2hELElBQUksQ0FBQyxvQkFBb0IsR0FBRyxJQUFJLENBQUMsMEJBQTBCLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDdEUsSUFBSSxDQUFDLG9CQUFvQixHQUFHLENBQUMsQ0FBQztRQUU5QixzQ0FBc0M7UUFDdEMsSUFBRyxJQUFJLENBQUMsb0JBQW9CLEtBQUssQ0FBQyxFQUFDO1lBQy9CLGVBQWUsRUFBRSxDQUFDO1lBQ2xCLE9BQU87U0FDVjtRQUVELE9BQU0sSUFBSSxDQUFDLDBCQUEwQixDQUFDLFFBQVEsRUFBRSxFQUFDO1lBQzdDLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUN0RCxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLElBQUksRUFBRSxlQUFlLENBQUMsQ0FBQztTQUMxRDtJQUNMLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNLLFNBQVMsQ0FBQyxHQUFXLEVBQUUsSUFBWSxFQUFFLGNBQXdCO1FBQ2pFLElBQUksUUFBUSxHQUFHLHNCQUFZLENBQUMsV0FBVyxFQUFFLENBQUMsZUFBZSxFQUFFLENBQUM7UUFFNUQsSUFBSSxPQUFPLEdBQUcsSUFBSSxjQUFjLEVBQUUsQ0FBQztRQUNuQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDaEMsT0FBTyxDQUFDLFlBQVksR0FBRyxhQUFhLENBQUM7UUFFckMsT0FBTyxDQUFDLE1BQU0sR0FBRyxHQUFHLEVBQUU7WUFDbEIsUUFBUSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLENBQUMsTUFBTSxFQUFFLEVBQUU7Z0JBQ2xELCtCQUErQjtnQkFDL0IsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFDO2dCQUNuQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLElBQUksaUJBQWlCLENBQUMsR0FBRyxFQUFFLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO2dCQUU1RSx1QkFBdUI7Z0JBQ3ZCLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxjQUFjLENBQUMsQ0FBQztZQUM1QyxDQUFDLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRTtnQkFDVCxNQUFNLHFCQUFxQixDQUFDO1lBQ2hDLENBQUMsQ0FBQyxDQUFDO1FBQ1AsQ0FBQyxDQUFBO1FBQ0QsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ25CLENBQUM7SUFFRDs7O09BR0c7SUFDSyxrQkFBa0IsQ0FBQyxRQUFrQjtRQUN6QyxJQUFJLENBQUMsb0JBQW9CLElBQUksQ0FBQyxDQUFDO1FBRS9CLElBQUcsSUFBSSxDQUFDLG9CQUFvQixLQUFLLElBQUksQ0FBQyxvQkFBb0IsRUFBQztZQUN2RCwyQkFBMkI7WUFDM0IsUUFBUSxFQUFFLENBQUM7U0FDZDtJQUNMLENBQUM7SUFFRDs7O09BR0c7SUFDSyxvQkFBb0IsQ0FBQyxlQUF5QjtRQUNsRCxJQUFJLENBQUMsbUJBQW1CLEdBQUcsSUFBSSxDQUFDLHlCQUF5QixDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ3BFLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxDQUFDLENBQUM7UUFFN0Isc0NBQXNDO1FBQ3RDLElBQUcsSUFBSSxDQUFDLG1CQUFtQixLQUFLLENBQUMsRUFBQztZQUM5QixlQUFlLEVBQUUsQ0FBQztZQUNsQixPQUFPO1NBQ1Y7UUFFRCxPQUFNLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxRQUFRLEVBQUUsRUFBQztZQUM1QyxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMseUJBQXlCLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDbkQsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxJQUFJLEVBQUUsZUFBZSxDQUFDLENBQUM7U0FDdkQ7SUFDTCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxVQUFVLENBQUMsR0FBVyxFQUFFLElBQVksRUFBRSxjQUF3QjtRQUNqRSxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxDQUFDLFFBQWdCLEVBQUUsRUFBRTtZQUN6QyxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQy9CLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztZQUUvQixJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLElBQUksaUJBQWlCLENBQUMsR0FBRyxFQUFFLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBRTNFLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUM3QyxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFRDs7O09BR0c7SUFDSyxtQkFBbUIsQ0FBQyxRQUFrQjtRQUMxQyxJQUFJLENBQUMsbUJBQW1CLElBQUksQ0FBQyxDQUFDO1FBRTlCLElBQUcsSUFBSSxDQUFDLG1CQUFtQixLQUFLLElBQUksQ0FBQyxtQkFBbUIsRUFBQztZQUNyRCw2QkFBNkI7WUFDN0IsUUFBUSxFQUFFLENBQUM7U0FDZDtJQUNMLENBQUM7SUFFRCxvREFBb0Q7SUFFN0MsVUFBVSxDQUFDLEdBQVc7UUFDekIsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRU0sZ0JBQWdCLENBQUMsR0FBVztRQUMvQixPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDO0lBQ25ELENBQUM7SUFFTSxTQUFTLENBQUMsR0FBVztRQUN4QixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFFTyxrQkFBa0IsQ0FBQyxRQUFnQixFQUFFLEtBQXVCO1FBQ2hFLHFCQUFxQjtRQUNyQixNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBRTNELHFCQUFxQjtRQUNyQixNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBRXhDLHFCQUFxQjtRQUNyQixrQkFBa0I7UUFDbEIsSUFBSSxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFakMsZ0NBQWdDO1FBQ2hDLElBQUksQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBRWpELDZCQUE2QjtRQUM3QixJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLGtCQUFrQixFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDdEYsSUFBSSxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxjQUFjLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUN6RixJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBRXpGLHdCQUF3QjtRQUN4QixJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxhQUFhLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFcEcsNERBQTREO1FBQzVELElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUV0RCxvQkFBb0I7UUFDcEIsSUFBSSxDQUFDLGdCQUFnQixJQUFJLENBQUMsQ0FBQztJQUMvQixDQUFDO0lBRU8sWUFBWSxDQUFDLEVBQVU7UUFDM0IscUZBQXFGO1FBQ3JGLDRDQUE0QztRQUM1QyxRQUFPLEVBQUUsRUFBQztZQUNOLEtBQUssQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQztZQUNoQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUM7WUFDaEMsS0FBSyxDQUFDLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDO1lBQ2hDLEtBQUssQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQztZQUNoQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUM7WUFDaEMsS0FBSyxDQUFDLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDO1lBQ2hDLEtBQUssQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQztZQUNoQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUM7WUFDaEMsS0FBSyxDQUFDLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDO1lBQ2hDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUM7U0FDcEM7SUFDTCxDQUFDO0lBRU0sWUFBWSxDQUFDLEdBQVc7UUFDM0IsSUFBRyxJQUFJLENBQUMsY0FBYyxFQUFDO1lBQ25CLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsWUFBWSxFQUFFLENBQUM7WUFFcEMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQ3BDO0lBQ0wsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ksTUFBTSxDQUFDLEdBQVcsRUFBRSxlQUF1QixFQUFFLGVBQXVCO1FBQ3ZFLElBQUksU0FBUyxHQUFHLGVBQWUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDM0MsSUFBSSxHQUFHLEdBQUcsU0FBUyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFFMUMsSUFBRyxHQUFHLEtBQUssU0FBUyxFQUFDO1lBQ2pCLE1BQU0sR0FBRyxlQUFlLHVEQUF1RCxDQUFDO1NBQ25GO1FBRUQsU0FBUyxHQUFHLGVBQWUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDdkMsR0FBRyxHQUFHLFNBQVMsQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBRXRDLElBQUcsR0FBRyxLQUFLLFNBQVMsRUFBQztZQUNqQixNQUFNLEdBQUcsZUFBZSx1REFBdUQsQ0FBQztTQUNuRjtRQUVELElBQUksS0FBSyxHQUFHLElBQUksY0FBYyxFQUFFLENBQUM7UUFDakMsS0FBSyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7UUFDaEIsS0FBSyxDQUFDLEtBQUssR0FBRyxlQUFlLENBQUM7UUFDOUIsS0FBSyxDQUFDLEtBQUssR0FBRyxlQUFlLENBQUM7UUFFOUIsSUFBSSxDQUFDLDhCQUE4QixDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ssVUFBVSxDQUFDLEdBQVc7UUFDMUIsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLEVBQUUsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQy9DLENBQUM7SUFFTyx1QkFBdUIsQ0FBQyxlQUF5QjtRQUNyRCxJQUFJLENBQUMsZ0NBQWdDLEdBQUcsSUFBSSxDQUFDLDhCQUE4QixDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ3RGLElBQUksQ0FBQyxnQ0FBZ0MsR0FBRyxDQUFDLENBQUM7UUFFMUMsb0VBQW9FO1FBQ3BFLElBQUcsQ0FBQyxJQUFJLENBQUMsY0FBYyxJQUFJLElBQUksQ0FBQyxnQ0FBZ0MsS0FBSyxDQUFDLEVBQUM7WUFDbkUsZUFBZSxFQUFFLENBQUM7WUFDbEIsT0FBTztTQUNWO1FBRUQsT0FBTSxJQUFJLENBQUMsOEJBQThCLENBQUMsUUFBUSxFQUFFLEVBQUM7WUFDakQsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLDhCQUE4QixDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQzNELElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxNQUFNLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxLQUFLLEVBQUUsZUFBZSxDQUFDLENBQUM7U0FDL0U7SUFDTCxDQUFDO0lBRU8sYUFBYSxDQUFDLEdBQVcsRUFBRSxLQUFhLEVBQUUsS0FBYSxFQUFFLGNBQXdCO1FBQ3JGLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxFQUFFLENBQUMsU0FBaUIsRUFBRSxFQUFFO1lBQzNDLE1BQU0sT0FBTyxHQUFHLFNBQVMsQ0FBQztZQUUxQixJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssRUFBRSxDQUFDLFNBQWlCLEVBQUUsRUFBRTtnQkFDM0MsTUFBTSxPQUFPLEdBQUcsU0FBUyxDQUFBO2dCQUV6QixrQ0FBa0M7Z0JBQ2xDLE1BQU0sQ0FBQyxhQUFhLEVBQUUsWUFBWSxFQUFFLGNBQWMsQ0FBQyxHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7Z0JBRWpHLHdCQUF3QjtnQkFDeEIsTUFBTSxjQUFjLEdBQUcsSUFBSSwwQkFBZ0IsRUFBRSxDQUFDO2dCQUM5QyxjQUFjLENBQUMsT0FBTyxHQUFHLGFBQWEsQ0FBQztnQkFDdkMsY0FBYyxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7Z0JBQzNDLGNBQWMsQ0FBQyxjQUFjLEdBQUcsY0FBYyxDQUFDO2dCQUUvQyxpQkFBaUI7Z0JBQ2pCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLGNBQWMsQ0FBQyxDQUFDO2dCQUVoRCxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLElBQUksaUJBQWlCLENBQUMsR0FBRyxFQUFFLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO2dCQUU3RSxpQkFBaUI7Z0JBQ2pCLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxjQUFjLENBQUMsQ0FBQztZQUNoRCxDQUFDLENBQUMsQ0FBQztRQUNQLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVPLHNCQUFzQixDQUFDLFFBQWtCO1FBQzdDLElBQUksQ0FBQyxnQ0FBZ0MsSUFBSSxDQUFDLENBQUM7UUFFM0MsSUFBRyxJQUFJLENBQUMsZ0NBQWdDLEtBQUssSUFBSSxDQUFDLGdDQUFnQyxFQUFDO1lBQy9FLDZCQUE2QjtZQUM3QixRQUFRLEVBQUUsQ0FBQztTQUNkO0lBQ0wsQ0FBQztJQUVPLG1CQUFtQixDQUFDLGFBQXFCLEVBQUUsYUFBcUI7UUFDcEUsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQzFELE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUU5RCxJQUFHLFlBQVksS0FBSyxJQUFJLElBQUksY0FBYyxLQUFLLElBQUksRUFBQztZQUNoRCx1Q0FBdUM7WUFDdkMsT0FBTyxJQUFJLENBQUM7U0FDZjtRQUVELDBCQUEwQjtRQUMxQixNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBQ3hDLElBQUcsQ0FBQyxPQUFPLEVBQUU7WUFDVCxpQkFBaUI7WUFDakIsT0FBTyxDQUFDLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO1lBQ3pDLE9BQU8sSUFBSSxDQUFDO1NBQ2Y7UUFFRCx3Q0FBd0M7UUFDeEMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQzVDLElBQUksQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLE9BQU8sRUFBRSxjQUFjLENBQUMsQ0FBQztRQUU5QyxPQUFPO1FBQ1AsSUFBSSxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDN0IsSUFBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsbUJBQW1CLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLEVBQUM7WUFDMUQsZ0JBQWdCO1lBQ2hCLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsaUJBQWlCLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDakQsT0FBTyxDQUFDLElBQUksQ0FBQywwQkFBMEIsR0FBRyxLQUFLLENBQUMsQ0FBQztZQUVqRCxXQUFXO1lBQ1gsSUFBSSxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDL0IsSUFBSSxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsWUFBWSxDQUFDLENBQUM7WUFDbkMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDckMsT0FBTyxJQUFJLENBQUM7U0FDZjtRQUVELG1DQUFtQztRQUNuQyxPQUFPLENBQUMsT0FBTyxFQUFFLFlBQVksRUFBRSxjQUFjLENBQUMsQ0FBQztJQUNuRCxDQUFDO0lBRU8sZ0JBQWdCLENBQUMsWUFBb0I7UUFDekMsNkJBQTZCO1FBQzdCLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsRUFBRSxZQUFZLENBQUMsQ0FBQztJQUNoRSxDQUFDO0lBRU8sa0JBQWtCLENBQUMsWUFBb0I7UUFDM0MsK0JBQStCO1FBQy9CLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLGVBQWUsRUFBRSxZQUFZLENBQUMsQ0FBQztJQUNsRSxDQUFDO0lBRU8sVUFBVSxDQUFDLElBQVksRUFBRSxZQUFvQjtRQUNqRCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUUxQywwQ0FBMEM7UUFDMUMsSUFBRyxNQUFNLEtBQUssSUFBSSxFQUFDO1lBQ2YsT0FBTyxDQUFDLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO1lBQ3hDLE9BQU8sSUFBSSxDQUFDO1NBQ2Y7UUFFRCwyQ0FBMkM7UUFDM0MsSUFBSSxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQzNDLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRTlCLHFEQUFxRDtRQUNyRCxJQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxjQUFjLENBQUMsRUFBQztZQUMzRCx1QkFBdUI7WUFDdkIsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUMvQyxPQUFPLENBQUMsSUFBSSxDQUFDLDRCQUE0QixHQUFHLEtBQUssQ0FBQyxDQUFDO1lBRW5ELFdBQVc7WUFDWCxJQUFJLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUM3QixPQUFPLElBQUksQ0FBQztTQUNmO1FBRUQsK0JBQStCO1FBQy9CLE9BQU8sTUFBTSxDQUFDO0lBQ2xCLENBQUM7SUFFRCxxREFBcUQ7SUFFN0MsWUFBWSxDQUFDLFlBQW9CLEVBQUUsUUFBa0I7UUFDekQsSUFBSSxJQUFJLEdBQW1CLElBQUksY0FBYyxFQUFFLENBQUM7UUFDaEQsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGtCQUFrQixDQUFDLENBQUM7UUFDMUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsWUFBWSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ3JDLElBQUksQ0FBQyxrQkFBa0IsR0FBRztZQUN0QixJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLElBQUksR0FBRyxDQUFDLEVBQUU7Z0JBQ2hELFFBQVEsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7YUFDL0I7UUFDTCxDQUFDLENBQUM7UUFDRixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3BCLENBQUM7SUFFRCw0Q0FBNEM7SUFFcEMsY0FBYztRQUNsQixPQUFPLENBQUMsSUFBSSxDQUFDLHVCQUF1QixHQUFDLElBQUksQ0FBQyx1QkFBdUI7Y0FDM0QsSUFBSSxDQUFDLDJCQUEyQixHQUFDLElBQUksQ0FBQywyQkFBMkI7Y0FDakUsSUFBSSxDQUFDLHFCQUFxQixHQUFDLElBQUksQ0FBQyxxQkFBcUI7Y0FDckQsSUFBSSxDQUFDLG9CQUFvQixHQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQztjQUNwRCxJQUFJLENBQUMsb0JBQW9CLENBQUM7SUFDcEMsQ0FBQztJQUVELE1BQU0sQ0FBQyxNQUFjO1FBQ2pCLElBQUcsSUFBSSxDQUFDLE9BQU8sRUFBQztZQUNaLElBQUcsSUFBSSxDQUFDLGNBQWMsRUFBQztnQkFDbkIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUMsQ0FBQzthQUM5QztTQUNKO2FBQU0sSUFBRyxJQUFJLENBQUMsVUFBVSxFQUFDO1lBQ3RCLElBQUksQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDO1lBQ3hCLElBQUcsSUFBSSxDQUFDLGNBQWMsRUFBQztnQkFDbkIsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO2FBQ3pCO1NBQ0o7SUFDTCxDQUFDO0NBQ0o7QUE3OEJELGtDQTY4QkM7QUFFRDs7OztHQUlHO0FBQ0gsTUFBTSxpQkFBaUI7SUFLbkIsWUFBWSxHQUFXLEVBQUUsWUFBMEI7UUFDL0MsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7UUFDZixJQUFJLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQztRQUNqQyxJQUFJLENBQUUsWUFBWSxHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7SUFDckMsQ0FBQztJQUVELGFBQWEsQ0FBQyxRQUEyQjtRQUNyQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNyQyxDQUFDO0NBQ0o7QUFHRCxJQUFLLFlBT0o7QUFQRCxXQUFLLFlBQVk7SUFDYiwrQkFBZSxDQUFBO0lBQ2YsbUNBQW1CLENBQUE7SUFDbkIsMkNBQTJCLENBQUE7SUFDM0IsK0JBQWUsQ0FBQTtJQUNmLDZCQUFhLENBQUE7SUFDYixpQ0FBaUIsQ0FBQTtBQUNyQixDQUFDLEVBUEksWUFBWSxLQUFaLFlBQVksUUFPaEI7QUFFRDs7R0FFRztBQUNILE1BQU0sV0FBVztJQUFqQjtRQUdJLGlCQUFZLEdBQWEsS0FBSyxDQUFDO0lBQ25DLENBQUM7Q0FBQTtBQUVELE1BQU0sY0FBYztDQUluQjs7Ozs7Ozs7QUN2Z0NELHdFQUFnRDtBQUVoRCxvRUFBZ0U7QUFDaEUsMEVBQXNFO0FBQ3RFLHVFQUErQztBQUMvQyxnRUFBd0M7QUFDeEMsMkVBQW1EO0FBQ25ELHlFQUFpRDtBQUNqRCwyRUFBbUQ7QUFDbkQsaUZBQXlEO0FBQ3pELHFFQUE2QztBQUM3Qyw0RkFBb0U7QUFDcEUscUVBQTZDO0FBQzdDLDZFQUFxRDtBQUdyRCxjQUFjO0FBRWQ7OztHQUdHO0FBQ0gsTUFBcUIsaUJBQWlCO0lBQXRDO1FBU0M7Ozs7OztXQU1HO1FBQ0gsaUJBQVksR0FBRyxDQUFDLElBQTRCLEVBQUUsU0FBaUIsRUFBRSxPQUE2QixFQUFhLEVBQUU7WUFDNUcsZ0JBQWdCO1lBQ2hCLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBRTNDLElBQUksUUFBbUIsQ0FBQztZQUV4QixRQUFPLElBQUksRUFBQztnQkFDWCxLQUFLLDhCQUFhLENBQUMsTUFBTTtvQkFDeEIsUUFBUSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7b0JBQ3RDLE1BQU07Z0JBQ04sS0FBSyw4QkFBYSxDQUFDLEtBQUs7b0JBQ3ZCLFFBQVEsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDO29CQUNyQyxNQUFNO2dCQUNOLEtBQUssOEJBQWEsQ0FBQyxNQUFNO29CQUN4QixRQUFRLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztvQkFDdEMsTUFBTTtnQkFDTixLQUFLLDhCQUFhLENBQUMsVUFBVTtvQkFDNUIsUUFBUSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLENBQUM7b0JBQ3pDLE1BQU07Z0JBQ047b0JBQ0MsTUFBTSxrQkFBa0IsSUFBSSxpREFBaUQsQ0FBQTthQUM5RTtZQUVELFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzlCLFFBQVEsQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLEVBQUUsQ0FBQztZQUN0QyxJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsRUFBRSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUU3Qyx3QkFBd0I7WUFDeEIsS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQTtZQUV2QixPQUFPLFFBQVEsQ0FBQztRQUNqQixDQUFDLENBQUE7UUFFRDs7Ozs7V0FLRztRQUNILGNBQVMsR0FBRyxDQUFDLEdBQVcsRUFBRSxTQUFpQixFQUFVLEVBQUU7WUFDdEQsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUM7WUFFM0MsSUFBSSxRQUFRLEdBQUcsSUFBSSxnQkFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBRS9CLHdCQUF3QjtZQUN4QixRQUFRLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUM5QixRQUFRLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFLENBQUM7WUFFdEMsSUFBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUMsU0FBUyxDQUFDLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBQztnQkFDOUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLEVBQUUsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7YUFDN0M7WUFFRCx3QkFBd0I7WUFDeEIsS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUV4QixPQUFPLFFBQVEsQ0FBQztRQUNqQixDQUFDLENBQUE7UUFFRDs7Ozs7V0FLRztRQUNILHNCQUFpQixHQUFHLENBQTJCLE1BQWlDLEVBQUUsR0FBVyxFQUFFLFNBQWlCLEVBQUssRUFBRTtZQUN0SCxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUMzQyxJQUFJLFdBQVcsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUMzRCxJQUFJLFFBQVEsR0FBRyxJQUFJLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUV2Qyx3QkFBd0I7WUFDeEIsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDOUIsUUFBUSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsRUFBRSxDQUFDO1lBRXRDLElBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsZUFBZSxDQUFDLFNBQVMsQ0FBQyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUM7Z0JBQzlFLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxFQUFFLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO2FBQzdDO1lBRUQsd0JBQXdCO1lBQ3hCLEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7WUFFeEIsT0FBTyxRQUFRLENBQUM7UUFDakIsQ0FBQyxDQUFBO1FBRUQ7Ozs7OztXQU1HO1FBQ0gsZUFBVSxHQUFHLENBQUMsSUFBMEIsRUFBRSxTQUFpQixFQUFFLE9BQTZCLEVBQVcsRUFBRTtZQUN0RyxnQkFBZ0I7WUFDaEIsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUM7WUFFM0MsSUFBSSxRQUFpQixDQUFDO1lBRXRCLFFBQU8sSUFBSSxFQUFDO2dCQUNYLEtBQUssMEJBQVcsQ0FBQyxLQUFLO29CQUNyQixRQUFRLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztvQkFDcEMsTUFBTTtnQkFDUCxLQUFLLDBCQUFXLENBQUMsSUFBSTtvQkFDcEIsUUFBUSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUM7b0JBQ25DLE1BQU07Z0JBQ1AsS0FBSywwQkFBVyxDQUFDLElBQUk7b0JBQ3BCLFFBQVEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDO29CQUNuQyxNQUFNO2dCQUNQLEtBQUssMEJBQVcsQ0FBQyxRQUFRO29CQUN4QixRQUFRLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQztvQkFDdkMsTUFBTTtnQkFDUDtvQkFDQyxNQUFNLGdCQUFnQixJQUFJLGlEQUFpRCxDQUFBO2FBQzVFO1lBRUQsd0JBQXdCO1lBQ3hCLFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzlCLFFBQVEsQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLEVBQUUsQ0FBQztZQUV0QyxJQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxTQUFTLENBQUMsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFDO2dCQUM5RSxJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsRUFBRSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUM3QztZQUVELHdCQUF3QjtZQUN4QixLQUFLLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBRXhCLE9BQU8sUUFBUSxDQUFDO1FBQ2pCLENBQUMsQ0FBQTtJQXNGRixDQUFDO0lBL05BLElBQUksQ0FBQyxLQUFZO1FBQ2hCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ25CLElBQUksQ0FBQyxlQUFlLEdBQUcseUJBQWUsQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUN0RCxDQUFDO0lBd0lELG9DQUFvQztJQUVwQyxXQUFXLENBQUMsT0FBNkI7UUFDeEMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFFBQVEsRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLGNBQUksRUFBRSxNQUFNLENBQUMsQ0FBQztRQUNwRSxJQUFJLENBQUMsaUJBQWlCLENBQUMsUUFBUSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFFNUQsT0FBTyxJQUFJLGdCQUFNLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDbkQsQ0FBQztJQUVELFVBQVUsQ0FBQyxPQUE2QjtRQUN2QyxJQUFJLENBQUMsaUJBQWlCLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsY0FBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ25FLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQztRQUUzRCxPQUFPLElBQUksZUFBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFBO0lBQ2pELENBQUM7SUFFRCxXQUFXLENBQUMsT0FBNEI7UUFDdkMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFFBQVEsRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLGNBQUksRUFBRSxNQUFNLENBQUMsQ0FBQztRQUVwRSxJQUFJLFNBQVMsR0FBRyxDQUFDLENBQUM7UUFDbEIsSUFBRyxPQUFPLENBQUMsS0FBSyxLQUFLLFNBQVMsRUFBQztZQUM5QixTQUFTLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQztTQUMxQjtRQUVELE9BQU8sSUFBSSxnQkFBTSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUVELGNBQWMsQ0FBQyxPQUE0QjtRQUMxQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsV0FBVyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsY0FBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBRXZFLE9BQU8sSUFBSSxtQkFBUyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN4QyxDQUFDO0lBRUQsVUFBVSxDQUFDLE9BQTZCO1FBQ3ZDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxjQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFFbkUsT0FBTyxJQUFJLGVBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUVELGFBQWEsQ0FBQyxPQUE2QjtRQUMxQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsVUFBVSxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsY0FBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3RFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxVQUFVLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxjQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDbEUsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFVBQVUsRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUV4RSxxQkFBcUI7UUFDckIsT0FBTyxJQUFJLGtCQUFRLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNuRSxDQUFDO0lBRUQsU0FBUyxDQUFDLE9BQTZCO1FBQ3RDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxjQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDL0QsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE1BQU0sRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLGNBQUksRUFBRSxNQUFNLENBQUMsQ0FBQztRQUU3RCxPQUFPLElBQUksY0FBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzdDLENBQUM7SUFFRCxTQUFTLENBQUMsT0FBNkI7UUFDdEMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE1BQU0sRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLGNBQUksRUFBRSxNQUFNLENBQUMsQ0FBQztRQUNsRSxJQUFJLENBQUMsaUJBQWlCLENBQUMsTUFBTSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsY0FBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBRTlELE9BQU8sSUFBSSxjQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDakQsQ0FBQztJQUVELDBDQUEwQztJQUUxQyxpQkFBaUIsQ0FBSSxVQUFrQixFQUFFLE9BQTRCLEVBQUUsSUFBWSxFQUFFLElBQXdDLEVBQUUsUUFBaUI7UUFDL0ksSUFBRyxDQUFDLE9BQU8sSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssU0FBUyxFQUFDO1lBQzFDLGlEQUFpRDtZQUNqRCxNQUFNLEdBQUcsVUFBVSw2QkFBNkIsSUFBSSxZQUFZLFFBQVEsMEJBQTBCLENBQUM7U0FDbkc7YUFBTTtZQUNOLCtDQUErQztZQUMvQyxJQUFHLENBQUMsT0FBTyxJQUFJLENBQUMsS0FBSyxRQUFRLEVBQUM7Z0JBQzdCLElBQUcsQ0FBQyxDQUFDLE9BQU8sT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksQ0FBQyxFQUFDO29CQUNuQyxNQUFNLEdBQUcsVUFBVSw2QkFBNkIsSUFBSSxZQUFZLElBQUksa0JBQWtCLElBQUksb0JBQW9CLElBQUksR0FBRyxDQUFDO2lCQUN0SDthQUNEO2lCQUFNLElBQUcsSUFBSSxZQUFZLFFBQVEsRUFBQztnQkFDbEMsK0NBQStDO2dCQUMvQyxJQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFlBQVksSUFBSSxDQUFDLEVBQUM7b0JBQ25DLE1BQU0sR0FBRyxVQUFVLDZCQUE2QixJQUFJLFlBQVksUUFBUSxrQkFBa0IsSUFBSSxvQkFBb0IsUUFBUSxHQUFHLENBQUM7aUJBQzlIO2FBQ0Q7aUJBQU07Z0JBQ04sTUFBTSxHQUFHLFVBQVUsNkJBQTZCLElBQUksWUFBWSxRQUFRLGtCQUFrQixJQUFJLG9CQUFvQixRQUFRLEdBQUcsQ0FBQzthQUM5SDtTQUNEO0lBQ0YsQ0FBQztDQUNEO0FBbk9ELG9DQW1PQzs7Ozs7Ozs7QUMzUEQsNEVBQW9EO0FBQ3BELHNFQUE4QztBQVk5Qzs7R0FFRztBQUNILE1BQXFCLGNBQWM7SUFNL0IsWUFBWSxLQUFZLEVBQUUsUUFBd0I7UUFKbEQsaUdBQWlHO1FBQ3pGLHNCQUFpQixHQUFzQixJQUFJLDJCQUFpQixFQUFFLENBQUM7UUFDL0QsbUJBQWMsR0FBbUIsSUFBSSx3QkFBYyxFQUFFLENBQUM7UUFHMUQsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNuQyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDOUMsQ0FBQztJQUVELDBEQUEwRDtJQUMxRDs7Ozs7O09BTUE7SUFDQSxTQUFTLENBQUMsSUFBNEIsRUFBRSxTQUFpQixFQUFFLE9BQTZCO1FBQ3BGLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ3pFLENBQUM7SUFFRDs7Ozs7T0FLQTtJQUNILE1BQU0sQ0FBQyxHQUFXLEVBQUUsU0FBaUI7UUFDOUIsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUM1RCxDQUFDO0lBRUQ7Ozs7O09BS0E7SUFDSCxjQUFjLENBQTJCLE1BQWlDLEVBQUUsR0FBVyxFQUFFLFNBQWlCO1FBQ25HLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDLGlCQUFpQixDQUFDLE1BQU0sRUFBRSxHQUFHLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDNUUsQ0FBQztJQUVEOzs7Ozs7T0FNQTtJQUNILE9BQU8sQ0FBQyxJQUEwQixFQUFFLFNBQWlCLEVBQUUsT0FBNkI7UUFDN0UsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDdkUsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNOLE9BQU8sQ0FBQyxHQUFXLEVBQUUsS0FBWTtRQUMxQixPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUMvQyxDQUFDO0NBQ0o7QUFoRUQsaUNBZ0VDOzs7Ozs7Ozs7QUMvRUQsNEZBQW9FO0FBQ3BFLCtGQUF1RTtBQUV2RSwrRUFBdUQ7QUFDdkQsZ0VBQXdDO0FBR3hDLHlGQUFpRTtBQUNqRSx3RUFBZ0Q7QUFDaEQsNkZBQXFFO0FBQ3JFLCtHQUF1RjtBQUV2RixjQUFjO0FBQ2QsSUFBWSxrQkFJWDtBQUpELFdBQVksa0JBQWtCO0lBQzFCLCtDQUF5QixDQUFBO0lBQ3pCLDZDQUF1QixDQUFBO0lBQ3ZCLHVEQUFpQyxDQUFBO0FBQ3JDLENBQUMsRUFKVyxrQkFBa0IsR0FBbEIsMEJBQWtCLEtBQWxCLDBCQUFrQixRQUk3QjtBQUdEOzs7R0FHRztBQUNILE1BQXFCLGNBQWM7SUFBbkM7UUFXSSxrRkFBa0Y7UUFDbEYsb0ZBQW9GO1FBQ3BGLGdGQUFnRjtRQUNoRix1REFBdUQ7UUFDdkQ7Ozs7OztXQU1HO1FBQ04sUUFBRyxHQUFHLENBQUMsR0FBVyxFQUFFLFFBQWMsSUFBSSxjQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFnQixFQUFFO1lBQzNELG1CQUFtQjtZQUNuQixJQUFJLFdBQVcsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUV2RCw4RUFBOEU7WUFDOUUsSUFBSSxNQUFvQyxDQUFDO1lBRXpDLFFBQU8sV0FBVyxDQUFDLFdBQVcsRUFBRTtnQkFDNUIsS0FBSyxrQkFBa0IsQ0FBQyxVQUFVLENBQUMsQ0FBQztvQkFDaEMsTUFBTSxHQUFHLDJCQUFpQixDQUFDO29CQUMzQixNQUFNO2lCQUNUO2dCQUNELEtBQUssa0JBQWtCLENBQUMsU0FBUyxDQUFDLENBQUM7b0JBQy9CLE1BQU0sR0FBRywwQkFBZ0IsQ0FBQztvQkFDMUIsTUFBTTtpQkFDVDtnQkFDRCxLQUFLLGtCQUFrQixDQUFDLG1CQUFtQixDQUFDLENBQUM7b0JBQ3pDLE1BQU0sR0FBRyxtQ0FBeUIsQ0FBQztvQkFDbkMsTUFBTTtpQkFDVDtnQkFDRCxPQUFPLENBQUMsQ0FBQztvQkFDTCxNQUFNLElBQUksS0FBSyxDQUFDLGdDQUFnQyxXQUFXLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQztpQkFDL0U7YUFDSjtZQUVELG9DQUFvQztZQUNwQyxJQUFJLFdBQVcsR0FBRyxJQUFJLEtBQUssRUFBUyxDQUFDO1lBRXJDLDhDQUE4QztZQUM5QyxJQUFJLFFBQVEsR0FBRyxJQUFJLEtBQUssRUFBVyxDQUFDO1lBRXBDLElBQUksZUFBZSxHQUFHLElBQUksS0FBSyxFQUF1QixDQUFDO1lBRXZELEtBQUksSUFBSSxPQUFPLElBQUksV0FBVyxDQUFDLFFBQVEsRUFBQztnQkFDcEMsSUFBRyxPQUFPLENBQUMsS0FBSyxFQUFDO29CQUNiLCtFQUErRTtvQkFDL0UsbUdBQW1HO29CQUNuRyxpR0FBaUc7b0JBQ2pHLGtEQUFrRDtvQkFDbEQsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLGlCQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztpQkFDdkM7cUJBQU07b0JBQ0gsT0FBTyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztvQkFDM0QsZUFBZSxDQUFDLElBQUksQ0FBQyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztpQkFDMUM7YUFDSjtZQUVELDhFQUE4RTtZQUM5RSxLQUFJLElBQUksS0FBSyxJQUFJLFdBQVcsQ0FBQyxNQUFNLEVBQUM7Z0JBRWhDLElBQUksVUFBVSxDQUFDO2dCQUNmLElBQUksZUFBZSxHQUFHLEtBQUssQ0FBQztnQkFDNUIsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO2dCQUVkLElBQUcsS0FBSyxDQUFDLFVBQVUsRUFBQztvQkFDaEIsS0FBSSxJQUFJLElBQUksSUFBSSxLQUFLLENBQUMsVUFBVSxFQUFDO3dCQUM3QixJQUFHLElBQUksQ0FBQyxJQUFJLEtBQUssVUFBVSxFQUFDOzRCQUN4QixlQUFlLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQzt5QkFDaEM7NkJBQU0sSUFBRyxJQUFJLENBQUMsSUFBSSxLQUFLLE9BQU8sRUFBRTs0QkFDN0IsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7eUJBQ3RCO3FCQUNKO2lCQUNKO2dCQUVELElBQUcsZUFBZSxFQUFDO29CQUNmLFVBQVUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsSUFBSSxjQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO2lCQUMvRTtxQkFBTTtvQkFDSCxVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztpQkFDdkQ7Z0JBRUQsSUFBRyxLQUFLLENBQUMsSUFBSSxLQUFLLFdBQVcsRUFBQztvQkFDMUIsNENBQTRDO29CQUM1QyxJQUFJLE9BQU8sR0FBRyxJQUFJLE1BQU0sQ0FBQyxXQUFXLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQztvQkFDOUQsT0FBTyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsRUFBRSxDQUFDO29CQUNyQyxPQUFPLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFFN0IsdUJBQXVCO29CQUN2QixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztvQkFFNUIsVUFBVSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztvQkFFNUIsbURBQW1EO29CQUNuRCxJQUFHLE9BQU8sQ0FBQyxZQUFZLEVBQUM7d0JBQ3BCLE9BQU8sQ0FBQyxVQUFVLEVBQUUsQ0FBQzt3QkFFckIsSUFBRyxLQUFLLENBQUMsVUFBVSxFQUFDOzRCQUNoQixLQUFJLElBQUksSUFBSSxJQUFJLEtBQUssQ0FBQyxVQUFVLEVBQUM7Z0NBQzdCLElBQUcsSUFBSSxDQUFDLElBQUksS0FBSyxPQUFPLEVBQUM7b0NBQ3JCLE9BQU8sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2lDQUNoQzs2QkFDSjt5QkFDSjtxQkFDSjtpQkFDSjtxQkFBTTtvQkFFSCxJQUFJLGVBQWUsR0FBRyxLQUFLLENBQUM7b0JBQzVCLElBQUksV0FBVyxDQUFDO29CQUNoQixJQUFJLEtBQUssQ0FBQztvQkFDVixJQUFHLEtBQUssQ0FBQyxVQUFVLEVBQUM7d0JBQ2hCLEtBQUksSUFBSSxJQUFJLElBQUksS0FBSyxDQUFDLFVBQVUsRUFBQzs0QkFDN0IsSUFBRyxJQUFJLENBQUMsSUFBSSxLQUFLLGVBQWUsRUFBQztnQ0FDN0IsZUFBZSxHQUFHLElBQUksQ0FBQzs2QkFDMUI7aUNBQU0sSUFBRyxJQUFJLENBQUMsSUFBSSxLQUFLLE1BQU0sRUFBQztnQ0FDM0IsV0FBVyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7NkJBQzVCO2lDQUFNLElBQUcsSUFBSSxDQUFDLElBQUksS0FBSyxPQUFPLEVBQUM7Z0NBQzVCLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFBOzZCQUNyQjt5QkFDSjtxQkFDSjtvQkFFRCxJQUFHLGVBQWUsRUFBQzt3QkFDZixJQUFJLENBQUMsR0FBRyxJQUFJLHVCQUFhLEVBQUUsQ0FBQzt3QkFFNUIsS0FBSSxJQUFJLEdBQUcsSUFBSSxLQUFLLENBQUMsT0FBTyxFQUFDOzRCQUN6QixDQUFDLENBQUMsaUJBQWlCLENBQUMsSUFBSSxjQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzt5QkFDL0M7d0JBRUQsS0FBSSxJQUFJLElBQUksSUFBSSxLQUFLLEVBQUM7NEJBQ2xCLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7eUJBQ2pDO3dCQUVELElBQUksQ0FBQyxLQUFLLENBQUMsb0JBQW9CLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxXQUFXLEVBQUUsSUFBSSxpQkFBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBRWxGLFNBQVM7cUJBQ1o7b0JBRUQsMEVBQTBFO29CQUMxRSxLQUFJLElBQUksR0FBRyxJQUFJLEtBQUssQ0FBQyxPQUFPLEVBQUM7d0JBQ3pCLDZCQUE2Qjt3QkFDN0IsSUFBSSxVQUFVLEdBQUcsS0FBSyxDQUFDO3dCQUN2QixJQUFJLFlBQVksR0FBRyxLQUFLLENBQUM7d0JBQ3pCLElBQUksU0FBUyxHQUFHLEtBQUssQ0FBQzt3QkFDdEIsSUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDO3dCQUNuQixJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUM7d0JBQ2xCLElBQUksWUFBWSxHQUFHLElBQUksQ0FBQzt3QkFDeEIsSUFBSSxLQUFLLEdBQUcsRUFBRSxDQUFDO3dCQUVmLElBQUcsR0FBRyxDQUFDLFVBQVUsRUFBQzs0QkFDZCxLQUFJLElBQUksSUFBSSxJQUFJLEdBQUcsQ0FBQyxVQUFVLEVBQUM7Z0NBQzNCLElBQUcsSUFBSSxDQUFDLElBQUksS0FBSyxZQUFZLEVBQUM7b0NBQzFCLFVBQVUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO2lDQUMzQjtxQ0FBTSxJQUFHLElBQUksQ0FBQyxJQUFJLEtBQUssWUFBWSxFQUFDO29DQUNqQyxZQUFZLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztpQ0FDN0I7cUNBQU0sSUFBRyxJQUFJLENBQUMsSUFBSSxLQUFLLE9BQU8sRUFBQztvQ0FDNUIsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7aUNBQ3RCO3FDQUFNLElBQUcsSUFBSSxDQUFDLElBQUksS0FBSyxXQUFXLEVBQUM7b0NBQ2hDLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO2lDQUMxQjtxQ0FBTSxJQUFHLElBQUksQ0FBQyxJQUFJLEtBQUssY0FBYyxFQUFDO29DQUNuQyxZQUFZLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztpQ0FDN0I7cUNBQU0sSUFBRyxJQUFJLENBQUMsSUFBSSxLQUFLLGdCQUFnQixFQUFDO29DQUNyQyxPQUFPLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztpQ0FDeEI7cUNBQU0sSUFBRyxJQUFJLENBQUMsSUFBSSxLQUFLLGVBQWUsRUFBQztvQ0FDcEMsTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7aUNBQ3ZCOzZCQUNKO3lCQUNKO3dCQUVELElBQUksTUFBYyxDQUFDO3dCQUVuQix3Q0FBd0M7d0JBQ3hDLEtBQUksSUFBSSxPQUFPLElBQUksUUFBUSxFQUFDOzRCQUN4QixJQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFDO2dDQUN4QixxQ0FBcUM7Z0NBQ3JDLElBQUksUUFBUSxHQUFHLE9BQU8sQ0FBQyxXQUFXLEVBQUUsQ0FBQztnQ0FDckMsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLHFCQUFxQixDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQ0FDcEQsTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO2dDQUNyRCxJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsV0FBVyxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUM7Z0NBQ3pDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxHQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLEdBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dDQUM1RSxNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2dDQUM5QixNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztnQ0FDdkIsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7NkJBQ3RDO3lCQUNKO3dCQUVELG9EQUFvRDt3QkFDcEQsSUFBRyxDQUFDLE1BQU0sRUFBQzs0QkFDUCxLQUFJLElBQUksSUFBSSxJQUFJLGVBQWUsRUFBQztnQ0FDNUIsSUFBRyxHQUFHLENBQUMsR0FBRyxLQUFLLElBQUksQ0FBQyxFQUFFLEVBQUM7b0NBQ25CLElBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7b0NBQzFCLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztvQ0FDckQsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxVQUFVLEdBQUMsQ0FBQyxDQUFDLEdBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFdBQVcsR0FBQyxDQUFDLENBQUMsR0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7b0NBQy9GLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO2lDQUN0Qzs2QkFDSjt5QkFDSjt3QkFFRCwyRUFBMkU7d0JBQzNFLElBQUcsVUFBVSxFQUFDOzRCQUNWLDBDQUEwQzs0QkFDMUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxFQUFFLGNBQUksQ0FBQyxJQUFJLEVBQUUsWUFBWSxFQUFFLElBQUksQ0FBQyxDQUFDOzRCQUMxRSxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDOzRCQUN2QixJQUFHLFNBQVMsSUFBSSxZQUFZLEtBQUssSUFBSSxFQUFDO2dDQUNsQyxNQUFNLENBQUMsVUFBVSxDQUFDLFlBQVksRUFBRSxPQUFPLEVBQUUsTUFBTSxDQUFDLENBQUM7NkJBQ3BEO3lCQUNKO3FCQUNKO2lCQUNKO2dCQUVELDBCQUEwQjtnQkFDMUIsV0FBVyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQzthQUNoQztZQUVELE9BQU8sV0FBVyxDQUFDO1FBQzFCLENBQUMsQ0FBQTtJQUNGLENBQUM7SUE1TkcsSUFBSSxDQUFDLEtBQVksRUFBRSxRQUF3QjtRQUN2QyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixJQUFJLENBQUMsZUFBZSxHQUFHLHlCQUFlLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDekQsQ0FBQztDQXdOSjtBQWpPRCxpQ0FpT0M7Ozs7Ozs7O0FDMVBELG1FQUEyQztBQUkzQzs7R0FFRztBQUNILE1BQXFCLEtBQUs7SUF5QnRCOzs7O09BSUc7SUFDSCxZQUFZLEtBQVksRUFBRSxJQUFZO1FBQ2xDLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ25CLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2pCLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1FBQ3BCLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1FBQ3BCLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO1FBQ2YsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLEtBQUssRUFBRSxDQUFDO1FBQ3pCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ25CLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO0lBQ25CLENBQUM7SUFFRDs7O09BR0c7SUFDSCxPQUFPO1FBQ0gsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQ3JCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxTQUFTLENBQUMsVUFBbUI7UUFDekIsSUFBSSxDQUFDLE1BQU0sR0FBRyxVQUFVLENBQUM7SUFDN0IsQ0FBQztJQUVEOztPQUVHO0lBQ0gsUUFBUTtRQUNKLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUN2QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsUUFBUSxDQUFDLEtBQWE7UUFDbEIsSUFBSSxDQUFDLEtBQUssR0FBRyxtQkFBUyxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQzlDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxRQUFRO1FBQ0osT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO0lBQ3RCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxTQUFTLENBQUMsTUFBZTtRQUNyQixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztJQUN6QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsUUFBUTtRQUNKLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUN2QixDQUFDO0lBRUQscUNBQXFDO0lBQ3JDLE9BQU87UUFDSCxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQztRQUNuQixJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQztJQUN2QixDQUFDO0lBRUQsK0NBQStDO0lBQy9DLE1BQU07UUFDRixJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztRQUNwQixJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztJQUN4QixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILFFBQVEsQ0FBQyxLQUFjO1FBQ25CLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0lBQ3ZCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxRQUFRO1FBQ0osT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO0lBQ3RCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxRQUFRLENBQUMsS0FBYTtRQUNsQixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztJQUN2QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsUUFBUTtRQUNKLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQztJQUN0QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsT0FBTyxDQUFDLElBQWM7UUFDbEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDdEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN4QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILFVBQVUsQ0FBQyxJQUFjO1FBQ3JCLDJCQUEyQjtRQUMzQixJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUVyQyxJQUFHLEtBQUssS0FBSyxDQUFDLENBQUMsRUFBQztZQUNaLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztZQUM1QixJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1NBQzVCO0lBQ0wsQ0FBQztJQUVEOzs7T0FHRztJQUNILFFBQVE7UUFDSixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7SUFDdEIsQ0FBQztDQUNKO0FBL0tELHdCQStLQzs7Ozs7Ozs7QUN2TEQscURBQTZCO0FBSTdCOztHQUVHO0FBQ0gsTUFBcUIsYUFBYyxTQUFRLGVBQUs7SUFJL0M7Ozs7OztPQU1HO0lBQ0gsWUFBWSxLQUFZLEVBQUUsSUFBWSxFQUFFLFFBQWM7UUFDckQsS0FBSyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztRQUNuQixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztJQUMxQixDQUFDO0NBQ0Q7QUFmRCxnQ0FlQzs7Ozs7Ozs7QUN0QkQsZ0VBQXdDO0FBRXhDLG9FQUE0QztBQUU1Qzs7OztHQUlHO0FBQ0gsTUFBcUIsT0FBUSxTQUFRLHVCQUFhO0lBQ2pEOzs7OztPQUtHO0lBQ0gsWUFBWSxLQUFZLEVBQUUsSUFBWTtRQUNyQyxLQUFLLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxjQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDL0IsQ0FBQztDQUNEO0FBVkQsMEJBVUM7Ozs7Ozs7O0FDbkJELG9EQUE0QjtBQUU1Qiw2REFBcUM7QUFHckMseUZBQWlFO0FBQ2pFLG9GQUE0RDtBQUM1RCxnRkFBd0Q7QUFFeEQseUZBQWlFO0FBR2pFLGtFQUEwQztBQUMxQyxnRUFBd0M7QUFFeEMseUZBQWlFO0FBQ2pFLGdFQUF3QztBQUN4Qyx1RUFBK0M7QUFDL0MsMkVBQW1EO0FBQ25ELCtEQUF1QztBQUN2QyxxRUFBNkM7QUFFN0Msa0VBQTBDO0FBRTFDLDJEQUFtQztBQUNuQywwRUFBa0Q7QUFDbEQsd0ZBQWdFO0FBQ2hFLDBHQUFrRjtBQUVsRjs7Ozs7R0FLRztBQUNILE1BQXFCLEtBQUs7SUEwRHRCOzs7Ozs7O09BT0c7SUFDSCxZQUFZLFFBQWtCLEVBQUUsWUFBMEIsRUFBRSxnQkFBa0MsRUFBRSxPQUE0QjtRQUN4SCxJQUFJLENBQUMsWUFBWSxHQUFHLHNCQUFZLENBQUMsS0FBSyxDQUFDLE9BQU8sS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFN0UsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLGNBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDcEMsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7UUFDekIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDMUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7UUFDckIsSUFBSSxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7UUFDakMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLGtCQUFRLEVBQUUsQ0FBQztRQUMvQixJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksaUJBQU8sRUFBRSxDQUFDO1FBRTdCLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxLQUFLLEVBQUUsQ0FBQztRQUM1QixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUkseUJBQWUsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRTNELElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxhQUFHLEVBQUUsQ0FBQztRQUN4QixJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksYUFBRyxFQUFFLENBQUM7UUFDMUIsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLGFBQUcsRUFBRSxDQUFDO1FBRWhDLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSw2QkFBbUIsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3pFLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSwyQkFBaUIsRUFBRSxDQUFDO1FBQzFDLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxtQkFBUyxFQUFFLENBQUM7UUFDakMsSUFBSSxDQUFDLGdCQUFnQixHQUFHLGdCQUFnQixDQUFDO1FBRXpDLElBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSx3QkFBYyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFbkQsSUFBSSxDQUFDLElBQUksR0FBRyx5QkFBZSxDQUFDLFdBQVcsRUFBRSxDQUFBO1FBQ3pDLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztRQUVqQyxzREFBc0Q7UUFDdEQsc0JBQVksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUM3QyxDQUFDO0lBRUQsMEdBQTBHO0lBQzFHLFNBQVMsQ0FBQyxJQUF5QixJQUFTLENBQUM7SUFFN0MsNEhBQTRIO0lBQzVILFNBQVMsS0FBVSxDQUFDO0lBRXBCLHVIQUF1SDtJQUN2SCxVQUFVLEtBQVUsQ0FBQztJQUVyQjs7O09BR0c7SUFDSCxXQUFXLENBQUMsTUFBYyxJQUFTLENBQUM7SUFFcEMsK0hBQStIO0lBQy9ILFdBQVcsS0FBVSxDQUFDO0lBRXRCLE1BQU0sQ0FBQyxNQUFjO1FBQ2pCLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFekIsa0JBQWtCO1FBQ2xCLHNCQUFZLENBQUMsV0FBVyxFQUFFLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRTFDLG9CQUFvQjtRQUNwQixJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUU5Qiw2QkFBNkI7UUFDN0IsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFbkMsNEJBQTRCO1FBQzVCLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRS9CLHNCQUFzQjtRQUN0QixJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUM1QixJQUFHLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFDLFFBQVEsRUFBRSxFQUFDO2dCQUM5QixPQUFPLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQzFCO1FBQ0wsQ0FBQyxDQUFDLENBQUM7UUFFSCxvQkFBb0I7UUFDcEIsc0JBQVksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFMUMsOEJBQThCO1FBQzlCLCtCQUFxQixDQUFDLFdBQVcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUVuRCxrQkFBa0I7UUFDbEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDakMsQ0FBQztJQUVEOztPQUVHO0lBQ0gsTUFBTTtRQUNGLCtCQUErQjtRQUMvQixJQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBRWpELGlGQUFpRjtRQUNqRixJQUFJLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUM5QixJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUMxQyxLQUFJLElBQUksSUFBSSxJQUFJLE1BQU0sQ0FBQyxRQUFRLEVBQUUsRUFBQztnQkFDOUIsSUFBRyxJQUFJLFlBQVksb0JBQVUsRUFBQztvQkFDMUIsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDekI7YUFDSjtRQUNMLENBQUMsQ0FBQyxDQUFDO1FBRUgsK0RBQStEO1FBQy9ELElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRXZFLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDMUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM1RSxlQUFLLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxVQUFVLENBQUMsT0FBZ0I7UUFDdkIsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7T0FHRztJQUNILFNBQVM7UUFDTCxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUM7SUFDeEIsQ0FBQztJQUVEOzs7T0FHRztJQUNILE1BQU0sQ0FBQyxJQUFjO1FBQ2pCLDhCQUE4QjtRQUM5QixJQUFHLElBQUksWUFBWSxvQkFBVSxFQUFDO1lBQzFCLElBQUksQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3BDO0lBRUwsQ0FBQztJQUVELDhDQUE4QztJQUM5QyxPQUFPO1FBQ0gsS0FBSSxJQUFJLElBQUksSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsRUFBRSxFQUFDO1lBQzFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztTQUNsQjtRQUVELEtBQUksSUFBSSxPQUFPLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBQztZQUM3QixPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7U0FDckI7UUFFRCxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBRXhCLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQztRQUN2QixPQUFPLElBQUksQ0FBQyxjQUFjLENBQUM7UUFDM0IsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQztRQUN0QixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7SUFDekIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsUUFBUSxDQUFDLElBQVksRUFBRSxLQUFjO1FBQ2pDLElBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUM7WUFDakYsTUFBTSxtQkFBbUIsSUFBSSxpQkFBaUIsQ0FBQztTQUNsRDtRQUVELElBQUksS0FBSyxHQUFHLElBQUksZUFBSyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztRQUVsQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFN0IsSUFBRyxLQUFLLEVBQUM7WUFDTCxLQUFLLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ3pCO1FBRUQsT0FBTyxLQUFLLENBQUM7SUFDakIsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILGdCQUFnQixDQUFDLElBQVksRUFBRSxRQUFjLEVBQUUsS0FBYztRQUN6RCxJQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFDO1lBQ2pGLE1BQU0sbUJBQW1CLElBQUksaUJBQWlCLENBQUM7U0FDbEQ7UUFFRCxJQUFJLEtBQUssR0FBRyxJQUFJLHVCQUFhLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztRQUVwRCxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFckMsSUFBRyxLQUFLLEVBQUM7WUFDTCxLQUFLLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ3pCO1FBRUQsT0FBTyxLQUFLLENBQUM7SUFDakIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxVQUFVLENBQUMsSUFBWTtRQUNuQixJQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFDO1lBQ2pGLE1BQU0sbUJBQW1CLElBQUksaUJBQWlCLENBQUM7U0FDbEQ7UUFFRCxJQUFJLEtBQUssR0FBRyxJQUFJLGlCQUFPLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRXBDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztRQUUvQixPQUFPLEtBQUssQ0FBQztJQUNqQixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxRQUFRLENBQUMsSUFBWTtRQUNqQixJQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFDO1lBQ3JCLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDaEM7YUFBTSxJQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFDO1lBQ3BDLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDeEM7YUFBTSxJQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFDO1lBQzlCLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDbEM7YUFBTTtZQUNILE1BQU0sbUJBQW1CLElBQUksa0JBQWtCLENBQUM7U0FDbkQ7SUFDTCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILGVBQWUsQ0FBQyxJQUFZO1FBQ3hCLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDekMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxTQUFTLENBQUMsSUFBWTtRQUNsQixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILGtCQUFrQixDQUFDLElBQWM7UUFDN0IsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBRTVCLElBQUcsS0FBSyxZQUFZLHVCQUFhLElBQUksS0FBSyxZQUFZLGlCQUFPLEVBQUM7WUFDMUQsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDekQ7YUFBTTtZQUNILE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsQ0FBQztTQUNwQztJQUNSLENBQUM7SUFFRTs7O01BR0U7SUFDTCxZQUFZO1FBQ1gsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRSxDQUFDO0lBQ3JDLENBQUM7SUFFRTs7O09BR0c7SUFDSCxXQUFXO1FBQ1AsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQ3pCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxZQUFZO1FBQ1IsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDO0lBQzFCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxhQUFhO1FBQ1QsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDO0lBQzNCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxpQkFBaUI7UUFDYixPQUFPLElBQUksQ0FBQyxjQUFjLENBQUM7SUFDL0IsQ0FBQztJQUVEOzs7T0FHRztJQUNILG9CQUFvQjtRQUNoQixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7T0FHRztJQUNILFlBQVk7UUFDUixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUM7SUFDMUIsQ0FBQztJQUVEOzs7T0FHRztJQUNILFVBQVU7UUFDTixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsVUFBVSxFQUFFLENBQUM7SUFDMUMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxVQUFVLENBQUMsSUFBWTtRQUNuQixLQUFJLElBQUksT0FBTyxJQUFJLElBQUksQ0FBRSxRQUFRLEVBQUM7WUFDOUIsSUFBRyxPQUFPLENBQUMsSUFBSSxLQUFLLElBQUksRUFBQztnQkFDckIsT0FBTyxPQUFPLENBQUM7YUFDbEI7U0FDSjtRQUVELE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7Q0FDSjtBQTVaRCx3QkE0WkM7Ozs7Ozs7O0FDOWJELHlGQUFpRTtBQUlqRSxrRUFBMEM7QUFDMUMsMkRBQXdEO0FBRXhEOzs7R0FHRztBQUNILE1BQXFCLFlBQVk7SUFzQmhDOzs7OztPQUtHO0lBQ0gsWUFBWSxRQUFrQixFQUFFLGdCQUFrQztRQUNqRSxJQUFJLENBQUMsZUFBZSxHQUFHLHlCQUFlLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDckQsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7UUFDekIsSUFBSSxDQUFDLGdCQUFnQixHQUFHLGdCQUFnQixDQUFDO1FBQ3pDLElBQUksQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDO1FBQ25CLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDO1FBRXpCLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxrQkFBUSxFQUFFLENBQUM7UUFDL0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsNkJBQWEsQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUNyRCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxhQUFhLENBQWtCLE1BQStCLEVBQUUsSUFBMEIsRUFBRSxPQUE2QjtRQUMvSCxPQUFPLENBQUMsR0FBRyxDQUFDLDhEQUE4RCxDQUFDLENBQUM7UUFDNUUsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDcEYsSUFBSSxDQUFDLGdCQUFnQixHQUFHLElBQUksQ0FBQztJQUM5QixDQUFDO0lBRVMsYUFBYTtRQUN0QixPQUFPLENBQUMsR0FBRyxDQUFDLHlCQUF5QixDQUFDLENBQUM7UUFDdkMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUV0RixJQUFHLElBQUksQ0FBQyxZQUFZLEVBQUM7WUFDcEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFBO1lBQ2xDLElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxFQUFFLENBQUM7WUFFaEMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO1lBQ3BDLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFLENBQUM7U0FDNUI7UUFFRCxPQUFPLENBQUMsR0FBRyxDQUFDLDRCQUE0QixDQUFDLENBQUM7UUFDMUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1FBRTFDLHlDQUF5QztRQUN6QyxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUM7UUFFdEMsOEJBQThCO1FBQzlCLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDO1FBRXpCLGlCQUFpQjtRQUNqQixJQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUVuRCxnQ0FBZ0M7UUFDaEMsSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUU5QixrQkFBa0I7UUFDbEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO1FBQ25DLElBQUksQ0FBQyxlQUFlLENBQUMsc0JBQXNCLENBQUMsR0FBRyxFQUFFO1lBQ2hELE9BQU8sQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztZQUM5QixJQUFJLENBQUMsWUFBWSxDQUFDLFVBQVUsRUFBRSxDQUFDO1lBQy9CLElBQUksQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3BDLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDbkQsQ0FBQztJQUVEOzs7T0FHRztJQUNJLFVBQVU7UUFDaEIsT0FBTyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7SUFDekIsQ0FBQztJQUVEOztPQUVHO0lBQ0ksTUFBTTtRQUNaLElBQUcsSUFBSSxDQUFDLFlBQVksRUFBQztZQUNwQixJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxDQUFDO1NBQzNCO0lBQ0YsQ0FBQztJQUVEOzs7T0FHRztJQUNJLE1BQU0sQ0FBQyxNQUFjO1FBQzNCLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLEVBQUUsRUFBRTtZQUNwQyxJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRSxDQUFDO1lBQ3RDLElBQUksRUFBRSxDQUFDLElBQUksS0FBSyw2QkFBYSxDQUFDLFlBQVk7Z0JBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1NBQzFHO1FBRUQsSUFBRyxJQUFJLENBQUMsWUFBWSxLQUFLLElBQUksRUFBQztZQUM3QixJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7U0FDckI7UUFFRCxJQUFHLElBQUksQ0FBQyxZQUFZLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLEVBQUUsRUFBQztZQUNyRCxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUNqQztJQUNGLENBQUM7Q0FDRDtBQTVIRCwrQkE0SEM7Ozs7O0FDdElELGNBQWM7QUFFZDs7R0FFRztBQUNILE1BQXFCLFlBQVk7SUFNN0IsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUE0QjtRQUNyQyxJQUFJLElBQUksR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO1FBRTlCLElBQUcsT0FBTyxDQUFDLE9BQU8sS0FBSyxTQUFTLEVBQUM7WUFDN0IsSUFBSSxDQUFDLE9BQU8sR0FBRyxFQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBQyxDQUFDO1NBQzdEO2FBQU07WUFDSCxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUM7U0FDbEM7UUFFRCxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0NBQ0o7QUFqQkQsK0JBaUJDOzs7Ozs7OztBQ3JCRCw2REFBcUM7QUFJckM7Ozs7R0FJRztBQUNILE1BQThCLFVBQVU7SUFVdkM7Ozs7T0FJRztJQUNBLFlBQVksUUFBa0IsRUFBRSxLQUFZO1FBQzlDLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO1FBQ3pCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ25CLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxLQUFLLEVBQUUsQ0FBQztRQUMzQixJQUFJLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQztJQUNqQixDQUFDO0lBRUo7Ozs7T0FJRztJQUNBLE9BQU8sQ0FBQyxJQUFnQjtRQUMxQixJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUM7UUFDN0IsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQzNDLElBQUksQ0FBQyxTQUFTLElBQUksQ0FBQyxDQUFDO1FBQ3BCLE9BQU8sSUFBSSxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUM7SUFDM0IsQ0FBQztJQUFBLENBQUM7SUFTRjs7O09BR0c7SUFDQSxVQUFVLENBQUMsSUFBZ0I7UUFDN0IsK0JBQStCO1FBQy9CLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQztRQUNsQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUN4QyxDQUFDO0lBQUEsQ0FBQztJQVNGOzs7O09BSUc7SUFDSCxPQUFPLENBQUMsRUFBVTtRQUNqQixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDekIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0EsVUFBVSxDQUFDLE1BQXFCLEVBQUUsSUFBWSxJQUFJO1FBQ3BELElBQUcsTUFBTSxZQUFZLGNBQUksRUFBQztZQUN6QixPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNqRDthQUFNO1lBQ04sT0FBTyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQ3hDO0lBQ0YsQ0FBQztJQVNEOzs7T0FHRztJQUNILFdBQVc7UUFDVixJQUFJLEdBQUcsR0FBRyxJQUFJLEtBQUssRUFBYyxDQUFDO1FBQ2xDLEtBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBQztZQUMzQyxJQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssU0FBUyxFQUFDO2dCQUNoQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUMxQjtTQUNEO1FBQ0QsT0FBTyxHQUFHLENBQUM7SUFDWixDQUFDO0NBa0JEO0FBdEhELDZCQXNIQzs7Ozs7Ozs7QUNsSUQsOERBQXNDO0FBS3RDLDJEQUFtQztBQUVuQzs7R0FFRztBQUNILE1BQXFCLGVBQWdCLFNBQVEsb0JBQVU7SUFJbkQ7Ozs7T0FJRztJQUNILFlBQVksUUFBa0IsRUFBRSxLQUFZO1FBQ3hDLEtBQUssQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFdkIsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLEtBQUssRUFBYyxDQUFDO0lBQzVDLENBQUM7SUFFRCxZQUFZO0lBQ0YsZUFBZSxDQUFDLElBQWdCLEVBQUUsRUFBVTtRQUNsRCxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRUQsWUFBWTtJQUNGLGtCQUFrQixDQUFDLElBQWdCLEVBQUUsRUFBVTtRQUNyRCxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN4QyxJQUFHLEtBQUssR0FBRyxDQUFDLENBQUMsRUFBQztZQUNWLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztTQUNsQztJQUNMLENBQUM7SUFFRCxZQUFZO0lBQ1osZ0JBQWdCLENBQUMsQ0FBUyxFQUFFLENBQVM7UUFDakMsSUFBSSxPQUFPLEdBQUcsRUFBRSxDQUFDO1FBRWpCLEtBQUksSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBQztZQUMxQixJQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFDO2dCQUNuQixPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3RCO1NBQ0o7UUFFRCxPQUFPLE9BQU8sQ0FBQztJQUNuQixDQUFDO0lBRUQsWUFBWTtJQUNaLGdCQUFnQixDQUFDLFFBQWM7UUFDM0IsSUFBSSxFQUFFLEdBQUcsV0FBVyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQzNCLElBQUksT0FBTyxHQUFHLEVBQUUsQ0FBQztRQUVqQixLQUFJLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUM7WUFDMUIsSUFBRyxRQUFRLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBQztnQkFDaEMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUN0QjtTQUNKO1FBQ0QsSUFBSSxFQUFFLEdBQUcsV0FBVyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQzNCLGVBQUssQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLENBQUMsRUFBRSxHQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFFOUIsT0FBTyxPQUFPLENBQUM7SUFDbkIsQ0FBQztJQUVELE1BQU0sQ0FBQyxNQUFjO1FBQ2pCLElBQUksRUFBRSxHQUFHLFdBQVcsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUMzQixLQUFJLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUM7WUFDMUIsSUFBRyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxRQUFRLEVBQUUsRUFBQztnQkFDM0IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUN2QjtTQUNKO1FBQ0QsSUFBSSxFQUFFLEdBQUcsV0FBVyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQzNCLGVBQUssQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFLENBQUMsRUFBRSxHQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDbkMsQ0FBQztJQUVELE1BQU0sQ0FBQyxHQUE2QixJQUFTLENBQUM7SUFFOUMsWUFBWTtJQUNaLGFBQWE7UUFDVCxJQUFJLFVBQVUsR0FBRyxJQUFJLEtBQUssRUFBYyxDQUFDO1FBRXpDLEtBQUksSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBQztZQUMxQixJQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLFFBQVEsRUFBRSxJQUFJLElBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUM7Z0JBQzNFLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDekI7U0FDSjtRQUVELE9BQU8sVUFBVSxDQUFDO0lBQ3RCLENBQUM7Q0FDSjtBQWxGRCxrQ0FrRkM7Ozs7Ozs7O0FDNUZELDZEQUFxQztBQUdyQyxtRUFBMkM7QUFDM0MsMkVBQW1EO0FBQ25ELG9FQUE0QztBQUM1QywyREFBbUM7QUFDbkMsa0ZBQTBEO0FBQzFELHNFQUE4QztBQUU5Qzs7O0dBR0c7QUFDSCxNQUFxQixRQUFRO0lBeUJ6QixZQUFZLFVBQWdCLEVBQUUsU0FBaUI7UUFOL0MsMkNBQTJDO1FBQ25DLGdCQUFXLEdBQVcsR0FBRyxDQUFDO1FBTTlCLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxjQUFJLENBQUMsY0FBSSxDQUFDLElBQUksRUFBRSxjQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDM0MsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLGNBQUksQ0FBQyxjQUFJLENBQUMsSUFBSSxFQUFFLGNBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUMvQyxJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksZUFBSyxFQUFFLENBQUM7UUFDakMsSUFBSSxDQUFDLGVBQWUsR0FBRyxFQUFFLENBQUM7UUFDMUIsSUFBSSxDQUFDLGlCQUFpQixHQUFHLEtBQUssQ0FBQztRQUMvQixJQUFJLENBQUMsVUFBVSxHQUFHLGNBQUksQ0FBQyxJQUFJLENBQUM7UUFDNUIsSUFBSSxDQUFDLEtBQUssR0FBRyxjQUFJLENBQUMsSUFBSSxDQUFDO1FBRXZCLDZCQUE2QjtRQUM3QixJQUFJLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRS9CLCtCQUErQjtRQUMvQixJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ3pCLElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFN0Isb0RBQW9EO1FBQ3BELElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUMzQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7SUFDOUMsQ0FBQztJQUVELDhDQUE4QztJQUM5QyxVQUFVO1FBQ04sSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksQ0FBQztJQUNsQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsU0FBUztRQUNMLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7SUFDNUIsQ0FBQztJQUVEOzs7T0FHRztJQUNILFNBQVM7UUFDTCxPQUFPLElBQUksY0FBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDbkQsQ0FBQztJQUVEOzs7T0FHRztJQUNILE9BQU87UUFDSCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUM7SUFDckIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxTQUFTLENBQUMsTUFBcUIsRUFBRSxJQUFZLElBQUk7UUFDN0MsSUFBSSxHQUFTLENBQUM7UUFDcEIsSUFBRyxNQUFNLFlBQVksY0FBSSxFQUFDO1lBQ2hCLEdBQUcsR0FBRyxNQUFNLENBQUM7U0FDaEI7YUFBTTtZQUNILEdBQUcsR0FBRyxJQUFJLGNBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7U0FDN0I7UUFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxHQUFHLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7T0FHRztJQUNILFdBQVc7UUFDUCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDbkMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxPQUFPLENBQUMsTUFBcUIsRUFBRSxJQUFZLElBQUk7UUFDakQsSUFBRyxNQUFNLFlBQVksY0FBSSxFQUFDO1lBQ3pCLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDMUM7YUFBTTtZQUNOLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksY0FBSSxDQUFDLE1BQU0sR0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDL0M7SUFDQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILFdBQVcsQ0FBQyxNQUFxQixFQUFFLElBQVksSUFBSTtRQUNyRCxJQUFHLE1BQU0sWUFBWSxjQUFJLEVBQUM7WUFDekIsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7U0FDdEM7YUFBTTtZQUNOLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksY0FBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQzNDO0lBQ0MsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxhQUFhLENBQUMsTUFBcUIsRUFBRSxJQUFZLElBQUk7UUFDdkQsSUFBRyxNQUFNLFlBQVksY0FBSSxFQUFDO1lBQ3pCLElBQUksQ0FBQyxVQUFVLEdBQUcsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDO1NBQ2pDO2FBQU07WUFDTixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksY0FBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztTQUN0QztJQUNDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxZQUFZLENBQUMsSUFBWTtRQUNyQixJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFDLElBQUksR0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzlELENBQUM7SUFFRDs7O09BR0c7SUFDSCxZQUFZO1FBQ1IsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUE7SUFDM0MsQ0FBQztJQUVEOzs7T0FHRztJQUNILGtCQUFrQixDQUFDLGVBQXVCO1FBQ3RDLElBQUcsZUFBZSxHQUFHLENBQUM7WUFBRSxlQUFlLEdBQUcsQ0FBQyxDQUFDO1FBQzVDLElBQUksQ0FBQyxlQUFlLEdBQUcsZUFBZSxDQUFDO0lBQzNDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxRQUFRLENBQUMsS0FBVztRQUNoQixJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUMzQixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILFFBQVEsQ0FBQyxJQUFnQjtRQUNyQixJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLFlBQVksdUJBQWEsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFLFlBQVksaUJBQU8sQ0FBQyxDQUFDLENBQWlCLElBQUksQ0FBQyxRQUFRLEVBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksY0FBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUMzSixJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUN0QyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDaEMsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ2pELElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQTtRQUN6QixPQUFPLFFBQVEsQ0FBQztJQUNwQixDQUFDO0lBRUosaUdBQWlHO0lBQzlGLHFHQUFxRztJQUNyRzs7Ozs7O09BTUc7SUFDSCxTQUFTLENBQUMsTUFBYyxFQUFFLE1BQWMsRUFBRSxNQUFjLEVBQUUsTUFBYztRQUNwRSxJQUFJLE1BQU0sR0FBRyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsR0FBQyxDQUFDLENBQUM7UUFDakMsSUFBSSxPQUFPLEdBQUcsQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLEdBQUMsQ0FBQyxDQUFDO1FBQ2xDLElBQUksQ0FBQyxHQUFHLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDeEIsSUFBSSxDQUFDLEdBQUcsTUFBTSxHQUFHLE9BQU8sQ0FBQztRQUN6QixJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQy9CLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUVEOzs7T0FHRztJQUNILE1BQU0sQ0FBQyxJQUFjO1FBQ2pCLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDO0lBQzFCLENBQUM7SUFFRCxVQUFVO1FBQ04sSUFBRyxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sRUFBRSxHQUFHLElBQUksQ0FBQyxlQUFlLEVBQUM7WUFDbkQsSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLEVBQUUsQ0FBQztTQUNoQztRQUVELDJDQUEyQztRQUMzQyxJQUFJLEdBQUcsR0FBRyxjQUFJLENBQUMsSUFBSSxDQUFDO1FBQ3BCLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQzFELEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztRQUUxQywwREFBMEQ7UUFDMUQsR0FBRyxDQUFDLENBQUMsR0FBRyxtQkFBUyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDdEcsR0FBRyxDQUFDLENBQUMsR0FBRyxtQkFBUyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFdEcsMkNBQTJDO1FBQzNDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDMUIsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUUxQixJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDL0IsQ0FBQztJQUVELE1BQU0sQ0FBQyxNQUFjO1FBQ2pCLHFCQUFxQjtRQUNyQixJQUFHLElBQUksQ0FBQyxpQkFBaUIsRUFBQztZQUN0QixJQUFHLGVBQUssQ0FBQyxhQUFhLEVBQUUsRUFBQztnQkFDckIsSUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQztnQkFDbEQsSUFBRyxlQUFLLENBQUMsa0JBQWtCLEVBQUUsR0FBRyxDQUFDLEVBQUM7b0JBQzlCLFVBQVU7b0JBQ1YsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO2lCQUN6QztxQkFBTTtvQkFDSCxXQUFXO29CQUNYLFdBQVcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO2lCQUN2QztnQkFFRCxJQUFHLFdBQVcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLEVBQUM7b0JBQ2hDLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxHQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7b0JBQzVDLFdBQVcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUM7b0JBQ2pDLFdBQVcsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDO2lCQUMzQjtnQkFFRCxJQUFHLFdBQVcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLEVBQUM7b0JBQ2hDLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxHQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7b0JBQzVDLFdBQVcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUM7b0JBQ2pDLFdBQVcsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDO2lCQUMzQjtnQkFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxXQUFXLENBQUMsQ0FBQzthQUN0QztTQUNKO1FBRUQscUNBQXFDO1FBQ3JDLElBQUcsSUFBSSxDQUFDLFNBQVMsRUFBQztZQUNkLHdDQUF3QztZQUN4QyxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO1NBQy9EO2FBQU07WUFDSCxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDMUM7UUFFRCxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7SUFDdEIsQ0FBQztDQUNKO0FBL1FELDJCQStRQzs7Ozs7Ozs7O0FDN1JELHVFQUErQztBQUMvQyxrRUFBMEM7QUFDMUMseUZBQWlFO0FBQ2pFLDJEQUF3RDtBQUV4RDs7OztHQUlHO0FBQ0gsTUFBcUIsWUFBWTtJQWE3QjtRQUNJLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNqQixJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksa0JBQVEsRUFBRSxDQUFDO1FBQy9CLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDO1lBQ3BCLDZCQUFhLENBQUMsVUFBVTtZQUN4Qiw2QkFBYSxDQUFDLFVBQVU7WUFDeEIsNkJBQWEsQ0FBQyxVQUFVO1lBQ3hCLDZCQUFhLENBQUMsUUFBUTtZQUN0Qiw2QkFBYSxDQUFDLFlBQVk7WUFDMUIsNkJBQWEsQ0FBQyxjQUFjO1NBQy9CLENBQUMsQ0FBQztRQUNILElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxhQUFHLEVBQUUsQ0FBQztRQUUvQixJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksS0FBSyxDQUFXLDBCQUFrQixDQUFDLENBQUM7UUFDekQsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO0lBQ3pCLENBQUM7SUFFRDs7O09BR0c7SUFDSSxNQUFNLENBQUMsV0FBVztRQUNyQixJQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBQztZQUNkLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztTQUN0QztRQUNELE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQztJQUN6QixDQUFDO0lBRUQ7O09BRUc7SUFDSyxTQUFTO1FBQ2IsSUFBSTtZQUNBLE1BQU0sQ0FBQyxZQUFZLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFBLGlDQUFpQztZQUMzRSxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7WUFDbkMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDO1NBQ3BEO1FBQUMsT0FBTSxDQUFDLEVBQUU7WUFDUCxPQUFPLENBQUMsSUFBSSxDQUFDLGdEQUFnRCxDQUFDLENBQUM7U0FDbEU7SUFDTCxDQUFDO0lBRU8sYUFBYTtRQUNqQixLQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsMEJBQWtCLEVBQUUsQ0FBQyxFQUFFLEVBQUM7WUFDdkMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsRUFBRSxDQUFDO1NBQ2xEO0lBQ0wsQ0FBQztJQUVEOzs7T0FHRztJQUNJLGVBQWU7UUFDbEIsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQ3pCLENBQUM7SUFFRDs7Ozs7Ozs7O01BU0U7SUFDRjs7OztPQUlHO0lBQ08sV0FBVyxDQUFDLEdBQVcsRUFBRSxhQUFzQixFQUFFLE9BQXlCLEVBQUUsT0FBaUI7UUFDbkcsbUJBQW1CO1FBQ25CLElBQUksTUFBTSxHQUFHLHlCQUFlLENBQUMsV0FBVyxFQUFFLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRXpELHdCQUF3QjtRQUN4QixJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLGtCQUFrQixFQUFFLENBQUM7UUFFaEQsc0NBQXNDO1FBQ3RDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBRXZCLDJCQUEyQjtRQUMzQixNQUFNLEtBQUssR0FBcUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUV6QyxnQ0FBZ0M7UUFDaEMsK0NBQStDO1FBRS9DLHFDQUFxQztRQUNyQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztRQUVwQyxtQ0FBbUM7UUFDbkMsS0FBSSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUM7WUFDakMsS0FBSyxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDaEM7UUFFRCxrREFBa0Q7UUFDbEQsS0FBSyxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUM7UUFFM0QsT0FBTyxNQUFNLENBQUM7SUFDbEIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ08sU0FBUyxDQUFDLEdBQVcsRUFBRSxJQUFhLEVBQUUsYUFBc0IsRUFBRSxPQUF5QixFQUFFLE9BQWlCO1FBQ2hILElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxFQUFFLGFBQWEsRUFBRSxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFFbkUsSUFBRyxJQUFJLEVBQUM7WUFDSixLQUFLLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztTQUNyQjtRQUVELGdIQUFnSDtRQUNoSCxJQUFHLGFBQWEsRUFBQztZQUNiLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztTQUN0QztRQUVELEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUNsQixDQUFDO0lBRUQ7O09BRUc7SUFDTyxTQUFTLENBQUMsR0FBVztRQUMzQixJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN4QyxJQUFHLEtBQUssRUFBQztZQUNMLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNiLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ2xDO0lBQ0wsQ0FBQztJQUVTLFdBQVcsQ0FBQyxPQUF5QjtRQUMzQyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDOUUsQ0FBQztJQUVTLGFBQWEsQ0FBQyxPQUF5QjtRQUM3QyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDOUUsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsTUFBTSxDQUFDLFNBQVMsQ0FBQyxPQUF5QixFQUFFLE1BQWM7UUFDdEQsSUFBRyxNQUFNLEdBQUcsQ0FBQyxFQUFDO1lBQ1YsTUFBTSxHQUFHLENBQUMsQ0FBQztTQUNkO1FBRUQsTUFBTSxFQUFFLEdBQUcsWUFBWSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ3RDLEVBQUUsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUMvRSxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsa0JBQWtCLENBQUMsT0FBeUI7UUFDeEMsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUFFRCxNQUFNLENBQUMsTUFBYztRQUNqQixpQ0FBaUM7UUFDakMseUVBQXlFO1FBQ3pFLE9BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLEVBQUUsRUFBQztZQUMvQixJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRSxDQUFDO1lBQ3pDLElBQUcsS0FBSyxDQUFDLElBQUksS0FBSyw2QkFBYSxDQUFDLFVBQVUsSUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLDZCQUFhLENBQUMsVUFBVSxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssNkJBQWEsQ0FBQyxRQUFRLEVBQUM7Z0JBQzNILElBQUksUUFBUSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUNyQyxJQUFJLElBQUksR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDbEMsSUFBSSxhQUFhLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsZUFBZSxDQUFDLENBQUM7Z0JBRXBELElBQUksT0FBTyxHQUFHLGdCQUFnQixDQUFDLE9BQU8sQ0FBQztnQkFFdkMsSUFBRyxLQUFLLENBQUMsSUFBSSxLQUFLLDZCQUFhLENBQUMsVUFBVSxFQUFDO29CQUN2QyxPQUFPLEdBQUcsZ0JBQWdCLENBQUMsS0FBSyxDQUFDO2lCQUNwQztxQkFBTSxJQUFHLDZCQUFhLENBQUMsUUFBUSxFQUFDO29CQUM3QixPQUFPLEdBQUcsZ0JBQWdCLENBQUMsR0FBRyxDQUFDO2lCQUNsQztxQkFBTSxJQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxFQUFDO29CQUNoQyxPQUFPLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7aUJBQ3ZDO2dCQUVELElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLElBQUksRUFBRSxhQUFhLEVBQUUsT0FBTyxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUN0RTtZQUVELElBQUcsS0FBSyxDQUFDLElBQUksS0FBSyw2QkFBYSxDQUFDLFVBQVUsRUFBQztnQkFDdkMsSUFBSSxRQUFRLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQ3JDLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUM7YUFDNUI7WUFFRCxJQUFHLEtBQUssQ0FBQyxJQUFJLEtBQUssNkJBQWEsQ0FBQyxZQUFZLEVBQUM7Z0JBQ3pDLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQzthQUMvQztZQUVELElBQUcsS0FBSyxDQUFDLElBQUksS0FBSyw2QkFBYSxDQUFDLGNBQWMsRUFBQztnQkFDM0MsSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO2FBQ2pEO1NBQ0o7SUFDTCxDQUFDO0NBQ0o7QUF4TkQsK0JBd05DO0FBRUQsSUFBWSxnQkFhWDtBQWJELFdBQVksZ0JBQWdCO0lBQ3hCLDZEQUFXLENBQUE7SUFDWCxxREFBTyxDQUFBO0lBQ1AseURBQVMsQ0FBQTtJQUNULCtEQUFZLENBQUE7SUFDWiwrREFBWSxDQUFBO0lBQ1osK0RBQVksQ0FBQTtJQUNaLCtEQUFZLENBQUE7SUFDWiwrREFBWSxDQUFBO0lBQ1osK0RBQVksQ0FBQTtJQUNaLCtEQUFZLENBQUE7SUFDWixnRUFBYSxDQUFBO0lBQ2IsZ0VBQWEsQ0FBQTtBQUNqQixDQUFDLEVBYlcsZ0JBQWdCLEdBQWhCLHdCQUFnQixLQUFoQix3QkFBZ0IsUUFhM0I7QUFFWSxRQUFBLGtCQUFrQixHQUFHLEVBQUUsQ0FBQzs7Ozs7Ozs7O0FDbFByQyxtRUFBMkM7QUFDM0Msa0VBQTBDO0FBRTFDLE1BQU07QUFDTixNQUFxQixLQUFLO0lBb0J0QixZQUFZLElBQVksRUFBRSxLQUFnQixFQUFFLE9BQWdCLEtBQUs7UUFDN0Qsc0JBQXNCO1FBQ3RCLHNCQUFZLENBQUMsV0FBVyxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRTFDLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDO1FBQ3RCLElBQUksQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDO1FBQ2xCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ25CLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2pCLElBQUksQ0FBQyxLQUFLLEdBQUcsVUFBVSxDQUFDLE9BQU8sQ0FBQztRQUNoQyxJQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQztJQUNyQixDQUFDO0lBRUQsU0FBUztRQUNMLE9BQU8sSUFBSSxDQUFDLEtBQUssS0FBSyxVQUFVLENBQUMsT0FBTyxDQUFDO0lBQzdDLENBQUM7SUFFRCxRQUFRO1FBQ0osT0FBTyxJQUFJLENBQUMsS0FBSyxLQUFLLFVBQVUsQ0FBQyxNQUFNLENBQUM7SUFDNUMsQ0FBQztJQUVEOzs7T0FHRztJQUNILE1BQU07UUFDRixPQUFPLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDO0lBQzVCLENBQUM7SUFFRCxLQUFLLENBQUMsSUFBYTtRQUNmLElBQUcsSUFBSSxLQUFLLFNBQVMsRUFBQztZQUNsQixJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQztTQUN6QjtRQUNELElBQUksQ0FBQyxLQUFLLEdBQUcsVUFBVSxDQUFDLE1BQU0sQ0FBQztRQUMvQixJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUM7SUFDbkMsQ0FBQztJQUVELGtHQUFrRztJQUNsRyxLQUFLO1FBQ0QsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO1FBQy9CLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDO0lBQ3JCLENBQUM7SUFFRCxLQUFLO1FBQ0QsSUFBSSxDQUFDLEtBQUssR0FBRyxVQUFVLENBQUMsTUFBTSxDQUFDO0lBQ25DLENBQUM7SUFFRCxNQUFNLENBQUMsTUFBYztRQUNqQixJQUFHLElBQUksQ0FBQyxLQUFLLEtBQUssVUFBVSxDQUFDLE1BQU0sRUFBQztZQUNoQyxJQUFJLENBQUMsUUFBUSxJQUFJLE1BQU0sR0FBQyxJQUFJLENBQUM7WUFFN0IsSUFBRyxJQUFJLENBQUMsUUFBUSxJQUFJLENBQUMsRUFBQztnQkFDbEIsSUFBSSxDQUFDLFFBQVEsR0FBRyxtQkFBUyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7Z0JBQ25ELElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQzthQUNkO1NBQ0o7SUFDTCxDQUFDO0lBRVMsR0FBRztRQUNULG1CQUFtQjtRQUNuQixJQUFJLENBQUMsS0FBSyxHQUFHLFVBQVUsQ0FBQyxPQUFPLENBQUM7UUFDaEMsSUFBSSxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUM7UUFFbEIsd0NBQXdDO1FBQ3hDLElBQUcsSUFBSSxDQUFDLEtBQUssRUFBQztZQUNWLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztTQUNoQjtRQUVELHFCQUFxQjtRQUNyQixJQUFHLElBQUksQ0FBQyxJQUFJLEVBQUM7WUFDVCxJQUFJLENBQUMsS0FBSyxHQUFHLFVBQVUsQ0FBQyxNQUFNLENBQUM7WUFDL0IsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO1NBQ2xDO0lBQ0wsQ0FBQztJQUVELFFBQVE7UUFDSixPQUFPLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxHQUFHLGdCQUFnQixHQUFHLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxHQUFHLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDO0lBQ3hHLENBQUM7Q0FDSjtBQWpHRCx3QkFpR0M7QUFFRCxJQUFZLFVBSVg7QUFKRCxXQUFZLFVBQVU7SUFDbEIsK0JBQWlCLENBQUE7SUFDakIsK0JBQWlCLENBQUE7SUFDakIsaUNBQW1CLENBQUE7QUFDdkIsQ0FBQyxFQUpXLFVBQVUsR0FBVixrQkFBVSxLQUFWLGtCQUFVLFFBSXJCOzs7OztBQ3pHRCxNQUFxQixZQUFZO0lBSTdCO1FBQ0ksSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLEtBQUssRUFBRSxDQUFDO0lBQzlCLENBQUM7SUFJRCxNQUFNLENBQUMsV0FBVztRQUNkLElBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFDO1lBQ2QsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO1NBQ3RDO1FBRUQsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQ3pCLENBQUM7SUFFRCxRQUFRLENBQUMsS0FBWTtRQUNqQixJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM1QixDQUFDO0lBRUQsV0FBVztRQUNQLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxLQUFLLEVBQUUsQ0FBQztJQUM5QixDQUFDO0lBRUQsTUFBTSxDQUFDLE1BQWM7UUFDakIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDdkQsQ0FBQztDQUNKO0FBN0JELCtCQTZCQzs7Ozs7Ozs7QUNoQ0QsNERBQW9DO0FBRXBDLHFEQUFxRDtBQUNyRDs7R0FFRztBQUNILE1BQXFCLEtBQUs7SUFVekI7Ozs7OztPQU1HO0lBQ0gsWUFBWSxJQUFZLENBQUMsRUFBRSxJQUFZLENBQUMsRUFBRSxJQUFZLENBQUMsRUFBRSxJQUFZLENBQUM7UUFDL0QsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDWCxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNYLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1gsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDbEIsQ0FBQztJQUVEOzs7T0FHRztJQUNILE1BQU0sS0FBSyxXQUFXO1FBQ3JCLE9BQU8sSUFBSSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDOUIsQ0FBQztJQUVEOzs7T0FHRztJQUNILE1BQU0sS0FBSyxHQUFHO1FBQ2IsT0FBTyxJQUFJLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNoQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsTUFBTSxLQUFLLEtBQUs7UUFDZixPQUFPLElBQUksS0FBSyxDQUFDLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ2hDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxNQUFNLEtBQUssSUFBSTtRQUNkLE9BQU8sSUFBSSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDaEMsQ0FBQztJQUVEOzs7T0FHRztJQUNILE1BQU0sS0FBSyxNQUFNO1FBQ2hCLE9BQU8sSUFBSSxLQUFLLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDbEMsQ0FBQztJQUVEOzs7T0FHRztJQUNILE1BQU0sS0FBSyxPQUFPO1FBQ2pCLE9BQU8sSUFBSSxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDbEMsQ0FBQztJQUVEOzs7T0FHRztJQUNILE1BQU0sS0FBSyxJQUFJO1FBQ2QsT0FBTyxJQUFJLEtBQUssQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNsQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsTUFBTSxLQUFLLEtBQUs7UUFDZixPQUFPLElBQUksS0FBSyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxNQUFNLEtBQUssS0FBSztRQUNmLE9BQU8sSUFBSSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDOUIsQ0FBQztJQUVEOzs7T0FHRztJQUNILE1BQU0sS0FBSyxNQUFNO1FBQ2hCLE9BQU8sSUFBSSxLQUFLLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDbEMsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILEdBQUcsQ0FBQyxDQUFTLEVBQUUsQ0FBUyxFQUFFLENBQVMsRUFBRSxJQUFZLENBQUM7UUFDakQsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDWCxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNYLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1gsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDWixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsT0FBTztRQUNOLE9BQU8sSUFBSSxLQUFLLENBQUMsbUJBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLG1CQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRSxtQkFBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsbUJBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDMUssQ0FBQztJQUVEOzs7T0FHRztJQUNILE1BQU07UUFDTCxPQUFPLElBQUksS0FBSyxDQUFDLG1CQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRSxtQkFBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsbUJBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLG1CQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQzFLLENBQUM7SUFFRDs7O09BR0c7SUFDSCxPQUFPO1FBQ04sT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN6QyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsUUFBUTtRQUNQLE9BQU8sR0FBRyxHQUFHLG1CQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsbUJBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxtQkFBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ25HLENBQUM7SUFFRDs7O09BR0c7SUFDSCxXQUFXO1FBQ1YsT0FBTyxNQUFNLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsR0FBRyxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsR0FBRyxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsR0FBRyxHQUFHLENBQUM7SUFDL0YsQ0FBQztJQUVEOzs7T0FHRztJQUNILFlBQVk7UUFDWCxJQUFHLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFDO1lBQ2YsT0FBTyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7U0FDMUI7UUFDRCxPQUFPLE9BQU8sR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxHQUFHLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxHQUFHLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxHQUFHLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxHQUFFLEdBQUcsQ0FBQTtJQUN6SCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsT0FBTztRQUNOLE9BQU8sSUFBSSxZQUFZLENBQUM7WUFDdkIsSUFBSSxDQUFDLENBQUMsR0FBQyxHQUFHO1lBQ1YsSUFBSSxDQUFDLENBQUMsR0FBQyxHQUFHO1lBQ1YsSUFBSSxDQUFDLENBQUMsR0FBQyxHQUFHO1lBQ1YsSUFBSSxDQUFDLENBQUM7U0FDTixDQUFDLENBQUM7SUFDSixDQUFDO0lBRUQsTUFBTSxDQUFDLGFBQWEsQ0FBQyxHQUFXO1FBQy9CLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNWLElBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxHQUFHO1lBQUUsQ0FBQyxJQUFHLENBQUMsQ0FBQztRQUMvQixJQUFJLENBQUMsR0FBRyxtQkFBUyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNqRCxJQUFJLENBQUMsR0FBRyxtQkFBUyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbkQsSUFBSSxDQUFDLEdBQUcsbUJBQVMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxFQUFFLENBQUMsR0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ25ELE9BQU8sSUFBSSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUMzQixDQUFDO0NBQ0Q7QUE5TEQsd0JBOExDOzs7O0FDcE1ELGNBQWM7OztBQUVkLE1BQXFCLGFBQWE7SUFFOUIsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFTO1FBQzFCLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUVELE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBUztRQUMxQixPQUFPLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDekYsQ0FBQztJQUVELE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBUztRQUN4QixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ3ZDLENBQUM7SUFFRCxNQUFNLENBQUMsVUFBVSxDQUFDLENBQVM7UUFDdkIsT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDM0MsQ0FBQztJQUVELE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBUztRQUMzQixPQUFPLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUM5RSxDQUFDO0lBRUQsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFTO1FBQzFCLE9BQU8sQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2pFLENBQUM7SUFFRCxNQUFNLENBQUMsYUFBYSxDQUFDLENBQVM7UUFDMUIsT0FBTyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUM5RSxDQUFDO0lBRU8sTUFBTSxDQUFDLGdCQUFnQixDQUFDLENBQVMsRUFBRSxHQUFXO1FBQ2xELE9BQU8sR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUVPLE1BQU0sQ0FBQyxlQUFlLENBQUMsQ0FBUyxFQUFFLEdBQVc7UUFDakQsT0FBTyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDOUMsQ0FBQztDQUNKO0FBckNELGdDQXFDQztBQUVELElBQVksZ0JBYVg7QUFiRCxXQUFZLGdCQUFnQjtJQUN4QixPQUFPO0lBQ1AsaURBQTZCLENBQUE7SUFDN0IsaURBQTZCLENBQUE7SUFDN0IsMENBQXNCLENBQUE7SUFDdEIsNENBQXdCLENBQUE7SUFFeEIsT0FBTztJQUNQLGlEQUE2QixDQUFBO0lBQzdCLGlEQUE2QixDQUFBO0lBRTdCLFFBQVE7SUFDUixtREFBK0IsQ0FBQTtBQUNuQyxDQUFDLEVBYlcsZ0JBQWdCLEdBQWhCLHdCQUFnQixLQUFoQix3QkFBZ0IsUUFhM0I7Ozs7O0FDbkRELDREQUE0RDtBQUM1RCxNQUFxQixVQUFVO0lBRTlCOzs7OztPQUtHO0lBQ0gsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFRLEVBQUUsS0FBYTtRQUN0QyxJQUFJLENBQVMsQ0FBQyxDQUFFLFVBQVU7UUFDMUIsSUFBSSxDQUFXLENBQUMsQ0FBQyxzQkFBc0I7UUFDdkMsSUFBSSxNQUFNLEdBQW1CLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUN0RCxJQUFJLFFBQVEsR0FBa0IsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ3ZELElBQUksTUFBTSxHQUFrQixJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDckQsSUFBSSxDQUFTLENBQUMsQ0FBRSw0QkFBNEI7UUFDNUMsSUFBSSxDQUFTLENBQUMsQ0FBRyw0QkFBNEI7UUFDN0MsSUFBSSxNQUFjLENBQUMsQ0FBQyxjQUFjO1FBQ2xDLElBQUksSUFBSSxDQUFDLENBQUcsbUNBQW1DO1FBRS9DLEtBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLEVBQUUsRUFBQztZQUNqQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDO1lBQ2xCLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUM7WUFDdkIsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQ2Y7UUFFRCxRQUFRLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3BCLENBQUMsR0FBRyxLQUFLLENBQUM7UUFFVixPQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFDO1lBQ2hCLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7WUFDakIsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFFZixPQUFNLENBQUMsS0FBSyxJQUFJLEVBQUM7Z0JBQ2hCLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNSLE1BQU0sR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDO2dCQUVsQixJQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxFQUFDO29CQUNyQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQztvQkFDbkMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztpQkFDZDtnQkFFRCxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQzthQUNYO1lBRUQsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUVOLElBQUksR0FBRyxRQUFRLENBQUM7WUFFaEIsS0FBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsRUFBRSxFQUFDO2dCQUNsQyxJQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUM7b0JBQ25DLElBQUksR0FBRyxRQUFRLENBQUM7b0JBQ2hCLENBQUMsR0FBRyxDQUFDLENBQUM7aUJBQ047YUFDRDtTQUNEO1FBRUQsT0FBTyxNQUFNLENBQUM7SUFFZixDQUFDO0NBRUQ7QUE1REQsNkJBNERDOzs7OztBQzlERCxvRUFBb0U7QUFDcEUsTUFBcUIsU0FBUztJQUMxQjs7OztPQUlHO0lBQ0gsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFTO1FBQ2pCLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMxQixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBUyxFQUFFLENBQVMsRUFBRSxDQUFTLEVBQUUsU0FBbUI7UUFDL0QsSUFBRyxTQUFTLEVBQUM7WUFDVCxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQzdCO2FBQU07WUFDSCxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1NBQy9CO0lBQ0wsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBUyxFQUFFLEdBQVcsRUFBRSxHQUFXO1FBQzVDLElBQUcsQ0FBQyxHQUFHLEdBQUc7WUFBRSxPQUFPLEdBQUcsQ0FBQztRQUN2QixJQUFHLENBQUMsR0FBRyxHQUFHO1lBQUUsT0FBTyxHQUFHLENBQUM7UUFDdkIsT0FBTyxDQUFDLENBQUM7SUFDYixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBUztRQUNwQixPQUFPLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxNQUFNLENBQUMsUUFBUSxDQUFDLENBQVMsRUFBRSxHQUFXO1FBQ2xDLE9BQU8sQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxNQUFNLENBQUMsU0FBUyxDQUFDLENBQVM7UUFDdEIsT0FBTyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBRUQsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFPLEVBQUUsQ0FBUztRQUNwQyxJQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLEdBQUMsQ0FBQyxFQUFDO1lBQ2YsT0FBTyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3ZCO2FBQUs7WUFDRixPQUFPLENBQUMsQ0FBQztTQUNaO0lBQ0wsQ0FBQztJQUVELE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBUyxFQUFFLEdBQVcsRUFBRSxHQUFXLEVBQUUsTUFBYyxFQUFFLE1BQWM7UUFDbEYsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDaEUsQ0FBQztJQUVEOzs7Ozs7T0FNQTtJQUNILE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBUyxFQUFFLENBQVMsRUFBRSxDQUFTO1FBQ3BDLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUMzQixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFTLEVBQUUsQ0FBUyxFQUFFLEtBQWE7UUFDOUMsT0FBTyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUMvQixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxNQUFNLENBQUMsWUFBWSxDQUFDLEdBQVcsRUFBRSxLQUFhO1FBQzFDLElBQUcsS0FBSyxLQUFLLENBQUMsRUFBQztZQUNYLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUMxQjtRQUVELElBQUksTUFBTSxHQUFHLEVBQUUsQ0FBQztRQUNoQixPQUFNLEtBQUssR0FBRyxDQUFDLEVBQUM7WUFDWixNQUFNLElBQUksRUFBRSxDQUFDO1lBQ2IsS0FBSyxFQUFFLENBQUM7U0FDWDtRQUVELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUMsTUFBTSxDQUFDLEdBQUMsTUFBTSxDQUFDO0lBRXpDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFXO1FBQ3RCLE9BQU8sUUFBUSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQVcsRUFBRSxZQUFvQixJQUFJO1FBQzlDLElBQUksTUFBTSxHQUFHLENBQUMsQ0FBQztRQUNmLE9BQU0sTUFBTSxHQUFDLEVBQUUsR0FBRyxHQUFHLEVBQUM7WUFDbEIsTUFBTSxJQUFJLEVBQUUsQ0FBQztTQUNoQjtRQUNELElBQUksTUFBTSxHQUFHLEVBQUUsQ0FBQztRQUNoQixPQUFNLE1BQU0sSUFBSSxDQUFDLEVBQUM7WUFDZCxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBQyxNQUFNLENBQUMsQ0FBQztZQUNuQyxNQUFNLElBQUksU0FBUyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUN0QyxHQUFHLElBQUksS0FBSyxHQUFHLE1BQU0sQ0FBQztZQUN0QixNQUFNLElBQUksRUFBRSxDQUFDO1NBQ3RCO1FBRUQsSUFBRyxTQUFTLEtBQUssSUFBSSxFQUFDO1lBQ3JCLE9BQU0sTUFBTSxDQUFDLE1BQU0sR0FBRyxTQUFTLEVBQUM7Z0JBQy9CLE1BQU0sR0FBRyxHQUFHLEdBQUcsTUFBTSxDQUFDO2FBQ3RCO1NBQ0Q7UUFFSyxPQUFPLE1BQU0sQ0FBQztJQUNsQixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILE1BQU0sQ0FBQyxVQUFVLENBQUMsR0FBVztRQUN6QixJQUFHLEdBQUcsR0FBRyxFQUFFLEVBQUM7WUFDUixPQUFPLEVBQUUsR0FBRyxHQUFHLENBQUM7U0FDbkI7YUFBTTtZQUNILE9BQU8sTUFBTSxDQUFDLFlBQVksQ0FBQyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsQ0FBQyxDQUFDO1NBQzdDO0lBQ0wsQ0FBQztDQUNKO0FBM0tELDRCQTJLQzs7Ozs7Ozs7QUM5S0QsNkRBQXFDO0FBRXJDLE1BQU0sV0FBVyxHQUFHLENBQUUsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFO0lBQ3pDLEdBQUcsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsQ0FBQyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLEdBQUcsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEdBQUcsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFO0lBQzNFLEdBQUcsRUFBRSxDQUFDLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLEdBQUcsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLEVBQUU7SUFDM0UsRUFBRSxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUMsR0FBRyxFQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxHQUFHO0lBQzNFLEVBQUUsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEdBQUcsRUFBQyxFQUFFLEVBQUMsR0FBRztJQUMzRSxHQUFHLEVBQUMsR0FBRyxFQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUUsQ0FBQyxFQUFDLEdBQUcsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEdBQUcsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUUsRUFBRSxFQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUc7SUFDM0UsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUc7SUFDM0UsQ0FBQyxFQUFDLEdBQUcsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLEdBQUcsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxFQUFFLEVBQUMsRUFBRTtJQUMzRSxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFFLEVBQUUsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFFLEVBQUUsRUFBQyxHQUFHLEVBQUMsQ0FBQztJQUMzRSxHQUFHLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUUsRUFBRSxFQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFFLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxFQUFFLEVBQUMsR0FBRztJQUMzRSxHQUFHLEVBQUMsRUFBRSxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUMsRUFBRSxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsR0FBRztJQUMzRSxFQUFFLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFFLENBQUMsRUFBQyxHQUFHLEVBQUMsR0FBRztJQUMzRSxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsR0FBRztDQUN2RSxDQUFDO0FBRUY7O0dBRUc7QUFDSCxNQUFxQixNQUFNO0lBSzFCO1FBQ0MsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUM3QixLQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFDO1lBQzNCLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQUMsR0FBQyxHQUFHLENBQUMsQ0FBQztTQUMvQjtRQUNELElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDbEIsQ0FBQztJQUVFOzs7Ozs7T0FNRztJQUNOLE1BQU0sQ0FBQyxDQUFTLEVBQUUsQ0FBUyxFQUFFLElBQVksQ0FBQztRQUN6QyxJQUFHLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQ25CLENBQUMsR0FBRyxDQUFDLEdBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztZQUNsQixDQUFDLEdBQUcsQ0FBQyxHQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7WUFDbEIsQ0FBQyxHQUFHLENBQUMsR0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDO1NBQ2xCO1FBRUQsaURBQWlEO1FBQ2pELElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO1FBQzdCLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO1FBQzdCLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO1FBQzdCLGtEQUFrRDtRQUNsRCxJQUFJLEVBQUUsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMzQixJQUFJLEVBQUUsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMzQixJQUFJLEVBQUUsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUUzQix1RUFBdUU7UUFDdkUsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUN0QixJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3RCLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFdEIsNkJBQTZCO1FBQzdCLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFLLEVBQUUsQ0FBRSxHQUFLLEVBQUUsQ0FBRSxHQUFLLEVBQUUsQ0FBRSxDQUFDO1FBQzFELElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFLLEVBQUUsQ0FBRSxHQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBSyxFQUFFLENBQUUsQ0FBQztRQUMvRCxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBSyxFQUFFLENBQUUsR0FBSyxFQUFFLENBQUUsR0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDL0QsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUssRUFBRSxDQUFFLEdBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNwRSxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUssRUFBRSxDQUFFLEdBQUssRUFBRSxDQUFFLENBQUM7UUFDL0QsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBSyxFQUFFLENBQUUsQ0FBQztRQUNwRSxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUssRUFBRSxDQUFFLEdBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3BFLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBRXpFLDBDQUEwQztRQUN2QyxJQUFJLEVBQUUsR0FBRyxtQkFBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUksRUFBRSxFQUFJLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUUsR0FBRyxFQUFFLEVBQUUsR0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFJLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQzdGLElBQUksRUFBRSxHQUFHLG1CQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUUsR0FBRyxFQUFFLEVBQUUsRUFBSSxFQUFFLEdBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUUsR0FBRyxFQUFFLEVBQUUsR0FBQyxDQUFDLEVBQUUsRUFBRSxHQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUM3RixJQUFJLEVBQUUsR0FBRyxtQkFBUyxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBRW5DLEVBQUUsR0FBRyxtQkFBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUksRUFBRSxFQUFJLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFFLEdBQUcsRUFBRSxFQUFFLEdBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBSSxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDN0YsRUFBRSxHQUFHLG1CQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUUsR0FBRyxFQUFFLEVBQUUsRUFBSSxFQUFFLEdBQUMsQ0FBQyxFQUFFLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFFLEdBQUcsRUFBRSxFQUFFLEdBQUMsQ0FBQyxFQUFFLEVBQUUsR0FBQyxDQUFDLEVBQUUsRUFBRSxHQUFDLENBQUMs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QUFLLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDdEMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2xDLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUVwQyxJQUFJLElBQUksR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUM7UUFDaEUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzlILElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUV4SixJQUFJLENBQUMsU0FBUyxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxlQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxlQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxlQUFLLENBQUMsS0FBSyxDQUFDO0lBQ3hLLENBQUM7SUFFRCxJQUFJLE9BQU8sS0FBYSxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUUvQyxJQUFJLE9BQU8sQ0FBQyxPQUFnQjtRQUN4QixJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7UUFDakMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO0lBQ3ZDLENBQUM7Q0FHSjtBQWpFRCwrQkFpRUM7Ozs7Ozs7O0FDdEZELHNGQUFrRjtBQUtsRiw0RUFBb0Q7QUFDcEQsMEVBQWtEO0FBYWxEOzs7O0dBSUc7QUFDSCxNQUFxQixZQUFZO0lBMEI3QixZQUFtQixLQUFZLEVBQUUsU0FBb0IsRUFBRSxVQUFrQixFQUFFLE9BQW1CO1FBRTFGLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ25CLElBQUksQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO1FBQzNCLElBQUksQ0FBQyxVQUFVLEdBQUcsVUFBVSxDQUFDO1FBRTdCLDhDQUE4QztRQUM5QyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDO1FBQ3BDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQztRQUMvQixJQUFJLENBQUMsS0FBSyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUM7UUFDM0IsZ0NBQWdDO1FBQ2hDLElBQUksQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQztRQUNuQyxJQUFJLENBQUMsU0FBUyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUM7UUFFbkMsZ0RBQWdEO1FBQ2hELElBQUksS0FBSyxHQUFHLEtBQUssQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUNqQyxJQUFJLE1BQU0sR0FBRyxJQUFJLGNBQUksQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFcEMsNkJBQTZCO1FBQzdCLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxLQUFLLEVBQVUsQ0FBQztRQUNyQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ25DLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQzNFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUN2QztRQUNELDZDQUE2QztRQUM3QyxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDckMsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ3RDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDbkMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBQyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDckc7UUFDRCw2Q0FBNkM7UUFDN0MsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLEtBQUssRUFBUyxDQUFDO1FB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YyxHQUFTLEVBQUMsUUFBUSxFQUFFLGFBQWE7WUFDL0MsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUM7WUFDdkQsQ0FBQyxFQUFFLGFBQWEsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDO1lBQy9CLENBQUMsRUFBRSxXQUFXLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLEdBQUcsYUFBYSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUM7WUFDdEYsTUFBTSxFQUFFLFdBQVcsRUFBRSxDQUFDO1FBQzFCLElBQUksVUFBVSxHQUFTLEVBQUMsUUFBUSxFQUFFLFNBQVM7WUFDdkMsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUM7WUFDbkQsQ0FBQyxFQUFFLGFBQWEsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDO1lBQy9CLENBQUMsRUFBRSxXQUFXLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLEdBQUcsYUFBYSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUM7WUFDbEYsTUFBTSxFQUFFLFdBQVcsRUFBRSxDQUFDO1FBQzFCLElBQUksWUFBWSxHQUFTLEVBQUMsUUFBUSxFQUFFLFdBQVc7WUFDM0MsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUM7WUFDckQsQ0FBQyxFQUFFLGFBQWEsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDO1lBQy9CLENBQUMsRUFBRSxXQUFXLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLEdBQUcsYUFBYSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUM7WUFDcEYsTUFBTSxFQUFFLFdBQVcsRUFBRSxDQUFDO1FBQzFCLElBQUksWUFBWSxHQUFTLEVBQUMsUUFBUSxFQUFFLFdBQVc7WUFDM0MsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUM7WUFDckQsQ0FBQyxFQUFFLGFBQWEsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDO1lBQy9CLENBQUMsRUFBRSxXQUFXLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLEdBQUcsYUFBYSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUM7WUFDcEYsTUFBTSxFQUFFLFdBQVcsRUFBRSxDQUFDO1FBQzFCLElBQUksY0FBYyxHQUFTLEVBQUMsUUFBUSxFQUFFLGFBQWE7WUFDL0MsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUM7WUFDdkQsQ0FBQyxFQUFFLGFBQWEsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDO1lBQy9CLENBQUMsRUFBRSxXQUFXLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLEdBQUcsYUFBYSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUM7WUFDdEYsTUFBTSxFQUFFLFdBQVcsRUFBRSxDQUFDO1FBQzFCLElBQUksZUFBZSxHQUFTLEVBQUMsUUFBUSxFQUFFLGNBQWM7WUFDakQsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUM7WUFDeEQsQ0FBQyxFQUFFLGFBQWEsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDO1lBQy9CLENBQUMsRUFBRSxXQUFXLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLEdBQUcsYUFBYSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUM7WUFDdkYsTUFBTSxFQUFFLFdBQVcsRUFBRSxDQUFDO1FBQzFCLElBQUksV0FBVyxHQUFTLEVBQUMsUUFBUSxFQUFFLFVBQVU7WUFDekMsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUM7WUFDcEQsQ0FBQyxFQUFFLGFBQWEsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDO1lBQy9CLENBQUMsRUFBRSxXQUFXLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLEdBQUcsYUFBYSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUM7WUFDbkYsTUFBTSxFQUFFLFdBQVcsRUFBRSxDQUFDO1FBQzFCLElBQUksYUFBYSxHQUFTLEVBQUMsUUFBUSxFQUFFLFlBQVk7WUFDN0MsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUM7WUFDdEQsQ0FBQyxFQUFFLGFBQWEsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDO1lBQy9CLENBQUMsRUFBRSxXQUFXLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDLEdBQUcsYUFBYSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUM7WUFDckYsTUFBTSxFQUFFLFdBQVcsRUFBRSxDQUFDO1FBRTFCLElBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsSUFBSSxLQUFLO2VBQ3RDLElBQUksQ0FBQyxTQUFTLENBQUMsY0FBYyxFQUFFLE1BQU0sQ0FBQyxJQUFJLEtBQUs7ZUFDL0MsYUFBYSxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksYUFBYSxDQUFDLENBQUMsR0FBRyxDQUFDO1lBQ3pDLFdBQVcsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDckMsSUFBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxJQUFJLEtBQUs7ZUFDbEMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLEVBQUUsTUFBTSxDQUFDLElBQUksS0FBSztlQUMzQyxTQUFTLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxTQUFTLENBQUMsQ0FBQyxHQUFHLENBQUM7WUFDakMsV0FBVyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUNqQyxJQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLElBQUksS0FBSztlQUNwQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsWUFBWSxFQUFFLE1BQU0sQ0FBQyxJQUFJLEtBQUs7ZUFDOUMsV0FBVyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksV0FBVyxDQUFDLENBQUMsR0FBRyxDQUFDO1lBQ3JDLFdBQVcsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDbkMsSUFBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxJQUFJLEtBQUs7ZUFDbkMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxXQUFXLEVBQUUsTUFBTSxDQUFDLElBQUksS0FBSztlQUM1QyxVQUFVLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxVQUFVLENBQUMsQ0FBQyxHQUFHLENBQUM7WUFDbkMsV0FBVyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUNsQyxJQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLElBQUksS0FBSztlQUN2QyxJQUFJLENBQUMsU0FBUyxDQUFDLGVBQWUsRUFBRSxNQUFNLENBQUMsSUFBSSxLQUFLO2VBQ2hELGNBQWMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLGNBQWMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztZQUMzQyxXQUFXLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBQ3RDLElBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsSUFBSSxLQUFLO2VBQ3JDLElBQUksQ0FBQyxTQUFTLENBQUMsYUFBYSxFQUFFLE1BQU0sQ0FBQyxJQUFJLEtBQUs7ZUFDOUMsWUFBWSxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksWUFBWSxDQUFDLENBQUMsR0FBRyxDQUFDO1lBQ3ZDLFdBQVcsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDcEMsSUFBRyxJQUFJLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxJQUFJLEtBQUs7ZUFDdEMsSUFBSSxDQUFDLFNBQVMsQ0FB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QyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxtQkFBUyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztnQkFDdEUsQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsbUJBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsbUJBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7Z0JBQ3pHLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLG1CQUFTLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLG1CQUFTLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO2dCQUN6RyxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxtQkFBUyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxtQkFBUyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztnQkFDekcsQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsbUJBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVB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QUFDLENBQUM7Z0JBQ3hDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxtQkFBUyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUMzRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsbUJBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDM0UsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsbUJBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7Z0JBQzNFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLG1CQUFTLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO2dCQUMzRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsbUJBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsbUJBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7Z0JBQzlHLENBQUMsSUFB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LEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQztZQUMxSSxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBRXZDLEdBQUcsQ0FBQyxLQUFLLENBQUMsd0JBQWMsQ0FBQyxDQUFDO1lBQzFCLEdBQUcsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQzNCLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzNCO0lBR0wsQ0FBQztJQUVEOztPQUVHO0lBQ08sZUFBZTtRQUNyQixJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUNqRCxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksS0FBSyxDQUFXLFNBQVMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDN0QsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQzdDLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLFVBQVUsRUFBRSxTQUFTLENBQUMsQ0FBQztZQUNwRCxJQUFJLElBQUksR0FBUyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQywwQkFBVyxDQUFDLElBQUksRUFBRSxTQUFTLEVBQUUsRUFBQyxLQUFLLEVBQUUsY0FBSSxDQUFDLElBQUksRUFBRSxHQUFHLEVBQUUsY0FBSSxDQUFDLElBQUksRUFBQyxD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QUMsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxtQkFBUyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztnQkFDM0UsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsbUJBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7Z0JBQzNFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxtQkFBUyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxtQkFBUyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztnQkFDOUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLG1CQUFTLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLG1CQUFTLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO2dCQUM5RyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsbUJBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVB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RUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFDO1lBQzVCLEVBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBQztTQUMvQjtRQUNELFFBQVEsRUFBRSxLQUFLO1FBQ2YsU0FBUyxFQUFFLEtBQUssQ0FBc0IsMEVBQTBFO0tBQ25ILENBQUE7SUFFRCwyQkFBMkI7SUFFM0IsMkNBQTJDO0lBQzNDLE1BQU0sSUFBSSxHQUFHLElBQUksY0FBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBRS9CLGlCQUFpQjtJQUNqQixJQUFJLENBQUMsS0FBSyxDQUFDLGtCQUFRLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFFN0IsQ0FBQyxDQUFDLEVBQUUsQ0FBQztBQUVMLFNBQVMsUUFBUSxLQUFHLENBQUM7QUFBQSxDQUFDIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHdpZHRoID0gMjU2Oy8vIGVhY2ggUkM0IG91dHB1dCBpcyAwIDw9IHggPCAyNTZcclxudmFyIGNodW5rcyA9IDY7Ly8gYXQgbGVhc3Qgc2l4IFJDNCBvdXRwdXRzIGZvciBlYWNoIGRvdWJsZVxyXG52YXIgZGlnaXRzID0gNTI7Ly8gdGhlcmUgYXJlIDUyIHNpZ25pZmljYW50IGRpZ2l0cyBpbiBhIGRvdWJsZVxyXG52YXIgcG9vbCA9IFtdOy8vIHBvb2w6IGVudHJvcHkgcG9vbCBzdGFydHMgZW1wdHlcclxudmFyIEdMT0JBTCA9IHR5cGVvZiBnbG9iYWwgPT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsO1xyXG5cclxuLy9cclxuLy8gVGhlIGZvbGxvd2luZyBjb25zdGFudHMgYXJlIHJlbGF0ZWQgdG8gSUVFRSA3NTQgbGltaXRzLlxyXG4vL1xyXG52YXIgc3RhcnRkZW5vbSA9IE1hdGgucG93KHdpZHRoLCBjaHVua3MpLFxyXG4gICAgc2lnbmlmaWNhbmNlID0gTWF0aC5wb3coMiwgZGlnaXRzKSxcclxuICAgIG92ZXJmbG93ID0gc2lnbmlmaWNhbmNlICogMixcclxuICAgIG1hc2sgPSB3aWR0aCAtIDE7XHJcblxyXG5cclxudmFyIG9sZFJhbmRvbSA9IE1hdGgucmFuZG9tO1xyXG5cclxuLy9cclxuLy8gc2VlZHJhbmRvbSgpXHJcbi8vIFRoaXMgaXMgdGhlIHNlZWRyYW5kb20gZnVuY3Rpb24gZGVzY3JpYmVkIGFib3ZlLlxyXG4vL1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNlZWQsIG9wdGlvbnMpIHtcclxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmdsb2JhbCA9PT0gdHJ1ZSkge1xyXG4gICAgb3B0aW9ucy5nbG9iYWwgPSBmYWxzZTtcclxuICAgIE1hdGgucmFuZG9tID0gbW9kdWxlLmV4cG9ydHMoc2VlZCwgb3B0aW9ucyk7XHJcbiAgICBvcHRpb25zLmdsb2JhbCA9IHRydWU7XHJcbiAgICByZXR1cm4gTWF0aC5yYW5kb207XHJcbiAgfVxyXG4gIHZhciB1c2VfZW50cm9weSA9IChvcHRpb25zICYmIG9wdGlvbnMuZW50cm9weSkgfHwgZmFsc2U7XHJcbiAgdmFyIGtleSA9IFtdO1xyXG5cclxuICAvLyBGbGF0dGVuIHRoZSBzZWVkIHN0cmluZyBvciBidWlsZCBvbmUgZnJvbSBsb2NhbCBlbnRyb3B5IGlmIG5lZWRlZC5cclxuICB2YXIgc2hvcnRzZWVkID0gbWl4a2V5KGZsYXR0ZW4oXHJcbiAgICB1c2VfZW50cm9weSA/IFtzZWVkLCB0b3N0cmluZyhwb29sKV0gOlxyXG4gICAgMCBpbiBhcmd1bWVudHMgPyBzZWVkIDogYXV0b3NlZWQoKSwgMyksIGtleSk7XHJcblxyXG4gIC8vIFVzZSB0aGUgc2VlZCB0byBpbml0aWFsaXplIGFuIEFSQzQgZ2VuZXJhdG9yLlxyXG4gIHZhciBhcmM0ID0gbmV3IEFSQzQoa2V5KTtcclxuXHJcbiAgLy8gTWl4IHRoZSByYW5kb21uZXNzIGludG8gYWNjdW11bGF0ZWQgZW50cm9weS5cclxuICBtaXhrZXkodG9zdHJpbmcoYXJjNC5TKSwgcG9vbCk7XHJcblxyXG4gIC8vIE92ZXJyaWRlIE1hdGgucmFuZG9tXHJcblxyXG4gIC8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHJhbmRvbSBkb3VibGUgaW4gWzAsIDEpIHRoYXQgY29udGFpbnNcclxuICAvLyByYW5kb21uZXNzIGluIGV2ZXJ5IGJpdCBvZiB0aGUgbWFudGlzc2Egb2YgdGhlIElFRUUgNzU0IHZhbHVlLlxyXG5cclxuICByZXR1cm4gZnVuY3Rpb24oKSB7ICAgICAgICAgLy8gQ2xvc3VyZSB0byByZXR1cm4gYSByYW5kb20gZG91YmxlOlxyXG4gICAgdmFyIG4gPSBhcmM0LmcoY2h1bmtzKSwgICAgICAgICAgICAgLy8gU3RhcnQgd2l0aCBhIG51bWVyYXRvciBuIDwgMiBeIDQ4XHJcbiAgICAgICAgZCA9IHN0YXJ0ZGVub20sICAgICAgICAgICAgICAgICAvLyAgIGFuZCBkZW5vbWluYXRvciBkID0gMiBeIDQ4LlxyXG4gICAgICAgIHggPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBhbmQgbm8gJ2V4dHJhIGxhc3QgYnl0ZScuXHJcbiAgICB3aGlsZSAobiA8IHNpZ25pZmljYW5jZSkgeyAgICAgICAgICAvLyBGaWxsIHVwIGFsbCBzaWduaWZpY2FudCBkaWdpdHMgYnlcclxuICAgICAgbiA9IChuICsgeCkgKiB3aWR0aDsgICAgICAgICAgICAgIC8vICAgc2hpZnRpbmcgbnVtZXJhdG9yIGFuZFxyXG4gICAgICBkICo9IHdpZHRoOyAgICAgICAgICAgICAgICAgICAgICAgLy8gICBkZW5vbWluYXRvciBhbmQgZ2VuZXJhdGluZyBhXHJcbiAgICAgIHggPSBhcmM0LmcoMSk7ICAgICAgICAgICAgICAgICAgICAvLyAgIG5ldyBsZWFzdC1zaWduaWZpY2FudC1ieXRlLlxyXG4gICAgfVxyXG4gICAgd2hpbGUgKG4gPj0gb3ZlcmZsb3cpIHsgICAgICAgICAgICAgLy8gVG8gYXZvaWQgcm91bmRpbmcgdXAsIGJlZm9yZSBhZGRpbmdcclxuICAgICAgbiAvPSAyOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgbGFzdCBieXRlLCBzaGlmdCBldmVyeXRoaW5nXHJcbiAgICAgIGQgLz0gMjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIHJpZ2h0IHVzaW5nIGludGVnZXIgTWF0aCB1bnRpbFxyXG4gICAgICB4ID4+Pj0gMTsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICB3ZSBoYXZlIGV4YWN0bHkgdGhlIGRlc2lyZWQgYml0cy5cclxuICAgIH1cclxuICAgIHJldHVybiAobiArIHgpIC8gZDsgICAgICAgICAgICAgICAgIC8vIEZvcm0gdGhlIG51bWJlciB3aXRoaW4gWzAsIDEpLlxyXG4gIH07XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5yZXNldEdsb2JhbCA9IGZ1bmN0aW9uICgpIHtcclxuICBNYXRoLnJhbmRvbSA9IG9sZFJhbmRvbTtcclxufTtcclxuXHJcbi8vXHJcbi8vIEFSQzRcclxuLy9cclxuLy8gQW4gQVJDNCBpbXBsZW1lbnRhdGlvbi4gIFRoZSBjb25zdHJ1Y3RvciB0YWtlcyBhIGtleSBpbiB0aGUgZm9ybSBvZlxyXG4vLyBhbiBhcnJheSBvZiBhdCBtb3N0ICh3aWR0aCkgaW50ZWdlcnMgdGhhdCBzaG91bGQgYmUgMCA8PSB4IDwgKHdpZHRoKS5cclxuLy9cclxuLy8gVGhlIGcoY291bnQpIG1ldGhvZCByZXR1cm5zIGEgcHNldWRvcmFuZG9tIGludGVnZXIgdGhhdCBjb25jYXRlbmF0ZXNcclxuLy8gdGhlIG5leHQgKGNvdW50KSBvdXRwdXRzIGZyb20gQVJDNC4gIEl0cyByZXR1cm4gdmFsdWUgaXMgYSBudW1iZXIgeFxyXG4vLyB0aGF0IGlzIGluIHRoZSByYW5nZSAwIDw9IHggPCAod2lkdGggXiBjb3VudCkuXHJcbi8vXHJcbi8qKiBAY29uc3RydWN0b3IgKi9cclxuZnVuY3Rpb24gQVJDNChrZXkpIHtcclxuICB2YXIgdCwga2V5bGVuID0ga2V5Lmxlbmd0aCxcclxuICAgICAgbWUgPSB0aGlzLCBpID0gMCwgaiA9IG1lLmkgPSBtZS5qID0gMCwgcyA9IG1lLlMgPSBbXTtcclxuXHJcbiAgLy8gVGhlIGVtcHR5IGtleSBbXSBpcyB0cmVhdGVkIGFzIFswXS5cclxuICBpZiAoIWtleWxlbikgeyBrZXkgPSBba2V5bGVuKytdOyB9XHJcblxyXG4gIC8vIFNldCB1cCBTIHVzaW5nIHRoZSBzdGFuZGFyZCBrZXkgc2NoZWR1bGluZyBhbGdvcml0aG0uXHJcbiAgd2hpbGUgKGkgPCB3aWR0aCkge1xyXG4gICAgc1tpXSA9IGkrKztcclxuICB9XHJcbiAgZm9yIChpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcclxuICAgIHNbaV0gPSBzW2ogPSBtYXNrICYgKGogKyBrZXlbaSAlIGtleWxlbl0gKyAodCA9IHNbaV0pKV07XHJcbiAgICBzW2pdID0gdDtcclxuICB9XHJcblxyXG4gIC8vIFRoZSBcImdcIiBtZXRob2QgcmV0dXJucyB0aGUgbmV4dCAoY291bnQpIG91dHB1dHMgYXMgb25lIG51bWJlci5cclxuICAobWUuZyA9IGZ1bmN0aW9uKGNvdW50KSB7XHJcbiAgICAvLyBVc2luZyBpbnN0YW5jZSBtZW1iZXJzIGluc3RlYWQgb2YgY2xvc3VyZSBzdGF0ZSBuZWFybHkgZG91YmxlcyBzcGVlZC5cclxuICAgIHZhciB0LCByID0gMCxcclxuICAgICAgICBpID0gbWUuaSwgaiA9IG1lLmosIHMgPSBtZS5TO1xyXG4gICAgd2hpbGUgKGNvdW50LS0pIHtcclxuICAgICAgdCA9IHNbaSA9IG1hc2sgJiAoaSArIDEpXTtcclxuICAgICAgciA9IHIgKiB3aWR0aCArIHNbbWFzayAmICgoc1tpXSA9IHNbaiA9IG1hc2sgJiAoaiArIHQpXSkgKyAoc1tqXSA9IHQpKV07XHJcbiAgICB9XHJcbiAgICBtZS5pID0gaTsgbWUuaiA9IGo7XHJcbiAgICByZXR1cm4gcjtcclxuICAgIC8vIEZvciByb2J1c3QgdW5wcmVkaWN0YWJpbGl0eSBkaXNjYXJkIGFuIGluaXRpYWwgYmF0Y2ggb2YgdmFsdWVzLlxyXG4gICAgLy8gU2VlIGh0dHA6Ly93d3cucnNhLmNvbS9yc2FsYWJzL25vZGUuYXNwP2lkPTIwMDlcclxuICB9KSh3aWR0aCk7XHJcbn1cclxuXHJcbi8vXHJcbi8vIGZsYXR0ZW4oKVxyXG4vLyBDb252ZXJ0cyBhbiBvYmplY3QgdHJlZSB0byBuZXN0ZWQgYXJyYXlzIG9mIHN0cmluZ3MuXHJcbi8vXHJcbmZ1bmN0aW9uIGZsYXR0ZW4ob2JqLCBkZXB0aCkge1xyXG4gIHZhciByZXN1bHQgPSBbXSwgdHlwID0gKHR5cGVvZiBvYmopWzBdLCBwcm9wO1xyXG4gIGlmIChkZXB0aCAmJiB0eXAgPT0gJ28nKSB7XHJcbiAgICBmb3IgKHByb3AgaW4gb2JqKSB7XHJcbiAgICAgIHRyeSB7IHJlc3VsdC5wdXNoKGZsYXR0ZW4ob2JqW3Byb3BdLCBkZXB0aCAtIDEpKTsgfSBjYXRjaCAoZSkge31cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIChyZXN1bHQubGVuZ3RoID8gcmVzdWx0IDogdHlwID09ICdzJyA/IG9iaiA6IG9iaiArICdcXDAnKTtcclxufVxyXG5cclxuLy9cclxuLy8gbWl4a2V5KClcclxuLy8gTWl4ZXMgYSBzdHJpbmcgc2VlZCBpbnRvIGEga2V5IHRoYXQgaXMgYW4gYXJyYXkgb2YgaW50ZWdlcnMsIGFuZFxyXG4vLyByZXR1cm5zIGEgc2hvcnRlbmVkIHN0cmluZyBzZWVkIHRoYXQgaXMgZXF1aXZhbGVudCB0byB0aGUgcmVzdWx0IGtleS5cclxuLy9cclxuZnVuY3Rpb24gbWl4a2V5KHNlZWQsIGtleSkge1xyXG4gIHZhciBzdHJpbmdzZWVkID0gc2VlZCArICcnLCBzbWVhciwgaiA9IDA7XHJcbiAgd2hpbGUgKGogPCBzdHJpbmdzZWVkLmxlbmd0aCkge1xyXG4gICAga2V5W21hc2sgJiBqXSA9XHJcbiAgICAgIG1hc2sgJiAoKHNtZWFyIF49IGtleVttYXNrICYgal0gKiAxOSkgKyBzdHJpbmdzZWVkLmNoYXJDb2RlQXQoaisrKSk7XHJcbiAgfVxyXG4gIHJldHVybiB0b3N0cmluZyhrZXkpO1xyXG59XHJcblxyXG4vL1xyXG4vLyBhdXRvc2VlZCgpXHJcbi8vIFJldHVybnMgYW4gb2JqZWN0IGZvciBhdXRvc2VlZGluZywgdXNpbmcgd2luZG93LmNyeXB0byBpZiBhdmFpbGFibGUuXHJcbi8vXHJcbi8qKiBAcGFyYW0ge1VpbnQ4QXJyYXk9fSBzZWVkICovXHJcbmZ1bmN0aW9uIGF1dG9zZWVkKHNlZWQpIHtcclxuICB0cnkge1xyXG4gICAgR0xPQkFMLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoc2VlZCA9IG5ldyBVaW50OEFycmF5KHdpZHRoKSk7XHJcbiAgICByZXR1cm4gdG9zdHJpbmcoc2VlZCk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgcmV0dXJuIFsrbmV3IERhdGUsIEdMT0JBTCwgR0xPQkFMLm5hdmlnYXRvciAmJiBHTE9CQUwubmF2aWdhdG9yLnBsdWdpbnMsXHJcbiAgICAgICAgICAgIEdMT0JBTC5zY3JlZW4sIHRvc3RyaW5nKHBvb2wpXTtcclxuICB9XHJcbn1cclxuXHJcbi8vXHJcbi8vIHRvc3RyaW5nKClcclxuLy8gQ29udmVydHMgYW4gYXJyYXkgb2YgY2hhcmNvZGVzIHRvIGEgc3RyaW5nXHJcbi8vXHJcbmZ1bmN0aW9uIHRvc3RyaW5nKGEpIHtcclxuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSgwLCBhKTtcclxufVxyXG5cclxuLy9cclxuLy8gV2hlbiBzZWVkcmFuZG9tLmpzIGlzIGxvYWRlZCwgd2UgaW1tZWRpYXRlbHkgbWl4IGEgZmV3IGJpdHNcclxuLy8gZnJvbSB0aGUgYnVpbHQtaW4gUk5HIGludG8gdGhlIGVudHJvcHkgcG9vbC4gIEJlY2F1c2Ugd2UgZG9cclxuLy8gbm90IHdhbnQgdG8gaW50ZWZlcmUgd2l0aCBkZXRlcm1pbnN0aWMgUFJORyBzdGF0ZSBsYXRlcixcclxuLy8gc2VlZHJhbmRvbSB3aWxsIG5vdCBjYWxsIE1hdGgucmFuZG9tIG9uIGl0cyBvd24gYWdhaW4gYWZ0ZXJcclxuLy8gaW5pdGlhbGl6YXRpb24uXHJcbi8vXHJcbm1peGtleShNYXRoLnJhbmRvbSgpLCBwb29sKTtcclxuIiwiaW1wb3J0IEFjdG9yIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9BY3RvclwiO1xuaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcbmltcG9ydCBBSSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvQUlcIjtcbmltcG9ydCBHb2FwQUkgZnJvbSBcIi4uL0RhdGFUeXBlcy9Hb2FwL0dvYXBBSVwiXG5pbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvQ29sbGVjdGlvbnMvTWFwXCI7XG5cbi8qKlxuICogQSBtYW5hZ2VyIGNsYXNzIGZvciBhbGwgb2YgdGhlIEFJIGluIGEgc2NlbmUuXG4gKiBLZWVwcyBhIGxpc3Qgb2YgcmVnaXN0ZXJlZCBhY3RvcnMgYW5kIGhhbmRsZXMgQUkgZ2VuZXJhdGlvbiBmb3IgYWN0b3JzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBSU1hbmFnZXIgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcblx0LyoqIFRoZSBhcnJheSBvZiByZWdpc3RlcmVkIGFjdG9ycyAqL1xuXHRhY3RvcnM6IEFycmF5PEFjdG9yPjtcblx0LyoqIE1hcHMgQUkgbmFtZXMgdG8gdGhlaXIgY29uc3RydWN0b3JzICovXG5cdHJlZ2lzdGVyZWRBSTogTWFwPEFJQ29uc3RydWN0b3I+O1xuXG5cdGNvbnN0cnVjdG9yKCl7XG5cdFx0dGhpcy5hY3RvcnMgPSBuZXcgQXJyYXkoKTtcblx0XHR0aGlzLnJlZ2lzdGVyZWRBSSA9IG5ldyBNYXAoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgYW4gYWN0b3Igd2l0aCB0aGUgQUlNYW5hZ2VyXG5cdCAqIEBwYXJhbSBhY3RvciBUaGUgYWN0b3IgdG8gcmVnaXN0ZXJcblx0ICovXG5cdHJlZ2lzdGVyQWN0b3IoYWN0b3I6IEFjdG9yKTogdm9pZCB7XG5cdFx0dGhpcy5hY3RvcnMucHVzaChhY3Rvcik7XG5cdH1cblxuXHRyZW1vdmVBY3RvcihhY3RvcjogQWN0b3IpOiB2b2lkIHtcblx0XHRsZXQgaW5kZXggPSB0aGlzLmFjdG9ycy5pbmRleE9mKGFjdG9yKTtcblxuXHRcdGlmKGluZGV4ICE9PSAtMSl7XG5cdFx0XHR0aGlzLmFjdG9ycy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgYW4gQUkgd2l0aCB0aGUgQUlNYW5hZ2VyIGZvciB1c2UgbGF0ZXIgb25cblx0ICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIEFJIHRvIHJlZ2lzdGVyXG5cdCAqIEBwYXJhbSBjb25zdHIgVGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgQUlcblx0ICovXG5cdHJlZ2lzdGVyQUkobmFtZTogc3RyaW5nLCBjb25zdHI6IG5ldyA8VCBleHRlbmRzIEFJIHwgR29hcEFJPigpID0+IFQgKTogdm9pZCB7XG5cdFx0dGhpcy5yZWdpc3RlcmVkQUkuYWRkKG5hbWUsIGNvbnN0cik7XG5cdH1cblxuXHQvKipcblx0ICogR2VuZXJhdGVzIGFuIEFJIGluc3RhbmNlIGZyb20gaXRzIG5hbWVcblx0ICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIEFJIHRvIGFkZFxuXHQgKiBAcmV0dXJucyBBIG5ldyBBSSBpbnN0YW5jZVxuXHQgKi9cblx0Z2VuZXJhdGVBSShuYW1lOiBzdHJpbmcpOiBBSSB8IEdvYXBBSSB7XG5cdFx0aWYodGhpcy5yZWdpc3RlcmVkQUkuaGFzKG5hbWUpKXtcblx0XHRcdHJldHVybiBuZXcgKHRoaXMucmVnaXN0ZXJlZEFJLmdldChuYW1lKSkoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgYENhbm5vdCBjcmVhdGUgQUkgd2l0aCBuYW1lICR7bmFtZX0sIG5vIEFJIHdpdGggdGhhdCBuYW1lIGlzIHJlZ2lzdGVyZWRgO1xuXHRcdH1cblx0fVxuXG5cdHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuXHRcdC8vIFJ1biB0aGUgYWkgZm9yIGV2ZXJ5IGFjdGl2ZSBhY3RvclxuXHRcdHRoaXMuYWN0b3JzLmZvckVhY2goYWN0b3IgPT4geyBpZihhY3Rvci5haUFjdGl2ZSkgYWN0b3IuYWkudXBkYXRlKGRlbHRhVCkgfSk7XG5cdH1cbn1cblxudHlwZSBBSUNvbnN0cnVjdG9yID0gbmV3IDxUIGV4dGVuZHMgQUk+KCkgPT4gVDsiLCJpbXBvcnQgQWN0b3IgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL0FjdG9yXCI7XG5pbXBvcnQgU3RhdGUgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9TdGF0ZS9TdGF0ZVwiO1xuaW1wb3J0IFN0YXRlTWFjaGluZUdvYXBBSSBmcm9tIFwiLi9TdGF0ZU1hY2hpbmVHb2FwQUlcIjtcblxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgR29hcEFjdGlvbiBleHRlbmRzIFN0YXRlIHtcblxuICAgIHByb3RlY3RlZCBwYXJlbnQ6IFN0YXRlTWFjaGluZUdvYXBBSTxHb2FwQWN0aW9uPlxuICAgIHByb3RlY3RlZCBhY3RvcjogQWN0b3I7XG5cbiAgICBwcm90ZWN0ZWQgX3ByZWNvbmRpdGlvbnM6IFNldDxzdHJpbmc+O1xuICAgIHByb3RlY3RlZCBfZWZmZWN0czogU2V0PHN0cmluZz47XG4gICAgcHJvdGVjdGVkIF9jb3N0OiBudW1iZXI7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IocGFyZW50OiBTdGF0ZU1hY2hpbmVHb2FwQUk8R29hcEFjdGlvbj4sIGFjdG9yOiBBY3Rvcikge1xuICAgICAgICBzdXBlcihwYXJlbnQpO1xuICAgICAgICB0aGlzLmFjdG9yID0gYWN0b3I7XG4gICAgICAgIHRoaXMuX3ByZWNvbmRpdGlvbnMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICAgICAgdGhpcy5fZWZmZWN0cyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgICAgICB0aGlzLl9jb3N0ID0gMDtcbiAgICB9XG5cbiAgICAvKiogQ29zdCBpdCB0YWtlcyB0byBjb21wbGV0ZSB0aGlzIGFjdGlvbiAqL1xuICAgIGdldCBjb3N0KCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9jb3N0OyB9XG4gICAgc2V0IGNvc3QoY29zdDogbnVtYmVyKSB7IHRoaXMuX2Nvc3QgPSBjb3N0OyB9XG5cbiAgICAvKiogUHJlY29uZGl0aW9ucyB0aGF0IGhhdmUgdG8gYmUgc2F0aXNmaWVkIGZvciBhbiBhY3Rpb24gdG8gaGFwcGVuICovXG4gICAgZ2V0IHByZWNvbmRpdGlvbnMoKTogc3RyaW5nW10geyByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9wcmVjb25kaXRpb25zLnZhbHVlcygpKTsgfTtcblxuICAgIC8qKiBSZXN1bHRpbmcgc3RhdHVzZXMgYWZ0ZXIgdGhpcyBhY3Rpb24gY29tcGxldGVzICovXG4gICAgZ2V0IGVmZmVjdHMoKTogc3RyaW5nW10geyByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9lZmZlY3RzLnZhbHVlcygpKTsgfVxuXG4gICAgcHVibGljIGNoZWNrUHJlY29uZGl0aW9ucyhzdGF0dXM6IHN0cmluZ1tdKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX3ByZWNvbmRpdGlvbnMudmFsdWVzKCkpLmV2ZXJ5KHByZWNvbmRpdGlvbiA9PiBzdGF0dXMuaW5jbHVkZXMocHJlY29uZGl0aW9uKSk7XG4gICAgfVxuXG4gICAgcHVibGljIGFkZFByZWNvbmRpdGlvbihzdGF0dXM6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLl9wcmVjb25kaXRpb25zLmFkZChzdGF0dXMpO1xuICAgIH1cbiAgICBwdWJsaWMgYWRkRWZmZWN0KHN0YXR1czogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2VmZmVjdHMuYWRkKHN0YXR1cyk7XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIGZpbmlzaGVkKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnBhcmVudC5jaGFuZ2VTdGF0ZSgpO1xuICAgIH1cblxufVxuXG5leHBvcnQgZW51bSBHb2FwQWN0aW9uU3RhdHVzIHtcbiAgICBGQUlMVVJFID0gMCxcbiAgICBTVUNDRVNTID0gMSxcbiAgICBSVU5OSU5HID0gMlxufSIsImltcG9ydCBHcmFwaCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL0dyYXBocy9HcmFwaFwiO1xuaW1wb3J0IEdvYXBBY3Rpb24gZnJvbSBcIi4vR29hcEFjdGlvblwiO1xuaW1wb3J0IFN0YWNrIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvQ29sbGVjdGlvbnMvU3RhY2tcIjtcbmltcG9ydCBHcmFwaFV0aWxzIGZyb20gXCIuLi8uLi9VdGlscy9HcmFwaFV0aWxzXCI7XG5pbXBvcnQgQUkgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL0FJXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdvYXBBY3Rpb25QbGFubmVyIHtcbiAgICBcbiAgICBwdWJsaWMgc3RhdGljIHBsYW48VCBleHRlbmRzIEdvYXBBY3Rpb24+KHN0YXR1czogc3RyaW5nW10sIGdvYWw6IHN0cmluZywgYWN0aW9uczogQXJyYXk8VD4pOiBTdGFjazxUPiB7XG4gICAgICAgIGxldCBncmFwaDogR3JhcGggPSBuZXcgR3JhcGgodHJ1ZSk7XG4gICAgICAgIGxldCBtYXBwaW5nOiBNYXA8bnVtYmVyLCBUIHwgc3RyaW5nPiA9IG5ldyBNYXAoKTtcblxuICAgICAgICAvLzAgaXMgb3VyIHJvb3RcbiAgICAgICAgZ3JhcGguYWRkTm9kZSgpO1xuICAgICAgICBtYXBwaW5nLnNldCgwLFwiU3RhcnRcIik7XG4gICAgICAgIC8vMSBpcyB0aGUgZ29hbFxuICAgICAgICBncmFwaC5hZGROb2RlKCk7XG4gICAgICAgIG1hcHBpbmcuc2V0KDEsXCJHb2FsXCIpO1xuICAgICAgICBncmFwaC5hZGRFZGdlKDEsMSxOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuXG4gICAgICAgIC8vQnVpbGQgdHJlZSBmcm9tIDAgdG8gMVxuICAgICAgICB0aGlzLmJ1aWxkVHJlZTxUPihzdGF0dXMsIGFjdGlvbnMsIDAsIGdvYWwsIG1hcHBpbmcsIGdyYXBoKTtcblxuICAgICAgICAvL1J1biBkamlrc3RyYSB0byBmaW5kIHNob3J0ZXN0IHBhdGhcbiAgICAgICAgbGV0IHBhdGg6IEFycmF5PG51bWJlcj4gPSBHcmFwaFV0aWxzLmRqaWtzdHJhKGdyYXBoLCAwKTtcblxuICAgICAgICAvL1B1c2ggYWxsIGVsZW1lbnRzIG9mIHRoZSBwbGFuXG4gICAgICAgIGxldCBwbGFuID0gbmV3IFN0YWNrPFQ+KCk7XG5cdFx0XG5cdFx0bGV0IGkgPSAxO1xuXHRcdHdoaWxlKHBhdGhbaV0gIT09IC0xKXtcbiAgICAgICAgICAgIGlmIChwYXRoW2ldICE9PSAwKXtcblx0XHRcdCAgICBwbGFuLnB1c2goPFQ+bWFwcGluZy5nZXQocGF0aFtpXSkpO1xuICAgICAgICAgICAgfVxuXHRcdFx0aSA9IHBhdGhbaV07XG5cdFx0fVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHBsYW47XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgYnVpbGRUcmVlICA8VCBleHRlbmRzIEdvYXBBY3Rpb24+IChzdGF0dXM6IHN0cmluZ1tdLCBhY3Rpb25zOiBBcnJheTxUPiwgcm9vdDogbnVtYmVyLCBnb2FsOiBzdHJpbmcsIG1hcHBpbmc6IE1hcDxudW1iZXIsIFQgfCBzdHJpbmc+LCBncmFwaDogR3JhcGgpOiB2b2lkIHtcbiAgICAgICAgLy9Gb3IgZWFjaCBwb3NzaWJsZSBhY3Rpb24gXG4gICAgICAgIGFjdGlvbnMuZm9yRWFjaChhY3Rpb24gPT4ge1xuICAgICAgICAgICAgLy9DYW4gaXQgYmUgcGVyZm9ybWVkP1xuICAgICAgICAgICAgaWYgKGFjdGlvbi5jaGVja1ByZWNvbmRpdGlvbnMoc3RhdHVzKSl7XG4gICAgICAgICAgICAgICAgLy9UaGlzIGFjdGlvbiBjYW4gYmUgcGVyZm9ybWVkXG4gICAgICAgICAgICAgICAgLy9BZGQgZWZmZWN0cyB0byBjdXJyZW50U3RhdHVzXG4gICAgICAgICAgICAgICAgbGV0IG5ld1N0YXR1cyA9IFsuLi5zdGF0dXNdO1xuICAgICAgICAgICAgICAgIG5ld1N0YXR1cy5wdXNoKC4uLmFjdGlvbi5lZmZlY3RzKTtcblxuICAgICAgICAgICAgICAgIC8vQ2hlY2sgaWYgdGhlIG5ldyBub2RlIGlzIHRoZSBnb2FsXG4gICAgICAgICAgICAgICAgaWYgKG5ld1N0YXR1cy5pbmNsdWRlcyhnb2FsKSl7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdOb2RlID0gZ3JhcGguYWRkTm9kZSgpO1xuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLnNldChuZXdOb2RlLCBhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICBncmFwaC5hZGRFZGdlKHJvb3QsIG5ld05vZGUsIGFjdGlvbi5jb3N0KTtcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGguYWRkRWRnZShuZXdOb2RlLCAxLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vQWRkIG5vZGUgYW5kIGVkZ2UgZnJvbSByb290XG4gICAgICAgICAgICAgICAgbGV0IG5ld05vZGUgPSBncmFwaC5hZGROb2RlKCk7XG4gICAgICAgICAgICAgICAgbWFwcGluZy5zZXQobmV3Tm9kZSwgYWN0aW9uKTtcbiAgICAgICAgICAgICAgICBncmFwaC5hZGRFZGdlKHJvb3QsIG5ld05vZGUsIGFjdGlvbi5jb3N0KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvL1JlY3Vyc2l2ZSBjYWxsXG4gICAgICAgICAgICAgICAgbGV0IG5ld0FjdGlvbnMgPSBhY3Rpb25zLmZpbHRlcihhY3QgPT4gYWN0ICE9PSBhY3Rpb24pXG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZFRyZWUobmV3U3RhdHVzLCBuZXdBY3Rpb25zLCBuZXdOb2RlLCBnb2FsLCBtYXBwaW5nLCBncmFwaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn0iLCJpbXBvcnQgQWN0b3IgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL0FjdG9yXCI7XG5cbi8qKlxuICogQSBzdGF0ZSBmb3IgYSBHb2FwQUkuIFRoZSBcInN0YXRlXCIgaXMgbm90IHRoZSBzYW1lIGFzIGEgc3RhdGUgaW4gYSBzdGF0ZSBtYWNoaW5lLCBvciBzb21ldGhpbmcgb2YgdGhhdCBuYXR1cmUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIEdvYXBTdGF0ZSB7XG5cbiAgICBwdWJsaWMgYWJzdHJhY3QgaXNTYXRpc2ZpZWQoKTogYm9vbGVhbjtcbiAgICBcbn0iLCJpbXBvcnQgU3RhY2sgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9Db2xsZWN0aW9ucy9TdGFja1wiO1xuaW1wb3J0IEdvYXBBY3Rpb24gZnJvbSBcIi4vR29hcEFjdGlvblwiO1xuaW1wb3J0IEdvYXBBY3Rpb25QbGFubmVyIGZyb20gXCIuL0dvYXBBY3Rpb25QbGFubmVyXCJcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uLy4uL0V2ZW50cy9HYW1lRXZlbnRcIjtcbmltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vLi4vTm9kZXMvR2FtZU5vZGVcIjtcbmltcG9ydCBBSSBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvQUlcIjtcbmltcG9ydCBNYXAgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9Db2xsZWN0aW9ucy9NYXBcIjtcbmltcG9ydCBBY3RvciBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvQWN0b3JcIjtcbmltcG9ydCBHb2FwU3RhdGUgZnJvbSBcIi4vR29hcFN0YXRlXCI7XG5pbXBvcnQgU3RhdGVNYWNoaW5lQUkgZnJvbSBcIi4uL1N0YXRlTWFjaGluZUFJXCI7XG5cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgYmFzaWMgR29hcCBiZWhhdmlvci5cbiAqIFxuICogR09BUCByZXF1aXJlcyBhIGxvdCBvZiBvdmVyaGVhZCBmb3IgbWFuYWdpbmcgYWxsIG9mIHRoZSBzeW1ib2xzIChzdGF0dXNlcyBhbmQgZ29hbHMpLCB0aGVcbiAqIGFjdHVhbCBnb2FwLWFjdGlvbnMsIGFuZCBjcmVhdGluZyB0aGUgYWN0aW9uIHBsYW5zLiBcbiAqIFxuICogSSd2ZSBvcHRlZCB0byB0cnkgYW5kIGV4dGVuZCB0aGUgU3RhdGVNYWNoaW5lQUkgZm9yIHRoaXMgY2xhc3MsIG1vc3RseSB0byB0cnkgYW5kIGtlZXAgdGhpbmdzXG4gKiBzaW1pbGFyIHRvIHRoZSBTdGF0ZU1hY2hpbmVBSS4gTXkgU3RhdGVNYWNoaW5lR29hcEFJIGNsYXNzIGtpbmQgb2YgYnJlYWtzIExTUCAoTGlza292J3Mgc3Vic3RpdHV0aW9uIHByaW5jaXBsZSlcbiAqIHdoaWNoIGN1ZXMgbWUgaW50byB0aGUgZmFjdCB0aGF0IEkgc2hvdWxkIHByb2JhYmx5IG1ha2UgYSBzZXBlcmF0ZSBjbGFzcy5cbiAqIFxuICogU29tZXRoaW5nIEknZCBsaWtlIHRvIGFkZCBpcyBhbiBhZGRpdGlvbmFsIGNsYXNzIGZvciBtYW5hZ2luZyBhIHNldCBvZiBnb2Fscy4gVGhlIGdvYWxzIFxuICogYXJlIHByZXR0eSBzaW1pbGFyIHRvIHN0YXR1c2VzLCBleGNlcHQgdGhhdCBnb2FscyBoYXZlIHNvbWUga2luZCBvZmYgcHJpb3JpdHkgYXNzb2NpYXRlZFxuICogd2l0aCB0aGVtLiBOb3Qgc3VyZSBob3cgd2UnZCBkbyB0aGlzLlxuICogXG4gKiBAYXV0aG9yIFBldGVyIFdhbHNoXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFN0YXRlTWFjaGluZUdvYXBBSTxUIGV4dGVuZHMgR29hcEFjdGlvbj4gZXh0ZW5kcyBTdGF0ZU1hY2hpbmVBSSB7XG5cbiAgICAvKiogVGhlIHBhcmVudCBBY3RvciBvZiB0aGlzIEdvYXBBSSAqL1xuICAgIHByb3RlY3RlZCBvd25lcjogR2FtZU5vZGU7XG5cbiAgICAvKiogVGhlIGdvYWwvc3RhdHVzIHdlJ3JlIHRyeWluZyB0byByZWFjaCAqL1xuICAgIHByb3RlY3RlZCBnb2FsOiBzdHJpbmc7XG4gICAgLyoqIEFsbCBzdGF0dXNlcyBmb3IgdGhpcyBHb2FwQUkgKi9cbiAgICBwcm90ZWN0ZWQgc3RhdHVzZXM6IE1hcDxHb2FwU3RhdGU+XG4gICAgLyoqIEFsbCBvZiB0aGUgYWN0aW9uIHRoZSBHT0FQIEFJIGNhbiBwZXJmb3JtICovXG4gICAgcHJvdGVjdGVkIHN0YXRlTWFwOiBNYXA8VD47XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc3RhdHVzZXMgPSBuZXcgTWFwPEdvYXBTdGF0ZT4oKTtcbiAgICAgICAgdGhpcy5zdGF0ZU1hcCA9IG5ldyBNYXA8VD4oKTtcbiAgICAgICAgdGhpcy5zdGFjayA9IG5ldyBTdGFjazxUPigpO1xuICAgICAgICB0aGlzLmdvYWwgPSBudWxsO1xuICAgIH1cblxuXG4gICAgcHVibGljIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBzdXBlci51cGRhdGUoZGVsdGFUKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgaW5pdGlhbGl6ZSgpOiB2b2lkIHtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgQUkgYnkgYnVpbGRpbmcgYSBwbGFuIGZyb20gdGhlIHRoZSBjdXJyZW50IGFjdGlvbnNcbiAgICAgICAgdGhpcy5zdGFjayA9IHRoaXMuYnVpbGRQbGFuKCk7XG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gdGhpcy5zdGFjay5wZWVrKCk7XG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlLm9uRW50ZXIoe30pO1xuICAgICAgICB0aGlzLnNldEFjdGl2ZSh0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBOT1RFOyB0aGlzIG1ldGhvZCBtaWdodCB0cmlnZ2VyIGluZmluaXRlIHJlY3Vyc2lvbiBpbiB5b3VyIEdPQVAgQUkgLSBQZXRleWx1bXBraW5zXG4gICAgcHVibGljIG92ZXJyaWRlIGNoYW5nZVN0YXRlKCk6IHZvaWQge1xuICAgICAgICAvLyBFeGl0IHRoZSBjdXJyZW50IHN0YXRlXG4gICAgICAgIGxldCBvcHRpb25zID0gdGhpcy5jdXJyZW50U3RhdGUub25FeGl0KCk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBwcmV2aW91cyBzdGF0ZVxuICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuXG4gICAgICAgIC8vIElmIHRoZSBwbGFuIGlzIGVtcHR5LCBidWlsZCBhIG5ldyBwbGFuXG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdGhpcy5zdGFjayA9IHRoaXMuYnVpbGRQbGFuKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdGhlIGN1cnJlbnQgYWN0aW9uXG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gdGhpcy5zdGFjay5wZWVrKCk7XG5cbiAgICAgICAgLy8gRW1pdCBhbiBldmVudCBpZiB0dXJuZWQgb25cbiAgICAgICAgaWYodGhpcy5lbWl0RXZlbnRPblN0YXRlQ2hhbmdlKXtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQodGhpcy5zdGF0ZUNoYW5nZUV2ZW50TmFtZSwge3N0YXRlOiB0aGlzLmN1cnJlbnRTdGF0ZX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW50ZXIgdGhlIG5ldyBhY3Rpb25cbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUub25FbnRlcihvcHRpb25zKTtcbiAgICB9XG4gICBcbiAgICBwcm90ZWN0ZWQgYnVpbGRQbGFuKCk6IFN0YWNrPFQ+IHtcbiAgICAgICAgLy8gR2V0IGFsbCB0aGUgY3VycmVudCBzdGF0dXNlc1xuICAgICAgICBsZXQgc3RhdHVzZXMgPSB0aGlzLmN1cnJlbnRTdGF0dXMoKTtcbiAgICAgICAgLy8gR2V0IGFsbCB0aGUgY3VycmVudCBhY3Rpb25zXG4gICAgICAgIGxldCBhY3Rpb25zID0gQXJyYXkuZnJvbSh0aGlzLnN0YXRlTWFwLmtleXMoKSkubWFwKGtleSA9PiB0aGlzLnN0YXRlTWFwLmdldChrZXkpKTtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBwbGFuXG4gICAgICAgIHJldHVybiBHb2FwQWN0aW9uUGxhbm5lci5wbGFuPFQ+KHN0YXR1c2VzLCB0aGlzLmdvYWwsIGFjdGlvbnMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBjdXJyZW50U3RhdHVzKCk6IHN0cmluZ1tdIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5zdGF0dXNlcy5rZXlzKCkpLmZpbHRlcihzdGF0ID0+IHRoaXMuc3RhdHVzZXMuZ2V0KHN0YXQpLmlzU2F0aXNmaWVkKCkpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXRHb2FsKGdvYWw6IHN0cmluZykgeyBcbiAgICAgICAgaWYgKCF0aGlzLnN0YXR1c2VzLmhhcyhnb2FsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR29hbCBkb2Vzbid0IGV4aXN0LiBNYWtlIHN1cmUgeW91ciBnb2FsIGlzIGEgc3RhdHVzIGZvciB0aGlzIEdPQVAgQUlcIilcbiAgICAgICAgfSAgIFxuICAgICAgICB0aGlzLmdvYWwgPSBnb2FsO1xuICAgIH1cblxuICAgIHB1YmxpYyBhZGRTdGF0dXMoc3RhdHVzTmFtZTogc3RyaW5nLCBzdGF0dXM6IEdvYXBTdGF0ZSk6IHZvaWQge1xuICAgICAgICB0aGlzLnN0YXR1c2VzLnNldChzdGF0dXNOYW1lLCBzdGF0dXMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBhZGRTdGF0ZShzdGF0ZU5hbWU6IHN0cmluZywgc3RhdGU6IEdvYXBBY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgc3VwZXIuYWRkU3RhdGUoc3RhdGVOYW1lLCBzdGF0ZSk7XG4gICAgfVxuXG5cbn0iLCJpbXBvcnQgQUkgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL0FJXCI7XG5pbXBvcnQgU3RhdGVNYWNoaW5lIGZyb20gXCIuLi9EYXRhVHlwZXMvU3RhdGUvU3RhdGVNYWNoaW5lXCI7XG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uL05vZGVzL0dhbWVOb2RlXCI7XG5cbi8qKlxuICogQSB2ZXJzaW9uIG9mIGEgQHJlZmVyZW5jZVtTdGF0ZU1hY2hpbmVdIHRoYXQgaXMgY29uZmlndXJlZCB0byB3b3JrIGFzIGFuIEFJIGNvbnRyb2xsZXIgZm9yIGEgQHJlZmVyZW5jZVtHYW1lTm9kZV1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdGVNYWNoaW5lQUkgZXh0ZW5kcyBTdGF0ZU1hY2hpbmUgaW1wbGVtZW50cyBBSSB7XG5cdC8qKlx0VGhlIEdhbWVOb2RlIHRoYXQgdXNlcyB0aGlzIFN0YXRlTWFjaGluZSBmb3IgaXRzIEFJICovXG5cdHByb3RlY3RlZCBvd25lcjogR2FtZU5vZGU7XG5cblx0Ly8gQGltcGxlbWVudGVkXG5cdGluaXRpYWxpemVBSShvd25lcjogR2FtZU5vZGUsIGNvbmZpZzogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQgeyB9XG5cblx0Ly8gQGltcGxlbWVudGVkXG5cdGRlc3Ryb3koKXtcblx0XHQvLyBHZXQgcmlkIG9mIG91ciByZWZlcmVuY2UgdG8gdGhlIG93bmVyXG5cdFx0ZGVsZXRlIHRoaXMub3duZXI7XG5cdFx0dGhpcy5yZWNlaXZlci5kZXN0cm95KCk7XG5cdH1cblxuXHQvLyBAaW1wbGVtZW50ZWRcblx0YWN0aXZhdGUob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge31cbn0iLCJpbXBvcnQgQ29sbGVjdGlvbiBmcm9tIFwiLi4vSW50ZXJmYWNlcy9Db2xsZWN0aW9uXCI7XG5cbi8qKlxuICogQXNzb2NpYXRlcyBzdHJpbmdzIHdpdGggZWxlbWVudHMgb2YgdHlwZSBUXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hcDxUPiBpbXBsZW1lbnRzIENvbGxlY3Rpb24ge1xuXHRwcml2YXRlIG1hcDogUmVjb3JkPHN0cmluZywgVD47XG5cblx0LyoqIENyZWF0ZXMgYSBuZXcgbWFwICovXG5cdGNvbnN0cnVjdG9yKCl7XG5cdFx0dGhpcy5tYXAgPSB7fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgdmFsdWUgVCBzdG9yZWQgYXQgYSBrZXkuXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaXRlbSB0byBiZSBzdG9yZWRcblx0ICogQHBhcmFtIHZhbHVlIFRoZSBpdGVtIHRvIGJlIHN0b3JlZFxuXHQgKi9cblx0YWRkKGtleTogc3RyaW5nLCB2YWx1ZTogVCk6IHZvaWQge1xuXHRcdHRoaXMubWFwW2tleV0gPSB2YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBhIGtleS5cblx0ICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBpdGVtXG5cdCAqIEByZXR1cm5zIFRoZSBpdGVtIGF0IHRoZSBrZXkgb3IgdW5kZWZpbmVkXG5cdCAqL1xuXHRnZXQoa2V5OiBzdHJpbmcpOiBUIHtcblx0XHRyZXR1cm4gdGhpcy5tYXBba2V5XTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBbiBhbGlhcyBvZiBhZGQuIFNldHMgdGhlIHZhbHVlIHN0b3JlZCBhdCBrZXkgdG8gdGhlIG5ldyBzcGVjaWZpZWQgdmFsdWVcblx0ICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBpdGVtIHRvIGJlIHN0b3JlZFxuXHQgKiBAcGFyYW0gdmFsdWUgVGhlIGl0ZW0gdG8gYmUgc3RvcmVkXG5cdCAqL1xuXHRzZXQoa2V5OiBzdHJpbmcsIHZhbHVlOiBUKTogdm9pZCB7XG5cdFx0dGhpcy5hZGQoa2V5LCB2YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZXJlIGlzIGEgdmFsdWUgc3RvcmVkIGF0IHRoZSBzcGVjaWZpZWQga2V5LCBmYWxzZSBvdGhlcndpc2UuXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBjaGVja1xuXHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoZXJlIGlzIGFuIGl0ZW0gYXQgdGhlIGdpdmVuIGtleS5cblx0ICovXG5cdGhhcyhrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0aGlzLm1hcFtrZXldICE9PSB1bmRlZmluZWQ7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgb2YgdGhlIGtleXMgaW4gdGhpcyBtYXAuXG5cdCAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIGtleXMgaW4gdGhlIG1hcC5cblx0ICovXG5cdGtleXMoKTogQXJyYXk8c3RyaW5nPiB7XG5cdFx0cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMubWFwKTtcblx0fVxuXHRcblx0Ly8gQGltcGxlbWVudGVkXG5cdGZvckVhY2goZnVuYzogKGtleTogc3RyaW5nKSA9PiB2b2lkKTogdm9pZCB7XG5cdFx0T2JqZWN0LmtleXModGhpcy5tYXApLmZvckVhY2goa2V5ID0+IGZ1bmMoa2V5KSk7XG5cdH1cblxuXHQvKipcblx0ICogRGVsZXRlcyBhbiBpdGVtIGFzc29jaWF0ZWQgd2l0aCBhIGtleVxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgYXQgd2hpY2ggdG8gZGVsZXRlIGFuIGl0ZW1cblx0ICovXG5cdGRlbGV0ZShrZXk6IHN0cmluZyk6IHZvaWQge1xuXHRcdGRlbGV0ZSB0aGlzLm1hcFtrZXldO1xuXHR9XG5cblx0Ly8gQGltcGxlbWVudGVkXG5cdGNsZWFyKCk6IHZvaWQge1xuXHRcdHRoaXMuZm9yRWFjaChrZXkgPT4gZGVsZXRlIHRoaXMubWFwW2tleV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIHRoaXMgbWFwIHRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuXHQgKiBAcmV0dXJucyBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgbWFwLlxuXHQgKi9cblx0dG9TdHJpbmcoKTogc3RyaW5nIHtcblx0XHRsZXQgc3RyID0gXCJcIjtcblxuXHRcdHRoaXMuZm9yRWFjaCgoa2V5KSA9PiBzdHIgKz0ga2V5ICsgXCIgLT4gXCIgKyB0aGlzLmdldChrZXkpLnRvU3RyaW5nKCkgKyBcIlxcblwiKTtcblxuXHRcdHJldHVybiBzdHI7XG5cdH1cbn0iLCJpbXBvcnQgQ29sbGVjdGlvbiBmcm9tIFwiLi4vSW50ZXJmYWNlcy9Db2xsZWN0aW9uXCI7XG5cbi8qKlxuICogQSBGSUZPIHF1ZXVlIHdpdGggZWxlbWVudHMgb2YgdHlwZSBUXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1ZXVlPFQ+IGltcGxlbWVudHMgQ29sbGVjdGlvbiB7XG4gICAgLyoqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgUXVldWUgKi9cbiAgICBwcml2YXRlIHJlYWRvbmx5IE1BWF9FTEVNRU5UUzogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcXVldWUgKi9cbiAgICBwcml2YXRlIHE6IEFycmF5PFQ+O1xuICAgIFxuICAgIC8qKiBUaGUgaGVhZCBvZiB0aGUgcXVldWUgKi9cbiAgICBwcml2YXRlIGhlYWQ6IG51bWJlcjtcbiAgICBcbiAgICAvKiogVGhlIHRhaWwgb2YgdGhlIHF1ZXVlICovXG4gICAgcHJpdmF0ZSB0YWlsOiBudW1iZXI7XG5cbiAgICAvKiogVGhlIGN1cnJlbnQgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBxdWV1ZSAqL1xuICAgIHByaXZhdGUgc2l6ZTogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBxdWV1ZVxuICAgICAqIEBwYXJhbSBtYXhFbGVtZW50cyBUaGUgbWF4aW11bSBzaXplIG9mIHRoZSBzdGFja1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1heEVsZW1lbnRzOiBudW1iZXIgPSAxMDApe1xuICAgICAgICB0aGlzLk1BWF9FTEVNRU5UUyA9IG1heEVsZW1lbnRzO1xuICAgICAgICB0aGlzLnEgPSBuZXcgQXJyYXkodGhpcy5NQVhfRUxFTUVOVFMpO1xuICAgICAgICB0aGlzLmhlYWQgPSAwO1xuICAgICAgICB0aGlzLnRhaWwgPSAwO1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gaXRlbSB0byB0aGUgYmFjayBvZiB0aGUgcXVldWVcbiAgICAgKiBAcGFyYW0gaXRlbSBUaGUgaXRlbSB0byBhZGQgdG8gdGhlIGJhY2sgb2YgdGhlIHF1ZXVlXG4gICAgICovXG4gICAgZW5xdWV1ZShpdGVtOiBUKTogdm9pZHtcbiAgICAgICAgaWYoKHRoaXMudGFpbCArIDEpICUgdGhpcy5NQVhfRUxFTUVOVFMgPT09IHRoaXMuaGVhZCl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJRdWV1ZSBmdWxsIC0gY2Fubm90IGFkZCBlbGVtZW50XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zaXplICs9IDE7XG4gICAgICAgIHRoaXMucVt0aGlzLnRhaWxdID0gaXRlbTtcbiAgICAgICAgdGhpcy50YWlsID0gKHRoaXMudGFpbCArIDEpICUgdGhpcy5NQVhfRUxFTUVOVFM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFuIGl0ZW0gZnJvbSB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlXG4gICAgICogQHJldHVybnMgVGhlIGl0ZW0gYXQgdGhlIGZyb250IG9mIHRoZSBxdWV1ZVxuICAgICAqL1xuICAgIGRlcXVldWUoKTogVCB7XG4gICAgICAgIGlmKHRoaXMuaGVhZCA9PT0gdGhpcy50YWlsKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlF1ZXVlIGVtcHR5IC0gY2Fubm90IHJlbW92ZSBlbGVtZW50XCIpO1xuICAgICAgICB9XG5cblxuICAgICAgICB0aGlzLnNpemUgLT0gMTtcbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLnFbdGhpcy5oZWFkXTtcbiAgICAgICAgLy8gTm93IGRlbGV0ZSB0aGUgaXRlbVxuICAgICAgICBkZWxldGUgdGhpcy5xW3RoaXMuaGVhZF07XG4gICAgICAgIHRoaXMuaGVhZCA9ICh0aGlzLmhlYWQgKyAxKSAlIHRoaXMuTUFYX0VMRU1FTlRTO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaXRlbSBhdCB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlLCBidXQgZG9lcyBub3QgcmVtb3ZlIGl0XG4gICAgICogQHJldHVybnMgVGhlIGl0ZW0gYXQgdGhlIGZyb250IG9mIHRoZSBxdWV1ZVxuICAgICAqL1xuICAgIHBlZWtOZXh0KCk6IFQge1xuICAgICAgICBpZih0aGlzLmhlYWQgPT09IHRoaXMudGFpbCl7XG4gICAgICAgICAgICB0aHJvdyBcIlF1ZXVlIGVtcHR5IC0gY2Fubm90IGdldCBlbGVtZW50XCJcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpdGVtID0gdGhpcy5xW3RoaXMuaGVhZF07XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHF1ZXVlIGhhcyBpdGVtcyBpbiBpdCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdCB0aGlzIHF1ZXVlIGhhcyBpdGVtc1xuICAgICAqL1xuICAgIGhhc0l0ZW1zKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkICE9PSB0aGlzLnRhaWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBxdWV1ZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgc2l6ZSBvZiB0aGUgcXVldWVcbiAgICAgKi9cbiAgICBnZXRTaXplKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemU7XG4gICAgfVxuXG4gICAgLy8gQGltcGxlbWVudGVkXG4gICAgY2xlYXIoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IGRlbGV0ZSB0aGlzLnFbaW5kZXhdKTtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsO1xuICAgIH1cblxuICAgIC8vIEBpbXBsZW1lbnRlZFxuICAgIGZvckVhY2goZnVuYzogKGl0ZW06IFQsIGluZGV4PzogbnVtYmVyKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgICAgIGxldCBpID0gdGhpcy5oZWFkO1xuICAgICAgICB3aGlsZShpICE9PSB0aGlzLnRhaWwpe1xuICAgICAgICAgICAgZnVuYyh0aGlzLnFbaV0sIGkpO1xuICAgICAgICAgICAgaSA9IChpICsgMSkgJSB0aGlzLk1BWF9FTEVNRU5UUztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoaXMgcXVldWUgaW50byBhIHN0cmluZyBmb3JtYXRcbiAgICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhpcyBxdWV1ZVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgICAgIGxldCByZXR2YWwgPSBcIlwiO1xuXG4gICAgICAgIHRoaXMuZm9yRWFjaCggKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgc3RyID0gaXRlbS50b1N0cmluZygpXG4gICAgICAgICAgICBpZihpbmRleCAhPT0gMCl7XG4gICAgICAgICAgICAgICAgc3RyICs9IFwiIC0+IFwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR2YWwgPSBzdHIgKyByZXR2YWw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBcIlRvcCAtPiBcIiArIHJldHZhbDtcbiAgICB9XG59IiwiaW1wb3J0IENvbGxlY3Rpb24gZnJvbSBcIi4uL0ludGVyZmFjZXMvQ29sbGVjdGlvblwiO1xuXG4vKipcbiAqIEEgTElGTyBzdGFjayB3aXRoIGl0ZW1zIG9mIHR5cGUgVFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGFjazxUPiBpbXBsZW1lbnRzIENvbGxlY3Rpb24ge1xuICAgIC8qKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIFN0YWNrICovXG4gICAgcHJpdmF0ZSBNQVhfRUxFTUVOVFM6IG51bWJlcjtcbiAgICBcbiAgICAvKiogVGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzdGFjayAqL1xuICAgIHByaXZhdGUgc3RhY2s6IEFycmF5PFQ+O1xuICAgIFxuICAgIC8qKiBUaGUgaGVhZCBvZiB0aGUgc3RhY2sgKi9cblx0cHJpdmF0ZSBoZWFkOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHN0YWNrXG4gICAgICogQHBhcmFtIG1heEVsZW1lbnRzIFRoZSBtYXhpbXVtIHNpemUgb2YgdGhlIHN0YWNrXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWF4RWxlbWVudHM6IG51bWJlciA9IDEwMCl7XG4gICAgICAgIHRoaXMuTUFYX0VMRU1FTlRTID0gbWF4RWxlbWVudHM7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBuZXcgQXJyYXk8VD4odGhpcy5NQVhfRUxFTUVOVFMpO1xuICAgICAgICB0aGlzLmhlYWQgPSAtMTtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBpdGVtIHRvIHRoZSB0b3Agb2YgdGhlIHN0YWNrXG4gICAgICogQHBhcmFtIGl0ZW0gVGhlIG5ldyBpdGVtIHRvIGFkZCB0byB0aGUgc3RhY2tcbiAgICAgKi9cbiAgICBwdXNoKGl0ZW06IFQpOiB2b2lkIHtcbiAgICAgICAgaWYodGhpcy5oZWFkICsgMSA9PT0gdGhpcy5NQVhfRUxFTUVOVFMpe1xuICAgICAgICAgICAgdGhyb3cgXCJTdGFjayBmdWxsIC0gY2Fubm90IGFkZCBlbGVtZW50XCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWFkICs9IDE7XG4gICAgICAgIHRoaXMuc3RhY2tbdGhpcy5oZWFkXSA9IGl0ZW07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbiBpdGVtIGZyb20gdGhlIHRvcCBvZiB0aGUgc3RhY2tcbiAgICAgKiBAcmV0dXJucyBUaGUgaXRlbSBhdCB0aGUgdG9wIG9mIHRoZSBzdGFja1xuICAgICAqL1xuICAgIHBvcCgpOiBUIHtcbiAgICAgICAgaWYodGhpcy5oZWFkID09PSAtMSl7XG4gICAgICAgICAgICB0aHJvdyBcIlN0YWNrIGVtcHR5IC0gY2Fubm90IHJlbW92ZSBlbGVtZW50XCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWFkIC09IDE7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YWNrW3RoaXMuaGVhZCArIDFdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGVsZW1lbnQgY3VycmVudGx5IGF0IHRoZSB0b3Agb2YgdGhlIHN0YWNrXG4gICAgICogQHJldHVybnMgVGhlIGl0ZW0gYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2tcbiAgICAgKi9cbiAgICBwZWVrKCk6IFQge1xuICAgICAgICBpZih0aGlzLmhlYWQgPT09IC0xKXtcbiAgICAgICAgICAgIHRocm93IFwiU3RhY2sgZW1wdHkgLSBjYW5ub3QgZ2V0IGVsZW1lbnRcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLmhlYWRdO1xuICAgIH1cblxuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBzdGFjayBpcyBlbXB0eVxuICAgICAqIEByZXR1cm5zIEEgYm9vbGVhbiB0aGF0IHJlcHJlc2VudHMgd2hldGhlciBvciBub3QgdGhlIHN0YWNrIGlzIGVtcHR5XG4gICAgKi9cbiAgICBpc0VtcHR5KCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkID09PSAtMTtcbiAgICB9XG5cbiAgICAvLyBAaW1wbGVtZW50ZWRcbiAgICBjbGVhcigpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4gZGVsZXRlIHRoaXMuc3RhY2tbaW5kZXhdKTtcbiAgICAgICAgdGhpcy5oZWFkID0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGl0ZW1zIGN1cnJlbnRseSBpbiB0aGUgc3RhY2tcbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBzdGFja1xuICAgICAqL1xuICAgIHNpemUoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZCArIDE7XG4gICAgfVxuXG4gICAgLy8gQGltcGxlbWVudGVkXG4gICAgZm9yRWFjaChmdW5jOiAoaXRlbTogVCwgaW5kZXg/OiBudW1iZXIpID0+IHZvaWQpOiB2b2lke1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHdoaWxlKGkgPD0gdGhpcy5oZWFkKXtcbiAgICAgICAgICAgIGZ1bmModGhpcy5zdGFja1tpXSwgaSk7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGlzIHN0YWNrIGludG8gYSBzdHJpbmcgZm9ybWF0XG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoaXMgc3RhY2tcbiAgICAgKi9cbiAgICB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgICAgICBsZXQgcmV0dmFsID0gXCJcIjtcblxuICAgICAgICB0aGlzLmZvckVhY2goIChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IHN0ciA9IGl0ZW0udG9TdHJpbmcoKVxuICAgICAgICAgICAgaWYoaW5kZXggIT09IDApe1xuICAgICAgICAgICAgICAgIHN0ciArPSBcIiAtPiBcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dmFsID0gc3RyICsgcmV0dmFsO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gXCJUb3AgLT4gXCIgKyByZXR2YWw7XG4gICAgfVxufSIsIi8vIEBpZ25vcmVQYWdlXG5cbi8qKlxuICogQSBwbGFjZWhvbGRlciBmdW5jdGlvbiBmb3IgTm8gT3BlcmF0aW9uLiBEb2VzIG5vdGhpbmdcbiAqL1xuY29uc3QgTnVsbEZ1bmMgPSAoKSA9PiB7fTtcblxuZXhwb3J0IGRlZmF1bHQgTnVsbEZ1bmM7IiwiLyoqXG4gKiBBIGxpbmtlZC1saXN0IGZvciB0aGUgZWRnZXMgaW4gYSBAcmVmZXJlbmNlW0dyYXBoXS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWRnZU5vZGUge1xuICAgIC8qKiBUaGUgbm9kZSBpbiB0aGUgR3JhcGggdGhpcyBlZGdlIGNvbm5lY3RzIHRvICovXG4gICAgeTogbnVtYmVyO1xuICAgIC8qKiBUaGUgd2VpZ2h0IG9mIHRoaXMgRWRnZU5vZGUgKi9cblx0d2VpZ2h0OiBudW1iZXI7XG4gICAgLyoqIFRoZSBuZXh0IEVkZ2VOb2RlIGluIHRoZSBsaW5rZWQtbGlzdCAqL1xuICAgIG5leHQ6IEVkZ2VOb2RlO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBFZGdlTm9kZVxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGUgdGhpcyBlZGdlIGNvbm5lY3RzIHRvXG4gICAgICogQHBhcmFtIHdlaWdodCBUaGUgd2VpZ2h0IG9mIHRoaXMgZWRnZVxuICAgICAqL1xuXHRjb25zdHJ1Y3RvcihpbmRleDogbnVtYmVyLCB3ZWlnaHQ/OiBudW1iZXIpe1xuXHRcdHRoaXMueSA9IGluZGV4O1xuXHRcdHRoaXMubmV4dCA9IG51bGw7XG5cdFx0dGhpcy53ZWlnaHQgPSB3ZWlnaHQgPyB3ZWlnaHQgOiAxO1xuXHR9XG59IiwiaW1wb3J0IEVkZ2VOb2RlIGZyb20gXCIuL0VkZ2VOb2RlXCI7XG5cbmV4cG9ydCBjb25zdCBNQVhfViA9IDEwMDAwO1xuXG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGEgZ3JhcGggZGF0YSBzdHJ1Y3R1cmUgdXNpbmcgZWRnZSBsaXN0cy4gSW5zcGlyZWQgYnkgVGhlIEFsZ29yaXRobSBEZXNpZ24gTWFudWFsLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcmFwaCB7XG5cdC8qKiBBbiBhcnJheSBvZiBlZGdlcyBhdCB0aGUgbm9kZSBzcGVjaWZpZWQgYnkgdGhlIGluZGV4ICovXG5cdGVkZ2VzOiBBcnJheTxFZGdlTm9kZT47XG5cdC8qKiBBbiBhcnJheSByZXByZXNlbnRpbmcgdGhlIGRlZ3JlZSBvZiB0aGUgbm9kZSBzcGVjaWZpZWQgYnkgdGhlIGluZGV4ICovXG5cdGRlZ3JlZTogQXJyYXk8bnVtYmVyPjtcblx0LyoqIFRoZSBudW1iZXIgb2YgdmVydGljZXMgaW4gdGhlIGdyYXBoICovXG5cdG51bVZlcnRpY2VzOiBudW1iZXI7XG5cdC8qKiBUaGUgbnVtYmVyIG9mIGVkZ2VzIGluIHRoZSBncmFwaCAqL1xuXHRudW1FZGdlczogbnVtYmVyO1xuXHQvKiogV2hldGhlciBvciBub3QgdGhlIGdyYXBoIGlzIGRpcmVjdGVkICovXG5cdGRpcmVjdGVkOiBib29sZWFuO1xuXHQvKiogV2hldGhlciBvciBub3QgdGhlIGdyYXBoIGlzIHdlaWdodGVkICovXG5cdHdlaWdodGVkOiBib29sZWFuO1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGdyYXBoXG5cdCAqIEBwYXJhbSBkaXJlY3RlZCBXaGV0aGVyIG9yIG5vdCB0aGlzIGdyYXBoIGlzIGRpcmVjdGVkXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihkaXJlY3RlZDogYm9vbGVhbiA9IGZhbHNlKXtcblx0XHR0aGlzLmRpcmVjdGVkID0gZGlyZWN0ZWQ7XG5cdFx0dGhpcy53ZWlnaHRlZCA9IGZhbHNlO1xuXG5cdFx0dGhpcy5udW1WZXJ0aWNlcyA9IDA7XG5cdFx0dGhpcy5udW1FZGdlcyA9IDA7XG5cblx0XHR0aGlzLmVkZ2VzID0gbmV3IEFycmF5KE1BWF9WKTtcblx0XHR0aGlzLmRlZ3JlZSA9IG5ldyBBcnJheShNQVhfVik7XG5cdH1cblxuXHQvKiogQWRkcyBhIG5vZGUgdG8gdGhpcyBncmFwaCBhbmQgcmV0dXJucyB0aGUgaW5kZXggb2YgaXRcblx0ICogQHJldHVybnMgVGhlIGluZGV4IG9mIHRoZSBuZXcgbm9kZVxuXHQqL1xuXHRhZGROb2RlKCk6IG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMubnVtVmVydGljZXMrKztcblx0fVxuXG5cdC8qKiBBZGRzIGFuIGVkZ2UgYmV0d2VlbiBub2RlIHggYW5kIHksIHdpdGggYW4gb3B0aW9uYWwgd2VpZ2h0XG5cdCAqIEBwYXJhbSB4IFRoZSBpbmRleCBvZiB0aGUgc3RhcnQgb2YgdGhlIGVkZ2Vcblx0ICogQHBhcmFtIHkgVGhlIGluZGV4IG9mIHRoZSBlbmQgb2YgdGhlIGVkZ2Vcblx0ICogQHBhcmFtIHdlaWdodCBUaGUgb3B0aW9uYWwgd2VpZ2h0IG9mIHRoZSBuZXcgZWRnZVxuXHQqL1xuXHRhZGRFZGdlKHg6IG51bWJlciwgeTogbnVtYmVyLCB3ZWlnaHQ/OiBudW1iZXIpOiB2b2lkIHtcblx0XHRsZXQgZWRnZSA9IG5ldyBFZGdlTm9kZSh5LCB3ZWlnaHQpO1xuXG5cblxuXHRcdGlmKHRoaXMuZWRnZXNbeF0pe1xuXHRcdFx0ZWRnZS5uZXh0ID0gdGhpcy5lZGdlc1t4XTtcblx0XHR9XG5cdFx0XG5cdFx0dGhpcy5lZGdlc1t4XSA9IGVkZ2U7XG5cblx0XHRpZighdGhpcy5kaXJlY3RlZCl7XG5cdFx0XHRlZGdlID0gbmV3IEVkZ2VOb2RlKHgsIHdlaWdodCk7XG5cblx0XHRcdGlmKHRoaXMuZWRnZXNbeV0pe1xuXHRcdFx0XHRlZGdlLm5leHQgPSB0aGlzLmVkZ2VzW3ldO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR0aGlzLmVkZ2VzW3ldID0gZWRnZTtcblx0XHR9XG5cblx0XHR0aGlzLm51bUVkZ2VzICs9IDE7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IGFuIGVkZ2UgZXhpc3RzIGJldHdlZW4gdHdvIG5vZGVzLlxuXHQgKiBUaGlzIGNoZWNrIGlzIGRpcmVjdGlvbmFsIGlmIHRoaXMgaXMgYSBkaXJlY3RlZCBncmFwaC5cblx0ICogQHBhcmFtIHggVGhlIGZpcnN0IG5vZGVcblx0ICogQHBhcmFtIHkgVGhlIHNlY29uZCBub2RlXG5cdCAqIEByZXR1cm5zIHRydWUgaWYgYW4gZWRnZSBleGlzdHMsIGZhbHNlIG90aGVyd2lzZVxuXHQgKi9cblx0ZWRnZUV4aXN0cyh4OiBudW1iZXIsIHk6IG51bWJlcik6IGJvb2xlYW4ge1xuXHRcdGxldCBlZGdlID0gdGhpcy5lZGdlc1t4XTtcblxuXHRcdHdoaWxlKGVkZ2UgIT09IG51bGwpe1xuXHRcdFx0aWYoZWRnZS55ID09PSB5KXtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRlZGdlID0gZWRnZS5uZXh0O1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBlZGdlIGxpc3QgYXNzb2NpYXRlZCB3aXRoIG5vZGUgeFxuXHQgKiBAcGFyYW0geCBUaGUgaW5kZXggb2YgdGhlIG5vZGVcblx0ICogQHJldHVybnMgVGhlIGhlYWQgb2YgYSBsaW5rZWQtbGlzdCBvZiBlZGdlc1xuXHQgKi9cblx0Z2V0RWRnZXMoeDogbnVtYmVyKTogRWRnZU5vZGUge1xuXHRcdHJldHVybiB0aGlzLmVkZ2VzW3hdO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGRlZ3JlZSBhc3NvY2lhdGVkIHdpdGggbm9kZSB4XG5cdCAqIEBwYXJhbSB4IFRoZSBpbmRleCBvZiB0aGUgbm9kZVxuXHQgKi9cblx0Z2V0RGVncmVlKHg6IG51bWJlcik6IG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMuZGVncmVlW3hdO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIHRoZSBzcGVjaWZlZCBub2RlIGludG8gYSBzdHJpbmdcblx0ICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZSB0byBjb252ZXJ0IHRvIGEgc3RyaW5nXG5cdCAqIEByZXR1cm5zIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG5vZGU6IFwiTm9kZSB4XCJcblx0ICovXG5cdHByb3RlY3RlZCBub2RlVG9TdHJpbmcoaW5kZXg6IG51bWJlcik6IHN0cmluZyB7XG5cdFx0cmV0dXJuIFwiTm9kZSBcIiArIGluZGV4O1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIHRoZSBHcmFwaCBpbnRvIGEgc3RyaW5nIGZvcm1hdFxuXHQgKiBAcmV0dXJucyBUaGUgZ3JhcGggYXMgYSBzdHJpbmdcblx0ICovXG5cdHRvU3RyaW5nKCk6IHN0cmluZyB7XG5cdFx0bGV0IHJldHZhbCA9IFwiXCI7XG5cblx0XHRmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5udW1WZXJ0aWNlczsgaSsrKXtcblx0XHRcdGxldCBlZGdlID0gdGhpcy5lZGdlc1tpXTtcblx0XHRcdGxldCBlZGdlU3RyID0gXCJcIjtcblx0XHRcdHdoaWxlKGVkZ2UgIT09IHVuZGVmaW5lZCAmJiBlZGdlICE9PSBudWxsKXtcblx0XHRcdFx0ZWRnZVN0ciArPSBlZGdlLnkudG9TdHJpbmcoKTtcblx0XHRcdFx0aWYodGhpcy53ZWlnaHRlZCl7XG5cdFx0XHRcdFx0ZWRnZVN0ciArPSBcIiAoXCIgKyBlZGdlLndlaWdodCArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGVkZ2UubmV4dCAhPT0gbnVsbCl7XG5cdFx0XHRcdFx0ZWRnZVN0ciArPSBcIiwgXCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRlZGdlID0gZWRnZS5uZXh0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR2YWwgKz0gdGhpcy5ub2RlVG9TdHJpbmcoaSkgKyBcIjogXCIgKyBlZGdlU3RyICsgXCJcXG5cIjtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0dmFsO1xuXHR9XG59IiwiaW1wb3J0IEdyYXBoLCB7IE1BWF9WIH0gZnJvbSBcIi4vR3JhcGhcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9WZWMyXCI7XG5pbXBvcnQgRGVidWdSZW5kZXJhYmxlIGZyb20gXCIuLi9JbnRlcmZhY2VzL0RlYnVnUmVuZGVyYWJsZVwiO1xuXG4vKipcbiAqIEFuIGV4dGVuc2lvbiBvZiBHcmFwaCB0aGF0IGhhcyBub2RlcyB3aXRoIHBvc2l0aW9ucyBpbiAyRCBzcGFjZS5cbiAqIFRoaXMgaXMgYSB3ZWlnaHRlZCBncmFwaCAodGhvdWdoIG5vdCBpbmhlcmVudGx5IGRpcmVjdGQpXG4qL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9zaXRpb25HcmFwaCBleHRlbmRzIEdyYXBoIGltcGxlbWVudHMgRGVidWdSZW5kZXJhYmxlIHtcblx0LyoqIEFuIGFycmF5IG9mIHRoZSBwb3NpdGlvbnMgb2YgdGhlIG5vZGVzIGluIHRoaXMgZ3JhcGggKi9cblx0cG9zaXRpb25zOiBBcnJheTxWZWMyPjtcblxuXHQvKipcblx0ICogQ3JlYXRlZXMgYSBuZXcgUG9zaXRpb25HcmFwaFxuXHQgKiBAcGFyYW0gZGlyZWN0ZWQgV2hldGhlciBvciBub3QgdGhpcyBncmFwaCBpcyBkaXJlY3RlZFxuXHQgKi9cblx0Y29uc3RydWN0b3IoZGlyZWN0ZWQ6IGJvb2xlYW4gPSBmYWxzZSl7XG5cdFx0c3VwZXIoZGlyZWN0ZWQpO1xuXHRcdHRoaXMucG9zaXRpb25zID0gbmV3IEFycmF5KE1BWF9WKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgcG9zaXRpb25lZCBub2RlIHRvIHRoaXMgZ3JhcGhcblx0ICogQHBhcmFtIHBvc2l0aW9uIFRoZSBwb3NpdGlvbiBvZiB0aGUgbm9kZSB0byBhZGRcblx0ICogQHJldHVybnMgVGhlIGluZGV4IG9mIHRoZSBhZGRlZCBub2RlXG5cdCAqL1xuXHRhZGRQb3NpdGlvbmVkTm9kZShwb3NpdGlvbjogVmVjMik6IG51bWJlciB7XG5cdFx0dGhpcy5wb3NpdGlvbnNbdGhpcy5udW1WZXJ0aWNlc10gPSBwb3NpdGlvbjtcblx0XHRyZXR1cm4gdGhpcy5hZGROb2RlKCk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hhbmdlcyB0aGUgcG9zaXRpb24gb2YgYSBub2RlLlxuXHQgKiBBdXRvbWF0aWNhbGx5IGFkanVzdHMgdGhlIHdlaWdodHMgb2YgdGhlIGdyYXBoIHRpZWQgdG8gdGhpcyBub2RlLlxuXHQgKiBBcyBzdWNoLCBiZSB3YXJuZWQgdGhhdCB0aGlzIGZ1bmN0aW9uIGhhcyBhbiBPKG4gKyBtKSBydW5uaW5nIHRpbWUsIGFuZCB1c2UgaXQgc3BhcmluZ2x5LlxuXHQgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlXG5cdCAqIEBwYXJhbSBwb3NpdGlvbiBUaGUgbmV3IHBvc2l0aW9uIG9mIHRoZSBub2RlXG5cdCAqL1xuXHRzZXROb2RlUG9zaXRpb24oaW5kZXg6IG51bWJlciwgcG9zaXRpb246IFZlYzIpOiB2b2lkIHtcblx0XHR0aGlzLnBvc2l0aW9uc1tpbmRleF0gPSBwb3NpdGlvbjtcblxuXHRcdC8vIFJlY2FsY3VsYXRlIGFsbCB3ZWlnaHRzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGluZGV4XG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IHRoaXMubnVtRWRnZXM7IGkrKyl7XG5cblx0XHRcdGxldCBlZGdlID0gdGhpcy5lZGdlc1tpXTtcblxuXHRcdFx0d2hpbGUoZWRnZSAhPT0gbnVsbCl7XG5cdFx0XHRcdC8vIElmIHRoaXMgbm9kZSBpcyBvbiBlaXRoZXIgc2lkZSBvZiB0aGUgZWRnZSwgcmVjYWxjdWxhdGUgd2VpZ2h0XG5cdFx0XHRcdGlmKGkgPT09IGluZGV4IHx8IGVkZ2UueSA9PT0gaW5kZXgpe1xuXHRcdFx0XHRcdGVkZ2Uud2VpZ2h0ID0gdGhpcy5wb3NpdGlvbnNbaV0uZGlzdGFuY2VUbyh0aGlzLnBvc2l0aW9uc1tlZGdlLnldKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVkZ2UgPSBlZGdlLm5leHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHBvc2l0aW9uIG9mIGEgbm9kZVxuXHQgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlXG5cdCAqIEByZXR1cm5zIFRoZSBwb3NpdGlvbiBvZiB0aGUgbm9kZVxuXHQgKi9cblx0Z2V0Tm9kZVBvc2l0aW9uKGluZGV4OiBudW1iZXIpOiBWZWMyIHtcblx0XHRyZXR1cm4gdGhpcy5wb3NpdGlvbnNbaW5kZXhdO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYW4gZWRnZSB0byB0aGlzIGdyYXBoIGJldHdlZW4gbm9kZSB4IGFuZCB5LlxuXHQgKiBBdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZXMgdGhlIHdlaWdodCBvZiB0aGUgZWRnZSBhcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgbm9kZXMuXG5cdCAqIEBwYXJhbSB4IFRoZSBiZWdpbm5pbmcgb2YgdGhlIGVkZ2Vcblx0ICogQHBhcmFtIHkgVGhlIGVuZCBvZiB0aGUgZWRnZVxuXHQgKi9cblx0YWRkRWRnZSh4OiBudW1iZXIsIHk6IG51bWJlcik6IHZvaWQge1xuXHRcdGlmKCF0aGlzLnBvc2l0aW9uc1t4XSB8fCAhdGhpcy5wb3NpdGlvbnNbeV0pe1xuXHRcdFx0dGhyb3cgXCJDYW4ndCBhZGQgZWRnZSB0byB1bi1wb3NpdGlvbmVkIG5vZGUhXCI7XG5cdFx0fVxuXG5cdFx0Ly8gV2VpZ2h0IGlzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBub2Rlc1xuXHRcdGxldCB3ZWlnaHQgPSB0aGlzLnBvc2l0aW9uc1t4XS5kaXN0YW5jZVRvKHRoaXMucG9zaXRpb25zW3ldKTtcblxuXHRcdHN1cGVyLmFkZEVkZ2UoeCwgeSwgd2VpZ2h0KTtcblx0fVxuXG5cdC8vIEBvdmVycmlkZVxuXHRwcm90ZWN0ZWQgbm9kZVRvU3RyaW5nKGluZGV4OiBudW1iZXIpOiBzdHJpbmcge1xuXHRcdHJldHVybiBcIk5vZGUgXCIgKyBpbmRleCArIFwiIC0gXCIgKyB0aGlzLnBvc2l0aW9uc1tpbmRleF0udG9TdHJpbmcoKTtcblx0fVxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIG5vZGUgaW4gdGhlIGdyYXBoIHdpdGggdGhlIHBvc2l0aW9uIGNsb3Nlc3QgdG8gdGhlIGdpdmVuIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIHRoZSBwb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHRoZSBub2RlIGluIHRoZSBncmFwaCB0aGF0IGlzIGNsb3Nlc3QgdG8gdGhlIGdpdmVuIHBvc2l0aW9uXG4gICAgICovXG4gICAgcHVibGljIHNuYXAocG9zaXRpb246IFZlYzIpOiBudW1iZXIge1xuICAgICAgICBsZXQgbiA9IHRoaXMubnVtVmVydGljZXM7XG5cdFx0bGV0IGkgPSAxO1xuXHRcdGxldCBpbmRleCA9IDA7XG5cdFx0bGV0IGRpc3QgPSBwb3NpdGlvbi5kaXN0YW5jZVNxVG8odGhpcy5wb3NpdGlvbnNbMF0pO1xuXHRcdHdoaWxlKGkgPCBuKXtcblx0XHRcdGxldCBkID0gcG9zaXRpb24uZGlzdGFuY2VTcVRvKHRoaXMucG9zaXRpb25zW2ldKTtcblx0XHRcdGlmKGQgPCBkaXN0KXtcblx0XHRcdFx0ZGlzdCA9IGQ7XG5cdFx0XHRcdGluZGV4ID0gaTtcblx0XHRcdH1cblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaW5kZXg7XG4gICAgfVxuXG5cdGRlYnVnUmVuZGVyID0gKCk6IHZvaWQgPT4ge1xuXHRcdC8vIGZvcihsZXQgcG9pbnQgb2YgdGhpcy5wb3NpdGlvbnMpe1xuXHRcdC8vIFx0Y3R4LmZpbGxSZWN0KChwb2ludC54IC0gb3JpZ2luLnggLSA0KSp6b29tLCAocG9pbnQueSAtIG9yaWdpbi55IC0gNCkqem9vbSwgOCwgOCk7XG5cdFx0Ly8gfVxuXHR9XG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1ZlYzJcIjtcbmltcG9ydCBBQUJCIGZyb20gXCIuLi9TaGFwZXMvQUFCQlwiO1xuXG4vKiogQW4gb2JqZWN0IHRoYXQgaXMgYSByZWdpb24sIHdpdGggYSBzaXplLCBzY2FsZSwgYW5kIGJvdW5kYXJ5LiAqL1xuZXhwb3J0IGRlZmF1bHQgaW50ZXJmYWNlIFJlZ2lvbiB7XG4gICAgLyoqIFRoZSBzaXplIG9mIHRoaXMgb2JqZWN0LiAqL1xuICAgIHNpemU6IFZlYzI7XG5cbiAgICAvKiogVGhlIHNjYWxlIG9mIHRoaXMgb2JqZWN0LiAqL1xuICAgIHNjYWxlOiBWZWMyO1xuXG4gICAgLyoqIFRoZSBzaXplIG9mIHRoZSBvYmplY3QgdGFraW5nIGludG8gYWNjb3VudCB0aGUgem9vbSBhbmQgc2NhbGUgKi9cbiAgICByZWFkb25seSBzaXplV2l0aFpvb206IFZlYzI7XG5cbiAgICAvKiogVGhlIGJvdW5kaW5nIGJveCBvZiB0aGlzIG9iamVjdC4gKi9cbiAgICBib3VuZGFyeTogQUFCQjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVnaW9uKGFyZzogYW55KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGFyZyAmJiBhcmcuc2l6ZSAmJiBhcmcuc2NhbGUgJiYgYXJnLmJvdW5kYXJ5O1xufSIsImltcG9ydCBWZWMyIGZyb20gXCIuL1ZlYzJcIjtcblxuLyoqIEEgNHg0IG1hdHJpeDAgKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hdDR4NCB7XG5cdHByaXZhdGUgbWF0OiBGbG9hdDMyQXJyYXk7XG5cblx0Y29uc3RydWN0b3IoKXtcblx0XHR0aGlzLm1hdCA9IG5ldyBGbG9hdDMyQXJyYXkoW1xuXHRcdFx0MCwgMCwgMCwgMCxcblx0XHRcdDAsIDAsIDAsIDAsXG5cdFx0XHQwLCAwLCAwLCAwLFxuXHRcdFx0MCwgMCwgMCwgMFxuXHRcdF0pO1xuXHR9XG5cblx0Ly8gU3RhdGljIG1lbWJlcnNcblx0c3RhdGljIGdldCBJREVOVElUWSgpOiBNYXQ0eDQge1xuXHRcdHJldHVybiBuZXcgTWF0NHg0KCkuaWRlbnRpdHkoKTtcblx0fVxuXG5cdHN0YXRpYyBnZXQgWkVSTygpOiBNYXQ0eDQge1xuXHRcdHJldHVybiBuZXcgTWF0NHg0KCkuemVybygpO1xuXHR9XG5cblx0Ly8gQWNjZXNzb3JzXG5cdHNldCBfMDAoeDogbnVtYmVyKSB7XG5cdFx0dGhpcy5tYXRbMF0gPSB4O1xuXHR9XG5cblx0c2V0KGNvbDogbnVtYmVyLCByb3c6IG51bWJlciwgdmFsdWU6IG51bWJlcik6IE1hdDR4NCB7XG5cdFx0aWYoY29sIDwgMCB8fCBjb2wgPiAzIHx8IHJvdyA8IDAgfHwgcm93ID4gMyl7XG5cdFx0XHR0aHJvdyBgRXJyb3IgLSBpbmRleCAoJHtjb2x9LCAke3Jvd30pIGlzIG91dCBvZiBib3VuZHMgZm9yIE1hdDR4NGBcblx0XHR9XG5cdFx0dGhpcy5tYXRbcm93KjQgKyBjb2xdID0gdmFsdWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGdldChjb2w6IG51bWJlciwgcm93OiBudW1iZXIpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLm1hdFtyb3cqNCArIGNvbF07XG5cdH1cblxuXHRzZXRBbGwoLi4uaXRlbXM6IEFycmF5PG51bWJlcj4pOiBNYXQ0eDQge1xuXHRcdHRoaXMubWF0LnNldChpdGVtcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRpZGVudGl0eSgpOiBNYXQ0eDQge1xuXHRcdHJldHVybiB0aGlzLnNldEFsbChcblx0XHRcdDEsIDAsIDAsIDAsXG5cdFx0XHQwLCAxLCAwLCAwLFxuXHRcdFx0MCwgMCwgMSwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblx0XHQpXG5cdH1cblxuXHR6ZXJvKCk6IE1hdDR4NCB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0QWxsKFxuXHRcdFx0MCwgMCwgMCwgMCxcblx0XHRcdDAsIDAsIDAsIDAsXG5cdFx0XHQwLCAwLCAwLCAwLFxuXHRcdFx0MCwgMCwgMCwgMFxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogTWFrZXMgdGhpcyBNYXQ0eDQgYSByb3RhdGlvbiBtYXRyaXggb2YgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgcmFkaWFucyBjY3dcblx0ICogQHBhcmFtIHpSYWRpYW5zIFRoZSBudW1iZXIgb2YgcmFkaWFucyB0byByb3RhdGVcblx0ICogQHJldHVybnMgdGhpcyBNYXQ0eDRcblx0ICovXG5cdHJvdGF0ZSh6UmFkaWFuczogbnVtYmVyKTogTWF0NHg0IHtcblx0XHRyZXR1cm4gdGhpcy5zZXRBbGwoXG5cdFx0XHRNYXRoLmNvcyh6UmFkaWFucyksIC1NYXRoLnNpbih6UmFkaWFucyksIFx0MCwgMCxcblx0XHRcdE1hdGguc2luKHpSYWRpYW5zKSwgTWF0aC5jb3MoelJhZGlhbnMpLCBcdDAsIDAsXG5cdFx0XHQwLCBcdFx0XHRcdFx0MCwgXHRcdFx0XHRcdFx0MSwgMCxcblx0XHRcdDAsIFx0XHRcdFx0XHQwLCBcdFx0XHRcdFx0XHQwLCAxXG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUdXJucyB0aGlzIE1hdDR4NCBpbnRvIGEgdHJhbnNsYXRpb24gbWF0cml4IG9mIHRoZSBzcGVjaWZpZWQgdHJhbnNsYXRpb25cblx0ICogQHBhcmFtIHRyYW5zbGF0aW9uIFRoZSB0cmFuc2xhdGlvbiBpbiB4IGFuZCB5XG5cdCAqIEByZXR1cm5zIHRoaXMgTWF0NHg0XG5cdCAqL1xuXHR0cmFuc2xhdGUodHJhbnNsYXRpb246IFZlYzIgfCBGbG9hdDMyQXJyYXkpOiBNYXQ0eDQge1xuXHRcdC8vIElmIHRyYW5zbGF0aW9uIGlzIGEgdmVjLCBnZXQgaXRzIGFycmF5XG5cdFx0aWYodHJhbnNsYXRpb24gaW5zdGFuY2VvZiBWZWMyKXtcblx0XHRcdHRyYW5zbGF0aW9uID0gdHJhbnNsYXRpb24udG9BcnJheSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnNldEFsbChcblx0XHRcdDEsIDAsIDAsIHRyYW5zbGF0aW9uWzBdLFxuXHRcdFx0MCwgMSwgMCwgdHJhbnNsYXRpb25bMV0sXG5cdFx0XHQwLCAwLCAxLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXHRcdCk7XG5cdH1cblxuXHRzY2FsZShzY2FsZTogVmVjMiB8IEZsb2F0MzJBcnJheSB8IG51bWJlcik6IE1hdDR4NCB7XG5cdFx0Ly8gTWFrZSBzdXJlIHNjYWxlIGlzIGEgZmxvYXQzMkFycmF5XG5cdFx0aWYoc2NhbGUgaW5zdGFuY2VvZiBWZWMyKXtcblx0XHRcdHNjYWxlID0gc2NhbGUudG9BcnJheSgpO1xuXHRcdH0gZWxzZSBpZighKHNjYWxlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSl7XG5cdFx0XHRzY2FsZSA9IG5ldyBGbG9hdDMyQXJyYXkoW3NjYWxlLCBzY2FsZV0pO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnNldEFsbChcblx0XHRcdHNjYWxlWzBdLCAwLCBcdFx0MCwgMCxcblx0XHRcdDAsIFx0XHQgIHNjYWxlWzFdLCAwLCAwLFxuXHRcdFx0MCwgXHRcdCAgMCxcdFx0MSwgMCxcblx0XHRcdDAsIFx0XHQgIDAsXHRcdDAsIDFcblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBuZXcgTWF0NHg0IHRoYXQgcmVwcmVzZW50cyB0aGUgcmlnaHQgc2lkZSBtdWx0aXBsaWNhdGlvbiBUSElTIHggT1RIRVJcblx0ICogQHBhcmFtIG90aGVyIFRoZSBvdGhlciBNYXQ0eDQgdG8gbXVsdGlwbHkgYnlcblx0ICogQHJldHVybnMgYSBuZXcgTWF0NHg0IGNvbnRhaW5pbmcgdGhlIHByb2R1Y3Qgb2YgdGhlc2UgdHdvIE1hdDR4NHNcblx0ICovXG5cdG11bHQob3RoZXI6IE1hdDR4NCwgb3V0PzogTWF0NHg0KTogTWF0NHg0IHtcblx0XHRsZXQgdGVtcCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuXG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IDQ7IGkrKyl7XG5cdFx0XHRmb3IobGV0IGogPSAwOyBqIDwgNDsgaisrKXtcblx0XHRcdFx0bGV0IHZhbHVlID0gMDtcblx0XHRcdFx0Zm9yKGxldCBrID0gMDsgayA8IDQ7IGsrKyl7XG5cdFx0XHRcdFx0dmFsdWUgKz0gdGhpcy5nZXQoaywgaSkgKiBvdGhlci5nZXQoaiwgayk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGVtcFtqKjQgKyBpXSAgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZihvdXQgIT09IHVuZGVmaW5lZCl7XG5cdFx0XHRyZXR1cm4gb3V0LnNldEFsbCguLi50ZW1wKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG5ldyBNYXQ0eDQoKS5zZXRBbGwoLi4udGVtcCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIE11bHRpcGxpZXMgYWxsIGdpdmVuIG1hdHJpY2llcyBpbiBvcmRlci4gZS5nLiBNVUxUKEEsIEIsIEMpIC0+IEEqQipDXG5cdCAqIEBwYXJhbSBtYXRzIEEgbGlzdCBvZiBNYXQ0eDRzIHRvIG11bHRpcGx5IGluIG9yZGVyXG5cdCAqIEByZXR1cm5zIEEgbmV3IE1hdDR4NCBob2xkaW5nIHRoZSByZXN1bHQgb2YgdGhlIG9wZXJhdGlvblxuXHQgKi9cblx0c3RhdGljIE1VTFQoLi4ubWF0czogQXJyYXk8TWF0NHg0Pik6IE1hdDR4NCB7XG5cdFx0Ly8gQ3JlYXRlIGEgbmV3IGFycmF5XG5cdFx0bGV0IHRlbXAgPSBNYXQ0eDQuSURFTlRJVFk7XG5cblx0XHQvLyBNdWx0aXBseSBieSBldmVyeSBhcnJheSBpbiBvcmRlciwgaW4gcGxhY2Vcblx0XHRmb3IobGV0IGkgPSAwOyBpIDwgbWF0cy5sZW5ndGg7IGkrKyl7XG5cdFx0XHR0ZW1wLm11bHQobWF0c1tpXSwgdGVtcCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRlbXA7XG5cdH1cblxuXHR0b0FycmF5KCk6IEZsb2F0MzJBcnJheSB7XG5cdFx0cmV0dXJuIHRoaXMubWF0O1xuXHR9XG5cblx0dG9TdHJpbmcoKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gIGB8JHt0aGlzLm1hdFswXS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFsxXS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFsyXS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFszXS50b0ZpeGVkKDIpfXxcXG5gICsgXG5cdFx0XHRcdGB8JHt0aGlzLm1hdFs0XS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFs1XS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFs2XS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFs3XS50b0ZpeGVkKDIpfXxcXG5gICtcblx0XHRcdFx0YHwke3RoaXMubWF0WzhdLnRvRml4ZWQoMil9LCAke3RoaXMubWF0WzldLnRvRml4ZWQoMil9LCAke3RoaXMubWF0WzEwXS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFsxMV0udG9GaXhlZCgyKX18XFxuYCArXG5cdFx0XHRcdGB8JHt0aGlzLm1hdFsxMl0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbMTNdLnRvRml4ZWQoMil9LCAke3RoaXMubWF0WzE0XS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFsxNV0udG9GaXhlZCgyKX18YDtcblx0fVxufSIsImltcG9ydCBQaHlzaWNhbCBmcm9tIFwiLi4vSW50ZXJmYWNlcy9QaHlzaWNhbFwiO1xuaW1wb3J0IEFBQkIgZnJvbSBcIi4uL1NoYXBlcy9BQUJCXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vVmVjMlwiO1xuaW1wb3J0IEhpdCBmcm9tIFwiLi9IaXRcIjtcblxuLyoqXG4gKiBBIGNsYXNzIHRoYXQgY29udGFpbnMgdGhlIGFyZWEgb2Ygb3ZlcmxhcCBvZiB0d28gY29sbGlkaW5nIG9iamVjdHMgdG8gYWxsb3cgZm9yIHNvcnRpbmcgYnkgdGhlIHBoeXNpY3Mgc3lzdGVtLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcmVhQ29sbGlzaW9uIHtcbiAgICAvKiogVGhlIGFyZWEgb2YgdGhlIG92ZXJsYXAgZm9yIHRoZSBjb2xsaWRpbmcgb2JqZWN0cyAqL1xuICAgIGFyZWE6IG51bWJlcjtcblxuICAgIC8qKiBUaGUgQUFCQiBvZiB0aGUgb3RoZXIgY29sbGlkZXIgaW4gdGhpcyBjb2xsaXNpb24gKi9cbiAgICBjb2xsaWRlcjogQUFCQjtcblxuICAgIC8qKiBUeXBlIG9mIHRoZSBjb2xsaXNpb24gKi9cbiAgICB0eXBlOiBzdHJpbmc7XG5cbiAgICAvKiogVGhlciBvdGhlciBvYmplY3QgaW4gdGhlIGNvbGxpc2lvbiAqL1xuICAgIG90aGVyOiBQaHlzaWNhbDtcblxuICAgIC8qKiBUaGUgdGlsZSwgaWYgdGhpcyB3YXMgYSB0aWxlbWFwIGNvbGxpc2lvbiAqL1xuICAgIHRpbGU6IFZlYzI7XG5cbiAgICAvKiogVGhlIHBoeXNpY3MgaGl0IGZvciB0aGlzIG9iamVjdCAqL1xuICAgIGhpdDogSGl0O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBBcmVhQ29sbGlzaW9uIG9iamVjdFxuICAgICAqIEBwYXJhbSBhcmVhIFRoZSBhcmVhIG9mIHRoZSBjb2xsaXNpb25cbiAgICAgKiBAcGFyYW0gY29sbGlkZXIgVGhlIG90aGVyIGNvbGxpZGVyXG4gICAgICovXG5cdGNvbnN0cnVjdG9yKGFyZWE6IG51bWJlciwgY29sbGlkZXI6IEFBQkIsIG90aGVyOiBQaHlzaWNhbCwgdHlwZTogc3RyaW5nLCB0aWxlOiBWZWMyKXtcblx0XHR0aGlzLmFyZWEgPSBhcmVhO1xuICAgICAgICB0aGlzLmNvbGxpZGVyID0gY29sbGlkZXI7XG4gICAgICAgIHRoaXMub3RoZXIgPSBvdGhlcjtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy50aWxlID0gdGlsZTtcblx0fVxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9WZWMyXCI7XG5cbi8qKlxuICogQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgZGF0YSBjb2xsZWN0ZWQgZnJvbSBhIHBoeXNpY3MgaGl0IGJldHdlZW4gdHdvIGdlb21ldHJpYyBvYmplY3RzLlxuICogSW5zcGlyZWQgYnkgdGhlIGhlbHBmdWwgY29sbGlzaW9uIGRvY3VtZW50YXRpb24gQGxpbmsoaGVyZSkoaHR0cHM6Ly9ub29uYXQuZ2l0aHViLmlvL2ludGVyc2VjdC8pLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIaXQge1xuICAgIC8qKiBUaGUgdGltZSBvZiB0aGUgY29sbGlzaW9uLiBPbmx5IG51bWJlcnMgMCB0aHJvdWdoIDEgaGFwcGVuIGluIHRoaXMgZnJhbWUuICovXG4gICAgdGltZTogbnVtYmVyO1xuICAgIC8qKiBUaGUgbmVhciB0aW1lcyBvZiB0aGUgY29sbGlzaW9uICovXG4gICAgbmVhclRpbWVzOiBWZWMyID0gVmVjMi5aRVJPO1xuICAgIC8qKiBUaGUgcG9zaXRpb24gb2YgdGhlIGNvbGxpc2lvbiAqL1xuICAgIHBvczogVmVjMiA9IFZlYzIuWkVSTztcbiAgICAvKiogVGhlIG92ZXJsYXAgZGlzdGFuY2Ugb2YgdGhlIGhpdCAqL1xuICAgIGRlbHRhOiBWZWMyID0gVmVjMi5aRVJPO1xuICAgIC8qKiBUaGUgbm9ybWFsIHZlY3RvciBvZiB0aGUgaGl0ICovXG4gICAgbm9ybWFsOiBWZWMyID0gVmVjMi5aRVJPO1xufSIsIi8qKiBBIGNvbnRhaW5lciBmb3IgaW5mbyBhYm91dCBhIHdlYkdMIHNoYWRlciBwcm9ncmFtICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJHTFByb2dyYW1UeXBlIHtcblx0LyoqIEEgd2ViR0wgcHJvZ3JhbSAqL1xuXHRwcm9ncmFtOiBXZWJHTFByb2dyYW07XG5cdFxuXHQvKiogQSB2ZXJ0ZXggc2hhZGVyICovXG5cdHZlcnRleFNoYWRlcjogV2ViR0xTaGFkZXI7XG5cblx0LyoqIEEgZnJhZ21lbnQgc2hhZGVyICovXG5cdGZyYWdtZW50U2hhZGVyOiBXZWJHTFNoYWRlcjtcblxuXHQvKipcblx0ICogRGVsZXRlcyB0aGlzIHNoYWRlciBwcm9ncmFtXG5cdCAqL1xuXHRkZWxldGUoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCk6IHZvaWQge1xuXHRcdC8vIENsZWFuIHVwIGFsbCBhc3BlY3RzIG9mIHRoaXMgcHJvZ3JhbVxuXHRcdGlmKHRoaXMucHJvZ3JhbSl7XG5cdFx0XHRnbC5kZWxldGVQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG5cdFx0fVxuXHRcdFx0XG5cdFx0aWYodGhpcy52ZXJ0ZXhTaGFkZXIpe1xuXHRcdFx0Z2wuZGVsZXRlU2hhZGVyKHRoaXMudmVydGV4U2hhZGVyKTtcblx0XHR9XG5cblx0XHRpZih0aGlzLmZyYWdtZW50U2hhZGVyKXtcblx0XHRcdGdsLmRlbGV0ZVNoYWRlcih0aGlzLmZyYWdtZW50U2hhZGVyKTtcblx0XHR9XG5cdH1cbn0iLCJpbXBvcnQgU2hhcGUgZnJvbSBcIi4vU2hhcGVcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9WZWMyXCI7XG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuLi8uLi9VdGlscy9NYXRoVXRpbHNcIjtcbmltcG9ydCBDaXJjbGUgZnJvbSBcIi4vQ2lyY2xlXCI7XG5pbXBvcnQgSGl0IGZyb20gXCIuLi9QaHlzaWNzL0hpdFwiO1xuXG4vKipcbiAqIEFuIEF4aXMtQWxpZ25lZCBCb3VuZGluZyBCb3guIEluIG90aGVyIHdvcmRzLCBhIHJlY3RhbmdsZSB0aGF0IGlzIGFsd2F5cyBhbGlnbmVkIHRvIHRoZSB4LXkgZ3JpZC5cbiAqIEluc3BpcmVkIGJ5IHRoZSBoZWxwZnVsIGNvbGxpc2lvbiBkb2N1bWVudGF0aW9uIEBsaW5rKGhlcmUpKGh0dHBzOi8vbm9vbmF0LmdpdGh1Yi5pby9pbnRlcnNlY3QvKS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQUFCQiBleHRlbmRzIFNoYXBlIHtcbiAgICBjZW50ZXI6IFZlYzI7XG4gICAgaGFsZlNpemU6IFZlYzI7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEFBQkJcbiAgICAgKiBAcGFyYW0gY2VudGVyIFRoZSBjZW50ZXIgb2YgdGhlIEFBQkJcbiAgICAgKiBAcGFyYW0gaGFsZlNpemUgVGhlIGhhbGYgc2l6ZSBvZiB0aGUgQUFCQiAtIFRoZSBkaXN0YW5jZSBmcm9tIHRoZSBjZW50ZXIgdG8gYW4gZWRnZSBpbiB4IGFuZCB5XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2VudGVyPzogVmVjMiwgaGFsZlNpemU/OiBWZWMyKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jZW50ZXIgPSBjZW50ZXIgPyBjZW50ZXIgOiBuZXcgVmVjMigwLCAwKTtcbiAgICAgICAgdGhpcy5oYWxmU2l6ZSA9IGhhbGZTaXplID8gaGFsZlNpemUgOiBuZXcgVmVjMigwLCAwKTtcbiAgICB9XG5cbiAgICAvKiogUmV0dXJucyBhIHBvaW50IHJlcHJlc2VudGluZyB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBBQUJCICovXG4gICAgZ2V0IHRvcExlZnQoKTogVmVjMiB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjMih0aGlzLmxlZnQsIHRoaXMudG9wKVxuICAgIH1cblxuICAgIC8qKiBSZXR1cm5zIGEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSB0b3AgcmlnaHQgY29ybmVyIG9mIHRoZSBBQUJCICovXG4gICAgZ2V0IHRvcFJpZ2h0KCk6IFZlYzIge1xuICAgICAgICByZXR1cm4gbmV3IFZlYzIodGhpcy5yaWdodCwgdGhpcy50b3ApXG4gICAgfVxuXG4gICAgLyoqIFJldHVybnMgYSBwb2ludCByZXByZXNlbnRpbmcgdGhlIGJvdHRvbSBsZWZ0IGNvcm5lciBvZiB0aGUgQUFCQiAqL1xuICAgIGdldCBib3R0b21MZWZ0KCk6IFZlYzIge1xuICAgICAgICByZXR1cm4gbmV3IFZlYzIodGhpcy5sZWZ0LCB0aGlzLmJvdHRvbSlcbiAgICB9XG5cbiAgICAvKiogUmV0dXJucyBhIHBvaW50IHJlcHJlc2VudGluZyB0aGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgQUFCQiAqL1xuICAgIGdldCBib3R0b21SaWdodCgpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMucmlnaHQsIHRoaXMuYm90dG9tKVxuICAgIH1cblxuICAgIC8vIEBvdmVycmlkZVxuICAgIGdldEJvdW5kaW5nUmVjdCgpOiBBQUJCIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgICB9XG5cbiAgICAvLyBAb3ZlcnJpZGVcbiAgICBnZXRCb3VuZGluZ0NpcmNsZSgpOiBDaXJjbGUge1xuICAgICAgICBsZXQgciA9IE1hdGgubWF4KHRoaXMuaHcsIHRoaXMuaGgpXG4gICAgICAgIHJldHVybiBuZXcgQ2lyY2xlKHRoaXMuY2VudGVyLmNsb25lKCksIHIpO1xuICAgIH1cblxuICAgIC8vIEBkZXByZWNhdGVkXG4gICAgZ2V0SGFsZlNpemUoKTogVmVjMiB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbGZTaXplO1xuICAgIH1cblxuICAgIC8vIEBkZXByZWNhdGVkXG4gICAgc2V0SGFsZlNpemUoaGFsZlNpemU6IFZlYzIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5oYWxmU2l6ZSA9IGhhbGZTaXplO1xuICAgIH1cblxuICAgIC8vIFRPRE8gLSBtb3ZlIHRoZXNlIGFsbCB0byB0aGUgU2hhcGUgY2xhc3NcbiAgICAvKipcbiAgICAgKiBBIHNpbXBsZSBib29sZWFuIGNoZWNrIG9mIHdoZXRoZXIgdGhpcyBBQUJCIGNvbnRhaW5zIGEgcG9pbnRcbiAgICAgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IHRvIGNoZWNrXG4gICAgICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIHRoaXMgQUFCQiBjb250YWlucyB0aGUgc3BlY2lmaWVkIHBvaW50XG4gICAgICovXG4gICAgY29udGFpbnNQb2ludChwb2ludDogVmVjMik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gcG9pbnQueCA+PSB0aGlzLnggLSB0aGlzLmh3ICYmIHBvaW50LnggPD0gdGhpcy54ICsgdGhpcy5od1xuICAgICAgICAgICAgJiYgcG9pbnQueSA+PSB0aGlzLnkgLSB0aGlzLmhoICYmIHBvaW50LnkgPD0gdGhpcy55ICsgdGhpcy5oaFxuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBBIHNpbXBsZSBib29sZWFuIGNoZWNrIG9mIHdoZXRoZXIgdGhpcyBBQUJCIGNvbnRhaW5zIGEgcG9pbnRcbiAgICAgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IHRvIGNoZWNrXG4gICAgICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIHRoaXMgQUFCQiBjb250YWlucyB0aGUgc3BlY2lmaWVkIHBvaW50XG4gICAgICovXG4gICAgaW50ZXJzZWN0UG9pbnQocG9pbnQ6IFZlYzIpOiBib29sZWFuIHtcbiAgICAgICAgbGV0IGR4ID0gcG9pbnQueCAtIHRoaXMueDtcbiAgICAgICAgbGV0IHB4ID0gdGhpcy5odyAtIE1hdGguYWJzKGR4KTtcbiAgICAgICAgXG4gICAgICAgIGlmKHB4IDw9IDApe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGR5ID0gcG9pbnQueSAtIHRoaXMueTtcbiAgICAgICAgbGV0IHB5ID0gdGhpcy5oaCAtIE1hdGguYWJzKGR5KTtcblxuICAgICAgICBpZihweSA8PSAwKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgYm9vbGVhbiBjaGVjayBvZiB3aGV0aGVyIHRoaXMgQUFCQiBjb250YWlucyBhIHBvaW50IHdpdGggc29mdCBsZWZ0IGFuZCB0b3AgYm91bmRhcmllcy5cbiAgICAgKiBJbiBvdGhlciB3b3JkcywgaWYgdGhlIHRvcCBsZWZ0IGlzICgwLCAwKSwgdGhlIHBvaW50ICgwLCAwKSBpcyBub3QgaW4gdGhlIEFBQkJcbiAgICAgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IHRvIGNoZWNrXG4gICAgICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIHRoaXMgQUFCQiBjb250YWlucyB0aGUgc3BlY2lmaWVkIHBvaW50XG4gICAgICovXG4gICAgY29udGFpbnNQb2ludFNvZnQocG9pbnQ6IFZlYzIpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHBvaW50LnggPiB0aGlzLnggLSB0aGlzLmh3ICYmIHBvaW50LnggPD0gdGhpcy54ICsgdGhpcy5od1xuICAgICAgICAgICAgJiYgcG9pbnQueSA+IHRoaXMueSAtIHRoaXMuaGggJiYgcG9pbnQueSA8PSB0aGlzLnkgKyB0aGlzLmhoXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkYXRhIGZyb20gdGhlIGludGVyc2VjdGlvbiBvZiB0aGlzIEFBQkIgd2l0aCBhIGxpbmUgc2VnbWVudCBmcm9tIGEgcG9pbnQgaW4gYSBkaXJlY3Rpb25cbiAgICAgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IHRoYXQgdGhlIGxpbmUgc2VnbWVudCBzdGFydHMgZnJvbVxuICAgICAqIEBwYXJhbSBkZWx0YSBUaGUgZGlyZWN0aW9uIGFuZCBkaXN0YW5jZSBvZiB0aGUgc2VnbWVudFxuICAgICAqIEBwYXJhbSBwYWRkaW5nIFBhZHMgdGhlIEFBQkIgdG8gbWFrZSBpdCB3aWRlciBmb3IgdGhlIGludGVyc2VjdGlvbiB0ZXN0XG4gICAgICogQHJldHVybnMgVGhlIEhpdCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbnRlcnNlY3Rpb24sIG9yIG51bGwgaWYgdGhlcmUgd2FzIG5vIGludGVyc2VjdGlvblxuICAgICAqL1xuICAgIGludGVyc2VjdFNlZ21lbnQocG9pbnQ6IFZlYzIsIGRlbHRhOiBWZWMyLCBwYWRkaW5nPzogVmVjMik6IEhpdCB7XG4gICAgICAgIGxldCBwYWRkaW5nWCA9IHBhZGRpbmcgPyBwYWRkaW5nLnggOiAwO1xuICAgICAgICBsZXQgcGFkZGluZ1kgPSBwYWRkaW5nID8gcGFkZGluZy55IDogMDtcblxuICAgICAgICBsZXQgc2NhbGVYID0gMS9kZWx0YS54O1xuICAgICAgICBsZXQgc2NhbGVZID0gMS9kZWx0YS55O1xuXG4gICAgICAgIGxldCBzaWduWCA9IE1hdGhVdGlscy5zaWduKHNjYWxlWCk7XG4gICAgICAgIGxldCBzaWduWSA9IE1hdGhVdGlscy5zaWduKHNjYWxlWSk7XG5cbiAgICAgICAgbGV0IHRuZWFyeCA9IHNjYWxlWCoodGhpcy54IC0gc2lnblgqKHRoaXMuaHcgKyBwYWRkaW5nWCkgLSBwb2ludC54KTtcbiAgICAgICAgbGV0IHRuZWFyeSA9IHNjYWxlWSoodGhpcy55IC0gc2lnblkqKHRoaXMuaGggKyBwYWRkaW5nWSkgLSBwb2ludC55KTtcbiAgICAgICAgbGV0IHRmYXJ4ID0gc2NhbGVYKih0aGlzLnggKyBzaWduWCoodGhpcy5odyArIHBhZGRpbmdYKSAtIHBvaW50LngpO1xuICAgICAgICBsZXQgdGZhcnkgPSBzY2FsZVkqKHRoaXMueSArIHNpZ25ZKih0aGlzLmhoICsgcGFkZGluZ1kpIC0gcG9pbnQueSk7XG4gICAgICAgIFxuICAgICAgICBpZih0bmVhcnggPiB0ZmFyeSB8fCB0bmVhcnkgPiB0ZmFyeCl7XG4gICAgICAgICAgICAvLyBXZSBhcmVuJ3QgY29sbGlkaW5nIC0gd2UgY2xlYXIgb25lIGF4aXMgYmVmb3JlIGludGVyc2VjdGluZyBhbm90aGVyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0bmVhciA9IE1hdGgubWF4KHRuZWFyeCwgdG5lYXJ5KTtcblxuICAgICAgICAvLyBEb3VibGUgY2hlY2sgZm9yIE5hTnNcbiAgICAgICAgaWYodG5lYXJ4ICE9PSB0bmVhcngpe1xuICAgICAgICAgICAgdG5lYXIgPSB0bmVhcnk7XG4gICAgICAgIH0gZWxzZSBpZiAodG5lYXJ5ICE9PSB0bmVhcnkpe1xuICAgICAgICAgICAgdG5lYXIgPSB0bmVhcng7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdGZhciA9IE1hdGgubWluKHRmYXJ4LCB0ZmFyeSk7XG5cbiAgICAgICAgaWYodG5lYXIgPT09IC1JbmZpbml0eSl7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRuZWFyID49IDEgfHwgdGZhciA8PSAwKXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgYXJlIGNvbGxpZGluZ1xuICAgICAgICBsZXQgaGl0ID0gbmV3IEhpdCgpO1xuICAgICAgICBoaXQudGltZSA9IE1hdGhVdGlscy5jbGFtcDAxKHRuZWFyKTtcbiAgICAgICAgaGl0Lm5lYXJUaW1lcy54ID0gdG5lYXJ4O1xuICAgICAgICBoaXQubmVhclRpbWVzLnkgPSB0bmVhcnk7XG5cbiAgICAgICAgaWYodG5lYXJ4ID4gdG5lYXJ5KXtcbiAgICAgICAgICAgIC8vIFdlIGhpdCBvbiB0aGUgbGVmdCBvciByaWdodCBzaXplXG4gICAgICAgICAgICBoaXQubm9ybWFsLnggPSAtc2lnblg7XG4gICAgICAgICAgICBoaXQubm9ybWFsLnkgPSAwO1xuICAgICAgICB9IGVsc2UgaWYoTWF0aC5hYnModG5lYXJ4IC0gdG5lYXJ5KSA8IDAuMDAwMSl7XG4gICAgICAgICAgICAvLyBXZSBoaXQgb24gdGhlIGNvcm5lclxuICAgICAgICAgICAgaGl0Lm5vcm1hbC54ID0gLXNpZ25YO1xuICAgICAgICAgICAgaGl0Lm5vcm1hbC55ID0gLXNpZ25ZO1xuICAgICAgICAgICAgaGl0Lm5vcm1hbC5ub3JtYWxpemUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlIGhpdCBvbiB0aGUgdG9wIG9yIGJvdHRvbVxuICAgICAgICAgICAgaGl0Lm5vcm1hbC54ID0gMDtcbiAgICAgICAgICAgIGhpdC5ub3JtYWwueSA9IC1zaWduWTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhpdC5kZWx0YS54ID0gKDEuMCAtIGhpdC50aW1lKSAqIC1kZWx0YS54O1xuICAgICAgICBoaXQuZGVsdGEueSA9ICgxLjAgLSBoaXQudGltZSkgKiAtZGVsdGEueTtcbiAgICAgICAgaGl0LnBvcy54ID0gcG9pbnQueCArIGRlbHRhLnggKiBoaXQudGltZTtcbiAgICAgICAgaGl0LnBvcy55ID0gcG9pbnQueSArIGRlbHRhLnkgKiBoaXQudGltZTtcblxuICAgICAgICByZXR1cm4gaGl0O1xuICAgIH1cblxuICAgIC8vIEBvdmVycmlkZVxuICAgIG92ZXJsYXBzKG90aGVyOiBTaGFwZSk6IGJvb2xlYW4ge1xuICAgICAgICBpZihvdGhlciBpbnN0YW5jZW9mIEFBQkIpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3ZlcmxhcHNBQUJCKG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBcIk92ZXJsYXAgbm90IGRlZmluZWQgYmV0d2VlbiB0aGVzZSBzaGFwZXMuXCJcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNpbXBsZSBib29sZWFuIGNoZWNrIG9mIHdoZXRoZXIgdGhpcyBBQUJCIG92ZXJsYXBzIGFub3RoZXJcbiAgICAgKiBAcGFyYW0gb3RoZXIgVGhlIG90aGVyIEFBQkIgdG8gY2hlY2sgYWdhaW5zdFxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhpcyBBQUJCIG92ZXJsYXBzIHRoZSBvdGhlciwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgcHJvdGVjdGVkIG92ZXJsYXBzQUFCQihvdGhlcjogQUFCQik6IGJvb2xlYW4ge1xuICAgICAgICBsZXQgZHggPSBvdGhlci54IC0gdGhpcy54O1xuICAgICAgICBsZXQgcHggPSB0aGlzLmh3ICsgb3RoZXIuaHcgLSBNYXRoLmFicyhkeCk7XG4gICAgICAgIFxuICAgICAgICBpZihweCA8PSAwKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBkeSA9IG90aGVyLnkgLSB0aGlzLnk7XG4gICAgICAgIGxldCBweSA9IHRoaXMuaGggKyBvdGhlci5oaCAtIE1hdGguYWJzKGR5KTtcblxuICAgICAgICBpZihweSA8PSAwKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGVzZSBBQUJCcyBhcmUgSlVTVCB0b3VjaGluZyAtIG5vdCBvdmVybGFwcGluZy5cbiAgICAgKiBWZWMyLnggaXMgLTEgaWYgdGhlIG90aGVyIGlzIHRvIHRoZSBsZWZ0LCAxIGlmIHRvIHRoZSByaWdodC5cbiAgICAgKiBMaWtld2lzZSwgVmVjMi55IGlzIC0xIGlmIHRoZSBvdGhlciBpcyBvbiB0b3AsIDEgaWYgb24gYm90dG9tLlxuICAgICAqIEBwYXJhbSBvdGhlciBUaGUgb3RoZXIgQUFCQiB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIFRoZSBjb2xsaXNpb24gc2lkZXMgc3RvcmVkIGluIGEgVmVjMiBpZiB0aGUgQUFCQnMgYXJlIHRvdWNoaW5nLCBudWxsIG90aGVyd2lzZVxuICAgICAqL1xuICAgIHRvdWNoZXNBQUJCKG90aGVyOiBBQUJCKTogVmVjMiB7XG4gICAgICAgIGxldCBkeCA9IG90aGVyLnggLSB0aGlzLng7XG4gICAgICAgIGxldCBweCA9IHRoaXMuaHcgKyBvdGhlci5odyAtIE1hdGguYWJzKGR4KTtcblxuICAgICAgICBsZXQgZHkgPSBvdGhlci55IC0gdGhpcy55O1xuICAgICAgICBsZXQgcHkgPSB0aGlzLmhoICsgb3RoZXIuaGggLSBNYXRoLmFicyhkeSk7XG5cbiAgICAgICAgLy8gSWYgb25lIGF4aXMgaXMganVzdCB0b3VjaGluZyBhbmQgdGhlIG90aGVyIGlzIG92ZXJsYXBwaW5nLCB0cnVlXG4gICAgICAgIGlmKChweCA9PT0gMCAmJiBweSA+PSAwKSB8fCAocHkgPT09IDAgJiYgcHggPj0gMCkpe1xuICAgICAgICAgICAgbGV0IHJldCA9IG5ldyBWZWMyKCk7XG5cbiAgICAgICAgICAgIGlmKHB4ID09PSAwKXtcbiAgICAgICAgICAgICAgICByZXQueCA9IG90aGVyLnggPCB0aGlzLnggPyAtMSA6IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHB5ID09PSAwKXtcbiAgICAgICAgICAgICAgICByZXQueSA9IG90aGVyLnkgPCB0aGlzLnkgPyAtMSA6IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGVzZSBBQUJCcyBhcmUgSlVTVCB0b3VjaGluZyAtIG5vdCBvdmVybGFwcGluZy5cbiAgICAgKiBBbHNvLCBpZiB0aGV5IGFyZSBvbmx5IHRvdWNoaW5nIGNvcm5lcnMsIHRoZXkgYXJlIGNvbnNpZGVyZWQgbm90IHRvdWNoaW5nLlxuICAgICAqIFZlYzIueCBpcyAtMSBpZiB0aGUgb3RoZXIgaXMgdG8gdGhlIGxlZnQsIDEgaWYgdG8gdGhlIHJpZ2h0LlxuICAgICAqIExpa2V3aXNlLCBWZWMyLnkgaXMgLTEgaWYgdGhlIG90aGVyIGlzIG9uIHRvcCwgMSBpZiBvbiBib3R0b20uXG4gICAgICogQHBhcmFtIG90aGVyIFRoZSBvdGhlciBBQUJCIHRvIGNoZWNrXG4gICAgICogQHJldHVybnMgVGhlIHNpZGUgb2YgdGhlIHRvdWNoLCBzdG9yZWQgYXMgYSBWZWMyLCBvciBudWxsIGlmIHRoZXJlIGlzIG5vIHRvdWNoXG4gICAgICovXG4gICAgdG91Y2hlc0FBQkJXaXRob3V0Q29ybmVycyhvdGhlcjogQUFCQik6IFZlYzIge1xuICAgICAgICBsZXQgZHggPSBvdGhlci54IC0gdGhpcy54O1xuICAgICAgICBsZXQgcHggPSB0aGlzLmh3ICsgb3RoZXIuaHcgLSBNYXRoLmFicyhkeCk7XG5cbiAgICAgICAgbGV0IGR5ID0gb3RoZXIueSAtIHRoaXMueTtcbiAgICAgICAgbGV0IHB5ID0gdGhpcy5oaCArIG90aGVyLmhoIC0gTWF0aC5hYnMoZHkpO1xuXG4gICAgICAgIC8vIElmIG9uZSBheGlzIGlzIHRvdWNoaW5nLCBhbmQgdGhlIG90aGVyIGlzIHN0cmljdGx5IG92ZXJsYXBwaW5nXG4gICAgICAgIGlmKChweCA9PT0gMCAmJiBweSA+IDApIHx8IChweSA9PT0gMCAmJiBweCA+IDApKXtcbiAgICAgICAgICAgIGxldCByZXQgPSBuZXcgVmVjMigpO1xuXG4gICAgICAgICAgICBpZihweCA9PT0gMCl7XG4gICAgICAgICAgICAgICAgcmV0LnggPSBvdGhlci54IDwgdGhpcy54ID8gLTEgOiAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXQueSA9IG90aGVyLnkgPCB0aGlzLnkgPyAtMSA6IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgYXJlYSBvZiB0aGUgb3ZlcmxhcCBiZXR3ZWVuIHRoaXMgQUFCQiBhbmQgYW5vdGhlclxuICAgICAqIEBwYXJhbSBvdGhlciBUaGUgb3RoZXIgQUFCQlxuICAgICAqIEByZXR1cm5zIFRoZSBhcmVhIG9mIHRoZSBvdmVybGFwIGJldHdlZW4gdGhlIEFBQkJzXG4gICAgICovXG4gICAgb3ZlcmxhcEFyZWEob3RoZXI6IEFBQkIpOiBudW1iZXIge1xuICAgICAgICBsZXQgbGVmdHggPSBNYXRoLm1heCh0aGlzLnggLSB0aGlzLmh3LCBvdGhlci54IC0gb3RoZXIuaHcpO1xuICAgICAgICBsZXQgcmlnaHR4ID0gTWF0aC5taW4odGhpcy54ICsgdGhpcy5odywgb3RoZXIueCArIG90aGVyLmh3KTtcbiAgICAgICAgbGV0IGR4ID0gcmlnaHR4IC0gbGVmdHg7XG5cbiAgICAgICAgbGV0IGxlZnR5ID0gTWF0aC5tYXgodGhpcy55IC0gdGhpcy5oaCwgb3RoZXIueSAtIG90aGVyLmhoKTtcbiAgICAgICAgbGV0IHJpZ2h0eSA9IE1hdGgubWluKHRoaXMueSArIHRoaXMuaGgsIG90aGVyLnkgKyBvdGhlci5oaCk7XG4gICAgICAgIGxldCBkeSA9IHJpZ2h0eSAtIGxlZnR5O1xuXG4gICAgICAgIGlmKGR4IDwgMCB8fCBkeSA8IDApIHJldHVybiAwO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGR4KmR5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGFuZCByZXNpemVzIHRoaXMgcmVjdCBmcm9tIGl0cyBjdXJyZW50IHBvc2l0aW9uIHRvIHRoZSBwb3NpdGlvbiBzcGVjaWZpZWRcbiAgICAgKiBAcGFyYW0gdmVsb2NpdHkgVGhlIG1vdmVtZW50IG9mIHRoZSByZWN0IGZyb20gaXRzIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIGZyb21Qb3NpdGlvbiBBIHBvc2l0aW9uIHNwZWNpZmllZCB0byBiZSB0aGUgc3RhcnRpbmcgcG9pbnQgb2Ygc3dlZXBpbmdcbiAgICAgKiBAcGFyYW0gaGFsZlNpemUgVGhlIGhhbGZTaXplIG9mIHRoZSBzd2VlcGluZyByZWN0IFxuICAgICAqL1xuICAgIHN3ZWVwKHZlbG9jaXR5OiBWZWMyLCBmcm9tUG9zaXRpb24/OiBWZWMyLCBoYWxmU2l6ZT86IFZlYzIpOiB2b2lkIHtcbiAgICAgICAgaWYoIWZyb21Qb3NpdGlvbil7XG4gICAgICAgICAgICBmcm9tUG9zaXRpb24gPSB0aGlzLmNlbnRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFoYWxmU2l6ZSl7XG4gICAgICAgICAgICBoYWxmU2l6ZSA9IHRoaXMuaGFsZlNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY2VudGVyWCA9IGZyb21Qb3NpdGlvbi54ICsgdmVsb2NpdHkueC8yO1xuICAgICAgICBsZXQgY2VudGVyWSA9IGZyb21Qb3NpdGlvbi55ICsgdmVsb2NpdHkueS8yO1xuXG4gICAgICAgIGxldCBtaW5YID0gTWF0aC5taW4oZnJvbVBvc2l0aW9uLnggLSBoYWxmU2l6ZS54LCBmcm9tUG9zaXRpb24ueCArIHZlbG9jaXR5LnggLSBoYWxmU2l6ZS54KTtcbiAgICAgICAgbGV0IG1pblkgPSBNYXRoLm1pbihmcm9tUG9zaXRpb24ueSAtIGhhbGZTaXplLnksIGZyb21Qb3NpdGlvbi55ICsgdmVsb2NpdHkueSAtIGhhbGZTaXplLnkpO1xuXG4gICAgICAgIHRoaXMuY2VudGVyLnNldChjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICAgICAgdGhpcy5oYWxmU2l6ZS5zZXQoY2VudGVyWCAtIG1pblgsIGNlbnRlclkgLSBtaW5ZKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgY2xvbmUoKTogQUFCQiB7XG4gICAgICAgIHJldHVybiBuZXcgQUFCQih0aGlzLmNlbnRlci5jbG9uZSgpLCB0aGlzLmhhbGZTaXplLmNsb25lKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoaXMgQUFCQiB0byBhIHN0cmluZyBmb3JtYXRcbiAgICAgKiBAcmV0dXJucyAoY2VudGVyOiAoeCwgeSksIGhhbGZTaXplOiAoeCwgeSkpXG4gICAgICovXG4gICAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIFwiKGNlbnRlcjogXCIgKyB0aGlzLmNlbnRlci50b1N0cmluZygpICsgXCIsIGhhbGYtc2l6ZTogXCIgKyB0aGlzLmhhbGZTaXplLnRvU3RyaW5nKCkgKyBcIilcIlxuICAgIH1cbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vVmVjMlwiO1xuaW1wb3J0IEFBQkIgZnJvbSBcIi4vQUFCQlwiO1xuaW1wb3J0IFNoYXBlIGZyb20gXCIuL1NoYXBlXCI7XG5cbi8qKlxuICogQSBDaXJjbGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2lyY2xlIGV4dGVuZHMgU2hhcGUge1xuXHRwcml2YXRlIF9jZW50ZXI6IFZlYzI7XG5cdHJhZGl1czogbnVtYmVyO1xuXHRcblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgQ2lyY2xlXG5cdCAqIEBwYXJhbSBjZW50ZXIgVGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlXG5cdCAqIEBwYXJhbSByYWRpdXMgVGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihjZW50ZXI6IFZlYzIsIHJhZGl1czogbnVtYmVyKSB7XG5cdFx0c3VwZXIoKTtcbiAgICAgICAgdGhpcy5fY2VudGVyID0gY2VudGVyID8gY2VudGVyIDogbmV3IFZlYzIoMCwgMCk7XG4gICAgICAgIHRoaXMucmFkaXVzID0gcmFkaXVzID8gcmFkaXVzIDogMDtcblx0fVxuXG5cdGdldCBjZW50ZXIoKTogVmVjMiB7XG5cdFx0cmV0dXJuIHRoaXMuX2NlbnRlcjtcblx0fVxuXG5cdHNldCBjZW50ZXIoY2VudGVyOiBWZWMyKSB7XG5cdFx0dGhpcy5fY2VudGVyID0gY2VudGVyO1xuXHR9XG5cblx0Z2V0IGhhbGZTaXplKCk6IFZlYzIge1xuXHRcdHJldHVybiBuZXcgVmVjMih0aGlzLnJhZGl1cywgdGhpcy5yYWRpdXMpO1xuXHR9XG5cblx0Z2V0IHIoKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5yYWRpdXM7XG5cdH1cblxuXHRzZXQgcihyYWRpdXM6IG51bWJlcikge1xuXHRcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xuXHR9XG5cblx0Ly8gQG92ZXJyaWRlXG5cdC8qKlxuICAgICAqIEEgc2ltcGxlIGJvb2xlYW4gY2hlY2sgb2Ygd2hldGhlciB0aGlzIEFBQkIgY29udGFpbnMgYSBwb2ludFxuICAgICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgdGhpcyBBQUJCIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgcG9pbnRcbiAgICAgKi9cbiAgICBjb250YWluc1BvaW50KHBvaW50OiBWZWMyKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNlbnRlci5kaXN0YW5jZVNxVG8ocG9pbnQpIDw9IHRoaXMucmFkaXVzKnRoaXMucmFkaXVzO1xuICAgIH1cblxuXHQvLyBAb3ZlcnJpZGVcblx0Z2V0Qm91bmRpbmdSZWN0KCk6IEFBQkIge1xuXHRcdHJldHVybiBuZXcgQUFCQih0aGlzLl9jZW50ZXIuY2xvbmUoKSwgbmV3IFZlYzIodGhpcy5yYWRpdXMsIHRoaXMucmFkaXVzKSk7XG5cdH1cblxuXHQvLyBAb3ZlcnJpZGVcblx0Z2V0Qm91bmRpbmdDaXJjbGUoKTogQ2lyY2xlIHtcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpO1xuXHR9XG5cblx0Ly8gQG92ZXJyaWRlXG5cdG92ZXJsYXBzKG90aGVyOiBTaGFwZSk6IGJvb2xlYW4ge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuXHR9XG5cblx0Ly8gQG92ZXJyaWRlXG5cdGNsb25lKCk6IENpcmNsZSB7XG5cdFx0cmV0dXJuIG5ldyBDaXJjbGUodGhpcy5fY2VudGVyLmNsb25lKCksIHRoaXMucmFkaXVzKTtcblx0fVxuXG5cdHRvU3RyaW5nKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuIFwiKGNlbnRlcjogXCIgKyB0aGlzLmNlbnRlci50b1N0cmluZygpICsgXCIsIHJhZGl1czogXCIgKyB0aGlzLnJhZGl1cyArIFwiKVwiO1xuXHR9XG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1ZlYzJcIjtcbmltcG9ydCBBQUJCIGZyb20gXCIuL0FBQkJcIjtcbmltcG9ydCBDaXJjbGUgZnJvbSBcIi4vQ2lyY2xlXCI7XG5cbi8qKlxuICogQW4gYWJzdHJhY3QgU2hhcGUgY2xhc3MgdGhhdCBhY3RzIGFzIGFuIGludGVyZmFjZSBmb3IgYmV0dGVyIGludGVyYWN0aW9ucyB3aXRoIHN1YmNsYXNzZXMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFNoYXBlIHtcbiAgICBhYnN0cmFjdCBnZXQgY2VudGVyKCk6IFZlYzI7XG5cbiAgICBhYnN0cmFjdCBzZXQgY2VudGVyKGNlbnRlcjogVmVjMik7XG5cbiAgICBhYnN0cmFjdCBnZXQgaGFsZlNpemUoKTogVmVjMjtcblxuICAgIGdldCB4KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmNlbnRlci54O1xuICAgIH1cblxuICAgIGdldCB5KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmNlbnRlci55O1xuICAgIH1cblxuICAgIGdldCBodygpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5oYWxmU2l6ZS54O1xuICAgIH1cblxuICAgIGdldCBoaCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5oYWxmU2l6ZS55O1xuICAgIH1cblxuICAgIGdldCB0b3AoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueSAtIHRoaXMuaGg7XG4gICAgfVxuXG4gICAgZ2V0IGJvdHRvbSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy55ICsgdGhpcy5oaDtcbiAgICB9XG5cbiAgICBnZXQgbGVmdCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy54IC0gdGhpcy5odztcbiAgICB9XG5cbiAgICBnZXQgcmlnaHQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCArIHRoaXMuaHc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIGJvdW5kaW5nIHJlY3RhbmdsZSBmb3IgdGhpcyBzaGFwZS4gV2FybmluZyAtIG1heSBiZSB0aGUgc2FtZSBhcyB0aGlzIFNoYXBlLlxuICAgICAqIEZvciBpbnN0YW5jZSwgdGhlIGJvdW5kaW5nIGNpcmNsZSBvZiBhbiBBQUJCIGlzIGl0c2VsZi4gVXNlIGNsb25lKCkgaWYgeW91IG5lZWQgYSBuZXcgc2hhcGUuXG4gICAgICogQHJldHVybnMgQW4gQUFCQiB0aGF0IGJvdW5kcyB0aGlzIHNoYXBlXG4gICAgICovXG4gICAgYWJzdHJhY3QgZ2V0Qm91bmRpbmdSZWN0KCk6IEFBQkI7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgYm91bmRpbmcgY2lyY2xlIGZvciB0aGlzIHNoYXBlLiBXYXJuaW5nIC0gbWF5IGJlIHRoZSBzYW1lIGFzIHRoaXMgU2hhcGUuXG4gICAgICogRm9yIGluc3RhbmNlLCB0aGUgYm91bmRpbmcgY2lyY2xlIG9mIGEgQ2lyY2xlIGlzIGl0c2VsZi4gVXNlIGNsb25lKCkgaWYgeW91IG5lZWQgYSBuZXcgc2hhcGUuXG4gICAgICogQHJldHVybnMgQSBDaXJjbGUgdGhhdCBib3VuZHMgdGhpcyBzaGFwZVxuICAgICAqL1xuICAgIGFic3RyYWN0IGdldEJvdW5kaW5nQ2lyY2xlKCk6IENpcmNsZTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgU2hhcGVcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBjb3B5IG9mIHRoaXMgc2hhcGVcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBjbG9uZSgpOiBTaGFwZTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGlzIHNoYXBlIG92ZXJsYXBzIGFub3RoZXJcbiAgICAgKiBAcGFyYW0gb3RoZXIgVGhlIG90aGVyIHNoYXBlIHRvIGNoZWNrIGFnYWluc3RcbiAgICAgKiBAcmV0dXJucyBhIGJvb2xlYW4gdGhhdCByZXByZXNlbnRzIHdoZXRoZXIgdGhpcyBTaGFwZSBvdmVybGFwcyB0aGUgb3RoZXIgb25lXG4gICAgICovXG4gICAgYWJzdHJhY3Qgb3ZlcmxhcHMob3RoZXI6IFNoYXBlKTogYm9vbGVhbjtcblxuICAgICAvKipcbiAgICAgKiBBIHNpbXBsZSBib29sZWFuIGNoZWNrIG9mIHdoZXRoZXIgdGhpcyBTaGFwZSBjb250YWlucyBhIHBvaW50XG4gICAgICogQHBhcmFtIHBvaW50IFRoZSBwb2ludCB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciB0aGlzIFNoYXBlIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgcG9pbnRcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBjb250YWluc1BvaW50KHBvaW50OiBWZWMyKTogYm9vbGVhbjtcblxuICAgIHN0YXRpYyBnZXRUaW1lT2ZDb2xsaXNpb24oQTogU2hhcGUsIHZlbEE6IFZlYzIsIEI6IFNoYXBlLCB2ZWxCOiBWZWMyKTogW1ZlYzIsIFZlYzIsIGJvb2xlYW4sIGJvb2xlYW5dIHtcblx0XHRpZihBIGluc3RhbmNlb2YgQUFCQiAmJiBCIGluc3RhbmNlb2YgQUFCQil7XG5cdFx0XHRyZXR1cm4gU2hhcGUuZ2V0VGltZU9mQ29sbGlzaW9uX0FBQkJfQUFCQihBLCB2ZWxBLCBCLCB2ZWxCKTtcblx0XHR9XG4gICAgfVxuICAgIFxuICAgIHByaXZhdGUgc3RhdGljIGdldFRpbWVPZkNvbGxpc2lvbl9BQUJCX0FBQkIoQTogQUFCQiwgdmVsQTogVmVjMiwgQjogU2hhcGUsIHZlbEI6IFZlYzIpOiBbVmVjMiwgVmVjMiwgYm9vbGVhbiwgYm9vbGVhbl0ge1xuICAgICAgICBsZXQgcG9zU21hbGxlciA9IEEuY2VudGVyO1xuICAgICAgICBsZXQgcG9zTGFyZ2VyID0gQi5jZW50ZXI7XG4gICAgICAgIFxuICAgICAgICBsZXQgc2l6ZVNtYWxsZXIgPSBBLmhhbGZTaXplO1xuICAgICAgICBsZXQgc2l6ZUxhcmdlciA9IEIuaGFsZlNpemU7XG4gICAgXG4gICAgICAgIGxldCBmaXJzdENvbnRhY3QgPSBuZXcgVmVjMigwLCAwKTtcbiAgICAgICAgbGV0IGxhc3RDb250YWN0ID0gbmV3IFZlYzIoMCwgMCk7XG4gICAgXG4gICAgICAgIGxldCBjb2xsaWRpbmdYID0gZmFsc2U7XG4gICAgICAgIGxldCBjb2xsaWRpbmdZID0gZmFsc2U7XG4gICAgXG4gICAgICAgIC8vIFNvcnQgYnkgcG9zaXRpb25cbiAgICAgICAgaWYocG9zTGFyZ2VyLnggPCBwb3NTbWFsbGVyLngpe1xuICAgICAgICAgICAgLy8gU3dhcCwgYmVjYXVzZSBzbWFsbGVyIGlzIGZ1cnRoZXIgcmlnaHQgdGhhbiBsYXJnZXJcbiAgICAgICAgICAgIGxldCB0ZW1wOiBWZWMyO1xuICAgICAgICAgICAgdGVtcCA9IHNpemVTbWFsbGVyO1xuICAgICAgICAgICAgc2l6ZVNtYWxsZXIgPSBzaXplTGFyZ2VyO1xuICAgICAgICAgICAgc2l6ZUxhcmdlciA9IHRlbXA7XG4gICAgXG4gICAgICAgICAgICB0ZW1wID0gcG9zU21hbGxlcjtcbiAgICAgICAgICAgIHBvc1NtYWxsZXIgPSBwb3NMYXJnZXI7XG4gICAgICAgICAgICBwb3NMYXJnZXIgPSB0ZW1wO1xuICAgIFxuICAgICAgICAgICAgdGVtcCA9IHZlbEE7XG4gICAgICAgICAgICB2ZWxBID0gdmVsQjtcbiAgICAgICAgICAgIHZlbEIgPSB0ZW1wO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIEEgaXMgbGVmdCwgQiBpcyByaWdodFxuICAgICAgICBmaXJzdENvbnRhY3QueCA9IEluZmluaXR5O1xuICAgICAgICBsYXN0Q29udGFjdC54ID0gSW5maW5pdHk7XG4gICAgXG4gICAgICAgIGlmIChwb3NMYXJnZXIueCAtIHNpemVMYXJnZXIueCA+PSBwb3NTbWFsbGVyLnggKyBzaXplU21hbGxlci54KXtcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZW4ndCBjdXJyZW50bHkgY29sbGlkaW5nXG4gICAgICAgICAgICBsZXQgcmVsVmVsID0gdmVsQS54IC0gdmVsQi54O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihyZWxWZWwgPiAwKXtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGV5IGFyZSBtb3ZpbmcgdG93YXJkcyBlYWNoIG90aGVyXG4gICAgICAgICAgICAgICAgZmlyc3RDb250YWN0LnggPSAoKHBvc0xhcmdlci54IC0gc2l6ZUxhcmdlci54KSAtIChwb3NTbWFsbGVyLnggKyBzaXplU21hbGxlci54KSkvKHJlbFZlbCk7XG4gICAgICAgICAgICAgICAgbGFzdENvbnRhY3QueCA9ICgocG9zTGFyZ2VyLnggKyBzaXplTGFyZ2VyLngpIC0gKHBvc1NtYWxsZXIueCAtIHNpemVTbWFsbGVyLngpKS8ocmVsVmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbGxpZGluZ1ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIGlmKHBvc0xhcmdlci55IDwgcG9zU21hbGxlci55KXtcbiAgICAgICAgICAgIC8vIFN3YXAsIGJlY2F1c2Ugc21hbGxlciBpcyBmdXJ0aGVyIHVwIHRoYW4gbGFyZ2VyXG4gICAgICAgICAgICBsZXQgdGVtcDogVmVjMjtcbiAgICAgICAgICAgIHRlbXAgPSBzaXplU21hbGxlcjtcbiAgICAgICAgICAgIHNpemVTbWFsbGVyID0gc2l6ZUxhcmdlcjtcbiAgICAgICAgICAgIHNpemVMYXJnZXIgPSB0ZW1wO1xuICAgIFxuICAgICAgICAgICAgdGVtcCA9IHBvc1NtYWxsZXI7XG4gICAgICAgICAgICBwb3NTbWFsbGVyID0gcG9zTGFyZ2VyO1xuICAgICAgICAgICAgcG9zTGFyZ2VyID0gdGVtcDtcbiAgICBcbiAgICAgICAgICAgIHRlbXAgPSB2ZWxBO1xuICAgICAgICAgICAgdmVsQSA9IHZlbEI7XG4gICAgICAgICAgICB2ZWxCID0gdGVtcDtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICAvLyBBIGlzIHRvcCwgQiBpcyBib3R0b21cbiAgICAgICAgZmlyc3RDb250YWN0LnkgPSBJbmZpbml0eTtcbiAgICAgICAgbGFzdENvbnRhY3QueSA9IEluZmluaXR5O1xuICAgIFxuICAgICAgICBpZiAocG9zTGFyZ2VyLnkgLSBzaXplTGFyZ2VyLnkgPj0gcG9zU21hbGxlci55ICsgc2l6ZVNtYWxsZXIueSl7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmVuJ3QgY3VycmVudGx5IGNvbGxpZGluZ1xuICAgICAgICAgICAgbGV0IHJlbFZlbCA9IHZlbEEueSAtIHZlbEIueTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYocmVsVmVsID4gMCl7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhleSBhcmUgbW92aW5nIHRvd2FyZHMgZWFjaCBvdGhlclxuICAgICAgICAgICAgICAgIGZpcnN0Q29udGFjdC55ID0gKChwb3NMYXJnZXIueSAtIHNpemVMYXJnZXIueSkgLSAocG9zU21hbGxlci55ICsgc2l6ZVNtYWxsZXIueSkpLyhyZWxWZWwpO1xuICAgICAgICAgICAgICAgIGxhc3RDb250YWN0LnkgPSAoKHBvc0xhcmdlci55ICsgc2l6ZUxhcmdlci55KSAtIChwb3NTbWFsbGVyLnkgLSBzaXplU21hbGxlci55KSkvKHJlbFZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2xsaWRpbmdZID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICByZXR1cm4gW2ZpcnN0Q29udGFjdCwgbGFzdENvbnRhY3QsIGNvbGxpZGluZ1gsIGNvbGxpZGluZ1ldO1xuICAgIH1cbn0iLCJpbXBvcnQgRW1pdHRlciBmcm9tIFwiLi4vLi4vRXZlbnRzL0VtaXR0ZXJcIjtcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uLy4uL0V2ZW50cy9HYW1lRXZlbnRcIjtcbmltcG9ydCBVcGRhdGVhYmxlIGZyb20gXCIuLi9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcbmltcG9ydCBTdGF0ZU1hY2hpbmUgZnJvbSBcIi4vU3RhdGVNYWNoaW5lXCI7XG5cbi8qKlxuICogQW4gYWJzdHJhY3QgaW1wbGVtZW50YXRpb24gb2YgYSBzdGF0ZSBmb3IgYSBAcmVmZXJlbmNlW1N0YXRlTWFjaGluZV0uXG4gKiBUaGlzIGNsYXNzIHNob3VsZCBiZSBleHRlbmRlZCB0byBhbGxvdyBmb3IgY3VzdG9tIHN0YXRlIGJlaGF2aW9ycy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgU3RhdGUgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcbiAgICAvKiogVGhlIFN0YXRlTWFjaGluZSB0aGF0IHVzZXMgdGhpcyBTdGF0ZSAqL1xuICAgIHByb3RlY3RlZCBwYXJlbnQ6IFN0YXRlTWFjaGluZTtcblxuICAgIC8qKiBBbiBldmVudCBlbWl0dGVyICovXG4gICAgcHJvdGVjdGVkIGVtaXR0ZXI6IEVtaXR0ZXI7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFN0YXRlXG4gICAgICogQHBhcmFtIHBhcmVudCBUaGUgcGFyZW50IFN0YXRlTWFjaGluZSBvZiB0aGlzIHN0YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBTdGF0ZU1hY2hpbmUpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBtZXRob2QgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGlzIHN0YXRlIGlzIGVudGVyZWQuIFVzZSB0aGlzIHRvIGluaXRpYWxpemUgYW55IHZhcmlhYmxlcyBiZWZvcmUgdXBkYXRlcyBvY2N1ci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBJbmZvcm1hdGlvbiB0byBwYXNzIHRvIHRoaXMgc3RhdGVcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBvbkVudGVyKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogQSBsaWZlY3ljbGUgbWV0aG9kIHRoYXQgaGFuZGxlcyBhbiBpbnB1dCBldmVudCwgc3VjaCBhcyB0YWtpbmcgZGFtYWdlLlxuICAgICAqIEBwYXJhbSBldmVudCBUaGUgR2FtZUV2ZW50IHRvIHByb2Nlc3NcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBoYW5kbGVJbnB1dChldmVudDogR2FtZUV2ZW50KTogdm9pZDtcblxuICAgIC8vIEBpbXBsZW1lbnRlZFxuICAgIGFic3RyYWN0IHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBUZWxscyB0aGUgc3RhdGUgbWFjaGluZSB0aGF0IHRoaXMgc3RhdGUgaGFzIGVuZGVkLCBhbmQgbWFrZXMgaXQgdHJhbnNpdGlvbiB0byB0aGUgbmV3IHN0YXRlIHNwZWNpZmllZFxuICAgICAqIEBwYXJhbSBzdGF0ZU5hbWUgVGhlIG5hbWUgb2YgdGhlIHN0YXRlIHRvIHRyYW5zaXRpb24gdG9cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZmluaXNoZWQoc3RhdGVOYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuY2hhbmdlU3RhdGUoc3RhdGVOYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGxpZmVjeWNsZSBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlIHN0YXRlIGlzIGVuZGluZy5cbiAgICAgKiBAcmV0dXJucyBpbmZvIHRvIHBhc3MgdG8gdGhlIG5leHQgc3RhdGVcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBvbkV4aXQoKTogUmVjb3JkPHN0cmluZywgYW55Pjtcbn0iLCJpbXBvcnQgU3RhY2sgZnJvbSBcIi4uL0NvbGxlY3Rpb25zL1N0YWNrXCI7XG5pbXBvcnQgU3RhdGUgZnJvbSBcIi4vU3RhdGVcIjtcbmltcG9ydCBNYXAgZnJvbSBcIi4uL0NvbGxlY3Rpb25zL01hcFwiO1xuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vLi4vRXZlbnRzL0dhbWVFdmVudFwiO1xuaW1wb3J0IFJlY2VpdmVyIGZyb20gXCIuLi8uLi9FdmVudHMvUmVjZWl2ZXJcIjtcbmltcG9ydCBFbWl0dGVyIGZyb20gXCIuLi8uLi9FdmVudHMvRW1pdHRlclwiO1xuaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0ludGVyZmFjZXMvVXBkYXRlYWJsZVwiO1xuXG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGEgUHVzaCBEb3duIEF1dG9tYXRhIFN0YXRlIG1hY2hpbmUuIFN0YXRlcyBjYW4gYWxzbyBiZSBoaWVyYXJjaGljYWxcbiAqIGZvciBtb3JlIGZsZXhpYmlsaXR5LCBhcyBkZXNjcmliZWQgaW4gQGxpbmsoR2FtZSBQcm9ncmFtbWluZyBQYXR0ZXJucykoaHR0cHM6Ly9nYW1lcHJvZ3JhbW1pbmdwYXR0ZXJucy5jb20vc3RhdGUuaHRtbCkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXRlTWFjaGluZSBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xuICAgIC8qKiBBIHN0YWNrIG9mIHRoZSBjdXJyZW50IHN0YXRlcyAqL1xuICAgIHByb3RlY3RlZCBzdGFjazogU3RhY2s8U3RhdGU+O1xuICAgIC8qKiBBIG1hcGUgb2Ygc3RhdGUga2V5cyB0byBhY3R1YWwgc3RhdGUgaW5zdGFuY2VzICovXG4gICAgcHJvdGVjdGVkIHN0YXRlTWFwOiBNYXA8U3RhdGU+O1xuICAgIC8qKiBUaGUgY3VycmVudCBzdGF0ZSAqL1xuICAgIHByb3RlY3RlZCBjdXJyZW50U3RhdGU6IFN0YXRlO1xuICAgIC8qKiBBbiBldmVudCByZWNlaXZlciAqL1xuICAgIHByb3RlY3RlZCByZWNlaXZlcjogUmVjZWl2ZXI7XG4gICAgLyoqIEFuIGV2ZW50IGVtaXR0ZXIgKi9cbiAgICBwcm90ZWN0ZWQgZW1pdHRlcjogRW1pdHRlcjtcbiAgICAvKiogQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdCB0aGlzIFN0YXRlTWFjaGluZSBpcyBjdXJyZW50bHkgYWN0aXZlICovXG4gICAgcHJvdGVjdGVkIGFjdGl2ZTogYm9vbGVhbjtcbiAgICAvKiogQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdCB0aGlzIFN0YXRlTWFjaGluZSBzaG91bGQgZW1pdCBhbiBldmVudCBvbiBzdGF0ZSBjaGFuZ2UgKi9cbiAgICBwcm90ZWN0ZWQgZW1pdEV2ZW50T25TdGF0ZUNoYW5nZTogYm9vbGVhbjtcbiAgICAvKiogVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGJlIGVtaXR0ZWQgb24gc3RhdGUgY2hhbmdlICovXG4gICAgcHJvdGVjdGVkIHN0YXRlQ2hhbmdlRXZlbnROYW1lOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFN0YXRlTWFjaGluZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBuZXcgU3RhY2soKTtcbiAgICAgICAgdGhpcy5zdGF0ZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IG5ldyBSZWNlaXZlcigpO1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuICAgICAgICB0aGlzLmVtaXRFdmVudE9uU3RhdGVDaGFuZ2UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhY3Rpdml0eSBzdGF0ZSBvZiB0aGlzIHN0YXRlIG1hY2hpbmVcbiAgICAgKiBAcGFyYW0gZmxhZyBUcnVlIGlmIHlvdSB3YW50IHRvIHNldCB0aGlzIG1hY2hpbmUgcnVubmluZywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgc2V0QWN0aXZlKGZsYWc6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmbGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoaXMgc3RhdGUgbWFjaGluZSBlbWl0IGFuIGV2ZW50IGFueSB0aW1lIGl0cyBzdGF0ZSBjaGFuZ2VzXG4gICAgICogQHBhcmFtIHN0YXRlQ2hhbmdlRXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBlbWl0XG4gICAgICovXG4gICAgc2V0RW1pdEV2ZW50T25TdGF0ZUNoYW5nZShzdGF0ZUNoYW5nZUV2ZW50TmFtZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZW1pdEV2ZW50T25TdGF0ZUNoYW5nZSA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VFdmVudE5hbWUgPSBzdGF0ZUNoYW5nZUV2ZW50TmFtZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9wcyB0aGlzIHN0YXRlIG1hY2hpbmUgZnJvbSBlbWl0dGluZyBldmVudHMgb24gc3RhdGUgY2hhbmdlLlxuICAgICAqL1xuICAgIGNhbmNlbEVtaXRFdmVudE9uU3RhdGVDaGFuZ2UoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZW1pdEV2ZW50T25TdGF0ZUNoYW5nZSA9IGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGlzIHN0YXRlIG1hY2hpbmUgd2l0aCBhbiBpbml0aWFsIHN0YXRlIGFuZCBzZXRzIGl0IHJ1bm5pbmdcbiAgICAgKiBAcGFyYW0gaW5pdGlhbFN0YXRlIFRoZSBuYW1lIG9mIGluaXRpYWwgc3RhdGUgb2YgdGhlIHN0YXRlIG1hY2hpbmVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplKGluaXRpYWxTdGF0ZTogc3RyaW5nLCBvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5zdGF0ZU1hcC5nZXQoaW5pdGlhbFN0YXRlKSk7XG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gdGhpcy5zdGFjay5wZWVrKCk7XG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlLm9uRW50ZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc2V0QWN0aXZlKHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBzdGF0ZSB0byB0aGlzIHN0YXRlIG1hY2hpbmVcbiAgICAgKiBAcGFyYW0gc3RhdGVOYW1lIFRoZSBuYW1lIG9mIHRoZSBzdGF0ZSB0byBhZGRcbiAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0YXRlIHRvIGFkZFxuICAgICAqL1xuICAgIGFkZFN0YXRlKHN0YXRlTmFtZTogc3RyaW5nLCBzdGF0ZTogU3RhdGUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zdGF0ZU1hcC5hZGQoc3RhdGVOYW1lLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgc3RhdGUgb2YgdGhpcyBzdGF0ZSBtYWNoaW5lIHRvIHRoZSBwcm92aWRlZCBzdHJpbmdcbiAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0cmluZyBuYW1lIG9mIHRoZSBzdGF0ZSB0byBjaGFuZ2UgdG9cbiAgICAgKi9cbiAgICBjaGFuZ2VTdGF0ZShzdGF0ZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIC8vIEV4aXQgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB0aGlzLmN1cnJlbnRTdGF0ZS5vbkV4aXQoKTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGNvcnJlY3Qgc3RhdGUgaXMgYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2tcbiAgICAgICAgaWYoc3RhdGUgPT09IFwicHJldmlvdXNcIil7XG4gICAgICAgICAgICAvLyBQb3AgdGhlIGN1cnJlbnQgc3RhdGUgb2ZmIHRoZSBzdGFja1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJldHJpZXZlIHRoZSBuZXcgc3RhdGUgZnJvbSB0aGUgc3RhdGVtYXAgYW5kIHB1dCBpdCBhdCB0aGUgdG9wIG9mIHRoZSBzdGFja1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLnN0YXRlTWFwLmdldChzdGF0ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmV0cmVpdmUgdGhlIG5ldyBzdGF0ZSBmcm9tIHRoZSBzdGFja1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IHRoaXMuc3RhY2sucGVlaygpO1xuXG4gICAgICAgIC8vIEVtaXQgYW4gZXZlbnQgaWYgdHVybmVkIG9uXG4gICAgICAgIGlmKHRoaXMuZW1pdEV2ZW50T25TdGF0ZUNoYW5nZSl7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KHRoaXMuc3RhdGVDaGFuZ2VFdmVudE5hbWUsIHtzdGF0ZTogdGhpcy5jdXJyZW50U3RhdGV9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVudGVyIHRoZSBuZXcgc3RhdGVcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUub25FbnRlcihvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGlucHV0LiBUaGlzIGhhcHBlbnMgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9mIHRoaXMgc3RhdGUgbWFjaGluZSdzIHVwZGF0ZSBjeWNsZS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgVGhlIGdhbWUgZXZlbnQgdG8gcHJvY2Vzc1xuICAgICAqL1xuICAgIGhhbmRsZUV2ZW50KGV2ZW50OiBHYW1lRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgaWYodGhpcy5hY3RpdmUpe1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUuaGFuZGxlSW5wdXQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQGltcGxlbWVudGVkXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIC8vIERpc3RyaWJ1dGUgZXZlbnRzXG4gICAgICAgIHdoaWxlKHRoaXMucmVjZWl2ZXIuaGFzTmV4dEV2ZW50KCkpe1xuICAgICAgICAgICAgbGV0IGV2ZW50ID0gdGhpcy5yZWNlaXZlci5nZXROZXh0RXZlbnQoKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVsZWdhdGUgdGhlIHVwZGF0ZSB0byB0aGUgY3VycmVudCBzdGF0ZVxuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZS51cGRhdGUoZGVsdGFUKTtcbiAgICB9XG59IiwiaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1ZlYzJcIjtcbmltcG9ydCB7IFRpbGVkVGlsZXNldERhdGEgfSBmcm9tIFwiLi9UaWxlZERhdGFcIjtcblxuLyoqXG4gKiBUaGUgZGF0YSByZXByZXNlbnRhdGlvbiBvZiBhIFRpbGVzZXQgZm9yIHRoZSBnYW1lIGVuZ2luZS4gVGhpcyByZXByZXNlbnRzIG9uZSBpbWFnZSxcbiAqIHdpdGggYSBzdGFydEluZGV4IGlmIHJlcXVpcmVkIChhcyBpdCBpcyB3aXRoIFRpbGVkIHVzaW5nIHR3byBpbWFnZXMgaW4gb25lIHRpbHNldCkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbGVzZXQge1xuICAgIC8qKiBUaGUga2V5IG9mIHRoZSBpbWFnZSB1c2VkIGJ5IHRoaXMgdGlsZXNldCAqL1xuICAgIHByb3RlY3RlZCBpbWFnZUtleTogc3RyaW5nO1xuICAgIC8qKiBUaGUgc2l6ZSBvZiB0aGUgdGlsZXNldCBpbWFnZSAqL1xuICAgIHByb3RlY3RlZCBpbWFnZVNpemU6IFZlYzI7XG4gICAgLyoqIFRoZSBpbmRleCBvZiAwdGggaW1hZ2Ugb2YgdGhpcyB0aWxlc2V0ICovXG4gICAgcHJvdGVjdGVkIHN0YXJ0SW5kZXg6IG51bWJlcjtcbiAgICAvKiogVGhlIGluZGV4IG9mIHRoZSBsYXN0IGltYWdlIG9mIHRoaXMgdGlsc2V0ICovXG4gICAgcHJvdGVjdGVkIGVuZEluZGV4OiBudW1iZXI7XG4gICAgLyoqIFRoZSBzaXplIG9mIHRoZSB0aWxlcyBpbiB0aGlzIHRpbGVzZXQgKi9cbiAgICBwcm90ZWN0ZWQgdGlsZVNpemU6IFZlYzI7XG4gICAgLyoqIFRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGlzIHRpbGVzZXQgKi9cbiAgICBwcm90ZWN0ZWQgbnVtUm93czogbnVtYmVyO1xuICAgIC8qKiBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhpcyB0aWxlc2V0ICovXG4gICAgcHJvdGVjdGVkIG51bUNvbHM6IG51bWJlcjtcblxuICAgIC8vIFRPRE86IENoYW5nZSB0aGlzIHRvIGJlIG1vcmUgZ2VuZXJhbCBhbmQgd29yayB3aXRoIG90aGVyIHRpbGVzZXQgZm9ybWF0c1xuICAgIGNvbnN0cnVjdG9yKHRpbGVzZXREYXRhOiBUaWxlZFRpbGVzZXREYXRhKXtcbiAgICAgICAgLy8gRGVmZXIgaGFuZGxpbmcgb2YgdGhlIGRhdGEgdG8gYSBoZWxwZXIgY2xhc3NcbiAgICAgICAgdGhpcy5pbml0RnJvbVRpbGVkRGF0YSh0aWxlc2V0RGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgdGlsZXNldCBmcm9tIHRoZSBkYXRhIGZyb20gYSBUaWxlZCBqc29uIGZpbGVcbiAgICAgKiBAcGFyYW0gdGlsZWREYXRhIFRoZSBwYXJzZWQgb2JqZWN0IGZyb20gYSBUaWxlZCBqc29uIGZpbGVcbiAgICAgKi9cbiAgICBpbml0RnJvbVRpbGVkRGF0YSh0aWxlZERhdGE6IFRpbGVkVGlsZXNldERhdGEpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5udW1Sb3dzID0gdGlsZWREYXRhLnRpbGVjb3VudC90aWxlZERhdGEuY29sdW1ucztcbiAgICAgICAgdGhpcy5udW1Db2xzID0gdGlsZWREYXRhLmNvbHVtbnM7XG4gICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IHRpbGVkRGF0YS5maXJzdGdpZDtcbiAgICAgICAgdGhpcy5lbmRJbmRleCA9IHRoaXMuc3RhcnRJbmRleCArIHRpbGVkRGF0YS50aWxlY291bnQgLSAxO1xuICAgICAgICB0aGlzLnRpbGVTaXplID0gbmV3IFZlYzIodGlsZWREYXRhLnRpbGV3aWR0aCwgdGlsZWREYXRhLnRpbGV3aWR0aCk7XG4gICAgICAgIHRoaXMuaW1hZ2VLZXkgPSB0aWxlZERhdGEuaW1hZ2U7XG4gICAgICAgIHRoaXMuaW1hZ2VTaXplID0gbmV3IFZlYzIodGlsZWREYXRhLmltYWdld2lkdGgsIHRpbGVkRGF0YS5pbWFnZWhlaWdodCk7XG4gICAgfVxuXG4gICAgLyoqIFxuICAgICAqIEdldHMgdGhlIGltYWdlIGtleSBhc3NvY2lhdGVkIHdpdGggdGhpcyB0aWxlbWFwXG4gICAgICogQHJldHVybnMgVGhlIGltYWdlIGtleSBvZiB0aGlzIHRpbGVtYXBcbiAgICAgKi9cbiAgICBnZXRJbWFnZUtleSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZUtleTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgVmVjMiBjb250YWluaW5nIHRoZSBsZWZ0IGFuZCB0b3Agb2Zmc2V0IGZyb20gdGhlIGltYWdlIG9yaWdpbiBmb3IgdGhpcyB0aWxlLlxuICAgICAqIEBwYXJhbSB0aWxlSW5kZXggVGhlIGluZGV4IG9mIHRoZSB0aWxlIGZyb20gc3RhcnRJbmRleCB0byBlbmRJbmRleCBvZiB0aGlzIHRpbGVzZXRcbiAgICAgKiBAcmV0dXJucyBBIFZlYzIgY29udGFpbmluZyB0aGUgb2Zmc2V0IGZvciB0aGUgc3BlY2lmaWVkIHRpbGUuXG4gICAgICovXG4gICAgZ2V0SW1hZ2VPZmZzZXRGb3JUaWxlKHRpbGVJbmRleDogbnVtYmVyKTogVmVjMiB7XG4gICAgICAgIC8vIEdldCB0aGUgdHJ1ZSBpbmRleFxuICAgICAgICBsZXQgaW5kZXggPSB0aWxlSW5kZXggLSB0aGlzLnN0YXJ0SW5kZXg7XG4gICAgICAgIGxldCByb3cgPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5udW1Db2xzKTtcbiAgICAgICAgbGV0IGNvbCA9IGluZGV4ICUgdGhpcy5udW1Db2xzO1xuICAgICAgICBsZXQgd2lkdGggPSB0aGlzLnRpbGVTaXplLng7XG4gICAgICAgIGxldCBoZWlnaHQgPSB0aGlzLnRpbGVTaXplLnk7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiB0byBzdGFydCBhIGNyb3AgaW4gdGhlIHRpbGVzZXQgaW1hZ2VcbiAgICAgICAgbGV0IGxlZnQgPSBjb2wgKiB3aWR0aDtcbiAgICAgICAgbGV0IHRvcCA9IHJvdyAqIGhlaWdodDtcblxuICAgICAgICByZXR1cm4gbmV3IFZlYzIobGVmdCwgdG9wKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGFydCBpbmRleFxuICAgICAqIEByZXR1cm5zIFRoZSBzdGFydCBpbmRleFxuICAgICAqL1xuICAgIGdldFN0YXJ0SW5kZXgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRJbmRleDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB0aWxlIHNldFxuICAgICAqIEByZXR1cm5zIEEgVmVjMiBjb250YWluaW5nIHRoZSB0aWxlIHNpemVcbiAgICAgKi9cbiAgICBnZXRUaWxlU2l6ZSgpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZVNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIHRpbGVzZXRcbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIHJvd3NcbiAgICAgKi9cbiAgICBnZXROdW1Sb3dzKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bVJvd3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIHRpbHNldFxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgY29sdW1uc1xuICAgICAqL1xuICAgIGdldE51bUNvbHMoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtQ29scztcbiAgICB9XG5cbiAgICBnZXRUaWxlQ291bnQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kSW5kZXggLSB0aGlzLnN0YXJ0SW5kZXggKyAxO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIHRpbHNldCBjb250YWlucyB0aGUgc3BlY2lmaWVkIHRpbGUgaW5kZXguIFRoaXMgaXMgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgICAqIEBwYXJhbSB0aWxlSW5kZXggVGhlIGluZGV4IG9mIHRoZSB0aWxlIHRvIGNoZWNrXG4gICAgICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdCB0aGlzIHRpbHNldCB1c2VzIHRoZSBzcGVjaWZpZWQgaW5kZXhcbiAgICAgKi9cbiAgICBoYXNUaWxlKHRpbGVJbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aWxlSW5kZXggPj0gdGhpcy5zdGFydEluZGV4ICYmIHRpbGVJbmRleCA8PSB0aGlzLmVuZEluZGV4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBhIHNpbmd1bGFyIHRpbGUgd2l0aCBpbmRleCB0aWxlSW5kZXggZnJvbSB0aGUgdGlsZXNldCBsb2NhdGVkIGF0IHBvc2l0aW9uIGRhdGFJbmRleFxuICAgICAqIEBwYXJhbSBjdHggVGhlIHJlbmRlcmluZyBjb250ZXh0XG4gICAgICogQHBhcmFtIHRpbGVJbmRleCBUaGUgdmFsdWUgb2YgdGhlIHRpbGUgdG8gcmVuZGVyXG4gICAgICogQHBhcmFtIGRhdGFJbmRleCBUaGUgaW5kZXggb2YgdGhlIHRpbGUgaW4gdGhlIGRhdGEgYXJyYXlcbiAgICAgKiBAcGFyYW0gd29ybGRTaXplIFRoZSBzaXplIG9mIHRoZSB3b3JsZFxuICAgICAqIEBwYXJhbSBvcmlnaW4gVGhlIHZpZXdwb3J0IG9yaWdpbiBpbiB0aGUgY3VycmVudCBsYXllclxuICAgICAqIEBwYXJhbSBzY2FsZSBUaGUgc2NhbGUgb2YgdGhlIHRpbGVtYXBcbiAgICAgKi9cbiAgICByZW5kZXJUaWxlKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCB0aWxlSW5kZXg6IG51bWJlciwgZGF0YUluZGV4OiBudW1iZXIsIG1heENvbHM6IG51bWJlciwgb3JpZ2luOiBWZWMyLCBzY2FsZTogVmVjMiwgem9vbTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGxldCBpbWFnZSA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpLmdldEltYWdlKHRoaXMuaW1hZ2VLZXkpO1xuXG4gICAgICAgIC8vIEdldCB0aGUgdHJ1ZSBpbmRleFxuICAgICAgICBsZXQgaW5kZXggPSB0aWxlSW5kZXggLSB0aGlzLnN0YXJ0SW5kZXg7XG4gICAgICAgIGxldCByb3cgPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5udW1Db2xzKTtcbiAgICAgICAgbGV0IGNvbCA9IGluZGV4ICUgdGhpcy5udW1Db2xzO1xuICAgICAgICBsZXQgd2lkdGggPSB0aGlzLnRpbGVTaXplLng7XG4gICAgICAgIGxldCBoZWlnaHQgPSB0aGlzLnRpbGVTaXplLnk7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiB0byBzdGFydCBhIGNyb3AgaW4gdGhlIHRpbGVzZXQgaW1hZ2VcbiAgICAgICAgbGV0IGxlZnQgPSBjb2wgKiB3aWR0aDtcbiAgICAgICAgbGV0IHRvcCA9IHJvdyAqIGhlaWdodDtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHBvc2l0aW9uIGluIHRoZSB3b3JsZCB0byByZW5kZXIgdGhlIHRpbGVcbiAgICAgICAgbGV0IHggPSBNYXRoLmZsb29yKChkYXRhSW5kZXggJSBtYXhDb2xzKSAqIHdpZHRoICogc2NhbGUueCk7XG4gICAgICAgIGxldCB5ID0gTWF0aC5mbG9vcihNYXRoLmZsb29yKGRhdGFJbmRleCAvIG1heENvbHMpICogaGVpZ2h0ICogc2NhbGUueSk7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCwgTWF0aC5mbG9vcigoeCAtIG9yaWdpbi54KSp6b29tKSwgTWF0aC5mbG9vcigoeSAtIG9yaWdpbi55KSp6b29tKSwgTWF0aC5jZWlsKHdpZHRoICogc2NhbGUueCAqIHpvb20pLCBNYXRoLmNlaWwoaGVpZ2h0ICogc2NhbGUueSAqIHpvb20pKTtcbiAgICB9XG59IiwiaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vVXRpbHMvTWF0aFV0aWxzXCI7XG5cbi8qKlxuICogQSB0d28tZGltZW5zaW9uYWwgdmVjdG9yICh4LCB5KVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZWMyIHtcblxuXHQvLyBTdG9yZSB4IGFuZCB5IGluIGFuIGFycmF5XG5cdC8qKiBUaGUgYXJyYXkgdGhhdCBzdG9yZXMgdGhlIGFjdHVhbCB2ZWN0b3IgdmFsdWVzIHggYW5kIHkgKi9cblx0cHJpdmF0ZSB2ZWM6IEZsb2F0MzJBcnJheTtcblxuXHQvKipcdFxuXHQgKiBXaGVuIHRoaXMgdmVjdG9yIGNoYW5nZXMgaXRzIHZhbHVlLCBkbyBzb21ldGhpbmdcblx0ICovXG5cdHByaXZhdGUgb25DaGFuZ2U6IEZ1bmN0aW9uID0gKCkgPT4ge307XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgVmVjMlxuXHQgKiBAcGFyYW0geCBUaGUgeCB2YWx1ZSBvZiB0aGUgdmVjdG9yXG5cdCAqIEBwYXJhbSB5IFRoZSB5IHZhbHVlIG9mIHRoZSB2ZWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKHg6IG51bWJlciA9IDAsIHk6IG51bWJlciA9IDApIHtcblx0XHR0aGlzLnZlYyA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XG5cdFx0dGhpcy52ZWNbMF0gPSB4O1xuXHRcdHRoaXMudmVjWzFdID0geTtcblx0fVxuXG5cdC8vIEV4cG9zZSB4IGFuZCB5IHdpdGggZ2V0dGVycyBhbmQgc2V0dGVyc1xuXHRnZXQgeCgpIHtcblx0XHRyZXR1cm4gdGhpcy52ZWNbMF07XG5cdH1cblxuXHRzZXQgeCh4OiBudW1iZXIpIHtcblx0XHR0aGlzLnZlY1swXSA9IHg7XG5cblx0XHRpZih0aGlzLm9uQ2hhbmdlKXtcblx0XHRcdHRoaXMub25DaGFuZ2UoKTtcblx0XHR9XG5cdH1cblxuXHRnZXQgeSgpIHtcblx0XHRyZXR1cm4gdGhpcy52ZWNbMV07XG5cdH1cblxuXHRzZXQgeSh5OiBudW1iZXIpIHtcblx0XHR0aGlzLnZlY1sxXSA9IHk7XG5cblx0XHRpZih0aGlzLm9uQ2hhbmdlKXtcblx0XHRcdHRoaXMub25DaGFuZ2UoKTtcblx0XHR9XG5cdH1cblxuXHRzdGF0aWMgZ2V0IFpFUk8oKSB7XG5cdFx0cmV0dXJuIG5ldyBWZWMyKDAsIDApO1xuXHR9XG5cblx0c3RhdGljIHJlYWRvbmx5IFpFUk9fU1RBVElDID0gbmV3IFZlYzIoMCwgMCk7XG5cblx0c3RhdGljIGdldCBJTkYoKSB7XG5cdFx0cmV0dXJuIG5ldyBWZWMyKEluZmluaXR5LCBJbmZpbml0eSk7XG5cdH1cblxuXHRzdGF0aWMgZ2V0IFVQKCkge1xuXHRcdHJldHVybiBuZXcgVmVjMigwLCAtMSk7XG5cdH1cblxuXHRzdGF0aWMgZ2V0IERPV04oKSB7XG5cdFx0cmV0dXJuIG5ldyBWZWMyKDAsIDEpO1xuXHR9XG5cblx0c3RhdGljIGdldCBMRUZUKCkge1xuXHRcdHJldHVybiBuZXcgVmVjMigtMSwgMCk7XG5cdH1cblxuXHRzdGF0aWMgZ2V0IFJJR0hUKCkge1xuXHRcdHJldHVybiBuZXcgVmVjMigxLCAwKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgc3F1YXJlZCBtYWduaXR1ZGUgb2YgdGhlIHZlY3Rvci4gVGhpcyB0ZW5kcyB0byBiZSBmYXN0ZXIsIHNvIHVzZSBpdCBpbiBzaXR1YXRpb25zIHdoZXJlIHRha2luZyB0aGVcblx0ICogc3F1YXJlIHJvb3QgZG9lc24ndCBtYXR0ZXIsIGxpa2UgZm9yIGNvbXBhcmluZyBkaXN0YW5jZXMuXG5cdCAqIEByZXR1cm5zIFRoZSBzcXVhcmVkIG1hZ25pdHVkZSBvZiB0aGUgdmVjdG9yXG5cdCAqL1xuXHRtYWdTcSgpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLngqdGhpcy54ICsgdGhpcy55KnRoaXMueTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgbWFnbml0dWRlIG9mIHRoZSB2ZWN0b3IuXG5cdCAqIEByZXR1cm5zIFRoZSBtYWduaXR1ZGUgb2YgdGhlIHZlY3Rvci5cblx0ICovXG5cdG1hZygpOiBudW1iZXIge1xuXHRcdHJldHVybiBNYXRoLnNxcnQodGhpcy5tYWdTcSgpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEaXZkZXMgeCBhbmQgeSBieSB0aGUgbWFnbml0dWRlIHRvIG9idGFpbiB0aGUgdW5pdCB2ZWN0b3IgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGlzIHZlY3Rvci5cblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IgYXMgYSB1bml0IHZlY3Rvci5cblx0ICovXG5cdG5vcm1hbGl6ZSgpOiBWZWMyIHtcblx0XHRpZih0aGlzLnggPT09IDAgJiYgdGhpcy55ID09PSAwKSByZXR1cm4gdGhpcztcblx0XHRsZXQgbWFnID0gdGhpcy5tYWcoKTtcblx0XHR0aGlzLnggLz0gbWFnO1xuXHRcdHRoaXMueSAvPSBtYWc7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogV29ya3MgbGlrZSBub3JtYWxpemUoKSwgYnV0IHJldHVybnMgYSBuZXcgVmVjMlxuXHQgKiBAcmV0dXJucyBBIG5ldyB2ZWN0b3IgdGhhdCBpcyB0aGUgdW5pdCB2ZWN0b3IgZm9yIHRoaXMgb25lXG5cdCAqL1xuXHRub3JtYWxpemVkKCk6IFZlYzIge1xuXHRcdGlmKHRoaXMuaXNaZXJvKCkpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdFxuXHRcdGxldCBtYWcgPSB0aGlzLm1hZygpO1xuXHRcdHJldHVybiBuZXcgVmVjMih0aGlzLngvbWFnLCB0aGlzLnkvbWFnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB4IGFuZCB5IGVsZW1lbnRzIG9mIHRoaXMgdmVjdG9yIHRvIHplcm8uXG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yLCB3aXRoIHggYW5kIHkgc2V0IHRvIHplcm8uXG5cdCAqL1xuXHR6ZXJvKCk6IFZlYzIge1xuXHRcdHJldHVybiB0aGlzLnNldCgwLCAwKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB2ZWN0b3IncyB4IGFuZCB5IGJhc2VkIG9uIHRoZSBhbmdsZSBwcm92aWRlZC4gR29lcyBjb3VudGVyIGNsb2Nrd2lzZS5cblx0ICogQHBhcmFtIGFuZ2xlIFRoZSBhbmdsZSBpbiByYWRpYW5zXG5cdCAqIEBwYXJhbSByYWRpdXMgVGhlIG1hZ25pdHVkZSBvZiB0aGUgdmVjdG9yIGF0IHRoZSBzcGVjaWZpZWQgYW5nbGVcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRzZXRUb0FuZ2xlKGFuZ2xlOiBudW1iZXIsIHJhZGl1czogbnVtYmVyID0gMSk6IFZlYzIge1xuXHRcdHRoaXMueCA9IE1hdGhVdGlscy5mbG9vclRvUGxhY2UoTWF0aC5jb3MoYW5nbGUpKnJhZGl1cywgNSk7XG5cdFx0dGhpcy55ID0gTWF0aFV0aWxzLmZsb29yVG9QbGFjZSgtTWF0aC5zaW4oYW5nbGUpKnJhZGl1cywgNSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHZlY3RvciB0aGF0IHBvaW50IGZyb20gdGhpcyB2ZWN0b3IgdG8gYW5vdGhlciBvbmVcblx0ICogQHBhcmFtIG90aGVyIFRoZSB2ZWN0b3IgdG8gcG9pbnQgdG9cblx0ICogQHJldHVybnMgQSBuZXcgVmVjMiB0aGF0IHBvaW50cyBmcm9tIHRoaXMgdmVjdG9yIHRvIHRoZSBvbmUgcHJvdmlkZWRcblx0ICovXG5cdHZlY1RvKG90aGVyOiBWZWMyKTogVmVjMiB7XG5cdFx0cmV0dXJuIG5ldyBWZWMyKG90aGVyLnggLSB0aGlzLngsIG90aGVyLnkgLSB0aGlzLnkpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIHZlY3RvciBjb250YWluaW5nIHRoZSBkaXJlY3Rpb24gZnJvbSB0aGlzIHZlY3RvciB0byBhbm90aGVyXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgdmVjdG9yIHRvIHBvaW50IHRvXG5cdCAqIEByZXR1cm5zIEEgbmV3IFZlYzIgdGhhdCBwb2ludHMgZnJvbSB0aGlzIHZlY3RvciB0byB0aGUgb25lIHByb3ZpZGVkLiBUaGlzIG5ldyBWZWMyIHdpbGwgYmUgYSB1bml0IHZlY3Rvci5cblx0ICovXG5cdGRpclRvKG90aGVyOiBWZWMyKTogVmVjMiB7XG5cdFx0cmV0dXJuIHRoaXMudmVjVG8ob3RoZXIpLm5vcm1hbGl6ZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEtlZXBzIHRoZSB2ZWN0b3IncyBkaXJlY3Rpb24sIGJ1dCBzZXRzIGl0cyBtYWduaXR1ZGUgdG8gYmUgdGhlIHByb3ZpZGVkIG1hZ25pdHVkZVxuXHQgKiBAcGFyYW0gbWFnbml0dWRlIFRoZSBtYWduaXR1ZGUgdGhlIHZlY3RvciBzaG91bGQgYmVcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3Igd2l0aCBpdHMgbWFnbml0dWRlIHNldCB0byB0aGUgbmV3IG1hZ25pdHVkZVxuXHQgKi9cblx0c2NhbGVUbyhtYWduaXR1ZGU6IG51bWJlcik6IFZlYzIge1xuXHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLnNjYWxlKG1hZ25pdHVkZSk7XG5cdH1cblxuXHQvKipcblx0ICogU2NhbGVzIHggYW5kIHkgYnkgdGhlIG51bWJlciBwcm92aWRlZCwgb3IgaWYgdHdvIG51bWJlciBhcmUgcHJvdmlkZWQsIHNjYWxlcyB0aGVtIGluZGl2aWR1YWxseS5cblx0ICogQHBhcmFtIGZhY3RvciBUaGUgc2NhbGluZyBmYWN0b3IgZm9yIHRoZSB2ZWN0b3IsIG9yIGZvciBvbmx5IHRoZSB4LWNvbXBvbmVudCBpZiB5RmFjdG9yIGlzIHByb3ZpZGVkXG5cdCAqIEBwYXJhbSB5RmFjdG9yIFRoZSBzY2FsaW5nIGZhY3RvciBmb3IgdGhlIHktY29tcG9uZW50IG9mIHRoZSB2ZWN0b3Jcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IgYWZ0ZXIgc2NhbGluZ1xuXHQgKi9cblx0c2NhbGUoZmFjdG9yOiBudW1iZXIsIHlGYWN0b3I6IG51bWJlciA9IG51bGwpOiBWZWMyIHtcblx0XHRpZih5RmFjdG9yICE9PSBudWxsKXtcblx0XHRcdHRoaXMueCAqPSBmYWN0b3I7XG5cdFx0XHR0aGlzLnkgKj0geUZhY3Rvcjtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHR0aGlzLnggKj0gZmFjdG9yO1xuXHRcdHRoaXMueSAqPSBmYWN0b3I7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHNjYWxlZCB2ZXJzaW9uIG9mIHRoaXMgdmVjdG9yIHdpdGhvdXQgbW9kaWZ5aW5nIGl0LlxuXHQgKiBAcGFyYW0gZmFjdG9yIFRoZSBzY2FsaW5nIGZhY3RvciBmb3IgdGhlIHZlY3Rvciwgb3IgZm9yIG9ubHkgdGhlIHgtY29tcG9uZW50IGlmIHlGYWN0b3IgaXMgcHJvdmlkZWRcblx0ICogQHBhcmFtIHlGYWN0b3IgVGhlIHNjYWxpbmcgZmFjdG9yIGZvciB0aGUgeS1jb21wb25lbnQgb2YgdGhlIHZlY3RvclxuXHQgKiBAcmV0dXJucyBBIG5ldyB2ZWN0b3IgdGhhdCBoYXMgdGhlIHZhbHVlcyBvZiB0aGlzIHZlY3RvciBhZnRlciBzY2FsaW5nXG5cdCAqL1xuXHRzY2FsZWQoZmFjdG9yOiBudW1iZXIsIHlGYWN0b3I6IG51bWJlciA9IG51bGwpOiBWZWMyIHtcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLnNjYWxlKGZhY3RvciwgeUZhY3Rvcik7XG5cdH1cblxuXHQvKipcblx0ICogUm90YXRlcyB0aGUgdmVjdG9yIGNvdW50ZXItY2xvY2t3aXNlIGJ5IHRoZSBhbmdsZSBhbW91bnQgc3BlY2lmaWVkXG5cdCAqIEBwYXJhbSBhbmdsZSBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5IGluIHJhZGlhbnNcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IgYWZ0ZXIgcm90YXRpb24uXG5cdCAqL1xuXHRyb3RhdGVDQ1coYW5nbGU6IG51bWJlcik6IFZlYzIge1xuXHRcdGxldCBjcyA9IE1hdGguY29zKGFuZ2xlKTtcblx0XHRsZXQgc24gPSBNYXRoLnNpbihhbmdsZSk7XG5cdFx0bGV0IHRlbXBYID0gdGhpcy54KmNzIC0gdGhpcy55KnNuO1xuXHRcdGxldCB0ZW1wWSA9IHRoaXMueCpzbiArIHRoaXMueSpjcztcblx0XHR0aGlzLnggPSB0ZW1wWDtcblx0XHR0aGlzLnkgPSB0ZW1wWTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB2ZWN0b3JzIGNvb3JkaW5hdGVzIHRvIGJlIHRoZSBvbmVzIHByb3ZpZGVkXG5cdCAqIEBwYXJhbSB4IFRoZSBuZXcgeCB2YWx1ZSBmb3IgdGhpcyB2ZWN0b3Jcblx0ICogQHBhcmFtIHkgVGhlIG5ldyB5IHZhbHVlIGZvciB0aGlzIHZlY3RvclxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvclxuXHQgKi9cblx0c2V0KHg6IG51bWJlciwgeTogbnVtYmVyKTogVmVjMiB7XG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvcGllcyB0aGUgdmFsdWVzIG9mIHRoZSBvdGhlciBWZWMyIGludG8gdGhpcyBvbmUuXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgVmVjMiB0byBjb3B5XG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIHdpdGggaXRzIHZhbHVlcyBzZXQgdG8gdGhlIHZlY3RvciBwcm92aWRlZFxuXHQgKi9cblx0Y29weShvdGhlcjogVmVjMik6IFZlYzIge1xuXHRcdHJldHVybiB0aGlzLnNldChvdGhlci54LCBvdGhlci55KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIHRoaXMgdmVjdG9yIHRoZSBhbm90aGVyIHZlY3RvclxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIFZlYzIgdG8gYWRkIHRvIHRoaXMgb25lXG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIGFmdGVyIGFkZGluZyB0aGUgb25lIHByb3ZpZGVkXG5cdCAqL1xuXHRhZGQob3RoZXI6IFZlYzIpOiBWZWMyIHtcblx0XHR0aGlzLnggKz0gb3RoZXIueDtcblx0XHR0aGlzLnkgKz0gb3RoZXIueTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBJbmNyZW1lbnRzIHRoZSBmaWVsZHMgb2YgdGhpcyB2ZWN0b3IuIEJvdGggYXJlIGluY3JlbWVudGVkIHdpdGggYSwgaWYgb25seSBhIGlzIHByb3ZpZGVkLlxuXHQgKiBAcGFyYW0gYSBUaGUgZmlyc3QgbnVtYmVyIHRvIGluY3JlbWVudCBieVxuXHQgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIG51bWJlciB0byBpbmNyZW1lbnQgYnlcblx0ICogQHJldHVybnNzIFRoaXMgdmVjdG9yIGFmdGVyIGluY3JlbWVudGluZ1xuXHQgKi9cblx0aW5jKGE6IG51bWJlciwgYj86IG51bWJlcik6IFZlYzIge1xuXHRcdGlmKGIgPT09IHVuZGVmaW5lZCl7XG5cdFx0XHR0aGlzLnggKz0gYTtcblx0XHRcdHRoaXMueSArPSBhO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnggKz0gYTtcblx0XHRcdHRoaXMueSArPSBiO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTdWJ0cmFjdHMgYW5vdGhlciB2ZWN0b3IgZnJvbSB0aGlzIHZlY3RvclxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIFZlYzIgdG8gc3VidHJhY3QgZnJvbSB0aGlzIG9uZVxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhZnRlciBzdWJ0cmFjdGluZyB0aGUgb25lIHByb3ZpZGVkXG5cdCAqL1xuXHRzdWIob3RoZXI6IFZlYzIpOiBWZWMyIHtcblx0XHR0aGlzLnggLT0gb3RoZXIueDtcblx0XHR0aGlzLnkgLT0gb3RoZXIueTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBNdWx0aXBsaWVzIHRoaXMgdmVjdG9yIHdpdGggYW5vdGhlciB2ZWN0b3IgZWxlbWVudC13aXNlLiBJbiBvdGhlciB3b3JkcywgdGhpcy54ICo9IG90aGVyLnggYW5kIHRoaXMueSAqPSBvdGhlci55XG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgVmVjMiB0byBtdWx0aXBseSB0aGlzIG9uZSBieVxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhZnRlciBtdWx0aXBseWluZyBpdHMgY29tcG9uZW50cyBieSB0aGlzIG9uZVxuXHQgKi9cblx0bXVsdChvdGhlcjogVmVjMik6IFZlYzIge1xuXHRcdHRoaXMueCAqPSBvdGhlci54O1xuXHRcdHRoaXMueSAqPSBvdGhlci55O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIERpdmlkZXMgdGhpcyB2ZWN0b3Igd2l0aCBhbm90aGVyIHZlY3RvciBlbGVtZW50LXdpc2UuIEluIG90aGVyIHdvcmRzLCB0aGlzLnggLz0gb3RoZXIueCBhbmQgdGhpcy55IC89IG90aGVyLnlcblx0ICogQHBhcmFtIG90aGVyIFRoZSB2ZWN0b3IgdG8gZGl2aWRlIHRoaXMgb25lIGJ5XG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIGFmdGVyIGRpdmlzaW9uXG5cdCAqL1xuXHRkaXYob3RoZXI6IFZlYzIpOiBWZWMyIHtcblx0XHRpZihvdGhlci54ID09PSAwIHx8IG90aGVyLnkgPT09IDApIHRocm93IFwiRGl2aWRlIGJ5IHplcm8gZXJyb3JcIjtcblx0XHR0aGlzLnggLz0gb3RoZXIueDtcblx0XHR0aGlzLnkgLz0gb3RoZXIueTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBEb2VzIGFuIGVsZW1lbnQgd2lzZSByZW1haW5kZXIgb3BlcmF0aW9uIG9uIHRoaXMgdmVjdG9yLiB0aGlzLnggJT0gb3RoZXIueCBhbmQgdGhpcy55ICU9IG90aGVyLnlcblx0ICogQHBhcmFtIG90aGVyIFRoZSBvdGhlciB2ZWN0b3Jcblx0ICogQHJldHVybnMgdGhpcyB2ZWN0b3Jcblx0ICovXG5cdHJlbWFpbmRlcihvdGhlcjogVmVjMik6IFZlYzIge1xuXHRcdHRoaXMueCA9IHRoaXMueCAlIG90aGVyLng7XG5cdFx0dGhpcy55ID0gdGhpcy55ICUgb3RoZXIueTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gdGhpcyB2ZWN0b3IgYW5kIGFub3RoZXIgdmVjdG9yXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgdmVjdG9yIHRvIGNvbXB1dGUgZGlzdGFuY2Ugc3F1YXJlZCB0b1xuXHQgKiBAcmV0dXJucyBUaGUgc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIHRoaXMgdmVjdG9yIGFuZCB0aGUgb25lIHByb3ZpZGVkXG5cdCAqL1xuXHRkaXN0YW5jZVNxVG8ob3RoZXI6IFZlYzIpOiBudW1iZXIge1xuXHRcdHJldHVybiAodGhpcy54IC0gb3RoZXIueCkqKHRoaXMueCAtIG90aGVyLngpICsgKHRoaXMueSAtIG90aGVyLnkpKih0aGlzLnkgLSBvdGhlci55KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoaXMgdmVjdG9yIGFuZCBhbm90aGVyIHZlY3RvclxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIHZlY3RvciB0byBjb21wdXRlIGRpc3RhbmNlIHRvXG5cdCAqIEByZXR1cm5zIFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoaXMgdmVjdG9yIGFuZCB0aGUgb25lIHByb3ZpZGVkXG5cdCAqL1xuXHRkaXN0YW5jZVRvKG90aGVyOiBWZWMyKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VTcVRvKG90aGVyKSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZG90IHByb2R1Y3Qgb2YgdGhpcyB2ZWN0b3IgYW5kIGFub3RoZXJcblx0ICogQHBhcmFtIG90aGVyIFRoZSB2ZWN0b3IgdG8gY29tcHV0ZSB0aGUgZG90IHByb2R1Y3Qgd2l0aFxuXHQgKiBAcmV0dXJucyBUaGUgZG90IHByb2R1Y3Qgb2YgdGhpcyB2ZWN0b3IgYW5kIHRoZSBvbmUgcHJvdmlkZWQuXG5cdCAqL1xuXHRkb3Qob3RoZXI6IFZlYzIpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLngqb3RoZXIueCArIHRoaXMueSpvdGhlci55O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGFuZ2xlIGNvdW50ZXItY2xvY2t3aXNlIGluIHJhZGlhbnMgZnJvbSB0aGlzIHZlY3RvciB0byBhbm90aGVyIHZlY3RvclxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIHZlY3RvciB0byBjb21wdXRlIHRoZSBhbmdsZSB0b1xuXHQgKiBAcmV0dXJucyBUaGUgYW5nbGUsIHJvdGF0aW5nIENDVywgZnJvbSB0aGlzIHZlY3RvciB0byB0aGUgb3RoZXIgdmVjdG9yXG5cdCAqL1xuXHRhbmdsZVRvQ0NXKG90aGVyOiBWZWMyKTogbnVtYmVyIHtcblx0XHRsZXQgZG90ID0gdGhpcy5kb3Qob3RoZXIpO1xuXHRcdGxldCBkZXQgPSB0aGlzLngqb3RoZXIueSAtIHRoaXMueSpvdGhlci54O1xuXHRcdGxldCBhbmdsZSA9IC1NYXRoLmF0YW4yKGRldCwgZG90KTtcblxuXHRcdGlmKGFuZ2xlIDwgMCl7XG5cdFx0XHRhbmdsZSArPSAyKk1hdGguUEk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFuZ2xlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2ZWN0b3Igcm91bmRlZCB0byAxIGRlY2ltYWwgcG9pbnRcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IgYXMgYSBzdHJpbmdcblx0ICovXG5cdHRvU3RyaW5nKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuIHRoaXMudG9GaXhlZCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2ZWN0b3Igcm91bmRlZCB0byB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBkZWNpbWFsIHBvaW50c1xuXHQgKiBAcGFyYW0gbnVtRGVjaW1hbFBvaW50cyBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzIHRvIGNyZWF0ZSBhIHN0cmluZyB0b1xuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhcyBhIHN0cmluZ1xuXHQgKi9cblx0dG9GaXhlZChudW1EZWNpbWFsUG9pbnRzOiBudW1iZXIgPSAxKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gXCIoXCIgKyB0aGlzLngudG9GaXhlZChudW1EZWNpbWFsUG9pbnRzKSArIFwiLCBcIiArIHRoaXMueS50b0ZpeGVkKG51bURlY2ltYWxQb2ludHMpICsgXCIpXCI7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIG5ldyB2ZWN0b3Igd2l0aCB0aGUgc2FtZSBjb29yZGluYXRlcyBhcyB0aGlzIG9uZS5cblx0ICogQHJldHVybnMgQSBuZXcgVmVjMiB3aXRoIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGlzIG9uZVxuXHQgKi9cblx0Y2xvbmUoKTogVmVjMiB7XG5cdFx0cmV0dXJuIG5ldyBWZWMyKHRoaXMueCwgdGhpcy55KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyB2ZWN0b3IgYW5kIG90aGVyIGhhdmUgdGhlIEVYQUNUIHNhbWUgeCBhbmQgeSAobm90IGFzc3VyZWQgdG8gYmUgc2FmZSBmb3IgZmxvYXRzKVxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIHZlY3RvciB0byBjaGVjayBhZ2FpbnN0XG5cdCAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIGVxdWFsaXR5IG9mIHRoZSB0d28gdmVjdG9yc1xuXHQgKi9cblx0c3RyaWN0RXF1YWxzKG90aGVyOiBWZWMyKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMueCA9PT0gb3RoZXIueCAmJiB0aGlzLnkgPT09IG90aGVyLnk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoaXMgdmVjdG9yIGFuZCBvdGhlciBoYXZlIHRoZSBzYW1lIHggYW5kIHlcblx0ICogQHBhcmFtIG90aGVyIFRoZSB2ZWN0b3IgdG8gY2hlY2sgYWdhaW5zdFxuXHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSBlcXVhbGl0eSBvZiB0aGUgdHdvIHZlY3RvcnNcblx0ICovXG5cdGVxdWFscyhvdGhlcjogVmVjMik6IGJvb2xlYW4ge1xuXHRcdGxldCB4RXEgPSBNYXRoLmFicyh0aGlzLnggLSBvdGhlci54KSA8IDAuMDAwMDAwMTtcblx0XHRsZXQgeUVxID0gTWF0aC5hYnModGhpcy55IC0gb3RoZXIueSkgPCAwLjAwMDAwMDE7XG5cblx0XHRyZXR1cm4geEVxICYmIHlFcTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyB2ZWN0b3IgaXMgdGhlIHplcm8gdmVjdG9yIGV4YWN0bHkgKG5vdCBhc3N1cmVkIHRvIGJlIHNhZmUgZm9yIGZsb2F0cykuXG5cdCAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIGVxdWFsaXR5IG9mIHRoaXMgdmVjdG9yIGFuZCB0aGUgemVybyB2ZWN0b3Jcblx0ICovXG5cdHN0cmljdElzWmVybygpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy54ID09PSAwICYmIHRoaXMueSA9PT0gMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyB4IGFuZCB5IGZvciB0aGlzIHZlY3RvciBhcmUgYm90aCB6ZXJvLlxuXHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSBlcXVhbGl0eSBvZiB0aGlzIHZlY3RvciBhbmQgdGhlIHplcm8gdmVjdG9yXG5cdCAqL1xuXHRpc1plcm8oKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIE1hdGguYWJzKHRoaXMueCkgPCAwLjAwMDAwMDEgJiYgTWF0aC5hYnModGhpcy55KSA8IDAuMDAwMDAwMTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFNldHMgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW5ldmVyIHRoaXMgdmVjdG9yIGlzIGNoYW5nZWQuXG5cdCAqIEBwYXJhbSBmIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWRcblx0ICovXG5cdHNldE9uQ2hhbmdlKGY6IEZ1bmN0aW9uKTogdm9pZCB7XG5cdFx0dGhpcy5vbkNoYW5nZSA9IGY7XG5cdH1cblxuXHR0b0FycmF5KCk6IEZsb2F0MzJBcnJheSB7XG5cdFx0cmV0dXJuIHRoaXMudmVjO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBlcmZvcm1zIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlY3RvcnNcblx0ICogQHBhcmFtIGEgVGhlIGZpcnN0IHZlY3RvclxuXHQgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZlY3RvclxuXHQgKiBAcGFyYW0gdCBUaGUgdGltZSBvZiB0aGUgbGVycCwgd2l0aCAwIGJlaW5nIHZlY3RvciBBLCBhbmQgMSBiZWluZyB2ZWN0b3IgQlxuXHQgKiBAcmV0dXJucyBBIG5ldyBWZWMyIHJlcHJlc2VudGluZyB0aGUgbGVycCBiZXR3ZWVuIHZlY3RvciBhIGFuZCBiLlxuXHQgKi9cblx0c3RhdGljIGxlcnAoYTogVmVjMiwgYjogVmVjMiwgdDogbnVtYmVyKTogVmVjMiB7XG5cdFx0cmV0dXJuIG5ldyBWZWMyKE1hdGhVdGlscy5sZXJwKGEueCwgYi54LCB0KSwgTWF0aFV0aWxzLmxlcnAoYS55LCBiLnksIHQpKTtcblx0fVxufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9Db2xsZWN0aW9ucy9NYXBcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi9Ob2Rlcy9HYW1lTm9kZVwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi9VdGlscy9Db2xvclwiO1xuXG4vKipcbiAqIEEgdXRpbCBjbGFzcyBmb3IgcmVuZGVyaW5nIERlYnVnIG1lc3NhZ2VzIHRvIHRoZSBjYW52YXMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlYnVnIHtcblxuXHQvKiogQSBtYXAgb2YgbG9nIG1lc3NhZ2VzIHRvIGRpc3BsYXkgb24gdGhlIHNjcmVlbiAqLyBcblx0cHJpdmF0ZSBzdGF0aWMgbG9nTWVzc2FnZXM6IE1hcDxzdHJpbmc+ID0gbmV3IE1hcCgpO1xuXG5cdC8qKiBBbiBhcnJheSBvZiBnYW1lIG5vZGVzIHRvIHJlbmRlciBkZWJ1ZyBpbmZvIGZvciAqL1xuXHRwcml2YXRlIHN0YXRpYyBub2RlczogQXJyYXk8R2FtZU5vZGU+O1xuXG5cdC8qKiBUaGUgcmVuZGVyaW5nIGNvbnRleHQgZm9yIGFueSBkZWJ1ZyBtZXNzYWdlcyAqL1xuXHRwcml2YXRlIHN0YXRpYyBkZWJ1Z1JlbmRlcmluZ0NvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcblxuXHQvKipcdFRoZSBzaXplIG9mIHRoZSBkZWJ1ZyBjYW52YXMgKi9cblx0cHJpdmF0ZSBzdGF0aWMgZGVidWdDYW52YXNTaXplOiBWZWMyO1xuXG5cdC8qKiBUaGUgcmVuZGVyaW5nIGNvbG9yIGZvciB0ZXh0ICovXG5cdHByaXZhdGUgc3RhdGljIGRlZmF1bHRUZXh0Q29sb3I6IENvbG9yID0gQ29sb3IuV0hJVEU7XG5cblx0LyoqXG5cdCAqIEFkZCBhIG1lc3NhZ2UgdG8gZGlzcGxheSBvbiB0aGUgZGVidWcgc2NyZWVuXG5cdCAqIEBwYXJhbSBpZCBBIHVuaXF1ZSBJRCBmb3IgdGhpcyBtZXNzYWdlXG5cdCAqIEBwYXJhbSBtZXNzYWdlcyBUaGUgbWVzc2FnZXMgdG8gcHJpbnQgdG8gdGhlIGRlYnVnIHNjcmVlblxuXHQgKi9cblx0c3RhdGljIGxvZyhpZDogc3RyaW5nLCAuLi5tZXNzYWdlczogYW55KTogdm9pZCB7XG5cdFx0Ly8gbGV0IG1lc3NhZ2UgPSBcIlwiO1xuXHRcdC8vIGZvcihsZXQgaSA9IDA7IGkgPCBtZXNzYWdlcy5sZW5ndGg7IGkrKyl7XG5cdFx0Ly8gXHRtZXNzYWdlICs9IG1lc3NhZ2VzW2ldLnRvU3RyaW5nKCk7XG5cdFx0Ly8gfVxuXHRcdC8vIEpvaW4gYWxsIG1lc3NhZ2VzIHdpdGggc3BhY2VzXG5cdFx0bGV0IG1lc3NhZ2UgPSBtZXNzYWdlcy5tYXAoKG06IGFueSkgPT4gbS50b1N0cmluZygpKS5qb2luKFwiIFwiKTtcblx0XHR0aGlzLmxvZ01lc3NhZ2VzLmFkZChpZCwgbWVzc2FnZSk7XG5cdH1cblxuXHQvKipcblx0ICogRGVsZXRlcyBhIGEga2V5IGZyb20gdGhlIGxvZyBhbmQgc3RvcHMgaXQgZnJvbSBrZWVwaW5nIHVwIHNwYWNlIG9uIHRoZSBzY3JlZW5cblx0ICogQHBhcmFtIGlkIFRoZSBpZCBvZiB0aGUgbG9nIGl0ZW0gdG8gY2xlYXJcblx0ICovXG5cdHN0YXRpYyBjbGVhckxvZ0l0ZW0oaWQ6IHN0cmluZyk6IHZvaWQge1xuXHRcdHRoaXMubG9nTWVzc2FnZXMuZGVsZXRlKGlkKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBsaXN0IG9mIG5vZGVzIHRvIHJlbmRlciB3aXRoIHRoZSBkZWJ1Z2dlclxuXHQgKiBAcGFyYW0gbm9kZXMgVGhlIG5ldyBsaXN0IG9mIG5vZGVzXG5cdCAqL1xuXHRzdGF0aWMgc2V0Tm9kZXMobm9kZXM6IEFycmF5PEdhbWVOb2RlPik6IHZvaWQge1xuXHRcdHRoaXMubm9kZXMgPSBub2Rlcztcblx0fVxuXG5cdC8qKlxuXHQgKiBEcmF3cyBhIGJveCBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uXG5cdCAqIEBwYXJhbSBjZW50ZXIgVGhlIGNlbnRlciBvZiB0aGUgYm94XG5cdCAqIEBwYXJhbSBoYWxmU2l6ZSBUaGUgZGltZW5zaW9ucyBvZiB0aGUgYm94XG5cdCAqIEBwYXJhbSBmaWxsZWQgQSBib29sZWFuIGZvciB3aGV0aGVyIG9yIG5vdCB0aGUgYm94IGlzIGZpbGxlZFxuXHQgKiBAcGFyYW0gY29sb3IgVGhlIGNvbG9yIG9mIHRoZSBib3ggdG8gZHJhd1xuXHQgKi9cblx0c3RhdGljIGRyYXdCb3goY2VudGVyOiBWZWMyLCBoYWxmU2l6ZTogVmVjMiwgZmlsbGVkOiBib29sZWFuLCBjb2xvcjogQ29sb3IpOiB2b2lkIHtcblx0XHRsZXQgYWxwaGEgPSB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5nbG9iYWxBbHBoYTtcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5nbG9iYWxBbHBoYSA9IGNvbG9yLmE7XG5cblx0XHRpZihmaWxsZWQpe1xuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZmlsbFN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmZpbGxSZWN0KGNlbnRlci54IC0gaGFsZlNpemUueCwgY2VudGVyLnkgLSBoYWxmU2l6ZS55LCBoYWxmU2l6ZS54KjIsIGhhbGZTaXplLnkqMik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxldCBsaW5lV2lkdGggPSAyO1xuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQubGluZVdpZHRoID0gbGluZVdpZHRoO1xuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuc3Ryb2tlUmVjdChjZW50ZXIueCAtIGhhbGZTaXplLngsIGNlbnRlci55IC0gaGFsZlNpemUueSwgaGFsZlNpemUueCoyLCBoYWxmU2l6ZS55KjIpO1xuXHRcdH1cblxuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0Lmdsb2JhbEFscGhhID0gYWxwaGE7XG5cdH1cblxuXHQvKipcblx0ICogRHJhd3MgYSBjaXJjbGUgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvblxuXHQgKiBAcGFyYW0gY2VudGVyIFRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZVxuXHQgKiBAcGFyYW0gcmFkaXVzIFRoZSBkaW1lbnNpb25zIG9mIHRoZSBib3hcblx0ICogQHBhcmFtIGZpbGxlZCBBIGJvb2xlYW4gZm9yIHdoZXRoZXIgb3Igbm90IHRoZSBjaXJjbGUgaXMgZmlsbGVkXG5cdCAqIEBwYXJhbSBjb2xvciBUaGUgY29sb3Igb2YgdGhlIGNpcmNsZVxuXHQgKi9cblx0c3RhdGljIGRyYXdDaXJjbGUoY2VudGVyOiBWZWMyLCByYWRpdXM6IG51bWJlciwgZmlsbGVkOiBib29sZWFuLCBjb2xvcjogQ29sb3IpOiB2b2lkIHtcblx0XHRsZXQgYWxwaGEgPSB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5nbG9iYWxBbHBoYTtcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5nbG9iYWxBbHBoYSA9IGNvbG9yLmE7XG5cblx0XHRpZihmaWxsZWQpe1xuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZmlsbFN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmJlZ2luUGF0aCgpO1xuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuYXJjKGNlbnRlci54LCBjZW50ZXIueSwgcmFkaXVzLCAwLCAyICogTWF0aC5QSSk7XG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5jbG9zZVBhdGgoKTtcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmZpbGwoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGV0IGxpbmVXaWR0aCA9IDI7XG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5iZWdpblBhdGgoKTtcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmFyYyhjZW50ZXIueCwgY2VudGVyLnksIHJhZGl1cywgMCwgMiAqIE1hdGguUEkpO1xuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuY2xvc2VQYXRoKCk7XG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5zdHJva2UoKTtcblx0XHR9XG5cblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhO1xuXHR9XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgcmF5IGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb25cblx0ICogQHBhcmFtIGZyb20gVGhlIHN0YXJ0aW5nIHBvc2l0aW9uIG9mIHRoZSByYXlcblx0ICogQHBhcmFtIHRvIFRoZSBlbmRpbmcgcG9zaXRpb24gb2YgdGhlIHJheVxuXHQgKiBAcGFyYW0gY29sb3IgVGhlIGNvbG9yIG9mIHRoZSByYXlcblx0ICovXG5cdHN0YXRpYyBkcmF3UmF5KGZyb206IFZlYzIsIHRvOiBWZWMyLCBjb2xvcjogQ29sb3IpOiB2b2lkIHtcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5saW5lV2lkdGggPSAyO1xuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcblxuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmJlZ2luUGF0aCgpO1xuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0Lm1vdmVUbyhmcm9tLngsIGZyb20ueSk7XG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQubGluZVRvKHRvLngsIHRvLnkpO1xuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmNsb3NlUGF0aCgpO1xuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LnN0cm9rZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgcG9pbnQgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvblxuXHQgKiBAcGFyYW0gcG9zIFRoZSBwb3NpdGlvbiBvZiB0aGUgcG9pbnRcblx0ICogQHBhcmFtIGNvbG9yIFRoZSBjb2xvciBvZiB0aGUgcG9pbnRcblx0ICovXG5cdHN0YXRpYyBkcmF3UG9pbnQocG9zOiBWZWMyLCBjb2xvcjogQ29sb3IpOiB2b2lkIHtcblx0XHRsZXQgcG9pbnRTaXplID0gNjtcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5maWxsU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmZpbGxSZWN0KHBvcy54IC0gcG9pbnRTaXplLzIsIHBvcy55IC0gcG9pbnRTaXplLzIsIHBvaW50U2l6ZSwgcG9pbnRTaXplKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBkZWZhdWx0IHJlbmRlcmluZyBjb2xvciBmb3IgdGV4dCBmb3IgdGhlIGRlYnVnZ2VyXG5cdCAqIEBwYXJhbSBjb2xvciBUaGUgY29sb3IgdG8gcmVuZGVyIHRoZSB0ZXh0XG5cdCAqL1xuXHRzdGF0aWMgc2V0RGVmYXVsdFRleHRDb2xvcihjb2xvcjogQ29sb3IpOiB2b2lkIHtcblx0XHR0aGlzLmRlZmF1bHRUZXh0Q29sb3IgPSBjb2xvcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBQZXJmb3JtcyBhbnkgbmVjZXNzYXJ5IHNldHVwIG9wZXJhdGlvbnMgb24gdGhlIERlYnVnIGNhbnZhc1xuXHQgKiBAcGFyYW0gY2FudmFzIFRoZSBkZWJ1ZyBjYW52YXNcblx0ICogQHBhcmFtIHdpZHRoIFRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIGhlaWdodCBUaGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIGNhbnZhc1xuXHQgKiBAcmV0dXJucyBUaGUgcmVuZGVyaW5nIGNvbnRleHQgZXh0cmFjdGVkIGZyb20gdGhlIGNhbnZhc1xuXHQgKi9cblx0c3RhdGljIGluaXRpYWxpemVEZWJ1Z0NhbnZhcyhjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuXHRcdGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0XG5cdFx0dGhpcy5kZWJ1Z0NhbnZhc1NpemUgPSBuZXcgVmVjMih3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0O1xuXHR9XG5cblx0LyoqIENsZWFycyB0aGUgZGVidWcgY2FudmFzICovXG5cdHN0YXRpYyBjbGVhckNhbnZhcygpOiB2b2lkIHtcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy5kZWJ1Z0NhbnZhc1NpemUueCwgdGhpcy5kZWJ1Z0NhbnZhc1NpemUueSk7XG5cdH1cblxuXHQvKiogUmVuZGVycyB0aGUgdGV4dCBhbmQgbm9kZXMgc2VudCB0byB0aGUgRGVidWcgc3lzdGVtICovXG5cdHN0YXRpYyByZW5kZXIoKTogdm9pZCB7XG5cdFx0dGhpcy5yZW5kZXJUZXh0KCk7XG5cdFx0dGhpcy5yZW5kZXJOb2RlcygpO1xuXHR9XG5cblx0LyoqIFJlbmRlcnMgdGhlIHRleHQgc2VudCB0byB0aGUgRGVidWcgY2FudmFzICovXG5cdHN0YXRpYyByZW5kZXJUZXh0KCk6IHZvaWQge1xuXHRcdGxldCB5ID0gMjA7XG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZm9udCA9IFwiMjBweCBBcmlhbFwiO1xuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuZGVmYXVsdFRleHRDb2xvci50b1N0cmluZygpO1xuXG5cdFx0Ly8gRHJhdyBhbGwgb2YgdGhlIHRleHRcblx0XHR0aGlzLmxvZ01lc3NhZ2VzLmZvckVhY2goKGtleTogc3RyaW5nKSA9PiB7XG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5maWxsVGV4dCh0aGlzLmxvZ01lc3NhZ2VzLmdldChrZXkpLCAxMCwgeSlcblx0XHRcdHkgKz0gMzA7XHRcblx0XHR9KTtcblx0fVxuXG5cdC8qKiBSZW5kZXJzIHRoZSBub2RlcyByZWdpc3RlcmVkIHdpdGggdGhlIGRlYnVnIGNhbnZhcyAqL1xuXHRzdGF0aWMgcmVuZGVyTm9kZXMoKTogdm9pZCB7XG5cdFx0aWYodGhpcy5ub2Rlcyl7XG5cdFx0XHR0aGlzLm5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG5cdFx0XHRcdG5vZGUuZGVidWdSZW5kZXIoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxufSIsImltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcblxuLy8gQGlnbm9yZVBhZ2VcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXRzIGV4dGVuZHMgT2JqZWN0IHtcbiAgICAvLyBUaGUgZnBzIG9mIHRoZSBnYW1lLlxuICAgIHByaXZhdGUgc3RhdGljIHByZXZmcHM6IEFycmF5PG51bWJlcj47XG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgTlVNX1BPSU5UUzogbnVtYmVyID0gNjA7XG4gICAgcHJpdmF0ZSBzdGF0aWMgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XG4gICAgcHJpdmF0ZSBzdGF0aWMgQ0FOVkFTX1dJRFRIOiBudW1iZXIgPSAzMDA7XG4gICAgcHJpdmF0ZSBzdGF0aWMgQ0FOVkFTX0hFSUdIVDogbnVtYmVyID0gMzAwO1xuICAgIHByaXZhdGUgc3RhdGljIHN0YXRzRGl2OiBIVE1MRGl2RWxlbWVudDtcbiAgICBwcml2YXRlIHN0YXRpYyBncmFwaENob2ljZXM6IEhUTUxTZWxlY3RFbGVtZW50O1xuXG4gICAgLy8gUXVhZHRyZWUgc3RhdHNcbiAgICBwcml2YXRlIHN0YXRpYyBwcmV2Q2xlYXJUaW1lczogQXJyYXk8bnVtYmVyPjtcbiAgICBwcml2YXRlIHN0YXRpYyBTR0NsZWFyVGltZXM6IEFycmF5PG51bWJlcj47XG4gICAgcHJpdmF0ZSBzdGF0aWMgYXZnU0dDbGVhclRpbWU6IG51bWJlcjtcblxuICAgIHByaXZhdGUgc3RhdGljIHByZXZGaWxsVGltZXM6IEFycmF5PG51bWJlcj47XG4gICAgcHJpdmF0ZSBzdGF0aWMgU0dGaWxsVGltZXM6IEFycmF5PG51bWJlcj47XG4gICAgcHJpdmF0ZSBzdGF0aWMgYXZnU0dGaWxsVGltZTogbnVtYmVyO1xuXG4gICAgcHJpdmF0ZSBzdGF0aWMgcHJldlVwZGF0ZVRpbWVzOiBBcnJheTxudW1iZXI+O1xuICAgIHByaXZhdGUgc3RhdGljIFNHVXBkYXRlVGltZXM6IEFycmF5PG51bWJlcj47XG4gICAgcHJpdmF0ZSBzdGF0aWMgYXZnU0dVcGRhdGVUaW1lOiBudW1iZXI7XG5cbiAgICBwcml2YXRlIHN0YXRpYyBwcmV2UXVlcnlUaW1lczogQXJyYXk8bnVtYmVyPjtcbiAgICBwcml2YXRlIHN0YXRpYyBTR1F1ZXJ5VGltZXM6IEFycmF5PG51bWJlcj47XG4gICAgcHJpdmF0ZSBzdGF0aWMgYXZnU0dRdWVyeVRpbWU6IG51bWJlcjtcblxuICAgIHN0YXRpYyBpbml0U3RhdHMoKTogdm9pZCB7XG4gICAgICAgIGxldCBjYW52YXMgPSA8SFRNTENhbnZhc0VsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdGF0cy1jYW52YXNcIik7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHRoaXMuQ0FOVkFTX1dJRFRIO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5DQU5WQVNfSEVJR0hUO1xuICAgICAgICB0aGlzLmN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICAgICAgdGhpcy5zdGF0c0RpdiA9IDxIVE1MRGl2RWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN0YXRzLWRpc3BsYXlcIik7XG5cbiAgICAgICAgdGhpcy5wcmV2ZnBzID0gbmV3IEFycmF5KCk7XG5cbiAgICAgICAgdGhpcy5wcmV2Q2xlYXJUaW1lcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLlNHQ2xlYXJUaW1lcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLmF2Z1NHQ2xlYXJUaW1lID0gMDtcblxuICAgICAgICB0aGlzLnByZXZGaWxsVGltZXMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy5TR0ZpbGxUaW1lcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLmF2Z1NHRmlsbFRpbWUgPSAwO1xuXG4gICAgICAgIHRoaXMucHJldlVwZGF0ZVRpbWVzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMuU0dVcGRhdGVUaW1lcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLmF2Z1NHVXBkYXRlVGltZSA9IDA7XG5cbiAgICAgICAgdGhpcy5wcmV2UXVlcnlUaW1lcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLlNHUXVlcnlUaW1lcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLmF2Z1NHUXVlcnlUaW1lID0gMDtcblxuICAgICAgICBsZXQgY2xlYXJUaW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIGNsZWFyVGltZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInNnY2xlYXJcIik7XG4gICAgICAgIGxldCBmaWxsVGltZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBmaWxsVGltZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInNnZmlsbFwiKTtcbiAgICAgICAgbGV0IHVwZGF0ZVRpbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgdXBkYXRlVGltZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInNndXBkYXRlXCIpO1xuICAgICAgICBsZXQgcXVlcnlUaW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHF1ZXJ5VGltZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInNncXVlcnlcIik7XG4gICAgICAgIGxldCBicjEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIik7XG4gICAgICAgIGxldCBicjIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIik7XG4gICAgICAgIGxldCBicjMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIik7XG5cbiAgICAgICAgdGhpcy5zdGF0c0Rpdi5hcHBlbmQoY2xlYXJUaW1lLCBicjEsIGZpbGxUaW1lLCBicjIsIHVwZGF0ZVRpbWUsIGJyMywgcXVlcnlUaW1lKTtcblxuICAgICAgICB0aGlzLmdyYXBoQ2hvaWNlcyA9IDxIVE1MU2VsZWN0RWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNoYXJ0LW9wdGlvblwiKTtcbiAgICAgICAgbGV0IG9wdGlvbjEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICBvcHRpb24xLnZhbHVlID0gXCJwcmV2ZnBzXCI7XG4gICAgICAgIG9wdGlvbjEubGFiZWwgPSBcIkZQU1wiO1xuICAgICAgICBsZXQgb3B0aW9uMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgIG9wdGlvbjIudmFsdWUgPSBcInByZXZDbGVhclRpbWVzXCI7XG4gICAgICAgIG9wdGlvbjIubGFiZWwgPSBcIkNsZWFyIFRpbWVcIjtcbiAgICAgICAgbGV0IG9wdGlvbjMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICBvcHRpb24zLnZhbHVlID0gXCJwcmV2RmlsbFRpbWVzXCI7XG4gICAgICAgIG9wdGlvbjMubGFiZWwgPSBcIkZpbGwgdGltZVwiO1xuICAgICAgICBsZXQgb3B0aW9uNCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgIG9wdGlvbjQudmFsdWUgPSBcInByZXZVcGRhdGVUaW1lc1wiO1xuICAgICAgICBvcHRpb240LmxhYmVsID0gXCJVcGRhdGUgdGltZVwiO1xuICAgICAgICBsZXQgb3B0aW9uNSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgIG9wdGlvbjUudmFsdWUgPSBcInByZXZRdWVyeVRpbWVzXCI7XG4gICAgICAgIG9wdGlvbjUubGFiZWwgPSBcIlF1ZXJ5IFRpbWVcIjtcbiAgICAgICAgbGV0IG9wdGlvbkFsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgIG9wdGlvbkFsbC52YWx1ZSA9IFwiYWxsXCI7XG4gICAgICAgIG9wdGlvbkFsbC5sYWJlbCA9IFwiQWxsXCI7XG4gICAgICAgIHRoaXMuZ3JhcGhDaG9pY2VzLmFwcGVuZChvcHRpb24xLCBvcHRpb24yLCBvcHRpb24zLCBvcHRpb240LCBvcHRpb241LCBvcHRpb25BbGwpO1xuICAgIH1cblxuICAgIHN0YXRpYyB1cGRhdGVGUFMoZnBzOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5wcmV2ZnBzLnB1c2goZnBzKTtcbiAgICAgICAgaWYodGhpcy5wcmV2ZnBzLmxlbmd0aCA+IFN0YXRzLk5VTV9QT0lOVFMpe1xuICAgICAgICAgICAgdGhpcy5wcmV2ZnBzLnNoaWZ0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLlNHQ2xlYXJUaW1lcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgIHRoaXMucHJldkNsZWFyVGltZXMucHVzaCh0aGlzLmF2Z1NHQ2xlYXJUaW1lKTtcbiAgICAgICAgICAgIGlmKHRoaXMucHJldkNsZWFyVGltZXMubGVuZ3RoID4gdGhpcy5OVU1fUE9JTlRTKXtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZDbGVhclRpbWVzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5TR0ZpbGxUaW1lcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgIHRoaXMucHJldkZpbGxUaW1lcy5wdXNoKHRoaXMuYXZnU0dGaWxsVGltZSk7XG4gICAgICAgICAgICBpZih0aGlzLnByZXZGaWxsVGltZXMubGVuZ3RoID4gdGhpcy5OVU1fUE9JTlRTKXtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZGaWxsVGltZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLlNHVXBkYXRlVGltZXMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICB0aGlzLnByZXZVcGRhdGVUaW1lcy5wdXNoKHRoaXMuYXZnU0dVcGRhdGVUaW1lKTtcbiAgICAgICAgICAgIGlmKHRoaXMucHJldlVwZGF0ZVRpbWVzLmxlbmd0aCA+IHRoaXMuTlVNX1BPSU5UUyl7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2VXBkYXRlVGltZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLlNHUXVlcnlUaW1lcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgIHRoaXMucHJldlF1ZXJ5VGltZXMucHVzaCh0aGlzLmF2Z1NHUXVlcnlUaW1lKTtcbiAgICAgICAgICAgIGlmKHRoaXMucHJldlF1ZXJ5VGltZXMubGVuZ3RoID4gdGhpcy5OVU1fUE9JTlRTKXtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZRdWVyeVRpbWVzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZVNHU3RhdHMoKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbG9nKGtleTogc3RyaW5nLCBkYXRhOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgaWYoa2V5ID09PSBcInNnY2xlYXJcIil7XG4gICAgICAgICAgICB0aGlzLlNHQ2xlYXJUaW1lcy5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgaWYodGhpcy5TR0NsZWFyVGltZXMubGVuZ3RoID4gMTAwKXtcbiAgICAgICAgICAgICAgICB0aGlzLlNHQ2xlYXJUaW1lcy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoa2V5ID09PSBcInNnZmlsbFwiKXtcbiAgICAgICAgICAgIHRoaXMuU0dGaWxsVGltZXMucHVzaChkYXRhKTtcbiAgICAgICAgICAgIGlmKHRoaXMuU0dGaWxsVGltZXMubGVuZ3RoID4gMTAwKXtcbiAgICAgICAgICAgICAgICB0aGlzLlNHRmlsbFRpbWVzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZihrZXkgPT09IFwic2d1cGRhdGVcIil7XG4gICAgICAgICAgICB0aGlzLlNHVXBkYXRlVGltZXMucHVzaChkYXRhKTtcbiAgICAgICAgICAgIGlmKHRoaXMuU0dVcGRhdGVUaW1lcy5sZW5ndGggPiAxMDApe1xuICAgICAgICAgICAgICAgIHRoaXMuU0dVcGRhdGVUaW1lcy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoa2V5ID09PSBcInNncXVlcnlcIil7XG4gICAgICAgICAgICB0aGlzLlNHUXVlcnlUaW1lcy5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgaWYodGhpcy5TR1F1ZXJ5VGltZXMubGVuZ3RoID4gMTAwMCl7XG4gICAgICAgICAgICAgICAgdGhpcy5TR1F1ZXJ5VGltZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgc3RhdGljIHJlbmRlcigpOiB2b2lkIHtcbiAgICAgICAgLy8gRGlzcGxheSBzdGF0c1xuICAgICAgICB0aGlzLmRyYXdDaGFydHMoKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZHJhd0NoYXJ0cygpe1xuICAgICAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5DQU5WQVNfV0lEVEgsIHRoaXMuQ0FOVkFTX0hFSUdIVCk7XG5cbiAgICAgICAgbGV0IHBhcmFtU3RyaW5nID0gdGhpcy5ncmFwaENob2ljZXMudmFsdWU7XG5cbiAgICAgICAgaWYocGFyYW1TdHJpbmcgPT09IFwicHJldmZwc1wiIHx8IHBhcmFtU3RyaW5nID09PSBcImFsbFwiKXtcbiAgICAgICAgICAgIGxldCBwYXJhbSA9IHRoaXMucHJldmZwcztcbiAgICAgICAgICAgIGxldCBjb2xvciA9IENvbG9yLkJMVUUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhd0NoYXJ0KHBhcmFtLCBjb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYocGFyYW1TdHJpbmcgPT09IFwicHJldkNsZWFyVGltZXNcIiB8fCBwYXJhbVN0cmluZyA9PT0gXCJhbGxcIil7XG4gICAgICAgICAgICBsZXQgcGFyYW0gPSB0aGlzLnByZXZDbGVhclRpbWVzO1xuICAgICAgICAgICAgbGV0IGNvbG9yID0gQ29sb3IuUkVELnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB0aGlzLmRyYXdDaGFydChwYXJhbSwgY29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmKHBhcmFtU3RyaW5nID09PSBcInByZXZGaWxsVGltZXNcIiB8fCBwYXJhbVN0cmluZyA9PT0gXCJhbGxcIil7XG4gICAgICAgICAgICBsZXQgcGFyYW0gPSB0aGlzLnByZXZGaWxsVGltZXM7XG4gICAgICAgICAgICBsZXQgY29sb3IgPSBDb2xvci5HUkVFTi50b1N0cmluZygpO1xuICAgICAgICAgICAgdGhpcy5kcmF3Q2hhcnQocGFyYW0sIGNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZihwYXJhbVN0cmluZyA9PT0gXCJwcmV2VXBkYXRlVGltZXNcIiB8fCBwYXJhbVN0cmluZyA9PT0gXCJhbGxcIil7XG4gICAgICAgICAgICBsZXQgcGFyYW0gPSB0aGlzLnByZXZVcGRhdGVUaW1lcztcbiAgICAgICAgICAgIGxldCBjb2xvciA9IENvbG9yLkNZQU4udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhd0NoYXJ0KHBhcmFtLCBjb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYocGFyYW1TdHJpbmcgPT09IFwicHJldlF1ZXJ5VGltZXNcIiB8fCBwYXJhbVN0cmluZyA9PT0gXCJhbGxcIil7XG4gICAgICAgICAgICBsZXQgcGFyYW0gPSB0aGlzLnByZXZRdWVyeVRpbWVzO1xuICAgICAgICAgICAgbGV0IGNvbG9yID0gQ29sb3IuT1JBTkdFLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB0aGlzLmRyYXdDaGFydChwYXJhbSwgY29sb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGRyYXdDaGFydChwYXJhbTogQXJyYXk8bnVtYmVyPiwgY29sb3I6IHN0cmluZyl7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gQ29sb3IuQkxBQ0sudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuY3R4Lm1vdmVUbygxMCwgMTApO1xuICAgICAgICB0aGlzLmN0eC5saW5lVG8oMTAsIHRoaXMuQ0FOVkFTX0hFSUdIVCAtIDEwKTtcbiAgICAgICAgdGhpcy5jdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuICAgICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5jdHgubW92ZVRvKDEwLCB0aGlzLkNBTlZBU19IRUlHSFQgLSAxMCk7XG4gICAgICAgIHRoaXMuY3R4LmxpbmVUbyh0aGlzLkNBTlZBU19XSURUSCAtIDEwLCB0aGlzLkNBTlZBU19IRUlHSFQgLSAxMCk7XG4gICAgICAgIHRoaXMuY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcblxuICAgICAgICBsZXQgbWF4ID0gTWF0aC5tYXgoLi4ucGFyYW0pO1xuICAgICAgICBsZXQgcHJldlggPSAxMDtcbiAgICAgICAgbGV0IHByZXZZID0gdGhpcy5DQU5WQVNfSEVJR0hUIC0gMTAgLSBwYXJhbVswXS9tYXgqKHRoaXMuQ0FOVkFTX0hFSUdIVC0yMCk7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG5cbiAgICAgICAgZm9yKGxldCBpID0gMTsgaSA8IHBhcmFtLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGxldCBmcHMgPSBwYXJhbVtpXTtcbiAgICAgICAgICAgIGxldCB4ID0gMTAgKyBpKih0aGlzLkNBTlZBU19XSURUSCAtIDIwKS90aGlzLk5VTV9QT0lOVFM7XG4gICAgICAgICAgICBsZXQgeSA9IHRoaXMuQ0FOVkFTX0hFSUdIVCAtIDEwIC0gZnBzL21heCoodGhpcy5DQU5WQVNfSEVJR0hULTIwKVxuICAgICAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICB0aGlzLmN0eC5tb3ZlVG8ocHJldlgsIHByZXZZKTtcbiAgICAgICAgICAgIHRoaXMuY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgIHRoaXMuY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgIHByZXZYID0geDtcbiAgICAgICAgICAgIHByZXZZID0geTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyB1cGRhdGVTR1N0YXRzKCl7XG4gICAgICAgIGlmKHRoaXMuU0dDbGVhclRpbWVzLmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgdGhpcy5hdmdTR0NsZWFyVGltZSA9IHRoaXMuU0dDbGVhclRpbWVzLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCkvdGhpcy5TR0NsZWFyVGltZXMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5TR0ZpbGxUaW1lcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgIHRoaXMuYXZnU0dGaWxsVGltZSA9IHRoaXMuU0dGaWxsVGltZXMucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgdmFsKS90aGlzLlNHRmlsbFRpbWVzLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuU0dVcGRhdGVUaW1lcy5sZW5ndGggPiAwKXtcbiAgICAgICAgdGhpcy5hdmdTR1VwZGF0ZVRpbWUgPSB0aGlzLlNHVXBkYXRlVGltZXMucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgdmFsKS90aGlzLlNHVXBkYXRlVGltZXMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5TR1F1ZXJ5VGltZXMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICB0aGlzLmF2Z1NHUXVlcnlUaW1lID0gdGhpcy5TR1F1ZXJ5VGltZXMucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgdmFsKS90aGlzLlNHUXVlcnlUaW1lcy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNnY2xlYXJcIikuaW5uZXJIVE1MID0gXCJBdmcgU0cgY2xlYXIgdGltZTogXCIgKyB0aGlzLmF2Z1NHQ2xlYXJUaW1lO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNnZmlsbFwiKS5pbm5lckhUTUwgPSBcIkF2ZyBTRyBmaWxsIHRpbWU6IFwiICsgdGhpcy5hdmdTR0ZpbGxUaW1lO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNndXBkYXRlXCIpLmlubmVySFRNTCA9IFwiQXZnIFNHIHVwZGF0ZSB0aW1lOiBcIiArIHRoaXMuYXZnU0dVcGRhdGVUaW1lO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNncXVlcnlcIikuaW5uZXJIVE1MID0gXCJBdmcgU0cgcXVlcnkgdGltZTogXCIgKyB0aGlzLmF2Z1NHUXVlcnlUaW1lO1xuICAgIH1cbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvQ29sbGVjdGlvbnMvTWFwXCI7XG5pbXBvcnQgRXZlbnRRdWV1ZSBmcm9tIFwiLi9FdmVudFF1ZXVlXCI7XG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuL0dhbWVFdmVudFwiO1xuXG4vKipcbiAqIEFuIGV2ZW50IGVtaXR0ZXIgb2JqZWN0IG90aGVyIHN5c3RlbXMgY2FuIHVzZSB0byBob29rIGludG8gdGhlIEV2ZW50UXVldWUuXG4gKiBQcm92aWRlcyBhbiBlYXN5IGludGVyZmFjZSBmb3IgZmlyaW5nIG9mZiBldmVudHMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVtaXR0ZXIge1xuXHQvKiogQSByZWZlcmVuY2UgdG8gdGhlIEV2ZW50UXVldWUgKi9cblx0cHJpdmF0ZSBldmVudFF1ZXVlOiBFdmVudFF1ZXVlO1xuXG5cdC8qKiBDcmVhdGVzIGEgbmV3IEVtaXR0ZXIgKi9cblx0Y29uc3RydWN0b3IoKXtcblx0XHR0aGlzLmV2ZW50UXVldWUgPSBFdmVudFF1ZXVlLmdldEluc3RhbmNlKCk7XG5cdH1cblxuXHQvKipcblx0ICogRW1pdCBhbmQgZXZlbnQgb2YgdHlwZSBldmVudFR5cGUgd2l0aCB0aGUgZGF0YSBwYWNrZXQgZGF0YVxuXHQgKiBAcGFyYW0gZXZlbnRUeXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBmaXJlIG9mZlxuXHQgKiBAcGFyYW0gZGF0YSBBIEByZWZlcmVuY2VbTWFwXSBvciByZWNvcmQgY29udGFpbmluZyBhbnkgZGF0YSBhYm91dCB0aGUgZXZlbnRcblx0ICovXG5cdGZpcmVFdmVudChldmVudFR5cGU6IHN0cmluZywgZGF0YTogTWFwPGFueT4gfCBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0gbnVsbCk6IHZvaWQge1xuXHRcdHRoaXMuZXZlbnRRdWV1ZS5hZGRFdmVudChuZXcgR2FtZUV2ZW50KGV2ZW50VHlwZSwgZGF0YSkpO1xuXHR9XG59IiwiaW1wb3J0IFF1ZXVlIGZyb20gXCIuLi9EYXRhVHlwZXMvQ29sbGVjdGlvbnMvUXVldWVcIjtcbmltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9Db2xsZWN0aW9ucy9NYXBcIjtcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4vR2FtZUV2ZW50XCI7XG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSBcIi4vUmVjZWl2ZXJcIjtcbmltcG9ydCB7IEdhbWVFdmVudFR5cGUgfSBmcm9tIFwiLi9HYW1lRXZlbnRUeXBlXCI7XG5cbi8qKlxuICogVGhlIG1haW4gZXZlbnQgc3lzdGVtIG9mIHRoZSBnYW1lIGVuZ2luZS5cbiAqIEV2ZW50cyBhcmUgc2VudCB0byB0aGUgRXZlbnRRdWV1ZSwgd2hpY2ggaGFuZGxlcyBkaXN0cmlidXRpb24gdG8gYW55IHN5c3RlbXMgdGhhdCBhcmUgbGlzdGVuaW5nIGZvciB0aG9zZSBldmVudHMuXG4gKiBUaGlzIGFsbG93cyBmb3IgaGFuZGxpbmcgb2YgaW5wdXQgd2l0aG91dCBoYXZpbmcgY2xhc3NlcyBkaXJlY3RseSBob29rIGludG8gamF2YXNjcmlwdCBldmVudCBoYW5kbGVzLCBcbiAqIGFuZCBhbGxvd3Mgb3RoZXJ3aXNlIHNlcGFyYXRlIGNsYXNzZXMgdG8gY29tbXVuaWNhdGUgd2l0aCBlYWNoIG90aGVyIGNsZWFubHksIHN1Y2ggYXMgYSBQbGF5ZXIgb2JqZWN0IFxuICogcmVxdWVzdGluZyBhIHNvdW5kIGJlIHBsYXllZCBieSB0aGUgYXVkaW8gc3lzdGVtLlxuICogXG4gKiBUaGUgZGlzdHJpYnV0aW9uIG9mIEByZWZlcmVuY2VbR2FtZUV2ZW50XXMgaGFwcGVucyBhcyBmb2xsb3dzOlxuICogXG4gKiBFdmVudHMgYXJlIHJlY2lldmVkIHRocm91Z2hvdXQgYSBmcmFtZSBhbmQgYXJlIHF1ZXVlZCB1cCBieSB0aGUgRXZlbnRRdWV1ZS5cbiAqIEF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5leHQgZnJhbWUsIGV2ZW50cyBhcmUgc2VudCBvdXQgdG8gYW55IHJlY2VpdmVycyB0aGF0IGFyZSBob29rZWQgaW50byB0aGUgZXZlbnQgdHlwZS5cbiAqIEByZWZlcmVuY2VbUmVjZWl2ZXJdcyBhcmUgdGhlbiBmcmVlIHRvIHByb2Nlc3MgZXZlbnRzIGFzIHRoZXkgc2VlIGZpdC5cbiAqIFxuICogT3ZlcmFsbCwgdGhlIEV2ZW50UXVldWUgY2FuIGJlIGNvbnNpZGVyZWQgYXMgc29tZXRoaW5nIHNpbWlsYXIgdG8gYW4gZW1haWwgc2VydmVyLFxuICogYW5kIHRoZSBAcmVmZXJlbmNlW1JlY2VpdmVyXXMgY2FuIGJlIGNvbnNpZGVyZWQgYXMgdGhlIGNsaWVudCBpbmJveGVzLlxuICogXG4gKiBTZWUgQGxpbmsoR2FtZSBQcm9ncmFtbWluZyBQYXR0ZXJucykoaHR0cHM6Ly9nYW1lcHJvZ3JhbW1pbmdwYXR0ZXJucy5jb20vZXZlbnQtcXVldWUuaHRtbCkgZm9yIG1vcmUgZGlzY3Vzc2lvbiBvbiBFdmVudFF1ZXVlc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFdmVudFF1ZXVlIHtcbiAgICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogRXZlbnRRdWV1ZSA9IG51bGw7XG4gICAgXG4gICAgLyoqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBldmVudHMgdmlzaWJsZSAqL1xuICAgIHByaXZhdGUgcmVhZG9ubHkgTUFYX1NJWkU6IG51bWJlcjtcbiAgICBcbiAgICAvKiogVGhlIGFjdHVhbCBxdWV1ZSBvZiBldmVudHMgKi9cbiAgICBwcml2YXRlIHE6IFF1ZXVlPEdhbWVFdmVudD47XG4gICAgXG4gICAgLyoqIFRoZSBtYXAgb2YgcmVjZWl2ZXJzIHJlZ2lzdGVyZWQgZm9yIGFuIGV2ZW50IG5hbWUgKi9cblx0cHJpdmF0ZSByZWNlaXZlcnM6IE1hcDxBcnJheTxSZWNlaXZlcj4+O1xuXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLk1BWF9TSVpFID0gMjAwO1xuICAgICAgICB0aGlzLnEgPSBuZXcgUXVldWU8R2FtZUV2ZW50Pih0aGlzLk1BWF9TSVpFKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlcnMgPSBuZXcgTWFwPEFycmF5PFJlY2VpdmVyPj4oKTtcblx0fVxuICAgIFxuICAgIC8qKiBSZXRyaWV2ZXMgdGhlIGluc3RhbmNlIG9mIHRoZSBTaW5nbGV0b24gRXZlbnRRdWV1ZSAqL1xuXHRzdGF0aWMgZ2V0SW5zdGFuY2UoKTogRXZlbnRRdWV1ZSB7XG5cdFx0aWYodGhpcy5pbnN0YW5jZSA9PT0gbnVsbCl7XG5cdFx0XHR0aGlzLmluc3RhbmNlID0gbmV3IEV2ZW50UXVldWUoKTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2U7XG5cdH1cblxuICAgIC8qKiBBZGRzIGFuIGV2ZW50IHRvIHRoZSBFdmVudFF1ZXVlLlxuICAgICAqIFRoaXMgaXMgZXhwb3NlZCB0byB0aGUgcmVzdCBvZiB0aGUgZ2FtZSBlbmdpbmUgdGhyb3VnaCB0aGUgQHJlZmVyZW5jZVtFbWl0dGVyXSBjbGFzcyAqL1xuICAgIGFkZEV2ZW50KGV2ZW50OiBHYW1lRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5xLmVucXVldWUoZXZlbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc29jaWF0ZXMgYSByZWNlaXZlciB3aXRoIGEgdHlwZSBvZiBldmVudC4gRXZlcnkgdGltZSB0aGlzIGV2ZW50IGFwcGVhcnMgaW4gdGhlIGZ1dHVyZSxcbiAgICAgKiBpdCB3aWxsIGJlIGdpdmVuIHRvIHRoZSByZWNlaXZlciAoYW5kIGFueSBvdGhlcnMgd2F0Y2hpbmcgdGhhdCB0eXBlKS5cbiAgICAgKiBUaGlzIGlzIGV4cG9zZWQgdG8gdGhlIHJlc3Qgb2YgdGhlIGdhbWUgZW5naW5lIHRocm91Z2ggdGhlIEByZWZlcmVuY2VbUmVjZWl2ZXJdIGNsYXNzXG4gICAgICogQHBhcmFtIHJlY2VpdmVyIFRoZSBldmVudCByZWNlaXZlclxuICAgICAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9yIHR5cGVzIG9mIGV2ZW50cyB0byBzdWJzY3JpYmUgdG9cbiAgICAgKi9cbiAgICBzdWJzY3JpYmUocmVjZWl2ZXI6IFJlY2VpdmVyLCB0eXBlOiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+KTogdm9pZCB7XG4gICAgICAgIGlmKHR5cGUgaW5zdGFuY2VvZiBBcnJheSl7XG4gICAgICAgICAgICAvLyBJZiBpdCBpcyBhbiBhcnJheSwgc3Vic2NyaWJlIHRvIGFsbCBldmVudCB0eXBlc1xuICAgICAgICAgICAgZm9yKGxldCB0IG9mIHR5cGUpe1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTGlzdGVuZXIocmVjZWl2ZXIsIHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGRMaXN0ZW5lcihyZWNlaXZlciwgdHlwZSk7XG4gICAgICAgIH1cblx0fVxuXG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmVzIHRoZSBzcGVjaWZpZWQgcmVjZWl2ZXIgZnJvbSBhbGwgZXZlbnRzLCBvciBmcm9tIHdoYXRldmVyIGV2ZW50cyBhcmUgcHJvdmlkZWRcbiAgICAgKiBAcGFyYW0gcmVjZWl2ZXIgVGhlIHJlY2VpdmVyIHRvIHVuc3Vic2NyaWJlXG4gICAgICogQHBhcmFtIGtleXMgVGhlIGV2ZW50cyB0byB1bnN1YnNjcmliZSBmcm9tLiBJZiBub25lIGFyZSBwcm92aWRlZCwgdW5zdWJzY3JpYmUgZnJvbSBhbGxcbiAgICAgKi9cbiAgICB1bnN1YnNjcmliZShyZWNlaXZlcjogUmVjZWl2ZXIsIC4uLmV2ZW50czogQXJyYXk8c3RyaW5nPik6IHZvaWQge1xuICAgICAgICB0aGlzLnJlY2VpdmVycy5mb3JFYWNoKGV2ZW50TmFtZSA9PiB7XG4gICAgICAgICAgICAvLyBJZiBrZXlzIHdlcmUgcHJvdmlkZWQsIG9ubHkgY29udGludWUgaWYgdGhpcyBrZXkgaXMgb25lIG9mIHRoZW1cbiAgICAgICAgICAgIGlmKGV2ZW50cy5sZW5ndGggPiAwICYmIGV2ZW50cy5pbmRleE9mKGV2ZW50TmFtZSkgPT09IC0xKSByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGluZGV4IG9mIG91ciByZWNlaXZlciBmb3IgdGhpcyBrZXlcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHRoaXMucmVjZWl2ZXJzLmdldChldmVudE5hbWUpLmluZGV4T2YocmVjZWl2ZXIpO1xuXG4gICAgICAgICAgICAvLyBJZiBhbiBpbmRleCB3YXMgZm91bmQsIHJlbW92ZSB0aGUgcmVjZWl2ZXJcbiAgICAgICAgICAgIGlmKGluZGV4ICE9PSAtMSl7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNlaXZlcnMuZ2V0KGV2ZW50TmFtZSkuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQXNzb2NpYXRlIHRoZSByZWNlaXZlciBhbmQgdGhlIHR5cGVcblx0cHJpdmF0ZSBhZGRMaXN0ZW5lcihyZWNlaXZlcjogUmVjZWl2ZXIsIHR5cGU6IHN0cmluZyk6IHZvaWQge1xuXHRcdGlmKHRoaXMucmVjZWl2ZXJzLmhhcyh0eXBlKSl7XG5cdFx0XHR0aGlzLnJlY2VpdmVycy5nZXQodHlwZSkucHVzaChyZWNlaXZlcik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucmVjZWl2ZXJzLmFkZCh0eXBlLCBbcmVjZWl2ZXJdKTtcblx0XHR9XG5cdH1cbiAgICBcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgd2hpbGUodGhpcy5xLmhhc0l0ZW1zKCkpe1xuICAgICAgICAgICAgLy8gUmV0cmlldmUgZWFjaCBldmVudFxuXHRcdFx0bGV0IGV2ZW50ID0gdGhpcy5xLmRlcXVldWUoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSWYgYSByZWNlaXZlciBoYXMgdGhpcyBldmVudCB0eXBlLCBzZW5kIGl0IHRoZSBldmVudFxuICAgICAgICAgICAgaWYodGhpcy5yZWNlaXZlcnMuaGFzKGV2ZW50LnR5cGUpKXtcbiAgICAgICAgICAgICAgICBmb3IobGV0IHJlY2VpdmVyIG9mIHRoaXMucmVjZWl2ZXJzLmdldChldmVudC50eXBlKSl7XG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmVyLnJlY2VpdmUoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cblx0XHRcdH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSWYgYSByZWNlaXZlciBpcyBzdWJzY3JpYmVkIHRvIGFsbCBldmVudHMsIHNlbmQgaXQgdGhlIGV2ZW50XG4gICAgICAgICAgICBpZih0aGlzLnJlY2VpdmVycy5oYXMoR2FtZUV2ZW50VHlwZS5BTEwpKXtcbiAgICAgICAgICAgICAgICBmb3IobGV0IHJlY2VpdmVyIG9mIHRoaXMucmVjZWl2ZXJzLmdldChHYW1lRXZlbnRUeXBlLkFMTCkpe1xuICAgICAgICAgICAgICAgICAgICByZWNlaXZlci5yZWNlaXZlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL0NvbGxlY3Rpb25zL01hcFwiXG5cbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhbiBpbi1nYW1lIGV2ZW50IHRoYXQgaXMgcGFzc2VkIHRocm91Z2ggdGhlIEByZWZlcmVuY2VbRXZlbnRRdWV1ZV1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2FtZUV2ZW50IHtcbiAgICAvKiogVGhlIHR5cGUgb2YgdGhlIGV2ZW50ICovXG4gICAgcHVibGljIHR5cGU6IHN0cmluZztcbiAgICAvKiogVGhlIGRhdGEgY29udGFpbmVkIGJ5IHRoZSBldmVudCAqL1xuICAgIHB1YmxpYyBkYXRhOiBNYXA8YW55PjtcbiAgICAvKiogVGhlIHRpbWUgb2YgdGhlIGV2ZW50IGluIG1zICovXG5cdHB1YmxpYyB0aW1lOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEdhbWVFdmVudC5cbiAgICAgKiBUaGlzIGlzIGhhbmRsZWQgaW1wbGljaXRseSB0aHJvdWdoIHRoZSBAcmVmZXJlbmNlW0VtaXR0ZXJdIGNsYXNzXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgdGhlIEdhbWVFdmVudFxuICAgICAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIGNvbnRhaW5lZCBieSB0aGUgR2FtZUV2ZW50XG4gICAgICovXG4gICAgY29uc3RydWN0b3IodHlwZTogc3RyaW5nLCBkYXRhOiBNYXA8YW55PiB8IFJlY29yZDxzdHJpbmcsIGFueT4gPSBudWxsKSB7XG4gICAgICAgIC8vIFBhcnNlIHRoZSBnYW1lIGV2ZW50IGRhdGFcbiAgICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBNYXA8YW55PigpO1xuICAgICAgICB9IGVsc2UgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIE1hcCkpe1xuICAgICAgICAgICAgLy8gZGF0YSBpcyBhIHJhdyBvYmplY3QsIHVucGFja1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IE1hcDxhbnk+KCk7XG4gICAgICAgICAgICBmb3IobGV0IGtleSBpbiBkYXRhKXtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuYWRkKGtleSwgZGF0YVtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnRpbWUgPSBEYXRlLm5vdygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGUgdHlwZSBvZiB0aGUgR2FtZUV2ZW50XG4gICAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBHYW1lRXZlbnQgaXMgdGhlIHNwZWNpZmllZCB0eXBlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNUeXBlKHR5cGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSB0eXBlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBHYW1lRXZlbnQgYXMgYSBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBHYW1lRXZlbnRcbiAgICAgKi9cbiAgICB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlICsgXCI6IEBcIiArIHRoaXMudGltZTtcbiAgICB9XG59IiwiLy8gQGlnbm9yZVBhZ2VcblxuZXhwb3J0IGVudW0gR2FtZUV2ZW50VHlwZSB7XG5cdC8qKlxuXHQgKiBNb3VzZSBEb3duIGV2ZW50LiBIYXMgZGF0YToge3Bvc2l0aW9uOiBWZWMyIC0gTW91c2UgUG9zaXRpb259XG5cdCAqL1xuXHRNT1VTRV9ET1dOID0gXCJtb3VzZV9kb3duXCIsXG5cdC8qKlxuXHQgKiBNb3VzZSBVcCBldmVudC4gSGFzIGRhdGE6IHtwb3NpdGlvbjogVmVjMiAtIE1vdXNlIFBvc2l0aW9ufVxuXHQgKi9cblx0TU9VU0VfVVAgPSBcIm1vdXNlX3VwXCIsXG5cdC8qKlxuXHQgKiBNb3VzZSBNb3ZlIGV2ZW50LiBIYXMgZGF0YToge3Bvc2l0aW9uOiBWZWMyIC0gTW91c2UgUG9zaXRpb259XG5cdCAqL1xuXHRNT1VTRV9NT1ZFID0gXCJtb3VzZV9tb3ZlXCIsXG5cblx0LyoqXG5cdCAqIEtleSBEb3duIGV2ZW50LiBIYXMgZGF0YToge2tleTogc3RyaW5nIC0gVGhlIGtleSB0aGF0IGlzIGRvd259XG5cdCAqL1xuXHRLRVlfRE9XTiA9IFwia2V5X2Rvd25cIixcblxuXHQvKipcblx0ICogS2V5IFVwIGV2ZW50LiBIYXMgZGF0YToge2tleTogc3RyaW5nIC0gVGhlIGtleSB0aGF0IGlzIHVwfVxuXHQgKi9cblx0S0VZX1VQID0gXCJrZXlfdXBcIixcblxuXHQvKipcblx0ICogQ2FudmFzIEJsdXIgZXZlbnQuIEhhcyBkYXRhOiB7fVxuXHQgKi9cblx0Q0FOVkFTX0JMVVIgPSBcImNhbnZhc19ibHVyXCIsXG5cblx0LyoqXG5cdCAqIE1vdXNlIHdoZWVsIHVwIGV2ZW50LiBIYXMgZGF0YToge31cblx0ICovXG5cdFdIRUVMX1VQID0gXCJ3aGVlbF91cFwiLFxuXG5cdC8qKlxuXHQgKiBNb3VzZSB3aGVlbCBkb3duIGV2ZW50LiBIYXMgZGF0YToge31cblx0ICovXG5cdFdIRUVMX0RPV04gPSBcIndoZWVsX2Rvd25cIixcblxuXHQvKipcblx0ICogU3RhcnQgUmVjb3JkaW5nIGV2ZW50LiBIYXMgZGF0YToge3JlY29yZGluZzogQWJzdHJhY3RSZWNvcmRpbmd9XG5cdCAqL1xuXHRTVEFSVF9SRUNPUkRJTkcgPSBcInN0YXJ0X3JlY29yZGluZ1wiLFxuXG5cdC8qKlxuXHQgKiBTdG9wIFJlY29yZGluZyBldmVudC4gSGFzIGRhdGE6IHt9XG5cdCAqL1xuXHRTVE9QX1JFQ09SRElORyA9IFwic3RvcF9yZWNvcmRpbmdcIixcblx0XG5cdC8qKlxuXHQgKiBQbGF5IFJlY29yZGluZyBldmVudC4gSGFzIGRhdGE6IHt9XG5cdCAqL1xuXHRQTEFZX1JFQ09SRElORyA9IFwicGxheV9yZWNvcmRpbmdcIixcblxuXHQvKipcblx0ICogUGxheSBTb3VuZCBldmVudC4gSGFzIGRhdGE6IHtrZXk6IHN0cmluZywgbG9vcDogYm9vbGVhbiwgaG9sZFJlZmVyZW5jZTogYm9vbGVhbiB9XG5cdCAqL1xuXHRQTEFZX1NPVU5EID0gXCJwbGF5X3NvdW5kXCIsXG5cblx0LyoqXG5cdCAqIFBsYXkgU291bmQgZXZlbnQuIEhhcyBkYXRhOiB7a2V5OiBzdHJpbmd9XG5cdCAqL1xuXHRTVE9QX1NPVU5EID0gXCJzdG9wX3NvdW5kXCIsXG5cblx0LyoqXG5cdCAqIFBsYXkgU291bmQgZXZlbnQuIEhhcyBkYXRhOiB7a2V5OiBzdHJpbmcsIGxvb3A6IGJvb2xlYW4sIGhvbGRSZWZlcmVuY2U6IGJvb2xlYW4sIGNoYW5uZWw6IEF1ZGlvQ2hhbm5lbFR5cGUgfVxuXHQgKi9cbiBcdFBMQVlfU0ZYID0gXCJwbGF5X3NmeFwiLFxuXG4gXHQvKipcblx0ICogUGxheSBTb3VuZCBldmVudC4gSGFzIGRhdGE6IHtrZXk6IHN0cmluZywgbG9vcDogYm9vbGVhbiwgaG9sZFJlZmVyZW5jZTogYm9vbGVhbiB9XG5cdCAqL1xuICBcdFBMQVlfTVVTSUMgPSBcInBsYXlfbXVzaWNcIixcblxuXHQvKipcblx0ICogTXV0ZSBhdWRpbyBjaGFubmVsIGV2ZW50LiBIYXMgZGF0YToge2NoYW5uZWw6IEF1ZGlvQ2hhbm5lbFR5cGV9XG5cdCAqL1xuXHRNVVRFX0NIQU5ORUwgPSBcIm11dGVfY2hhbm5lbFwiLFxuXG5cdC8qKlxuXHQgKiBVbm11dGUgYXVkaW8gY2hhbm5lbCBldmVudC4gSGFzIGRhdGE6IHtjaGFubmVsOiBBdWRpb0NoYW5uZWxUeXBlfVxuXHQgKi9cblx0VU5NVVRFX0NIQU5ORUwgPSBcInVubXV0ZV9jaGFubmVsXCIsXG5cblx0LyoqXG5cdCAqIEVuY29tcGFzc2VzIGFsbCBldmVudCB0eXBlcy4gVXNlZCBmb3IgcmVjZWl2ZXJzIG9ubHkuXG5cdCAqL1xuXHRBTEwgPSBcImFsbFwiLFxuXG5cdC8qKiBcblx0ICogRGlzYWJsZXMgcmV2ZWl2aW5nIGlucHV0IGZyb20gdGhlIHVzZXIgZm9yIHRoZSBzcGVjaWZpZWQgaW5wdXRzLiBIYXMgZGF0YToge2lucHV0czogSW5wdXRIYW5sZGVyc1tdfVxuXHQgKi9cblx0RElTQUJMRV9VU0VSX0lOUFVUID0gXCJkaXNhYmxlX3VzZXJfaW5wdXRcIixcblxuXHQvKiogXG5cdCAqIEVuYWJsZXMgcmVjZWl2aW5nIGlucHV0IGZyb20gdGhlIHVzZXIgZm9yIHRoZSBzcGVjaWZpZWQgaW5wdXRzLiBIYXMgZGF0YToge2lucHV0czogSW5wdXRIYW5kbGVyc1tdfVxuXHQgKi9cblx0RU5BQkxFX1VTRVJfSU5QVVQgPSBcImVuYWJsZV91c2VyX2lucHV0XCIsXG5cblx0LyoqXG5cdCAqIFRyaWdnZXJzIGEgc2NlbmUgY2hhbmdlLiBIYXMgZGF0YToge3NjZW5lOiBuZXcgKC4uLmFyZ3M6IGFueSkgPT4gVCBleHRlbmRzIFNjZW5lLCBpbml0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+fVxuXHQgKi9cblx0Q0hBTkdFX1NDRU5FID0gXCJjaGFuZ2Vfc2NlbmVcIlxufSIsImltcG9ydCBRdWV1ZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0NvbGxlY3Rpb25zL1F1ZXVlXCI7XG5pbXBvcnQgRXZlbnRRdWV1ZSBmcm9tIFwiLi9FdmVudFF1ZXVlXCI7XG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuL0dhbWVFdmVudFwiO1xuXG4vKipcbiAqIFJlY2VpdmVzIHN1YnNjcmliZWQgZXZlbnRzIGZyb20gdGhlIEV2ZW50UXVldWUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlY2VpdmVyIHtcblx0LyoqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBldmVudHMgdGhpcyBSZWNlaXZlciBjYW4gaG9sZCBhdCBvbmUgdGltZSAqL1xuXHRyZWFkb25seSBNQVhfU0laRTogbnVtYmVyO1xuXG5cdC8qKiBUaGUgaW5ib3ggb2YgdGhlIFJlY2VpdmVyICovXG5cdHByaXZhdGUgcTogUXVldWU8R2FtZUV2ZW50PjtcblxuXHQvKiogQ3JlYXRlcyBhIG5ldyBSZWNlaXZlciAqL1xuXHRjb25zdHJ1Y3Rvcigpe1xuXHRcdHRoaXMuTUFYX1NJWkUgPSAyMDA7XG4gICAgICAgIHRoaXMucSA9IG5ldyBRdWV1ZSh0aGlzLk1BWF9TSVpFKTtcblx0fVxuXG5cdGRlc3Ryb3koKXtcblx0XHRFdmVudFF1ZXVlLmdldEluc3RhbmNlKCkudW5zdWJzY3JpYmUodGhpcyk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBBZGRzIHRoZXNlIHR5cGVzIG9mIGV2ZW50cyB0byB0aGlzIHJlY2VpdmVyJ3MgcXVldWUgZXZlcnkgdXBkYXRlLlxuXHQgKiBAcGFyYW0gZXZlbnRUeXBlcyBUaGUgdHlwZXMgb2YgZXZlbnRzIHRoaXMgcmVjZWl2ZXIgd2lsbCBiZSBzdWJzY3JpYmVkIHRvXG5cdCAqL1xuXHRzdWJzY3JpYmUoZXZlbnRUeXBlczogc3RyaW5nIHwgQXJyYXk8c3RyaW5nPik6IHZvaWQge1xuXHRcdEV2ZW50UXVldWUuZ2V0SW5zdGFuY2UoKS5zdWJzY3JpYmUodGhpcywgZXZlbnRUeXBlcyk7XG5cdFx0dGhpcy5xLmNsZWFyKCk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhbiBldmVudCB0byB0aGUgcXVldWUgb2YgdGhpcyByZWNpZXZlci4gVGhpcyBpcyB1c2VkIGJ5IHRoZSBAcmVmZXJlbmNlW0V2ZW50UXVldWVdIHRvIGRpc3RyaWJ1dGUgZXZlbnRzXG5cdCAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgdG8gcmVjZWl2ZVxuXHQgKi9cblx0cmVjZWl2ZShldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XG5cdFx0dHJ5e1xuXHRcdHRoaXMucS5lbnF1ZXVlKGV2ZW50KTtcblx0XHR9IGNhdGNoKGUpe1xuXHRcdFx0Y29uc29sZS53YXJuKFwiUmVjZWl2ZXIgb3ZlcmZsb3cgZm9yIGV2ZW50IFwiICsgZXZlbnQudG9TdHJpbmcoKSk7XG5cdFx0XHR0aHJvdyBlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXRyaWV2ZXMgdGhlIG5leHQgZXZlbnQgZnJvbSB0aGUgcmVjZWl2ZXIncyBxdWV1ZVxuXHQgKiBAcmV0dXJucyBUaGUgbmV4dCBHYW1lRXZlbnRcblx0ICovXG5cdGdldE5leHRFdmVudCgpOiBHYW1lRXZlbnQge1xuXHRcdHJldHVybiB0aGlzLnEuZGVxdWV1ZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExvb2tzIGF0IHRoZSBuZXh0IGV2ZW50IGluIHRoZSByZWNlaXZlcidzIHF1ZXVlLCBidXQgZG9lc24ndCByZW1vdmUgaXQgZnJvbSB0aGUgcXVldWVcblx0ICogQHJldHVybnMgVGhlIG5leHQgR2FtZUV2ZW50XG5cdCAqL1xuXHRwZWVrTmV4dEV2ZW50KCk6IEdhbWVFdmVudCB7XG5cdFx0cmV0dXJuIHRoaXMucS5wZWVrTmV4dCgpXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSByZWNlaXZlciBoYXMgYW55IGV2ZW50cyBpbiBpdHMgcXVldWVcblx0ICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgcmVjZWl2ZXIgaGFzIGFub3RoZXIgZXZlbnQsIGZhbHNlIG90aGVyd2lzZVxuXHQgKi9cblx0aGFzTmV4dEV2ZW50KCk6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0aGlzLnEuaGFzSXRlbXMoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJZ25vcmUgYWxsIGV2ZW50cyB0aGlzIGZyYW1lXG5cdCAqL1xuXHRpZ25vcmVFdmVudHMoKTogdm9pZCB7XG5cdFx0dGhpcy5xLmNsZWFyKCk7XG5cdH1cbn0iLCJpbXBvcnQgUmVjZWl2ZXIgZnJvbSBcIi4uL0V2ZW50cy9SZWNlaXZlclwiO1xuaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL0NvbGxlY3Rpb25zL01hcFwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgRXZlbnRRdWV1ZSBmcm9tIFwiLi4vRXZlbnRzL0V2ZW50UXVldWVcIjtcbmltcG9ydCBWaWV3cG9ydCBmcm9tIFwiLi4vU2NlbmVHcmFwaC9WaWV3cG9ydFwiO1xuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vRXZlbnRzL0dhbWVFdmVudFwiO1xuaW1wb3J0IHsgR2FtZUV2ZW50VHlwZSB9IGZyb20gXCIuLi9FdmVudHMvR2FtZUV2ZW50VHlwZVwiO1xuXG4vKipcbiAqIFJlY2VpdmVzIGlucHV0IGV2ZW50cyBmcm9tIHRoZSBAcmVmZXJlbmNlW0V2ZW50UXVldWVdIGFuZCBhbGxvd3MgZm9yIGVhc3kgYWNjZXNzIG9mIGluZm9ybWF0aW9uIGFib3V0IGlucHV0IGJ5IG90aGVyIHN5c3RlbXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5wdXQge1xuXHRwcml2YXRlIHN0YXRpYyBtb3VzZVByZXNzZWQ6IGJvb2xlYW47XG5cdHByaXZhdGUgc3RhdGljIG1vdXNlSnVzdFByZXNzZWQ6IGJvb2xlYW47XG5cdHByaXZhdGUgc3RhdGljIG1vdXNlQnV0dG9uUHJlc3NlZDogbnVtYmVyO1xuXG5cdHByaXZhdGUgc3RhdGljIGtleUp1c3RQcmVzc2VkOiBNYXA8Ym9vbGVhbj47XG5cdHByaXZhdGUgc3RhdGljIGtleVByZXNzZWQ6IE1hcDxib29sZWFuPjtcblxuXHRwcml2YXRlIHN0YXRpYyBtb3VzZVBvc2l0aW9uOiBWZWMyO1xuXHRwcml2YXRlIHN0YXRpYyBtb3VzZVByZXNzUG9zaXRpb246IFZlYzI7XG5cblx0cHJpdmF0ZSBzdGF0aWMgc2Nyb2xsRGlyZWN0aW9uOiBudW1iZXI7XG5cdHByaXZhdGUgc3RhdGljIGp1c3RTY3JvbGxlZDogYm9vbGVhbjtcblxuXHRwcml2YXRlIHN0YXRpYyBldmVudFF1ZXVlOiBFdmVudFF1ZXVlO1xuXHRwcml2YXRlIHN0YXRpYyByZWNlaXZlcjogUmVjZWl2ZXI7XG5cdHByaXZhdGUgc3RhdGljIHZpZXdwb3J0OiBWaWV3cG9ydDtcblxuXHRwcml2YXRlIHN0YXRpYyBrZXlNYXA6IE1hcDxBcnJheTxzdHJpbmc+PjtcblxuXHRwcml2YXRlIHN0YXRpYyBrZXlzRGlzYWJsZWQ6IGJvb2xlYW47XG5cdHByaXZhdGUgc3RhdGljIG1vdXNlRGlzYWJsZWQ6IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemVzIHRoZSBJbnB1dCBvYmplY3Rcblx0ICogQHBhcmFtIHZpZXdwb3J0IEEgcmVmZXJlbmNlIHRvIHRoZSB2aWV3cG9ydCBvZiB0aGUgZ2FtZVxuXHQgKi9cblx0c3RhdGljIGluaXRpYWxpemUodmlld3BvcnQ6IFZpZXdwb3J0LCBrZXlNYXA6IEFycmF5PFJlY29yZDxzdHJpbmcsIGFueT4+KSB7XG5cdFx0SW5wdXQudmlld3BvcnQgPSB2aWV3cG9ydDtcblx0XHRJbnB1dC5tb3VzZVByZXNzZWQgPSBmYWxzZTtcblx0XHRJbnB1dC5tb3VzZUp1c3RQcmVzc2VkID0gZmFsc2U7XG5cdFx0SW5wdXQucmVjZWl2ZXIgPSBuZXcgUmVjZWl2ZXIoKTtcblx0XHRJbnB1dC5rZXlKdXN0UHJlc3NlZCA9IG5ldyBNYXA8Ym9vbGVhbj4oKTtcblx0XHRJbnB1dC5rZXlQcmVzc2VkID0gbmV3IE1hcDxib29sZWFuPigpO1xuXHRcdElucHV0Lm1vdXNlUG9zaXRpb24gPSBuZXcgVmVjMigwLCAwKTtcblx0XHRJbnB1dC5tb3VzZVByZXNzUG9zaXRpb24gPSBuZXcgVmVjMigwLCAwKTtcblx0XHRJbnB1dC5zY3JvbGxEaXJlY3Rpb24gPSAwO1xuXHRcdElucHV0Lmp1c3RTY3JvbGxlZCA9IGZhbHNlO1xuXHRcdElucHV0LmtleXNEaXNhYmxlZCA9IGZhbHNlO1xuXHRcdElucHV0Lm1vdXNlRGlzYWJsZWQgPSBmYWxzZTtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIGtleW1hcFxuXHRcdElucHV0LmtleU1hcCA9IG5ldyBNYXAoKTtcblxuXHRcdC8vIEFkZCBhbGwga2V5cyB0byB0aGUga2V5bWFwXG5cdFx0Zm9yIChsZXQgZW50cnkgaW4ga2V5TWFwKSB7XG5cdFx0XHRsZXQgbmFtZSA9IGtleU1hcFtlbnRyeV0ubmFtZTtcblx0XHRcdGxldCBrZXlzID0ga2V5TWFwW2VudHJ5XS5rZXlzO1xuXHRcdFx0SW5wdXQua2V5TWFwLmFkZChuYW1lLCBrZXlzKTtcblx0XHR9XG5cblx0XHRJbnB1dC5ldmVudFF1ZXVlID0gRXZlbnRRdWV1ZS5nZXRJbnN0YW5jZSgpO1xuXHRcdC8vIFN1YnNjcmliZSB0byBhbGwgaW5wdXQgZXZlbnRzXG5cdFx0SW5wdXQuZXZlbnRRdWV1ZS5zdWJzY3JpYmUoSW5wdXQucmVjZWl2ZXIsIFtHYW1lRXZlbnRUeXBlLk1PVVNFX0RPV04sIEdhbWVFdmVudFR5cGUuTU9VU0VfVVAsIEdhbWVFdmVudFR5cGUuTU9VU0VfTU9WRSxcblx0XHRHYW1lRXZlbnRUeXBlLktFWV9ET1dOLCBHYW1lRXZlbnRUeXBlLktFWV9VUCwgR2FtZUV2ZW50VHlwZS5DQU5WQVNfQkxVUiwgR2FtZUV2ZW50VHlwZS5XSEVFTF9VUCwgR2FtZUV2ZW50VHlwZS5XSEVFTF9ET1dOXSk7XG5cdH1cblxuXHRzdGF0aWMgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG5cdFx0Ly8gUmVzZXQgdGhlIGp1c3RQcmVzc2VkIHZhbHVlcyB0byBmYWxzZVxuXHRcdElucHV0Lm1vdXNlSnVzdFByZXNzZWQgPSBmYWxzZTtcblx0XHRJbnB1dC5rZXlKdXN0UHJlc3NlZC5mb3JFYWNoKChrZXk6IHN0cmluZykgPT4gSW5wdXQua2V5SnVzdFByZXNzZWQuc2V0KGtleSwgZmFsc2UpKTtcblx0XHRJbnB1dC5qdXN0U2Nyb2xsZWQgPSBmYWxzZTtcblx0XHRJbnB1dC5zY3JvbGxEaXJlY3Rpb24gPSAwO1xuXG5cdFx0d2hpbGUgKElucHV0LnJlY2VpdmVyLmhhc05leHRFdmVudCgpKSB7XG5cdFx0XHRsZXQgZXZlbnQgPSBJbnB1dC5yZWNlaXZlci5nZXROZXh0RXZlbnQoKTtcblxuXHRcdFx0Ly8gSGFuZGxlIGVhY2ggZXZlbnQgdHlwZVxuXHRcdFx0aWYgKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuTU9VU0VfRE9XTikge1xuXHRcdFx0XHRJbnB1dC5tb3VzZUp1c3RQcmVzc2VkID0gdHJ1ZTtcblx0XHRcdFx0SW5wdXQubW91c2VQcmVzc2VkID0gdHJ1ZTtcblx0XHRcdFx0SW5wdXQubW91c2VQcmVzc1Bvc2l0aW9uID0gZXZlbnQuZGF0YS5nZXQoXCJwb3NpdGlvblwiKTtcblx0XHRcdFx0SW5wdXQubW91c2VCdXR0b25QcmVzc2VkID0gZXZlbnQuZGF0YS5nZXQoXCJidXR0b25cIik7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLk1PVVNFX1VQKSB7XG5cdFx0XHRcdElucHV0Lm1vdXNlUHJlc3NlZCA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5NT1VTRV9NT1ZFKSB7XG5cdFx0XHRcdElucHV0Lm1vdXNlUG9zaXRpb24gPSBldmVudC5kYXRhLmdldChcInBvc2l0aW9uXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5LRVlfRE9XTikge1xuXHRcdFx0XHRsZXQga2V5ID0gZXZlbnQuZGF0YS5nZXQoXCJrZXlcIik7XG5cdFx0XHRcdC8vIEhhbmRsZSBzcGFjZSBiYXJcblx0XHRcdFx0aWYgKGtleSA9PT0gXCIgXCIpIHtcblx0XHRcdFx0XHRrZXkgPSBcInNwYWNlXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFJbnB1dC5rZXlQcmVzc2VkLmdldChrZXkpKSB7XG5cdFx0XHRcdFx0SW5wdXQua2V5SnVzdFByZXNzZWQuc2V0KGtleSwgdHJ1ZSk7XG5cdFx0XHRcdFx0SW5wdXQua2V5UHJlc3NlZC5zZXQoa2V5LCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5LRVlfVVApIHtcblx0XHRcdFx0bGV0IGtleSA9IGV2ZW50LmRhdGEuZ2V0KFwia2V5XCIpO1xuXHRcdFx0XHQvLyBIYW5kbGUgc3BhY2UgYmFyXG5cdFx0XHRcdGlmIChrZXkgPT09IFwiIFwiKSB7XG5cdFx0XHRcdFx0a2V5ID0gXCJzcGFjZVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdElucHV0LmtleVByZXNzZWQuc2V0KGtleSwgZmFsc2UpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5DQU5WQVNfQkxVUikge1xuXHRcdFx0XHRJbnB1dC5jbGVhcktleVByZXNzZXMoKVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5XSEVFTF9VUCkge1xuXHRcdFx0XHRJbnB1dC5zY3JvbGxEaXJlY3Rpb24gPSAtMTtcblx0XHRcdFx0SW5wdXQuanVzdFNjcm9sbGVkID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5XSEVFTF9ET1dOKSB7XG5cdFx0XHRcdElucHV0LnNjcm9sbERpcmVjdGlvbiA9IDE7XG5cdFx0XHRcdElucHV0Lmp1c3RTY3JvbGxlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBzdGF0aWMgY2xlYXJLZXlQcmVzc2VzKCk6IHZvaWQge1xuXHRcdElucHV0LmtleUp1c3RQcmVzc2VkLmZvckVhY2goKGtleTogc3RyaW5nKSA9PiBJbnB1dC5rZXlKdXN0UHJlc3NlZC5zZXQoa2V5LCBmYWxzZSkpO1xuXHRcdElucHV0LmtleVByZXNzZWQuZm9yRWFjaCgoa2V5OiBzdHJpbmcpID0+IElucHV0LmtleVByZXNzZWQuc2V0KGtleSwgZmFsc2UpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGEga2V5IHdhcyBuZXdseSBwcmVzc2VkIElucHV0IGZyYW1lLlxuXHQgKiBJZiB0aGUga2V5IGlzIHN0aWxsIHByZXNzZWQgZnJvbSBsYXN0IGZyYW1lIGFuZCB3YXNuJ3QgcmUtcHJlc3NlZCwgSW5wdXQgd2lsbCByZXR1cm4gZmFsc2UuXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleVxuXHQgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBrZXkgd2FzIGp1c3QgcHJlc3NlZCwgZmFsc2Ugb3RoZXJ3aXNlXG5cdCAqL1xuXHRzdGF0aWMgaXNLZXlKdXN0UHJlc3NlZChrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuXHRcdGlmIChJbnB1dC5rZXlzRGlzYWJsZWQpIHJldHVybiBmYWxzZTtcblxuXHRcdGlmIChJbnB1dC5rZXlKdXN0UHJlc3NlZC5oYXMoa2V5KSkge1xuXHRcdFx0cmV0dXJuIElucHV0LmtleUp1c3RQcmVzc2VkLmdldChrZXkpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgb2YgdGhlIGtleXMgdGhhdCBhcmUgbmV3bHkgcHJlc3NlZCBJbnB1dCBmcmFtZS5cblx0ICogSWYgYSBrZXkgaXMgc3RpbGwgcHJlc3NlZCBmcm9tIGxhc3QgZnJhbWUgYW5kIHdhc24ndCByZS1wcmVzc2VkLCBpdCB3aWxsIG5vdCBiZSBpbiBJbnB1dCBsaXN0LlxuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBhbGwgb2YgdGhlIG5ld2x5IHByZXNzZWQga2V5cy5cblx0ICovXG5cdHN0YXRpYyBnZXRLZXlzSnVzdFByZXNzZWQoKTogQXJyYXk8c3RyaW5nPiB7XG5cdFx0aWYgKElucHV0LmtleXNEaXNhYmxlZCkgcmV0dXJuIFtdO1xuXG5cdFx0bGV0IGtleXMgPSBBcnJheTxzdHJpbmc+KCk7XG5cdFx0SW5wdXQua2V5SnVzdFByZXNzZWQuZm9yRWFjaChrZXkgPT4ge1xuXHRcdFx0aWYgKElucHV0LmtleUp1c3RQcmVzc2VkLmdldChrZXkpKSB7XG5cdFx0XHRcdGtleXMucHVzaChrZXkpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiBrZXlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgd2hldGhlciBvciBub3QgYSBrZXkgaXMgYmVpbmcgcHJlc3NlZC5cblx0ICogQHBhcmFtIGtleSBUaGUga2V5XG5cdCAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGtleSBpcyBjdXJyZW50bHkgcHJlc3NlZCwgZmFsc2Ugb3RoZXJ3aXNlXG5cdCAqL1xuXHRzdGF0aWMgaXNLZXlQcmVzc2VkKGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG5cdFx0aWYgKElucHV0LmtleXNEaXNhYmxlZCkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0aWYgKElucHV0LmtleVByZXNzZWQuaGFzKGtleSkpIHtcblx0XHRcdHJldHVybiBJbnB1dC5rZXlQcmVzc2VkLmdldChrZXkpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2hhbmdlcyB0aGUgYmluZGluZyBvZiBhbiBpbnB1dCBuYW1lIHRvIGtleXNcblx0ICogQHBhcmFtIGlucHV0TmFtZSBUaGUgbmFtZSBvZiB0aGUgaW5wdXRcblx0ICogQHBhcmFtIGtleXMgVGhlIGNvcnJlc3BvbmRpbmcga2V5c1xuXHQgKi9cblx0c3RhdGljIGNoYW5nZUtleUJpbmRpbmcoaW5wdXROYW1lOiBzdHJpbmcsIGtleXM6IEFycmF5PHN0cmluZz4pOiB2b2lkIHtcblx0XHRJbnB1dC5rZXlNYXAuc2V0KGlucHV0TmFtZSwga2V5cyk7XG5cdH1cblxuXHQvKipcblx0ICogQ2xlYXJzIGFsbCBrZXkgYmluZGluZ3Ncblx0ICovXG5cdHN0YXRpYyBjbGVhckFsbEtleUJpbmRpbmdzKCk6IHZvaWQge1xuXHRcdElucHV0LmtleU1hcC5jbGVhcigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgd2hldGhlciBvciBub3QgYW4gaW5wdXQgd2FzIGp1c3QgcHJlc3NlZCB0aGlzIGZyYW1lXG5cdCAqIEBwYXJhbSBpbnB1dE5hbWUgVGhlIG5hbWUgb2YgdGhlIGlucHV0XG5cdCAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGlucHV0IHdhcyBqdXN0IHByZXNzZWQsIGZhbHNlIG90aGVyd2lzZVxuXHQgKi9cblx0c3RhdGljIGlzSnVzdFByZXNzZWQoaW5wdXROYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcblx0XHRpZiAoSW5wdXQua2V5c0Rpc2FibGVkKSByZXR1cm4gZmFsc2U7XG5cblx0XHRpZiAoSW5wdXQua2V5TWFwLmhhcyhpbnB1dE5hbWUpKSB7XG5cdFx0XHRjb25zdCBrZXlzID0gSW5wdXQua2V5TWFwLmdldChpbnB1dE5hbWUpO1xuXHRcdFx0bGV0IGp1c3RQcmVzc2VkID0gZmFsc2U7XG5cblx0XHRcdGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG5cdFx0XHRcdGp1c3RQcmVzc2VkID0ganVzdFByZXNzZWQgfHwgSW5wdXQuaXNLZXlKdXN0UHJlc3NlZChrZXkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ganVzdFByZXNzZWQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhbiBpbnB1dCBpcyBjdXJyZW50bHkgcHJlc3NlZFxuXHQgKiBAcGFyYW0gaW5wdXROYW1lIFRoZSBuYW1lIG9mIHRoZSBpbnB1dFxuXHQgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBpbnB1dCBpcyBwcmVzc2VkLCBmYWxzZSBvdGhlcndpc2Vcblx0ICovXG5cdHN0YXRpYyBpc1ByZXNzZWQoaW5wdXROYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcblx0XHRpZiAoSW5wdXQua2V5c0Rpc2FibGVkKSByZXR1cm4gZmFsc2U7XG5cblx0XHRpZiAoSW5wdXQua2V5TWFwLmhhcyhpbnB1dE5hbWUpKSB7XG5cdFx0XHRjb25zdCBrZXlzID0gSW5wdXQua2V5TWFwLmdldChpbnB1dE5hbWUpO1xuXHRcdFx0bGV0IHByZXNzZWQgPSBmYWxzZTtcblxuXHRcdFx0Zm9yIChsZXQga2V5IG9mIGtleXMpIHtcblx0XHRcdFx0cHJlc3NlZCA9IHByZXNzZWQgfHwgSW5wdXQuaXNLZXlQcmVzc2VkKGtleSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwcmVzc2VkO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQgKiBcblx0ICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbW91c2Ugd2FzIG5ld2x5IHByZXNzZWQgSW5wdXQgZnJhbWUuXG5cdCAqIEBwYXJhbSBtb3VzZUJ1dHRvbiBPcHRpb25hbGx5IHNwZWNpZnkgd2hpY2ggbW91c2UgY2xpY2sgeW91IHdhbnQgdG8ga25vdyB3YXMgcHJlc3NlZC4gXG5cdCAqIDAgZm9yIGxlZnQgY2xpY2ssIDEgZm9yIG1pZGRsZSBjbGljaywgMiBmb3IgcmlnaHQgY2xpY2suXG5cdCAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG1vdXNlIHdhcyBqdXN0IHByZXNzZWQsIGZhbHNlIG90aGVyd2lzZVxuXHQgKi9cblx0c3RhdGljIGlzTW91c2VKdXN0UHJlc3NlZChtb3VzZUJ1dHRvbj86IG51bWJlcik6IGJvb2xlYW4ge1xuXHRcdGlmIChtb3VzZUJ1dHRvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gSW5wdXQubW91c2VKdXN0UHJlc3NlZCAmJiAhSW5wdXQubW91c2VEaXNhYmxlZCAmJiBtb3VzZUJ1dHRvbiA9PSB0aGlzLm1vdXNlQnV0dG9uUHJlc3NlZDtcblx0XHR9XG5cdFx0cmV0dXJuIElucHV0Lm1vdXNlSnVzdFByZXNzZWQgJiYgIUlucHV0Lm1vdXNlRGlzYWJsZWQ7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbW91c2UgaXMgY3VycmVudGx5IHByZXNzZWRcblx0ICogQHBhcmFtIG1vdXNlQnV0dG9uIE9wdGlvbmFsbHkgc3BlY2lmeSB3aGljaCBtb3VzZSBjbGljayB5b3Ugd2FudCB0byBrbm93IHdhcyBwcmVzc2VkLiBcblx0ICogMCBmb3IgbGVmdCBjbGljaywgMSBmb3IgbWlkZGxlIGNsaWNrLCAyIGZvciByaWdodCBjbGljay5cblx0ICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgbW91c2UgaXMgY3VycmVudGx5IHByZXNzZWQsIGZhbHNlIG90aGVyd2lzZVxuXHQgKi9cblx0c3RhdGljIGlzTW91c2VQcmVzc2VkKG1vdXNlQnV0dG9uPzogbnVtYmVyKTogYm9vbGVhbiB7XG5cdFx0aWYgKG1vdXNlQnV0dG9uICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBJbnB1dC5tb3VzZVByZXNzZWQgJiYgIUlucHV0Lm1vdXNlRGlzYWJsZWQgJiYgbW91c2VCdXR0b24gPT0gdGhpcy5tb3VzZUJ1dHRvblByZXNzZWQ7XG5cdFx0fVxuXHRcdHJldHVybiBJbnB1dC5tb3VzZVByZXNzZWQgJiYgIUlucHV0Lm1vdXNlRGlzYWJsZWQ7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB3aGV0aGVyIHRoZSB1c2VyIHNjcm9sbGVkIG9yIG5vdFxuXHQgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB1c2VyIGp1c3Qgc2Nyb2xsZWQgSW5wdXQgZnJhbWUsIGZhbHNlIG90aGVyd2lzZVxuXHQgKi9cblx0c3RhdGljIGRpZEp1c3RTY3JvbGwoKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIElucHV0Lmp1c3RTY3JvbGxlZCAmJiAhSW5wdXQubW91c2VEaXNhYmxlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHNjcm9sbFxuXHQgKiBAcmV0dXJucyAtMSBpZiB0aGUgdXNlciBzY3JvbGxlZCB1cCwgMSBpZiB0aGV5IHNjcm9sbGVkIGRvd25cblx0ICovXG5cdHN0YXRpYyBnZXRTY3JvbGxEaXJlY3Rpb24oKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gSW5wdXQuc2Nyb2xsRGlyZWN0aW9uO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwbGF5ZXIncyBtb3VzZVxuXHQgKiBAcmV0dXJucyBUaGUgbW91c2UgcG9zaXRpb24gc3RvcmVkIGFzIGEgVmVjMlxuXHQgKi9cblx0c3RhdGljIGdldE1vdXNlUG9zaXRpb24oKTogVmVjMiB7XG5cdFx0cmV0dXJuIElucHV0Lm1vdXNlUG9zaXRpb24uc2NhbGVkKDEgLyB0aGlzLnZpZXdwb3J0LmdldFpvb21MZXZlbCgpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgcGxheWVyJ3MgbW91c2UgaW4gdGhlIGdhbWUgd29ybGQsXG5cdCAqIHRha2luZyBpbnRvIGNvbnNpZGVyYXRpb24gdGhlIHNjcm9sbGluZyBvZiB0aGUgdmlld3BvcnRcblx0ICogQHJldHVybnMgVGhlIG1vdXNlIHBvc2l0aW9uIHN0b3JlZCBhcyBhIFZlYzJcblx0ICovXG5cdHN0YXRpYyBnZXRHbG9iYWxNb3VzZVBvc2l0aW9uKCk6IFZlYzIge1xuXHRcdHJldHVybiBJbnB1dC5tb3VzZVBvc2l0aW9uLmNsb25lKCkuc2NhbGUoMSAvIHRoaXMudmlld3BvcnQuZ2V0Wm9vbUxldmVsKCkpLmFkZChJbnB1dC52aWV3cG9ydC5nZXRPcmlnaW4oKSk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIGxhc3QgbW91c2UgcHJlc3Ncblx0ICogQHJldHVybnMgVGhlIG1vdXNlIHBvc2l0aW9uIHN0b3JlZCBhcyBhIFZlYzJcblx0ICovXG5cdHN0YXRpYyBnZXRNb3VzZVByZXNzUG9zaXRpb24oKTogVmVjMiB7XG5cdFx0cmV0dXJuIElucHV0LmdldE1vdXNlUG9zaXRpb24oKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgbGFzdCBtb3VzZSBwcmVzcyBpbiB0aGUgZ2FtZSB3b3JsZCxcblx0ICogdGFraW5nIGludG8gY29uc2lkZXJhdGlvbiB0aGUgc2Nyb2xsaW5nIG9mIHRoZSB2aWV3cG9ydFxuXHQgKiBAcmV0dXJucyBUaGUgbW91c2UgcG9zaXRpb24gc3RvcmVkIGFzIGEgVmVjMlxuXHQgKi9cblx0c3RhdGljIGdldEdsb2JhbE1vdXNlUHJlc3NQb3NpdGlvbigpOiBWZWMyIHtcblx0XHRyZXR1cm4gSW5wdXQubW91c2VQcmVzc1Bvc2l0aW9uLmNsb25lKCkuYWRkKElucHV0LnZpZXdwb3J0LmdldE9yaWdpbigpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNhYmxlcyBhbGwga2V5cHJlc3MgYW5kIG1vdXNlIGNsaWNrIGlucHV0c1xuXHQgKi9cblx0c3RhdGljIGRpc2FibGVJbnB1dCgpOiB2b2lkIHtcblx0XHRJbnB1dC5rZXlzRGlzYWJsZWQgPSB0cnVlO1xuXHRcdElucHV0Lm1vdXNlRGlzYWJsZWQgPSB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuYWJsZXMgYWxsIGtleXByZXNzIGFuZCBtb3VzZSBjbGljayBpbnB1dHNcblx0ICovXG5cdHN0YXRpYyBlbmFibGVJbnB1dCgpOiB2b2lkIHtcblx0XHRJbnB1dC5rZXlzRGlzYWJsZWQgPSBmYWxzZTtcblx0XHRJbnB1dC5tb3VzZURpc2FibGVkID0gZmFsc2U7XG5cdH1cbn0iLCJpbXBvcnQgRXZlbnRRdWV1ZSBmcm9tIFwiLi4vRXZlbnRzL0V2ZW50UXVldWVcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vRXZlbnRzL0dhbWVFdmVudFwiO1xuaW1wb3J0IHsgR2FtZUV2ZW50VHlwZSB9IGZyb20gXCIuLi9FdmVudHMvR2FtZUV2ZW50VHlwZVwiO1xuaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcbmltcG9ydCBSZWNlaXZlciBmcm9tIFwiLi4vRXZlbnRzL1JlY2VpdmVyXCI7XG5cbmV4cG9ydCBlbnVtIElucHV0SGFuZGxlcnMge1xuICAgIE1PVVNFX0RPV04gPSAwLFxuICAgIE1PVVNFX1VQID0gMSxcbiAgICBDT05URVhUX01FTlUgPSAyLFxuICAgIE1PVVNFX01PVkUgPSAzLFxuICAgIEtFWV9ET1dOID0gNCxcbiAgICBLRVlfVVAgPSA1LCBcbiAgICBPTl9CTFVSID0gNixcbiAgICBPTl9XSEVFTCA9IDdcbn1cblxuLyoqXG4gKiBIYW5kbGVzIGNvbW11bmljYXRpb24gd2l0aCB0aGUgd2ViIGJyb3dzZXIgdG8gcmVjZWl2ZSBhc3luY2hyb25vdXMgZXZlbnRzIGFuZCBzZW5kIHRoZW0gdG8gdGhlIEByZWZlcmVuY2VbRXZlbnRRdWV1ZV1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5wdXRIYW5kbGVyIGltcGxlbWVudHMgVXBkYXRlYWJsZSB7XG5cdHByaXZhdGUgZXZlbnRRdWV1ZTogRXZlbnRRdWV1ZTtcbiAgICBwcml2YXRlIGVuYWJsZWQ6IGJvb2xlYW5bXTtcbiAgICBwcml2YXRlIHJlY2VpdmVyOiBSZWNlaXZlcjtcbiAgICAgXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBJbnB1dEhhbmRsZXJcbiAgICAgKiBAcGFyYW0gY2FudmFzIFRoZSBnYW1lIGNhbnZhc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpe1xuXHRcdHRoaXMuZXZlbnRRdWV1ZSA9IEV2ZW50UXVldWUuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgdGhpcy5lbmFibGVkID0gbmV3IEFycmF5PGJvb2xlYW4+KC4uLlt0cnVlLCB0cnVlLCB0cnVlLCB0cnVlLCB0cnVlLCB0cnVlLCB0cnVlLCB0cnVlXSk7XG5cdFx0XG4gICAgICAgIGNhbnZhcy5vbm1vdXNlZG93biA9IChldmVudCkgPT4gdGhpcy5oYW5kbGVNb3VzZURvd24oZXZlbnQsIGNhbnZhcyk7XG4gICAgICAgIGNhbnZhcy5vbm1vdXNldXAgPSAoZXZlbnQpID0+IHRoaXMuaGFuZGxlTW91c2VVcChldmVudCwgY2FudmFzKTtcbiAgICAgICAgY2FudmFzLm9uY29udGV4dG1lbnUgPSB0aGlzLmhhbmRsZUNvbnRleHRNZW51O1xuICAgICAgICBjYW52YXMub25tb3VzZW1vdmUgPSAoZXZlbnQpID0+IHRoaXMuaGFuZGxlTW91c2VNb3ZlKGV2ZW50LCBjYW52YXMpO1xuICAgICAgICBkb2N1bWVudC5vbmtleWRvd24gPSB0aGlzLmhhbmRsZUtleURvd247XG4gICAgICAgIGRvY3VtZW50Lm9ua2V5dXAgPSB0aGlzLmhhbmRsZUtleVVwO1xuICAgICAgICBkb2N1bWVudC5vbmJsdXIgPSB0aGlzLmhhbmRsZUJsdXI7XG4gICAgICAgIGRvY3VtZW50Lm9uY29udGV4dG1lbnUgPSB0aGlzLmhhbmRsZUJsdXI7XG4gICAgICAgIGRvY3VtZW50Lm9ud2hlZWwgPSB0aGlzLmhhbmRsZVdoZWVsO1xuXG4gICAgICAgIHRoaXMucmVjZWl2ZXIgPSBuZXcgUmVjZWl2ZXIoKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoR2FtZUV2ZW50VHlwZS5ESVNBQkxFX1VTRVJfSU5QVVQpO1xuICAgICAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZShHYW1lRXZlbnRUeXBlLkVOQUJMRV9VU0VSX0lOUFVUKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHdoaWxlKHRoaXMucmVjZWl2ZXIuaGFzTmV4dEV2ZW50KCkpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXZlbnQodGhpcy5yZWNlaXZlci5nZXROZXh0RXZlbnQoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvdGVjdGVkIGhhbmRsZUV2ZW50KGV2ZW50OiBHYW1lRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgc3dpdGNoKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgR2FtZUV2ZW50VHlwZS5ESVNBQkxFX1VTRVJfSU5QVVQ6IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2FibGVIYW5kbGVycyhldmVudC5kYXRhLmdldChcImlucHV0c1wiKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEdhbWVFdmVudFR5cGUuRU5BQkxFX1VTRVJfSU5QVVQ6IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZUhhbmRsZXJzKGV2ZW50LmRhdGEuZ2V0KFwiaW5wdXRzXCIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaGFuZGxlZCBldmVudCB3aXRoIHR5cGU6ICR7ZXZlbnQudHlwZX0gY2F1Z2h0IGluIElucHV0SGFuZGxlci50c2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGVuYWJsZUhhbmRsZXJzKGhhbmRsZXJzOiBJbnB1dEhhbmRsZXJzW10pOiB2b2lkIHtcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChoYW5kbGVyID0+IHRoaXMuZW5hYmxlZFtoYW5kbGVyXSA9IHRydWUpO1xuICAgIH1cbiAgICBwdWJsaWMgZGlzYWJsZUhhbmRsZXJzKGhhbmRsZXJzOiBJbnB1dEhhbmRsZXJzW10pOiB2b2lkIHtcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChoYW5kbGVyID0+IHRoaXMuZW5hYmxlZFtoYW5kbGVyXSA9IGZhbHNlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhhbmRsZU1vdXNlRG93biA9IChldmVudDogTW91c2VFdmVudCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCk6IHZvaWQgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZFtJbnB1dEhhbmRsZXJzLk1PVVNFX0RPV05dKSByZXR1cm47XG5cdFx0bGV0IHBvcyA9IHRoaXMuZ2V0TW91c2VQb3NpdGlvbihldmVudCwgY2FudmFzKTtcbiAgICAgICAgbGV0IGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcbiAgICAgICAgbGV0IGdhbWVFdmVudCA9IG5ldyBHYW1lRXZlbnQoR2FtZUV2ZW50VHlwZS5NT1VTRV9ET1dOLCB7cG9zaXRpb246IHBvcywgYnV0dG9uOiBidXR0b259KTtcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlLmFkZEV2ZW50KGdhbWVFdmVudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVNb3VzZVVwID0gKGV2ZW50OiBNb3VzZUV2ZW50LCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogdm9pZCA9PiB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkW0lucHV0SGFuZGxlcnMuTU9VU0VfRE9XTl0pIHJldHVybjtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMuZ2V0TW91c2VQb3NpdGlvbihldmVudCwgY2FudmFzKTtcbiAgICAgICAgbGV0IGdhbWVFdmVudCA9IG5ldyBHYW1lRXZlbnQoR2FtZUV2ZW50VHlwZS5NT1VTRV9VUCwge3Bvc2l0aW9uOiBwb3N9KTtcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlLmFkZEV2ZW50KGdhbWVFdmVudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVNb3VzZU1vdmUgPSAoZXZlbnQ6IE1vdXNlRXZlbnQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWRbSW5wdXRIYW5kbGVycy5NT1VTRV9NT1ZFXSkgcmV0dXJuO1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5nZXRNb3VzZVBvc2l0aW9uKGV2ZW50LCBjYW52YXMpO1xuICAgICAgICBsZXQgZ2FtZUV2ZW50ID0gbmV3IEdhbWVFdmVudChHYW1lRXZlbnRUeXBlLk1PVVNFX01PVkUsIHtwb3NpdGlvbjogcG9zfSk7XG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZS5hZGRFdmVudChnYW1lRXZlbnQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGFuZGxlS2V5RG93biA9IChldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZFtJbnB1dEhhbmRsZXJzLktFWV9ET1dOXSkgcmV0dXJuO1xuICAgICAgICBsZXQga2V5ID0gdGhpcy5nZXRLZXkoZXZlbnQpO1xuICAgICAgICBsZXQgZ2FtZUV2ZW50ID0gbmV3IEdhbWVFdmVudChHYW1lRXZlbnRUeXBlLktFWV9ET1dOLCB7a2V5OiBrZXl9KTtcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlLmFkZEV2ZW50KGdhbWVFdmVudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVLZXlVcCA9IChldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZFtJbnB1dEhhbmRsZXJzLktFWV9VUF0pIHJldHVybjtcbiAgICAgICAgbGV0IGtleSA9IHRoaXMuZ2V0S2V5KGV2ZW50KTtcbiAgICAgICAgbGV0IGdhbWVFdmVudCA9IG5ldyBHYW1lRXZlbnQoR2FtZUV2ZW50VHlwZS5LRVlfVVAsIHtrZXk6IGtleX0pO1xuICAgICAgICB0aGlzLmV2ZW50UXVldWUuYWRkRXZlbnQoZ2FtZUV2ZW50KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhhbmRsZUJsdXIgPSAoZXZlbnQ6IEV2ZW50KTogdm9pZCA9PiB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkW0lucHV0SGFuZGxlcnMuT05fQkxVUl0pIHJldHVybjtcbiAgICAgICAgbGV0IGdhbWVFdmVudCA9IG5ldyBHYW1lRXZlbnQoR2FtZUV2ZW50VHlwZS5DQU5WQVNfQkxVUiwge30pO1xuICAgICAgICB0aGlzLmV2ZW50UXVldWUuYWRkRXZlbnQoZ2FtZUV2ZW50KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhhbmRsZUNvbnRleHRNZW51ID0gKGV2ZW50OiBFdmVudCk6IHZvaWQgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhhbmRsZVdoZWVsID0gKGV2ZW50OiBXaGVlbEV2ZW50KTogdm9pZCA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkW0lucHV0SGFuZGxlcnMuT05fV0hFRUxdKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICBsZXQgZ2FtZUV2ZW50OiBHYW1lRXZlbnQ7XG4gICAgICAgIGlmKGV2ZW50LmRlbHRhWSA8IDApe1xuICAgICAgICAgICAgZ2FtZUV2ZW50ID0gbmV3IEdhbWVFdmVudChHYW1lRXZlbnRUeXBlLldIRUVMX1VQLCB7fSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnYW1lRXZlbnQgPSBuZXcgR2FtZUV2ZW50KEdhbWVFdmVudFR5cGUuV0hFRUxfRE9XTiwge30pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlLmFkZEV2ZW50KGdhbWVFdmVudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRLZXkoa2V5RXZlbnQ6IEtleWJvYXJkRXZlbnQpe1xuICAgICAgICByZXR1cm4ga2V5RXZlbnQua2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRNb3VzZVBvc2l0aW9uKG1vdXNlRXZlbnQ6IE1vdXNlRXZlbnQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpOiBWZWMyIHtcbiAgICAgICAgbGV0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCB4ID0gbW91c2VFdmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgICAgICBsZXQgeSA9IG1vdXNlRXZlbnQuY2xpZW50WSAtIHJlY3QudG9wO1xuICAgICAgICByZXR1cm4gbmV3IFZlYzIoeCwgeSk7XG4gICAgfVxufSIsImltcG9ydCB7fSBmcm9tIFwiLi4vLi4vaW5kZXhcIjsgIC8vIFRoaXMgaW1wb3J0IGFsbG93cyB1cyB0byBtb2RpZnkgdGhlIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB0byBhZGQgZXh0cmEgZnVuY3Rpb25hbGl0eVxuLy8gQGlnbm9yZVBhZ2VcblxuLyoqXG4gKiBTZXRzIHVwIHRoZSBlbnZpcm9ubWVudCBvZiB0aGUgZ2FtZSBlbmdpbmVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW52aXJvbm1lbnRJbml0aWFsaXplciB7XG4gICAgc3RhdGljIHNldHVwKCl7XG4gICAgICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUucm91bmRlZFJlY3QgPSBmdW5jdGlvbih4OiBudW1iZXIsIHk6IG51bWJlciwgdzogbnVtYmVyLCBoOiBudW1iZXIsIHI6IG51bWJlcik6IHZvaWQge1xuICAgICAgICAgICAgLy8gQ2xhbXAgdGhlIHJhZGl1cyBiZXR3ZWVuIDAgYW5kIHRoZSBtaW4gb2YgdGhlIHdpZHRoIG9yIGhlaWdodFxuICAgICAgICAgICAgaWYociA8IDApIHIgPSAwO1xuICAgICAgICAgICAgaWYociA+IE1hdGgubWluKHcsIGgpKSByID0gTWF0aC5taW4odywgaCk7XG4gICAgICAgIFxuICAgICAgICAgICAgLy8gRHJhdyB0aGUgcm91bmRlZCByZWN0XG4gICAgICAgICAgICB0aGlzLmJlZ2luUGF0aCgpO1xuICAgICAgICBcbiAgICAgICAgICAgIC8vIFRvcFxuICAgICAgICAgICAgdGhpcy5tb3ZlVG8oeCArIHIsIHkpO1xuICAgICAgICAgICAgdGhpcy5saW5lVG8oeCArIHcgLSByLCB5KTtcbiAgICAgICAgICAgIHRoaXMuYXJjVG8oeCArIHcsIHksIHggKyB3LCB5ICsgciwgcik7XG4gICAgICAgIFxuICAgICAgICAgICAgLy8gUmlnaHRcbiAgICAgICAgICAgIHRoaXMubGluZVRvKHggKyB3LCB5ICsgaCAtIHIpO1xuICAgICAgICAgICAgdGhpcy5hcmNUbyh4ICsgdywgeSArIGgsIHggKyB3IC0gciwgeSArIGgsIHIpO1xuICAgICAgICBcbiAgICAgICAgICAgIC8vIEJvdHRvbVxuICAgICAgICAgICAgdGhpcy5saW5lVG8oeCArIHIsIHkgKyBoKTtcbiAgICAgICAgICAgIHRoaXMuYXJjVG8oeCwgeSArIGgsIHgsIHkgKyBoIC0gciwgcik7XG4gICAgICAgIFxuICAgICAgICAgICAgLy8gTGVmdFxuICAgICAgICAgICAgdGhpcy5saW5lVG8oeCwgeSArIHIpO1xuICAgICAgICAgICAgdGhpcy5hcmNUbyh4LCB5LCB4ICsgciwgeSwgcilcbiAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLnN0cm9rZVJvdW5kZWRSZWN0ID0gZnVuY3Rpb24oeCwgeSwgdywgaCwgcil7XG4gICAgICAgICAgICB0aGlzLnJvdW5kZWRSZWN0KHgsIHksIHcsIGgsIHIpO1xuICAgICAgICAgICAgdGhpcy5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5maWxsUm91bmRlZFJlY3QgPSBmdW5jdGlvbih4LCB5LCB3LCBoLCByKXtcbiAgICAgICAgICAgIHRoaXMucm91bmRlZFJlY3QoeCwgeSwgdywgaCwgcik7XG4gICAgICAgICAgICB0aGlzLmZpbGwoKTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgR2FtZUxvb3AgZnJvbSBcIi4vR2FtZUxvb3BcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vRGVidWcvRGVidWdcIjtcbmltcG9ydCBTdGF0cyBmcm9tIFwiLi4vRGVidWcvU3RhdHNcIjtcblxuLyoqXG4gKiBBIGdhbWUgbG9vcCB3aXRoIGEgZml4ZWQgdXBkYXRlIHRpbWUgYW5kIGEgdmFyaWFibGUgcmVuZGVyIHRpbWUuXG4gKiBFdmVyeSBmcmFtZSwgdGhlIGdhbWUgdXBkYXRlcyB1bnRpbCBhbGwgdGltZSBzaW5jZSB0aGUgbGFzdCBmcmFtZSBoYXMgYmVlbiBwcm9jZXNzZWQuXG4gKiBJZiB0b28gbXVjaCB0aW1lIGhhcyBwYXNzZWQsIHN1Y2ggYXMgaWYgdGhlIGxhc3QgdXBkYXRlIHdhcyB0b28gc2xvdywgXG4gKiBvciBpZiB0aGUgYnJvd3NlciB3YXMgcHV0IGludG8gdGhlIGJhY2tncm91bmQsIHRoZSBsb29wIHdpbGwgcGFuaWMgYW5kIGRpc2NhcmQgdGltZS5cbiAqIEEgcmVuZGVyIGhhcHBlbnMgYXQgdGhlIGVuZCBvZiBldmVyeSBmcmFtZS4gVGhpcyBoYXBwZW5zIGFzIGZhc3QgYXMgcG9zc2libGUgdW5sZXNzIHNwZWNpZmllZC5cbiAqIEEgbG9vcCBvZiB0aGlzIHR5cGUgYWxsb3dzIGZvciBkZXRlcm1pbmlzdGljIGJlaGF2aW9yIC0gTm8gbWF0dGVyIHdoYXQgdGhlIGZyYW1lIHJhdGUgaXMsIHRoZSB1cGRhdGUgc2hvdWxkIGJlaGF2ZSB0aGUgc2FtZSwgXG4gKiBhcyBpdCBpcyBvY2N1cmluZyBpbiBhIGZpeGVkIGludGVydmFsLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaXhlZFVwZGF0ZUdhbWVMb29wIGV4dGVuZHMgR2FtZUxvb3Age1xuXG5cdC8qKiBUaGUgbWF4IGFsbG93ZWQgdXBkYXRlIGZwcy4qL1xuICAgIHByaXZhdGUgbWF4VXBkYXRlRlBTOiBudW1iZXI7XG4gICAgXG4gICAgLyoqIFRoZSB0aW1lc3RlcCBmb3IgZWFjaCB1cGRhdGUuIFRoaXMgaXMgdGhlIGRlbHRhVCBwYXNzZWQgdG8gdXBkYXRlIGNhbGxzLiAqL1xuXHRwcml2YXRlIHVwZGF0ZVRpbWVzdGVwOiBudW1iZXI7XG5cbiAgICAvKiogVGhlIGFtb3VudCBvZiB0aW1lIHdlIGFyZSB5ZXQgdG8gc2ltdWxhdGUuICovXG4gICAgcHJpdmF0ZSBmcmFtZURlbHRhOiBudW1iZXI7XG5cbiAgICAvKiogVGhlIHRpbWUgd2hlbiB0aGUgbGFzdCBmcmFtZSB3YXMgZHJhd24uICovXG4gICAgcHJpdmF0ZSBsYXN0RnJhbWVUaW1lOiBudW1iZXI7XG4gICAgXG4gICAgLyoqIFRoZSBtaW5pbXVtIHRpbWUgd2Ugd2FudCB0byB3YWl0IGJldHdlZW4gZ2FtZSBmcmFtZXMuICovXG4gICAgcHJpdmF0ZSBtaW5GcmFtZURlbGF5OiBudW1iZXI7XG5cblx0LyoqIFRoZSBjdXJyZW50IGZyYW1lIG9mIHRoZSBnYW1lLiAqL1xuXHRwcml2YXRlIGZyYW1lOiBudW1iZXI7XG5cblx0LyoqIFRoZSBhY3R1YWwgZnBzIG9mIHRoZSBnYW1lLiAqL1xuICAgIHByaXZhdGUgZnBzOiBudW1iZXI7XG4gICAgXG4gICAgLyoqIFRoZSB0aW1lIGJldHdlZW4gZnBzIG1lYXN1cmVtZW50IHVwZGF0ZXMuICovXG4gICAgcHJpdmF0ZSBmcHNVcGRhdGVJbnRlcnZhbDogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSB0aW1lIG9mIHRoZSBsYXN0IGZwcyB1cGRhdGUuICovXG4gICAgcHJpdmF0ZSBsYXN0RnBzVXBkYXRlOiBudW1iZXI7XG5cbiAgICAvKiogVGhlIG51bWJlciBvZiBmcmFtZXMgc2luY2UgdGhlIGxhc3QgZnBzIHVwZGF0ZSB3YXMgZG9uZS4gKi9cbiAgICBwcml2YXRlIGZyYW1lc1NpbmNlTGFzdEZwc1VwZGF0ZTogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSBzdGF0dXMgb2Ygd2hldGhlciBvciBub3QgdGhlIGdhbWUgbG9vcCBoYXMgc3RhcnRlZC4gKi9cbiAgICBwcml2YXRlIHN0YXJ0ZWQ6IGJvb2xlYW47XG5cbiAgICAvKiogVGhlIHN0YXR1cyBvZiB3aGV0aGVyIG9yIG5vdCB0aGUgZ2FtZSBsb29wIGlzIHBhdXNlZCAqL1xuICAgIHByaXZhdGUgcGF1c2VkOiBib29sZWFuO1xuICAgIFxuICAgIC8qKiBUaGUgc3RhdHVzIG9mIHdoZXRoZXIgb3Igbm90IHRoZSBnYW1lIGxvb3AgaXMgY3VycmVudGx5IHJ1bm5pbmcuICovXG4gICAgcHJpdmF0ZSBydW5uaW5nOiBib29sZWFuO1xuXG4gICAgLyoqIFRoZSBudW1iZXIgb2YgdXBkYXRlIHN0ZXBzIHRoaXMgaXRlcmF0aW9uIG9mIHRoZSBnYW1lIGxvb3AuICovXG4gICAgcHJpdmF0ZSBudW1VcGRhdGVTdGVwczogbnVtYmVyO1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWF4VXBkYXRlRlBTID0gNjA7XG4gICAgICAgIHRoaXMudXBkYXRlVGltZXN0ZXAgPSBNYXRoLmZsb29yKDEwMDAvdGhpcy5tYXhVcGRhdGVGUFMpO1xuICAgICAgICB0aGlzLmZyYW1lRGVsdGEgPSAwO1xuICAgICAgICB0aGlzLmxhc3RGcmFtZVRpbWUgPSAwO1xuICAgICAgICB0aGlzLm1pbkZyYW1lRGVsYXkgPSAwO1xuICAgICAgICB0aGlzLmZyYW1lID0gMDtcbiAgICAgICAgdGhpcy5mcHMgPSB0aGlzLm1heFVwZGF0ZUZQUzsgICAvLyBJbml0aWFsaXplIHRoZSBmcHMgdG8gdGhlIG1heCBhbGxvd2VkIGZwc1xuICAgICAgICB0aGlzLmZwc1VwZGF0ZUludGVydmFsID0gMTAwMDtcbiAgICAgICAgdGhpcy5sYXN0RnBzVXBkYXRlID0gMDtcbiAgICAgICAgdGhpcy5mcmFtZXNTaW5jZUxhc3RGcHNVcGRhdGUgPSAwO1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMubnVtVXBkYXRlU3RlcHMgPSAwO1xuXHR9XG5cblx0Z2V0RlBTKCk6IG51bWJlciB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHQvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBmcmFtZSBjb3VudCBhbmQgc3VtIG9mIHRpbWUgZm9yIHRoZSBmcmFtZXJhdGUgb2YgdGhlIGdhbWVcbiAgICAgKiBAcGFyYW0gdGltZXN0ZXAgVGhlIGN1cnJlbnQgdGltZSBpbiBtc1xuICAgICAqL1xuICAgIHByb3RlY3RlZCB1cGRhdGVGUFModGltZXN0YW1wOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5mcHMgPSAwLjkgKiB0aGlzLmZyYW1lc1NpbmNlTGFzdEZwc1VwZGF0ZSAqIDEwMDAgLyAodGltZXN0YW1wIC0gdGhpcy5sYXN0RnBzVXBkYXRlKSArKDEgLSAwLjkpICogdGhpcy5mcHM7XG4gICAgICAgIHRoaXMubGFzdEZwc1VwZGF0ZSA9IHRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy5mcmFtZXNTaW5jZUxhc3RGcHNVcGRhdGUgPSAwO1xuXG4gICAgICAgIERlYnVnLmxvZyhcImZwc1wiLCBcIkZQUzogXCIgKyB0aGlzLmZwcy50b0ZpeGVkKDEpKTtcbiAgICAgICAgU3RhdHMudXBkYXRlRlBTKHRoaXMuZnBzKTtcbiAgICB9XG5cblx0ICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIG1heGltdW0gYWxsb3dlZCBwaHlzaWNzIGZyYW1lcmF0ZSBvZiB0aGUgZ2FtZVxuICAgICAqIEBwYXJhbSBpbml0TWF4IFRoZSBtYXggZnJhbWVyYXRlXG4gICAgICovXG4gICAgc2V0TWF4VXBkYXRlRlBTKGluaXRNYXg6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLm1heFVwZGF0ZUZQUyA9IGluaXRNYXg7XG4gICAgICAgIHRoaXMudXBkYXRlVGltZXN0ZXAgPSBNYXRoLmZsb29yKDEwMDAvdGhpcy5tYXhVcGRhdGVGUFMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1heGltdW0gcmVuZGVyaW5nIGZyYW1lcmF0ZVxuICAgICAqIEBwYXJhbSBtYXhGUFMgVGhlIG1heCBmcmFtZXJhdGVcbiAgICAgKi9cbiAgICBzZXRNYXhGUFMobWF4RlBTOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5taW5GcmFtZURlbGF5ID0gMTAwMC9tYXhGUFM7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIHRoZSBnYW1lIGxvb3AgcGFuaWNzLCBpLmUuIGl0IHRyaWVzIHRvIHByb2Nlc3MgdG9vIG11Y2ggdGltZSBpbiBhbiBlbnRpcmUgZnJhbWUuXG5cdCAqIFRoaXMgd2lsbCByZXNldCB0aGUgYW1vdW50IG9mIHRpbWUgYmFjayB0byB6ZXJvLlxuXHQgKiBAcmV0dXJucyBUaGUgYW1vdW50IG9mIHRpbWUgd2UgYXJlIGRpc2NhcmRpbmcgZnJvbSBwcm9jZXNzaW5nLlxuXHQgKi9cblx0cmVzZXRGcmFtZURlbHRhKCkgOiBudW1iZXIge1xuICAgICAgICBsZXQgb2xkRnJhbWVEZWx0YSA9IHRoaXMuZnJhbWVEZWx0YTtcbiAgICAgICAgdGhpcy5mcmFtZURlbHRhID0gMDtcbiAgICAgICAgcmV0dXJuIG9sZEZyYW1lRGVsdGE7XG4gICAgfVxuXG5cdC8qKlxuICAgICAqIFN0YXJ0cyB1cCB0aGUgZ2FtZSBsb29wIGFuZCBjYWxscyB0aGUgZmlyc3QgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICovXG5cdHN0YXJ0KCk6IHZvaWQge1xuICAgICAgICBpZighdGhpcy5zdGFydGVkKXtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKHRpbWVzdGFtcCkgPT4gdGhpcy5kb0ZpcnN0RnJhbWUodGltZXN0YW1wKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYXVzZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJlc3VtZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICB9XG5cblx0LyoqXG4gICAgICogVGhlIGZpcnN0IGdhbWUgZnJhbWUgLSBpbml0aWFsaXplcyB0aGUgZmlyc3QgZnJhbWUgdGltZSBhbmQgYmVnaW5zIHRoZSByZW5kZXJcbiAgICAgKiBAcGFyYW0gdGltZXN0YW1wIFRoZSBjdXJyZW50IHRpbWUgaW4gbXNcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZG9GaXJzdEZyYW1lKHRpbWVzdGFtcDogbnVtYmVyKTogdm9pZCAge1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX2RvUmVuZGVyKCk7XG5cbiAgICAgICAgdGhpcy5sYXN0RnJhbWVUaW1lID0gdGltZXN0YW1wO1xuICAgICAgICB0aGlzLmxhc3RGcHNVcGRhdGUgPSB0aW1lc3RhbXA7XG4gICAgICAgIHRoaXMuZnJhbWVzU2luY2VMYXN0RnBzVXBkYXRlID0gMDtcblxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCh0KSA9PiB0aGlzLmRvRnJhbWUodCkpO1xuICAgIH1cblxuXHQvKipcblx0ICogSGFuZGxlcyBhbnkgcHJvY2Vzc2luZyB0aGF0IG5lZWRzIHRvIGJlIGRvbmUgYXQgdGhlIHN0YXJ0IG9mIHRoZSBmcmFtZVxuXHQgKiBAcGFyYW0gdGltZXN0YW1wIFRoZSB0aW1lIG9mIHRoZSBmcmFtZSBpbiBtc1xuXHQgKi9cblx0cHJvdGVjdGVkIHN0YXJ0RnJhbWUodGltZXN0YW1wOiBudW1iZXIpOiB2b2lkIHtcblx0XHQvLyBVcGRhdGUgdGhlIGFtb3VudCBvZiB0aW1lIHdlIG5lZWQgb3VyIHVwZGF0ZSB0byBwcm9jZXNzXG5cdFx0dGhpcy5mcmFtZURlbHRhICs9IHRpbWVzdGFtcCAtIHRoaXMubGFzdEZyYW1lVGltZTtcblxuXHRcdC8vIFNldCB0aGUgbmV3IHRpbWUgb2YgdGhlIGxhc3QgZnJhbWVcbiAgICAgICAgdGhpcy5sYXN0RnJhbWVUaW1lID0gdGltZXN0YW1wO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgZXN0aW1hdGUgb2YgdGhlIGZyYW1lcmF0ZVxuICAgICAgICBpZih0aW1lc3RhbXAgPiB0aGlzLmxhc3RGcHNVcGRhdGUgKyB0aGlzLmZwc1VwZGF0ZUludGVydmFsKXtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRlBTKHRpbWVzdGFtcCk7XG4gICAgICAgIH1cblxuXHRcdC8vIEluY3JlbWVudCB0aGUgbnVtYmVyIG9mIGZyYW1lc1xuICAgICAgICB0aGlzLmZyYW1lKys7XG4gICAgICAgIHRoaXMuZnJhbWVzU2luY2VMYXN0RnBzVXBkYXRlKys7XG5cdH1cblxuXHQvKipcbiAgICAgKiBUaGUgbWFpbiBsb29wIG9mIHRoZSBnYW1lLiBVcGRhdGVzIHVudGlsIHRoZSBjdXJyZW50IHRpbWUgaXMgcmVhY2hlZC4gUmVuZGVycyBvbmNlXG4gICAgICogQHBhcmFtIHRpbWVzdGFtcCBUaGUgY3VycmVudCB0aW1lIGluIG1zXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGRvRnJhbWUgPSAodGltZXN0YW1wOiBudW1iZXIpOiB2b2lkID0+IHtcbiAgICAgICAgLy8gSWYgYSBwYXVzZSB3YXMgZXhlY3V0ZWQsIHN0b3AgZG9pbmcgdGhlIGxvb3AuXG4gICAgICAgIGlmKHRoaXMucGF1c2VkKXsgXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXF1ZXN0IGFuaW1hdGlvbiBmcmFtZSB0byBwcmVwYXJlIGZvciBhbm90aGVyIHVwZGF0ZSBvciByZW5kZXJcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgodCkgPT4gdGhpcy5kb0ZyYW1lKHQpKTtcblxuICAgICAgICAvLyBJZiB3ZSBhcmUgdHJ5aW5nIHRvIHJlbmRlciB0b28gc29vbiwgZG8gbm90aGluZy5cbiAgICAgICAgaWYodGltZXN0YW1wIDwgdGhpcy5sYXN0RnJhbWVUaW1lICsgdGhpcy5taW5GcmFtZURlbGF5KXtcbiAgICAgICAgICAgIHJldHVybjtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gQSBmcmFtZSBpcyBhY3R1YWxseSBoYXBwZW5pbmdcblx0XHR0aGlzLnN0YXJ0RnJhbWUodGltZXN0YW1wKTtcblxuXHRcdC8vIFVwZGF0ZSB3aGlsZSB0aGVyZSBpcyBzdGlsbCB0aW1lIHRvIG1ha2UgdXAuIElmIHdlIGRvIHRvbyBtYW55IHVwZGF0ZSBzdGVwcywgcGFuaWMgYW5kIGV4aXQgdGhlIGxvb3AuXG5cdFx0dGhpcy5udW1VcGRhdGVTdGVwcyA9IDA7XG5cdFx0bGV0IHBhbmljID0gZmFsc2U7XG5cbiAgICAgICAgd2hpbGUodGhpcy5mcmFtZURlbHRhID49IHRoaXMudXBkYXRlVGltZXN0ZXApe1xuXHRcdFx0Ly8gRG8gYW4gdXBkYXRlXG5cdFx0XHR0aGlzLl9kb1VwZGF0ZSh0aGlzLnVwZGF0ZVRpbWVzdGVwLzEwMDApO1xuXHRcdFx0XG5cdFx0XHQvLyBSZW1vdmUgdGhlIHVwZGF0ZSBzdGVwIHRpbWUgZnJvbSB0aGUgdGltZSB3ZSBoYXZlIHRvIHByb2Nlc3NcbiAgICAgICAgICAgIHRoaXMuZnJhbWVEZWx0YSAtPSB0aGlzLnVwZGF0ZVRpbWVzdGVwO1xuXG5cdFx0XHQvLyBJbmNyZW1lbnQgc3RlcHMgYW5kIGNoZWNrIGlmIHdlJ3ZlIGRvbmUgdG9vIG1hbnlcbiAgICAgICAgICAgIHRoaXMubnVtVXBkYXRlU3RlcHMrKztcbiAgICAgICAgICAgIGlmKHRoaXMubnVtVXBkYXRlU3RlcHMgPiAxMDApe1xuICAgICAgICAgICAgICAgIHBhbmljID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZXMgYXJlIGRvbmUsIHJlbmRlclxuICAgICAgICB0aGlzLl9kb1JlbmRlcigpO1xuXG4gICAgICAgIC8vIFdyYXAgdXAgdGhlIGZyYW1lXG4gICAgICAgIHRoaXMuZmluaXNoRnJhbWUocGFuaWMpO1xuICAgIH1cblxuXHQvKipcblx0ICogV3JhcHMgdXAgdGhlIGZyYW1lIGFuZCBoYW5kbGVzIHRoZSBwYW5pYyBzdGF0ZSBpZiB0aGVyZSBpcyBvbmVcblx0ICogQHBhcmFtIHBhbmljIFdoZXRoZXIgb3Igbm90IHRoZSBsb29wIHBhbmlja2VkXG5cdCAqL1xuXHRwcm90ZWN0ZWQgZmluaXNoRnJhbWUocGFuaWM6IGJvb2xlYW4pOiB2b2lkIHtcblx0XHRpZihwYW5pYykge1xuICAgICAgICAgICAgdmFyIGRpc2NhcmRlZFRpbWUgPSBNYXRoLnJvdW5kKHRoaXMucmVzZXRGcmFtZURlbHRhKCkpO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdNYWluIGxvb3AgcGFuaWNrZWQsIHByb2JhYmx5IGJlY2F1c2UgdGhlIGJyb3dzZXIgdGFiIHdhcyBwdXQgaW4gdGhlIGJhY2tncm91bmQuIERpc2NhcmRpbmcgJyArIGRpc2NhcmRlZFRpbWUgKyAnbXMnKTtcbiAgICAgICAgfVxuXHR9XG5cbn0iLCJpbXBvcnQgRXZlbnRRdWV1ZSBmcm9tIFwiLi4vRXZlbnRzL0V2ZW50UXVldWVcIjtcbmltcG9ydCBJbnB1dCBmcm9tIFwiLi4vSW5wdXQvSW5wdXRcIjtcbmltcG9ydCBJbnB1dEhhbmRsZXIgZnJvbSBcIi4uL0lucHV0L0lucHV0SGFuZGxlclwiO1xuaW1wb3J0IFJlY29yZGVyIGZyb20gXCIuLi9QbGF5YmFjay9FdmVudFJlY29yZGVyXCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uL0RlYnVnL0RlYnVnXCI7XG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5pbXBvcnQgVmlld3BvcnQgZnJvbSBcIi4uL1NjZW5lR3JhcGgvVmlld3BvcnRcIjtcbmltcG9ydCBTY2VuZU1hbmFnZXIgZnJvbSBcIi4uL1NjZW5lL1NjZW5lTWFuYWdlclwiO1xuaW1wb3J0IEF1ZGlvTWFuYWdlciBmcm9tIFwiLi4vU291bmQvQXVkaW9NYW5hZ2VyXCI7XG5pbXBvcnQgU3RhdHMgZnJvbSBcIi4uL0RlYnVnL1N0YXRzXCI7XG5pbXBvcnQgUmVuZGVyaW5nTWFuYWdlciBmcm9tIFwiLi4vUmVuZGVyaW5nL1JlbmRlcmluZ01hbmFnZXJcIjtcbmltcG9ydCBDYW52YXNSZW5kZXJlciBmcm9tIFwiLi4vUmVuZGVyaW5nL0NhbnZhc1JlbmRlcmVyXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1V0aWxzL0NvbG9yXCI7XG5pbXBvcnQgR2FtZU9wdGlvbnMgZnJvbSBcIi4vR2FtZU9wdGlvbnNcIjtcbmltcG9ydCBHYW1lTG9vcCBmcm9tIFwiLi9HYW1lTG9vcFwiO1xuaW1wb3J0IEZpeGVkVXBkYXRlR2FtZUxvb3AgZnJvbSBcIi4vRml4ZWRVcGRhdGVHYW1lTG9vcFwiO1xuaW1wb3J0IEVudmlyb25tZW50SW5pdGlhbGl6ZXIgZnJvbSBcIi4vRW52aXJvbm1lbnRJbml0aWFsaXplclwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgUmVnaXN0cnlNYW5hZ2VyIGZyb20gXCIuLi9SZWdpc3RyeS9SZWdpc3RyeU1hbmFnZXJcIjtcbmltcG9ydCBXZWJHTFJlbmRlcmVyIGZyb20gXCIuLi9SZW5kZXJpbmcvV2ViR0xSZW5kZXJlclwiO1xuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZS9TY2VuZVwiO1xuaW1wb3J0IFJlY29yZGluZ01hbmFnZXIgZnJvbSBcIi4uL1BsYXliYWNrL1BsYXliYWNrTWFuYWdlclwiO1xuaW1wb3J0IElucHV0UmVwbGF5ZXIgZnJvbSBcIi4uL1BsYXliYWNrL0V2ZW50UmVwbGF5ZXJcIjtcbmltcG9ydCB7IFRpbWVyU3RhdGUgfSBmcm9tIFwiLi4vVGltaW5nL1RpbWVyXCI7XG5pbXBvcnQgUGxheWJhY2tNYW5hZ2VyIGZyb20gXCIuLi9QbGF5YmFjay9QbGF5YmFja01hbmFnZXJcIjtcblxuLyoqXG4gKiBUaGUgbWFpbiBsb29wIG9mIHRoZSBnYW1lIGVuZ2luZS5cbiAqIEhhbmRsZXMgdGhlIHVwZGF0ZSBvcmRlciwgYW5kIGluaXRpYWxpemVzIGFsbCBzdWJzeXN0ZW1zLlxuICogVGhlIEdhbWUgbWFuYWdlcyB0aGUgdXBkYXRlIGN5Y2xlLCBhbmQgcmVxdWVzdHMgYW5pbWF0aW9uIGZyYW1lcyB0byByZW5kZXIgdG8gdGhlIGJyb3dzZXIuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdhbWUge1xuICAgIGdhbWVPcHRpb25zOiBHYW1lT3B0aW9ucztcbiAgICBwcml2YXRlIHNob3dEZWJ1ZzogYm9vbGVhbjtcbiAgICBwcml2YXRlIHNob3dTdGF0czogYm9vbGVhbjtcblxuICAgIC8vIFRoZSBnYW1lIGxvb3BcbiAgICBwcml2YXRlIGxvb3A6IEdhbWVMb29wO1xuXG4gICAgLy8gR2FtZSBjYW52YXMgYW5kIGl0cyB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgcmVhZG9ubHkgR0FNRV9DQU5WQVM6IEhUTUxDYW52YXNFbGVtZW50O1xuICAgIHJlYWRvbmx5IERFQlVHX0NBTlZBUzogSFRNTENhbnZhc0VsZW1lbnQ7XG5cdHJlYWRvbmx5IFdJRFRIOiBudW1iZXI7XG4gICAgcmVhZG9ubHkgSEVJR0hUOiBudW1iZXI7XG4gICAgcHJpdmF0ZSB2aWV3cG9ydDogVmlld3BvcnQ7XG4gICAgcHJpdmF0ZSBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB8IFdlYkdMUmVuZGVyaW5nQ29udGV4dDtcbiAgICBwcml2YXRlIGNsZWFyQ29sb3I6IENvbG9yO1xuICAgIFxuICAgIC8vIEFsbCBvZiB0aGUgbmVjZXNzYXJ5IHN1YnN5c3RlbXMgdGhhdCBuZWVkIHRvIHJ1biBoZXJlXG5cdHByaXZhdGUgZXZlbnRRdWV1ZTogRXZlbnRRdWV1ZTtcblx0cHJpdmF0ZSBpbnB1dEhhbmRsZXI6IElucHV0SGFuZGxlcjtcblx0cHJpdmF0ZSBwbGF5YmFja01hbmFnZXI6IFBsYXliYWNrTWFuYWdlcjtcbiAgICBwcml2YXRlIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xuICAgIHByaXZhdGUgc2NlbmVNYW5hZ2VyOiBTY2VuZU1hbmFnZXI7XG4gICAgcHJpdmF0ZSBhdWRpb01hbmFnZXI6IEF1ZGlvTWFuYWdlcjtcbiAgICBwcml2YXRlIHJlbmRlcmluZ01hbmFnZXI6IFJlbmRlcmluZ01hbmFnZXI7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEdhbWVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgR2FtZSBpbml0aWFsaXphdGlvblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KXtcbiAgICAgICAgLy8gQmVmb3JlIGFueXRoaW5nIGVsc2UsIGJ1aWxkIHRoZSBlbnZpcm9ubWVudFxuICAgICAgICBFbnZpcm9ubWVudEluaXRpYWxpemVyLnNldHVwKCk7XG5cbiAgICAgICAgLy8gVHlwZWNhc3QgdGhlIGNvbmZpZyBvYmplY3QgdG8gYSBHYW1lQ29uZmlnIG9iamVjdFxuICAgICAgICB0aGlzLmdhbWVPcHRpb25zID0gR2FtZU9wdGlvbnMucGFyc2Uob3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5zaG93RGVidWcgPSB0aGlzLmdhbWVPcHRpb25zLnNob3dEZWJ1ZztcbiAgICAgICAgdGhpcy5zaG93U3RhdHMgPSB0aGlzLmdhbWVPcHRpb25zLnNob3dTdGF0cztcblxuICAgICAgICAvLyBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgYSBnYW1lIGxvb3BcbiAgICAgICAgdGhpcy5sb29wID0gbmV3IEZpeGVkVXBkYXRlR2FtZUxvb3AoKTtcblxuICAgICAgICAvLyBHZXQgdGhlIGdhbWUgY2FudmFzIGFuZCBnaXZlIGl0IGEgYmFja2dyb3VuZCBjb2xvclxuICAgICAgICB0aGlzLkdBTUVfQ0FOVkFTID0gPEhUTUxDYW52YXNFbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZ2FtZS1jYW52YXNcIik7XG4gICAgICAgIHRoaXMuREVCVUdfQ0FOVkFTID0gPEhUTUxDYW52YXNFbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZGVidWctY2FudmFzXCIpO1xuICAgIFxuICAgICAgICAvLyBHaXZlIHRoZSBjYW52YXMgYSBzaXplIGFuZCBnZXQgdGhlIHJlbmRlcmluZyBjb250ZXh0XG4gICAgICAgIHRoaXMuV0lEVEggPSB0aGlzLmdhbWVPcHRpb25zLmNhbnZhc1NpemUueDtcbiAgICAgICAgdGhpcy5IRUlHSFQgPSB0aGlzLmdhbWVPcHRpb25zLmNhbnZhc1NpemUueTtcblxuICAgICAgICAvLyBUaGlzIHN0ZXAgTVVTVCBoYXBwZW4gYmVmb3JlIHRoZSByZXNvdXJjZSBtYW5hZ2VyIGRvZXMgYW55dGhpbmdcbiAgICAgICAgaWYodGhpcy5nYW1lT3B0aW9ucy51c2VXZWJHTCl7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmluZ01hbmFnZXIgPSBuZXcgV2ViR0xSZW5kZXJlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJpbmdNYW5hZ2VyID0gbmV3IENhbnZhc1JlbmRlcmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0aWFsaXplR2FtZVdpbmRvdygpO1xuICAgICAgICB0aGlzLmN0eCA9IHRoaXMucmVuZGVyaW5nTWFuYWdlci5pbml0aWFsaXplQ2FudmFzKHRoaXMuR0FNRV9DQU5WQVMsIHRoaXMuV0lEVEgsIHRoaXMuSEVJR0hUKTtcbiAgICAgICAgdGhpcy5jbGVhckNvbG9yID0gbmV3IENvbG9yKHRoaXMuZ2FtZU9wdGlvbnMuY2xlYXJDb2xvci5yLCB0aGlzLmdhbWVPcHRpb25zLmNsZWFyQ29sb3IuZywgdGhpcy5nYW1lT3B0aW9ucy5jbGVhckNvbG9yLmIpO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgZGVidWdnaW5nIGFuZCBzdGF0c1xuICAgICAgICBEZWJ1Zy5pbml0aWFsaXplRGVidWdDYW52YXModGhpcy5ERUJVR19DQU5WQVMsIHRoaXMuV0lEVEgsIHRoaXMuSEVJR0hUKTtcbiAgICAgICAgU3RhdHMuaW5pdFN0YXRzKCk7XG5cbiAgICAgICAgaWYodGhpcy5nYW1lT3B0aW9ucy5zaG93U3RhdHMpIHtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIHN0YXRzIG91dHB1dCBhbmQgbWFrZSBpdCBubyBsb25nZXIgaGlkZGVuXG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN0YXRzXCIpLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2l6ZSB0aGUgdmlld3BvcnQgdG8gdGhlIGdhbWUgY2FudmFzXG4gICAgICAgIGNvbnN0IGNhbnZhc1NpemUgPSBuZXcgVmVjMih0aGlzLldJRFRILCB0aGlzLkhFSUdIVCk7XG4gICAgICAgIHRoaXMudmlld3BvcnQgPSBuZXcgVmlld3BvcnQoY2FudmFzU2l6ZSwgdGhpcy5nYW1lT3B0aW9ucy56b29tTGV2ZWwpO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgYWxsIG5lY2Vzc2FyeSBnYW1lIHN1YnN5c3RlbXNcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlID0gRXZlbnRRdWV1ZS5nZXRJbnN0YW5jZSgpO1xuICAgICAgICB0aGlzLmlucHV0SGFuZGxlciA9IG5ldyBJbnB1dEhhbmRsZXIodGhpcy5HQU1FX0NBTlZBUyk7XG4gICAgICAgIElucHV0LmluaXRpYWxpemUodGhpcy52aWV3cG9ydCwgdGhpcy5nYW1lT3B0aW9ucy5pbnB1dHMpO1xuICAgICAgICB0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xuICAgICAgICB0aGlzLnNjZW5lTWFuYWdlciA9IG5ldyBTY2VuZU1hbmFnZXIodGhpcy52aWV3cG9ydCwgdGhpcy5yZW5kZXJpbmdNYW5hZ2VyKTtcbiAgICAgICAgdGhpcy5hdWRpb01hbmFnZXIgPSBBdWRpb01hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgdGhpcy5wbGF5YmFja01hbmFnZXIgPSBuZXcgUGxheWJhY2tNYW5hZ2VyKCk7XG4gICAgICAgIFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB1cCB0aGUgZ2FtZSB3aW5kb3cgdGhhdCBob2xkcyB0aGUgY2FudmFzZXNcbiAgICAgKi9cbiAgICBwcml2YXRlIGluaXRpYWxpemVHYW1lV2luZG93KCk6IHZvaWQge1xuICAgICAgICBjb25zdCBnYW1lV2luZG93ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJnYW1lLXdpbmRvd1wiKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNldCB0aGUgaGVpZ2h0IG9mIHRoZSBnYW1lIHdpbmRvd1xuICAgICAgICBnYW1lV2luZG93LnN0eWxlLndpZHRoID0gdGhpcy5XSURUSCArIFwicHhcIjtcbiAgICAgICAgZ2FtZVdpbmRvdy5zdHlsZS5oZWlnaHQgPSB0aGlzLkhFSUdIVCArIFwicHhcIjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyZWl2ZXMgdGhlIFNjZW5lTWFuYWdlciBmcm9tIHRoZSBHYW1lXG4gICAgICogQHJldHVybnMgVGhlIFNjZW5lTWFuYWdlclxuICAgICAqL1xuICAgIGdldFNjZW5lTWFuYWdlcigpOiBTY2VuZU1hbmFnZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2VuZU1hbmFnZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnRzIHRoZSBnYW1lXG4gICAgICovXG4gICAgc3RhcnQoSW5pdGlhbFNjZW5lOiBuZXcgKC4uLmFyZ3M6IGFueSkgPT4gU2NlbmUsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcbiAgICAgICAgLy8gU2V0IHRoZSB1cGRhdGUgZnVuY3Rpb24gb2YgdGhlIGxvb3BcbiAgICAgICAgdGhpcy5sb29wLmRvVXBkYXRlID0gKGRlbHRhVDogbnVtYmVyKSA9PiB0aGlzLnVwZGF0ZShkZWx0YVQpO1xuXG4gICAgICAgIC8vIFNldCB0aGUgcmVuZGVyIGZ1bmN0aW9uIG9mIHRoZSBsb29wXG4gICAgICAgIHRoaXMubG9vcC5kb1JlbmRlciA9ICgpID0+IHRoaXMucmVuZGVyKCk7XG5cbiAgICAgICAgLy8gUHJlbG9hZCByZWdpc3RyeSBpdGVtc1xuICAgICAgICBSZWdpc3RyeU1hbmFnZXIucHJlbG9hZCgpO1xuXG4gICAgICAgIC8vIExvYWQgdGhlIGl0ZW1zIHdpdGggdGhlIHJlc291cmNlIG1hbmFnZXJcbiAgICAgICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIubG9hZFJlc291cmNlc0Zyb21RdWV1ZSgoKSA9PiB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlJ3JlIGRvbmUgbG9hZGluZywgc3RhcnQgdGhlIGxvb3BcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRmluaXNoZWQgUHJlbG9hZCAtIGxvYWRpbmcgZmlyc3Qgc2NlbmVcIik7XG4gICAgICAgICAgICB0aGlzLnNjZW5lTWFuYWdlci5jaGFuZ2VUb1NjZW5lKEluaXRpYWxTY2VuZSwge30sIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5sb29wLnN0YXJ0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYWxsIG5lY2Vzc2FyeSBzdWJzeXN0ZW1zIG9mIHRoZSBnYW1lLiBEZWZlcnMgc2NlbmUgdXBkYXRlcyB0byB0aGUgc2NlbmVNYW5hZ2VyXG4gICAgICogQHBhcmFtIGRlbHRhVCBUaGUgdGltZSBzaW5lIHRoZSBsYXN0IHVwZGF0ZVxuICAgICAqL1xuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0cnl7XG4gICAgICAgICAgICAvLyBIYW5kbGUgYWxsIGV2ZW50cyB0aGF0IGhhcHBlbmVkIHNpbmNlIHRoZSBzdGFydCBvZiB0aGUgbGFzdCBsb29wXG4gICAgICAgICAgICB0aGlzLmV2ZW50UXVldWUudXBkYXRlKGRlbHRhVCk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaW5wdXQgaGFuZGxlciAtIGRpc2FibGluZy9lbmFibGluZyB1c2VyIGlucHV0XG4gICAgICAgICAgICB0aGlzLmlucHV0SGFuZGxlci51cGRhdGUoZGVsdGFUKTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBpbnB1dCBkYXRhIHN0cnVjdHVyZXMgc28gZ2FtZSBvYmplY3RzIGNhbiBzZWUgdGhlIGlucHV0XG4gICAgICAgICAgICBJbnB1dC51cGRhdGUoZGVsdGFUKTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSByZWNvcmRpbmcgb2YgdGhlIGdhbWVcbiAgICAgICAgICAgIHRoaXMucGxheWJhY2tNYW5hZ2VyLnVwZGF0ZShkZWx0YVQpO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgYWxsIHNjZW5lc1xuICAgICAgICAgICAgdGhpcy5zY2VuZU1hbmFnZXIudXBkYXRlKGRlbHRhVCk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBhbGwgc291bmRzXG4gICAgICAgICAgICB0aGlzLmF1ZGlvTWFuYWdlci51cGRhdGUoZGVsdGFUKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gTG9hZCBvciB1bmxvYWQgYW55IHJlc291cmNlcyBpZiBuZWVkZWRcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyLnVwZGF0ZShkZWx0YVQpO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgdGhpcy5sb29wLnBhdXNlKCk7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbmNhdWdodCBFcnJvciBpbiBVcGRhdGUgLSBDcmFzaGluZyBncmFjZWZ1bGx5XCIpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgY2FudmFzIGFuZCBkZWZlcnMgc2NlbmUgcmVuZGVyaW5nIHRvIHRoZSBzY2VuZU1hbmFnZXIuIFJlbmRlcnMgdGhlIGRlYnVnIGNhbnZhc1xuICAgICAqL1xuICAgIHJlbmRlcigpOiB2b2lkIHtcbiAgICAgICAgdHJ5e1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIGNhbnZhc2VzXG4gICAgICAgICAgICBEZWJ1Zy5jbGVhckNhbnZhcygpO1xuXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmluZ01hbmFnZXIuY2xlYXIodGhpcy5jbGVhckNvbG9yKTtcblxuICAgICAgICAgICAgdGhpcy5zY2VuZU1hbmFnZXIucmVuZGVyKCk7XG5cbiAgICAgICAgICAgIC8vIEhhY2t5IGRlYnVnIG1vZGVcbiAgICAgICAgICAgIGlmKElucHV0LmlzS2V5SnVzdFByZXNzZWQoXCJnXCIpKXtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dEZWJ1ZyA9ICF0aGlzLnNob3dEZWJ1ZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGVidWcgcmVuZGVyXG4gICAgICAgICAgICBpZih0aGlzLnNob3dEZWJ1Zyl7XG4gICAgICAgICAgICAgICAgRGVidWcucmVuZGVyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHRoaXMuc2hvd1N0YXRzKXtcbiAgICAgICAgICAgICAgICBTdGF0cy5yZW5kZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIHRoaXMubG9vcC5wYXVzZSgpO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5jYXVnaHQgRXJyb3IgaW4gUmVuZGVyIC0gQ3Jhc2hpbmcgZ3JhY2VmdWxseVwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IE51bGxGdW5jIGZyb20gXCIuLi9EYXRhVHlwZXMvRnVuY3Rpb25zL051bGxGdW5jXCI7XG5cbi8qKlxuICogVGhlIG1haW4gZ2FtZSBsb29wIG9mIHRoZSBnYW1lLiBLZWVwcyB0cmFjayBvZiBmcHMgYW5kIGhhbmRsZXMgc2NoZWR1bGluZyBvZiB1cGRhdGVzIGFuZCByZW5kZXJpbmcuXG4gKiBUaGlzIGNsYXNzIGlzIGxlZnQgYWJzdHJhY3QsIHNvIHRoYXQgYSBzdWJjbGFzcyBjYW4gaGFuZGxlIGV4YWN0bHkgaG93IHRoZSBsb29wIGlzIHNjaGVkdWxlZC5cbiAqIEZvciBhbiBleGFtcGxlIG9mIGRpZmZlcmVudCB0eXBlcyBvZiBnYW1lIGxvb3Agc2NoZWR1bGluZywgY2hlY2sgb3V0IEBsaW5rKEdhbWUgUHJvZ3JhbW1pbmcgUGF0dGVybnMpKGh0dHBzOi8vZ2FtZXByb2dyYW1taW5ncGF0dGVybnMuY29tL2dhbWUtbG9vcC5odG1sKVxuICovXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBHYW1lTG9vcCB7XG5cblx0LyoqIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gYW4gdXBkYXRlIG9jY3VycyAqL1xuXHRwcm90ZWN0ZWQgX2RvVXBkYXRlOiBGdW5jdGlvbiA9IE51bGxGdW5jO1xuXG5cdHNldCBkb1VwZGF0ZSh1cGRhdGU6IEZ1bmN0aW9uKXtcblx0XHR0aGlzLl9kb1VwZGF0ZSA9IHVwZGF0ZTtcblx0fVxuXG5cdC8qKiBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGEgcmVuZGVyIG9jY3VycyAqL1xuXHRwcm90ZWN0ZWQgX2RvUmVuZGVyOiBGdW5jdGlvbiA9IE51bGxGdW5jO1xuXG5cblx0c2V0IGRvUmVuZGVyKHJlbmRlcjogRnVuY3Rpb24pe1xuXHRcdHRoaXMuX2RvUmVuZGVyID0gcmVuZGVyO1xuXHR9XG5cdFxuXHQvKipcblx0ICogUmV0cmlldmVzIHRoZSBjdXJyZW50IEZQUyBvZiB0aGUgZ2FtZVxuXHQgKi9cblx0YWJzdHJhY3QgZ2V0RlBTKCk6IG51bWJlcjtcblxuXHQvKipcbiAgICAgKiBTdGFydHMgdXAgdGhlIGdhbWUgbG9vcFxuICAgICAqL1xuXHRhYnN0cmFjdCBzdGFydCgpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBQYXVzZXMgdGhlIGdhbWUgbG9vcCwgdXN1YWxseSBmb3IgYW4gZXJyb3IgY29uZGl0aW9uLlxuXHQgKi9cblx0YWJzdHJhY3QgcGF1c2UoKTogdm9pZDtcblxuXHQvKipcblx0ICogUmVzdW1lcyB0aGUgZ2FtZSBsb29wLlxuXHQgKi9cblx0YWJzdHJhY3QgcmVzdW1lKCk6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIFJ1bnMgdGhlIGZpcnN0IGZyYW1lIG9mIHRoZSBnYW1lLiBObyB1cGRhdGUgb2NjdXJzIGhlcmUsIG9ubHkgYSByZW5kZXIuXG5cdCAqIFRoaXMgaXMgbmVlZGVkIHRvIGluaXRpYWxpemUgZGVsdGEgdGltZSB2YWx1ZXNcblx0ICogQHBhcmFtIHRpbWVzdGFtcCBUaGUgdGltZXN0YW1wIG9mIHRoZSBmcmFtZS4gVGhpcyBpcyByZWNlaXZlZCBmcm9tIHRoZSBicm93c2VyXG5cdCAqL1xuXHRwcm90ZWN0ZWQgYWJzdHJhY3QgZG9GaXJzdEZyYW1lKHRpbWVzdGFtcDogbnVtYmVyKTogdm9pZDtcblxuXHQvKipcblx0ICogUnVuIGJlZm9yZSBhbnkgdXBkYXRlcyBvciB0aGUgcmVuZGVyIG9mIGEgZnJhbWUuXG5cdCAqIEBwYXJhbSB0aW1lc3RhbXAgVGhlIHRpbWVzdGFtcCBvZiB0aGUgZnJhbWUuIFRoaXMgaXMgcmVjZWl2ZWQgZnJvbSB0aGUgYnJvd3NlclxuXHQgKi9cblx0cHJvdGVjdGVkIGFic3RyYWN0IHN0YXJ0RnJhbWUodGltZXN0YW1wOiBudW1iZXIpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBUaGUgY29yZSBvZiB0aGUgZnJhbWUsIHdoZXJlIGFueSBuZWNlc3NhcnkgdXBkYXRlcyBvY2N1ciwgYW5kIHdoZXJlIGEgcmVuZGVyIGhhcHBlbnNcblx0ICogQHBhcmFtIHRpbWVzdGFtcCBUaGUgdGltZXN0YW1wIG9mIHRoZSBmcmFtZS4gVGhpcyBpcyByZWNlaXZlZCBmcm9tIHRoZSBicm93c2VyXG5cdCAqL1xuXHRwcm90ZWN0ZWQgYWJzdHJhY3QgZG9GcmFtZSh0aW1lc3RhbXA6IG51bWJlcik6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIFdyYXBzIHVwIHRoZSBmcmFtZVxuXHQgKiBAcGFyYW0gcGFuaWMgV2hldGhlciBvciBub3QgdGhlIHVwZGF0ZSBjeWNsZSBwYW5pY2tlZC4gVGhpcyBoYXBwZW5zIHdoZW4gdG9vIG1hbnkgdXBkYXRlcyB0cnkgdG8gaGFwcGVuIGluIGEgc2luZ2xlIGZyYW1lXG5cdCAqL1xuXHRwcm90ZWN0ZWQgYWJzdHJhY3QgZmluaXNoRnJhbWUocGFuaWM6IGJvb2xlYW4pOiB2b2lkO1xufSIsIi8vIEBpZ25vcmVQYWdlXG5cbi8qKiBUaGUgb3B0aW9ucyBmb3IgaW5pdGlhbGl6aW5nIHRoZSBAcmVmZXJlbmNlW0dhbWVMb29wXSAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2FtZU9wdGlvbnMge1xuICAgIC8qKiBUaGUgc2l6ZSBvZiB0aGUgdmlld3BvcnQgKi9cbiAgICBjYW52YXNTaXplOiB7eDogbnVtYmVyLCB5OiBudW1iZXJ9O1xuXG4gICAgLyogVGhlIGRlZmF1bHQgbGV2ZWwgb2Ygem9vbSAqL1xuICAgIHpvb21MZXZlbDogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSBjb2xvciB0byBjbGVhciB0aGUgY2FudmFzIHRvIGVhY2ggZnJhbWUgKi9cbiAgICBjbGVhckNvbG9yOiB7cjogbnVtYmVyLCBnOiBudW1iZXIsIGI6IG51bWJlcn1cblxuICAgIC8qIEEgbGlzdCBvZiBpbnB1dCBiaW5kaW5ncyAqL1xuICAgIGlucHV0czogQXJyYXk8e25hbWU6IHN0cmluZywga2V5czogQXJyYXk8c3RyaW5nPn0+O1xuXG4gICAgLyogV2hldGhlciBvciBub3QgdGhlIGRlYnVnIHJlbmRlcmluZyBzaG91bGQgb2NjdXIgKi9cbiAgICBzaG93RGVidWc6IGJvb2xlYW47XG5cbiAgICAvKiBXaGV0aGVyIG9yIG5vdCB0aGUgc3RhdHMgcmVuZGVyaW5nIHNob3VsZCBvY2N1ciAqL1xuICAgIHNob3dTdGF0czogYm9vbGVhbjtcblxuICAgIC8qIFdoZXRoZXIgb3Igbm90IHRvIHVzZSB3ZWJHTCAqL1xuICAgIHVzZVdlYkdMOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRoZSBkYXRhIGluIHRoZSByYXcgb3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgZ2FtZSBvcHRpb25zIGFzIGEgUmVjb3JkXG4gICAgICogQHJldHVybnMgQSB2ZXJzaW9uIG9mIHRoZSBvcHRpb25zIGNvbnZlcnRlZCB0byBhIEdhbWVPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZShvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogR2FtZU9wdGlvbnMge1xuICAgICAgICBsZXQgZ09wdCA9IG5ldyBHYW1lT3B0aW9ucygpO1xuXG4gICAgICAgIGdPcHQuY2FudmFzU2l6ZSA9IG9wdGlvbnMuY2FudmFzU2l6ZSA/IG9wdGlvbnMuY2FudmFzU2l6ZSA6IHt4OiA4MDAsIHk6IDYwMH07XG4gICAgICAgIGdPcHQuem9vbUxldmVsID0gb3B0aW9ucy56b29tTGV2ZWwgPyBvcHRpb25zLnpvb21MZXZlbCA6IDE7XG4gICAgICAgIGdPcHQuY2xlYXJDb2xvciA9IG9wdGlvbnMuY2xlYXJDb2xvciA/IG9wdGlvbnMuY2xlYXJDb2xvciA6IHtyOiAyNTUsIGc6IDI1NSwgYjogMjU1fTtcbiAgICAgICAgZ09wdC5pbnB1dHMgPSBvcHRpb25zLmlucHV0cyA/IG9wdGlvbnMuaW5wdXRzIDogW107XG4gICAgICAgIGdPcHQuc2hvd0RlYnVnID0gISFvcHRpb25zLnNob3dEZWJ1ZztcbiAgICAgICAgZ09wdC5zaG93U3RhdHMgPSAhIW9wdGlvbnMuc2hvd1N0YXRzO1xuICAgICAgICBnT3B0LnVzZVdlYkdMID0gISFvcHRpb25zLnVzZVdlYkdMO1xuXG4gICAgICAgIHJldHVybiBnT3B0O1xuICAgIH1cbn0iLCJpbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4vR2FtZU5vZGVcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IFJlZ2lvbiBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvUmVnaW9uXCI7XG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uL0RlYnVnL0RlYnVnXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1V0aWxzL0NvbG9yXCI7XG5cbi8qKlxuICogVGhlIHJlcHJlc2VudGF0aW9uIG9mIGFuIG9iamVjdCBpbiB0aGUgZ2FtZSB3b3JsZCB0aGF0IGNhbiBiZSBkcmF3biB0byB0aGUgc2NyZWVuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIENhbnZhc05vZGUgZXh0ZW5kcyBHYW1lTm9kZSBpbXBsZW1lbnRzIFJlZ2lvbiB7XG5cdHByaXZhdGUgX3NpemU6IFZlYzI7XG5cdHByaXZhdGUgX3NjYWxlOiBWZWMyO1xuXHRwcml2YXRlIF9ib3VuZGFyeTogQUFCQjtcblx0cHJpdmF0ZSBfaGFzQ3VzdG9tU2hhZGVyOiBib29sZWFuO1xuXHRwcml2YXRlIF9jdXN0b21TaGFkZXJLZXk6IHN0cmluZztcblx0cHJpdmF0ZSBfYWxwaGE6IG51bWJlcjtcblxuXHQvKiogQSBmbGFnIGZvciB3aGV0aGVyIG9yIG5vdCB0aGUgQ2FudmFzTm9kZSBpcyB2aXNpYmxlICovXG5cdHZpc2libGU6IGJvb2xlYW4gPSB0cnVlO1xuXHRcblx0Y29uc3RydWN0b3IoKXtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuX3NpemUgPSBuZXcgVmVjMigwLCAwKTtcblx0XHR0aGlzLl9zaXplLnNldE9uQ2hhbmdlKCgpID0+IHRoaXMuc2l6ZUNoYW5nZWQoKSk7XG5cdFx0dGhpcy5fc2NhbGUgPSBuZXcgVmVjMigxLCAxKTtcblx0XHR0aGlzLl9zY2FsZS5zZXRPbkNoYW5nZSgoKSA9PiB0aGlzLnNjYWxlQ2hhbmdlZCgpKTtcblx0XHR0aGlzLl9ib3VuZGFyeSA9IG5ldyBBQUJCKCk7XG5cdFx0dGhpcy51cGRhdGVCb3VuZGFyeSgpO1xuXG5cdFx0dGhpcy5faGFzQ3VzdG9tU2hhZGVyID0gZmFsc2U7XG5cdH1cblxuXHRnZXQgYWxwaGEoKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5fYWxwaGE7XG5cdH1cblxuXHRzZXQgYWxwaGEoYTogbnVtYmVyKSB7XG5cdFx0dGhpcy5fYWxwaGEgPSBhO1xuXHR9XG5cblx0Z2V0IHNpemUoKTogVmVjMiB7XG5cdFx0cmV0dXJuIHRoaXMuX3NpemU7XG5cdH1cblxuXHRzZXQgc2l6ZShzaXplOiBWZWMyKXtcblx0XHR0aGlzLl9zaXplID0gc2l6ZTtcblx0XHQvLyBFbnRlciBhcyBhIGxhbWJkYSB0byBiaW5kIFwidGhpc1wiXG5cdFx0dGhpcy5fc2l6ZS5zZXRPbkNoYW5nZSgoKSA9PiB0aGlzLnNpemVDaGFuZ2VkKCkpO1xuXHRcdHRoaXMuc2l6ZUNoYW5nZWQoKTtcblx0fVxuXG5cdGdldCBzY2FsZSgpOiBWZWMyIHtcblx0XHRyZXR1cm4gdGhpcy5fc2NhbGU7XG5cdH1cblxuXHRzZXQgc2NhbGUoc2NhbGU6IFZlYzIpe1xuXHRcdHRoaXMuX3NjYWxlID0gc2NhbGU7XG5cdFx0Ly8gRW50ZXIgYXMgYSBsYW1iZGEgdG8gYmluZCBcInRoaXNcIlxuXHRcdHRoaXMuX3NjYWxlLnNldE9uQ2hhbmdlKCgpID0+IHRoaXMuc2NhbGVDaGFuZ2VkKCkpO1xuXHRcdHRoaXMuc2NhbGVDaGFuZ2VkKCk7XG5cdH1cblxuXHRzZXQgc2NhbGVYKHZhbHVlOiBudW1iZXIpIHtcblx0XHR0aGlzLnNjYWxlLnggPSB2YWx1ZTtcblx0fVxuXG5cdHNldCBzY2FsZVkodmFsdWU6IG51bWJlcikge1xuXHRcdHRoaXMuc2NhbGUueSA9IHZhbHVlO1xuXHR9XG5cblx0Z2V0IGhhc0N1c3RvbVNoYWRlcigpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy5faGFzQ3VzdG9tU2hhZGVyO1xuXHR9XG5cblx0Z2V0IGN1c3RvbVNoYWRlcktleSgpOiBzdHJpbmcge1xuXHRcdHJldHVybiB0aGlzLl9jdXN0b21TaGFkZXJLZXk7XG5cdH1cblxuXHQvLyBAb3ZlcnJpZGVcblx0cHJvdGVjdGVkIHBvc2l0aW9uQ2hhbmdlZCgpOiB2b2lkIHtcblx0XHRzdXBlci5wb3NpdGlvbkNoYW5nZWQoKTtcblx0XHR0aGlzLnVwZGF0ZUJvdW5kYXJ5KCk7XG5cdH1cblxuXHQvKiogQ2FsbGVkIGlmIHRoZSBzaXplIHZlY3RvciBpcyBjaGFuZ2VkIG9yIHJlcGxhY2VkLiAqL1xuXHRwcm90ZWN0ZWQgc2l6ZUNoYW5nZWQoKTogdm9pZCB7XG5cdFx0dGhpcy51cGRhdGVCb3VuZGFyeSgpO1xuXHR9XG5cblx0LyoqIENhbGxlZCBpZiB0aGUgc2NhbGUgdmVjdG9yIGlzIGNoYW5nZWQgb3IgcmVwbGFjZWQgKi9cblx0cHJvdGVjdGVkIHNjYWxlQ2hhbmdlZCgpOiB2b2lkIHtcblx0XHR0aGlzLnVwZGF0ZUJvdW5kYXJ5KCk7XG5cdH1cblxuXHQvLyBAZG9jSWdub3JlXG5cdC8qKiBDYWxsZWQgaWYgdGhlIHBvc2l0aW9uLCBzaXplLCBvciBzY2FsZSBvZiB0aGUgQ2FudmFzTm9kZSBpcyBjaGFuZ2VkLiBVcGRhdGVzIHRoZSBib3VuZGFyeS4gKi9cblx0cHJpdmF0ZSB1cGRhdGVCb3VuZGFyeSgpOiB2b2lkIHtcblx0XHR0aGlzLl9ib3VuZGFyeS5jZW50ZXIuc2V0KHRoaXMucG9zaXRpb24ueCwgdGhpcy5wb3NpdGlvbi55KTtcblx0XHR0aGlzLl9ib3VuZGFyeS5oYWxmU2l6ZS5zZXQodGhpcy5zaXplLngqdGhpcy5zY2FsZS54LzIsIHRoaXMuc2l6ZS55KnRoaXMuc2NhbGUueS8yKTtcblx0fVxuXG5cdGdldCBib3VuZGFyeSgpOiBBQUJCIHtcblx0XHRyZXR1cm4gdGhpcy5fYm91bmRhcnk7XG5cdH1cblxuXHRnZXQgc2l6ZVdpdGhab29tKCk6IFZlYzIge1xuXHRcdGxldCB6b29tID0gdGhpcy5zY2VuZS5nZXRWaWV3U2NhbGUoKTtcblxuXHRcdHJldHVybiB0aGlzLmJvdW5kYXJ5LmhhbGZTaXplLmNsb25lKCkuc2NhbGVkKHpvb20sIHpvb20pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBjdXN0b20gc2hhZGVyIHRvIHRoaXMgQ2FudmFzTm9kZVxuXHQgKiBAcGFyYW0ga2V5IFRoZSByZWdpc3RyeSBrZXkgb2YgdGhlIFNoYWRlclR5cGVcblx0ICovXG5cdHVzZUN1c3RvbVNoYWRlcihrZXk6IHN0cmluZyk6IHZvaWQge1xuXHRcdHRoaXMuX2hhc0N1c3RvbVNoYWRlciA9IHRydWU7XG5cdFx0dGhpcy5fY3VzdG9tU2hhZGVyS2V5ID0ga2V5O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcG9pbnQgKHgsIHkpIGlzIGluc2lkZSBvZiB0aGlzIGNhbnZhcyBvYmplY3Rcblx0ICogQHBhcmFtIHggVGhlIHggcG9zaXRpb24gb2YgdGhlIHBvaW50XG5cdCAqIEBwYXJhbSB5IFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBwb2ludFxuXHQgKiBAcmV0dXJucyBBIGZsYWcgcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoaXMgbm9kZSBjb250YWlucyB0aGUgcG9pbnQuXG5cdCAqL1xuXHRjb250YWlucyh4OiBudW1iZXIsIHk6IG51bWJlcik6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0aGlzLl9ib3VuZGFyeS5jb250YWluc1BvaW50KG5ldyBWZWMyKHgsIHkpKTtcblx0fVxuXG5cdC8vIEBpbXBsZW1lbnRlZFxuXHRkZWJ1Z1JlbmRlcigpOiB2b2lkIHtcblx0XHREZWJ1Zy5kcmF3Qm94KHRoaXMucmVsYXRpdmVQb3NpdGlvbiwgdGhpcy5zaXplV2l0aFpvb20sIGZhbHNlLCBDb2xvci5CTFVFKTtcblx0XHRzdXBlci5kZWJ1Z1JlbmRlcigpO1xuXHR9XG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSBcIi4uL0V2ZW50cy9SZWNlaXZlclwiO1xuaW1wb3J0IEVtaXR0ZXIgZnJvbSBcIi4uL0V2ZW50cy9FbWl0dGVyXCI7XG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lL1NjZW5lXCI7XG5pbXBvcnQgTGF5ZXIgZnJvbSBcIi4uL1NjZW5lL0xheWVyXCI7XG5pbXBvcnQgQUkgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL0FJXCI7XG5pbXBvcnQgUGh5c2ljYWwgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1BoeXNpY2FsXCI7XG5pbXBvcnQgUG9zaXRpb25lZCBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvUG9zaXRpb25lZFwiO1xuaW1wb3J0IHsgaXNSZWdpb24gfSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvUmVnaW9uXCI7XG5pbXBvcnQgVW5pcXVlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VbmlxdWVcIjtcbmltcG9ydCBVcGRhdGVhYmxlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VcGRhdGVhYmxlXCI7XG5pbXBvcnQgRGVidWdSZW5kZXJhYmxlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9EZWJ1Z1JlbmRlcmFibGVcIjtcbmltcG9ydCBBY3RvciBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvQWN0b3JcIjtcbmltcG9ydCBTaGFwZSBmcm9tIFwiLi4vRGF0YVR5cGVzL1NoYXBlcy9TaGFwZVwiO1xuaW1wb3J0IEFBQkIgZnJvbSBcIi4uL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xuaW1wb3J0IE5hdmlnYXRpb25QYXRoIGZyb20gXCIuLi9QYXRoZmluZGluZy9OYXZpZ2F0aW9uUGF0aFwiO1xuaW1wb3J0IFR3ZWVuQ29udHJvbGxlciBmcm9tIFwiLi4vUmVuZGVyaW5nL0FuaW1hdGlvbnMvVHdlZW5Db250cm9sbGVyXCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uL0RlYnVnL0RlYnVnXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1V0aWxzL0NvbG9yXCI7XG5pbXBvcnQgQ2lyY2xlIGZyb20gXCIuLi9EYXRhVHlwZXMvU2hhcGVzL0NpcmNsZVwiO1xuaW1wb3J0IEdvYXBBSSBmcm9tIFwiLi4vRGF0YVR5cGVzL0dvYXAvR29hcEFJXCI7XG5cbi8qKlxuICogVGhlIHJlcHJlc2VudGF0aW9uIG9mIGFuIG9iamVjdCBpbiB0aGUgZ2FtZSB3b3JsZC5cbiAqIFRvIGNvbnN0cnVjdCBHYW1lTm9kZXMsIHNlZSB0aGUgQHJlZmVyZW5jZVtTY2VuZV0gZG9jdW1lbnRhdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgR2FtZU5vZGUgaW1wbGVtZW50cyBQb3NpdGlvbmVkLCBVbmlxdWUsIFVwZGF0ZWFibGUsIFBoeXNpY2FsLCBBY3RvciwgRGVidWdSZW5kZXJhYmxlIHtcblx0LyotLS0tLS0tLS0tIFBPU0lUSU9ORUQgLS0tLS0tLS0tLSovXG5cdHByaXZhdGUgX3Bvc2l0aW9uOiBWZWMyO1xuXG5cdC8qLS0tLS0tLS0tLSBVTklRVUUgLS0tLS0tLS0tLSovXG5cdHByaXZhdGUgX2lkOiBudW1iZXI7XG5cblx0LyotLS0tLS0tLS0tIFBIWVNJQ0FMIC0tLS0tLS0tLS0qL1xuXHRoYXNQaHlzaWNzOiBib29sZWFuID0gZmFsc2U7XG5cdG1vdmluZzogYm9vbGVhbiA9IGZhbHNlO1xuXHRmcm96ZW46IGJvb2xlYW4gPSBmYWxzZTtcblx0b25Hcm91bmQ6IGJvb2xlYW4gPSBmYWxzZTtcblx0b25XYWxsOiBib29sZWFuID0gZmFsc2U7XG5cdG9uQ2VpbGluZzogYm9vbGVhbiA9IGZhbHNlO1xuXHRhY3RpdmU6IGJvb2xlYW4gPSBmYWxzZTtcblx0Y29sbGlzaW9uU2hhcGU6IFNoYXBlO1xuXHRjb2xsaWRlck9mZnNldDogVmVjMjtcblx0aXNTdGF0aWM6IGJvb2xlYW47XG5cdGlzQ29sbGlkYWJsZTogYm9vbGVhbjtcblx0aXNUcmlnZ2VyOiBib29sZWFuO1xuXHR0cmlnZ2VyTWFzazogbnVtYmVyO1xuXHR0cmlnZ2VyRW50ZXJzOiBBcnJheTxzdHJpbmc+O1xuXHR0cmlnZ2VyRXhpdHM6IEFycmF5PHN0cmluZz47XG5cdF92ZWxvY2l0eTogVmVjMjtcblx0c3dlcHRSZWN0OiBBQUJCO1xuXHRjb2xsaWRlZFdpdGhUaWxlbWFwOiBib29sZWFuO1xuXHRncm91cDogbnVtYmVyO1xuXHRpc1BsYXllcjogYm9vbGVhbjtcblx0aXNDb2xsaWRpbmc6IGJvb2xlYW4gPSBmYWxzZTtcblxuXHQvKi0tLS0tLS0tLS0gQUNUT1IgLS0tLS0tLS0tLSovXG5cdF9haTogQUkgfCBHb2FwQUk7XG5cdGFpQWN0aXZlOiBib29sZWFuO1xuXHRwYXRoOiBOYXZpZ2F0aW9uUGF0aDtcblx0cGF0aGZpbmRpbmc6IGJvb2xlYW4gPSBmYWxzZTtcblxuXHQvKi0tLS0tLS0tLS0gR0VORVJBTCAtLS0tLS0tLS0tKi9cblx0LyoqIEFuIGV2ZW50IHJlY2VpdmVyLiAqL1xuXHRwcm90ZWN0ZWQgcmVjZWl2ZXI6IFJlY2VpdmVyO1xuXHQvKiogQW4gZXZlbnQgZW1pdHRlci4gKi9cblx0cHJvdGVjdGVkIGVtaXR0ZXI6IEVtaXR0ZXI7XG5cdC8qKiBBIHJlZmVyZW5jZSB0byB0aGUgc2NlbmUgdGhpcyBHYW1lTm9kZSBpcyBhIHBhcnQgb2YuICovXG5cdHByb3RlY3RlZCBzY2VuZTogU2NlbmU7XG5cdC8qKiBUaGUgdmlzdWFsIGxheWVyIHRoaXMgR2FtZU5vZGUgcmVzaWRlcyBpbi4gKi9cblx0cHJvdGVjdGVkIGxheWVyOiBMYXllcjtcblx0LyoqIEEgdXRpbGl0eSB0aGF0IGFsbG93cyB0aGUgdXNlIG9mIHR3ZWVucyBvbiB0aGlzIEdhbWVOb2RlICovXG5cdHR3ZWVuczogVHdlZW5Db250cm9sbGVyO1xuXHQvKiogQSB0d2VlbmFibGUgcHJvcGVydHkgZm9yIHJvdGF0aW9uLiBEb2VzIG5vdCBhZmZlY3QgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGlzIEdhbWVOb2RlIC0gT25seSByZW5kZXJpbmcuICovXG5cdHJvdGF0aW9uOiBudW1iZXI7XG5cdC8qKiBUaGUgb3BhY2l0eSB2YWx1ZSBvZiB0aGlzIEdhbWVOb2RlICovXG5cdGFic3RyYWN0IHNldCBhbHBoYShhOiBudW1iZXIpO1xuXG5cdGFic3RyYWN0IGdldCBhbHBoYSgpOiBudW1iZXI7XG5cblx0Ly8gQ29uc3RydWN0b3IgZG9jcyBhcmUgaWdub3JlZCwgYXMgdGhlIHVzZXIgc2hvdWxkIE5PVCBjcmVhdGUgbmV3IEdhbWVOb2RlcyB3aXRoIGEgcmF3IGNvbnN0cnVjdG9yXG5cdGNvbnN0cnVjdG9yKCl7XG5cdFx0dGhpcy5fcG9zaXRpb24gPSBuZXcgVmVjMigwLCAwKTtcblx0XHR0aGlzLl9wb3NpdGlvbi5zZXRPbkNoYW5nZSgoKSA9PiB0aGlzLnBvc2l0aW9uQ2hhbmdlZCgpKTtcblx0XHR0aGlzLnJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKCk7XG5cdFx0dGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcblx0XHR0aGlzLnR3ZWVucyA9IG5ldyBUd2VlbkNvbnRyb2xsZXIodGhpcyk7XG5cdFx0dGhpcy5yb3RhdGlvbiA9IDA7XG5cdH1cblxuXHRkZXN0cm95KCl7XG5cdFx0dGhpcy50d2VlbnMuZGVzdHJveSgpO1xuXHRcdHRoaXMucmVjZWl2ZXIuZGVzdHJveSgpO1xuXG5cdFx0aWYodGhpcy5oYXNQaHlzaWNzKXtcblx0XHRcdHRoaXMucmVtb3ZlUGh5c2ljcygpO1xuXHRcdH1cblxuXHRcdGlmKHRoaXMuX2FpKXtcblx0XHRcdHRoaXMuX2FpLmRlc3Ryb3koKTtcblx0XHRcdGRlbGV0ZSB0aGlzLl9haTtcblx0XHRcdHRoaXMuc2NlbmUuZ2V0QUlNYW5hZ2VyKCkucmVtb3ZlQWN0b3IodGhpcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zY2VuZS5yZW1vdmUodGhpcyk7XG5cblx0XHR0aGlzLmxheWVyLnJlbW92ZU5vZGUodGhpcyk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0gUE9TSVRJT05FRCAtLS0tLS0tLS0tKi9cblx0Z2V0IHBvc2l0aW9uKCk6IFZlYzIge1xuXHRcdHJldHVybiB0aGlzLl9wb3NpdGlvbjtcblx0fVxuXG5cdHNldCBwb3NpdGlvbihwb3M6IFZlYzIpIHtcblx0XHR0aGlzLl9wb3NpdGlvbiA9IHBvcztcblx0XHR0aGlzLl9wb3NpdGlvbi5zZXRPbkNoYW5nZSgoKSA9PiB0aGlzLnBvc2l0aW9uQ2hhbmdlZCgpKTtcblx0XHR0aGlzLnBvc2l0aW9uQ2hhbmdlZCgpO1xuXHR9XG5cblx0Z2V0IHJlbGF0aXZlUG9zaXRpb24oKTogVmVjMiB7XG5cdFx0cmV0dXJuIHRoaXMuaW5SZWxhdGl2ZUNvb3JkaW5hdGVzKHRoaXMucG9zaXRpb24pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgcG9pbnQgdG8gY29vcmRpbmF0ZXMgcmVsYXRpdmUgdG8gdGhlIHpvb20gYW5kIG9yaWdpbiBvZiB0aGlzIG5vZGVcblx0ICogQHBhcmFtIHBvaW50IFRoZSBwb2ludCB0byBjb252ZXJcblx0ICogQHJldHVybnMgQSBuZXcgVmVjMiByZXByZXNlbnRpbmcgdGhlIHBvaW50IGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzXG5cdCAqL1xuXHRpblJlbGF0aXZlQ29vcmRpbmF0ZXMocG9pbnQ6IFZlYzIpOiBWZWMyIHtcblx0XHRsZXQgb3JpZ2luID0gdGhpcy5zY2VuZS5nZXRWaWV3VHJhbnNsYXRpb24odGhpcyk7XG5cdFx0bGV0IHpvb20gPSB0aGlzLnNjZW5lLmdldFZpZXdTY2FsZSgpO1xuXHRcdHJldHVybiBwb2ludC5jbG9uZSgpLnN1YihvcmlnaW4pLnNjYWxlKHpvb20pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tIFVOSVFVRSAtLS0tLS0tLS0tKi9cblx0Z2V0IGlkKCk6IG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMuX2lkO1xuXHR9XG5cblx0c2V0IGlkKGlkOiBudW1iZXIpIHtcblx0XHQvLyBpZCBjYW4gb25seSBiZSBzZXQgb25jZVxuXHRcdGlmKHRoaXMuX2lkID09PSB1bmRlZmluZWQpe1xuXHRcdFx0dGhpcy5faWQgPSBpZDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgXCJBdHRlbXB0ZWQgdG8gYXNzaWduIGlkIHRvIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIGlkLlwiXG5cdFx0fVxuXHR9XG5cblx0LyotLS0tLS0tLS0tIFBIWVNJQ0FMIC0tLS0tLS0tLS0qL1xuXHQvLyBAaW1wbGVtZW50ZWRcblx0LyoqXG4gICAgICogQHBhcmFtIHZlbG9jaXR5IFRoZSB2ZWxvY2l0eSB3aXRoIHdoaWNoIHRvIG1vdmUgdGhlIG9iamVjdC5cbiAgICAgKi9cblx0bW92ZSh2ZWxvY2l0eTogVmVjMik6IHZvaWQge1xuXHRcdGlmKHRoaXMuZnJvemVuKSByZXR1cm47XG5cdFx0dGhpcy5tb3ZpbmcgPSB0cnVlO1xuXHRcdHRoaXMuX3ZlbG9jaXR5ID0gdmVsb2NpdHk7XG5cdH07XG5cblx0bW92ZU9uUGF0aChzcGVlZDogbnVtYmVyLCBwYXRoOiBOYXZpZ2F0aW9uUGF0aCk6IHZvaWQge1xuXHRcdGlmKHRoaXMuZnJvemVuIHx8IHBhdGguaXNEb25lKCkpIHJldHVybjtcblx0XHR0aGlzLnBhdGggPSBwYXRoO1xuXHRcdGxldCBkaXIgPSBwYXRoLmdldE1vdmVEaXJlY3Rpb24odGhpcyk7XG5cdFx0dGhpcy5tb3ZpbmcgPSB0cnVlO1xuXHRcdHRoaXMucGF0aGZpbmRpbmcgPSB0cnVlO1xuXHRcdHRoaXMuX3ZlbG9jaXR5ID0gZGlyLnNjYWxlKHNwZWVkKTtcblx0fVxuXG5cdC8vIEBpbXBsZW1lbnRlZFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB2ZWxvY2l0eSBUaGUgdmVsb2NpdHkgd2l0aCB3aGljaCB0aGUgb2JqZWN0IHdpbGwgbW92ZS5cbiAgICAgKi9cblx0ZmluaXNoTW92ZSgpOiB2b2lkIHtcblx0XHR0aGlzLm1vdmluZyA9IGZhbHNlO1xuXHRcdHRoaXMucG9zaXRpb24uYWRkKHRoaXMuX3ZlbG9jaXR5KTtcblx0XHRpZih0aGlzLnBhdGhmaW5kaW5nKXtcblx0XHRcdHRoaXMucGF0aC5oYW5kbGVQYXRoUHJvZ3Jlc3ModGhpcyk7XG5cdFx0XHR0aGlzLnBhdGggPSBudWxsO1xuXHRcdFx0dGhpcy5wYXRoZmluZGluZyA9IGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8vIEBpbXBsZW1lbnRlZFxuXHQvKipcblx0ICogQHBhcmFtIGNvbGxpc2lvblNoYXBlIFRoZSBjb2xsaWRlciBmb3IgdGhpcyBvYmplY3QuIElmIHRoaXMgaGFzIGEgcmVnaW9uIChpbXBsZW1lbnRzIFJlZ2lvbiksXG5cdCAqIGl0IHdpbGwgYmUgdXNlZCB3aGVuIG5vIGNvbGxpc2lvbiBzaGFwZSBpcyBzcGVjaWZpZWQgKG9yIGlmIGNvbGxpc2lvbiBzaGFwZSBpcyBudWxsKS5cblx0ICogQHBhcmFtIGlzQ29sbGlkYWJsZSBXaGV0aGVyIHRoaXMgaXMgY29sbGlkYWJsZSBvciBub3QuIFRydWUgYnkgZGVmYXVsdC5cblx0ICogQHBhcmFtIGlzU3RhdGljIFdoZXRoZXIgdGhpcyBpcyBzdGF0aWMgb3Igbm90LiBGYWxzZSBieSBkZWZhdWx0XG5cdCAqL1xuXHRhZGRQaHlzaWNzKGNvbGxpc2lvblNoYXBlPzogU2hhcGUsIGNvbGxpZGVyT2Zmc2V0PzogVmVjMiwgaXNDb2xsaWRhYmxlOiBib29sZWFuID0gdHJ1ZSwgaXNTdGF0aWM6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xuXHRcdC8vIEluaXRpYWxpemUgdGhlIHBoeXNpY3MgdmFyaWFibGVzXG5cdFx0dGhpcy5oYXNQaHlzaWNzID0gdHJ1ZTtcblx0XHR0aGlzLm1vdmluZyA9IGZhbHNlO1xuXHRcdHRoaXMub25Hcm91bmQgPSBmYWxzZTtcblx0XHR0aGlzLm9uV2FsbCA9IGZhbHNlO1xuXHRcdHRoaXMub25DZWlsaW5nID0gZmFsc2U7XG5cdFx0dGhpcy5hY3RpdmUgPSB0cnVlO1xuXHRcdHRoaXMuaXNDb2xsaWRhYmxlID0gaXNDb2xsaWRhYmxlO1xuXHRcdHRoaXMuaXNTdGF0aWMgPSBpc1N0YXRpYztcblx0XHR0aGlzLmlzVHJpZ2dlciA9IGZhbHNlO1xuXHRcdHRoaXMudHJpZ2dlck1hc2sgPSAwO1xuXHRcdHRoaXMudHJpZ2dlckVudGVycyA9IG5ldyBBcnJheSgzMik7XG5cdFx0dGhpcy50cmlnZ2VyRXhpdHMgPSBuZXcgQXJyYXkoMzIpO1xuXHRcdHRoaXMuX3ZlbG9jaXR5ID0gVmVjMi5aRVJPO1xuXHRcdHRoaXMuc3dlcHRSZWN0ID0gbmV3IEFBQkIoKTtcblx0XHR0aGlzLmNvbGxpZGVkV2l0aFRpbGVtYXAgPSBmYWxzZTtcblx0XHR0aGlzLmdyb3VwID0gLTE7XHRcdFx0XHRcdC8vIFRoZSBkZWZhdWx0IGdyb3VwLCBjb2xsaWRlcyB3aXRoIGV2ZXJ5dGhpbmdcblxuXHRcdC8vIFNldCB0aGUgY29sbGlzaW9uIHNoYXBlIGlmIHByb3ZpZGVkLCBvciBzaW1wbHkgdXNlIHRoZSB0aGUgcmVnaW9uIGlmIHRoZXJlIGlzIG9uZS5cblx0XHRpZihjb2xsaXNpb25TaGFwZSl7XG5cdFx0XHR0aGlzLmNvbGxpc2lvblNoYXBlID0gY29sbGlzaW9uU2hhcGU7XG5cdFx0XHR0aGlzLmNvbGxpc2lvblNoYXBlLmNlbnRlciA9IHRoaXMucG9zaXRpb247XG5cdFx0fSBlbHNlIGlmIChpc1JlZ2lvbih0aGlzKSkge1xuXHRcdFx0Ly8gSWYgdGhlIGdhbWVub2RlIGhhcyBhIHJlZ2lvbiBhbmQgbm8gb3RoZXIgaXMgc3BlY2lmaWVkLCB1c2UgdGhhdFxuXHRcdFx0dGhpcy5jb2xsaXNpb25TaGFwZSA9ICg8YW55PnRoaXMpLmJvdW5kYXJ5LmNsb25lKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IFwiTm8gY29sbGlzaW9uIHNoYXBlIHNwZWNpZmllZCBmb3IgcGh5c2ljcyBvYmplY3QuXCJcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSB3ZXJlIHByb3ZpZGVkIHdpdGggYSBjb2xsaWRlciBvZmZzZXQsIHNldCBpdC4gT3RoZXJ3aXNlIHRoZXJlIGlzIG5vIG9mZnNldCwgc28gdXNlIHRoZSB6ZXJvIHZlY3RvclxuXHRcdGlmKGNvbGxpZGVyT2Zmc2V0KXtcblx0XHRcdHRoaXMuY29sbGlkZXJPZmZzZXQgPSBjb2xsaWRlck9mZnNldDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5jb2xsaWRlck9mZnNldCA9IFZlYzIuWkVSTztcblx0XHR9XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzd2VwdCByZWN0XG5cdFx0dGhpcy5zd2VwdFJlY3QgPSB0aGlzLmNvbGxpc2lvblNoYXBlLmdldEJvdW5kaW5nUmVjdCgpO1xuXG5cdFx0Ly8gUmVnaXN0ZXIgdGhlIG9iamVjdCB3aXRoIHBoeXNpY3Ncblx0XHR0aGlzLnNjZW5lLmdldFBoeXNpY3NNYW5hZ2VyKCkucmVnaXN0ZXJPYmplY3QodGhpcyk7XG5cdH1cblxuXHQvKiogUmVtb3ZlcyB0aGlzIG9iamVjdCBmcm9tIHRoZSBwaHlzaWNzIHN5c3RlbSAqL1xuICAgIHJlbW92ZVBoeXNpY3MoKTogdm9pZCB7XG5cdFx0Ly8gUmVtb3ZlIHRoaXMgZnJvbSB0aGUgcGh5c2ljcyBtYW5hZ2VyXG5cdFx0dGhpcy5zY2VuZS5nZXRQaHlzaWNzTWFuYWdlcigpLmRlcmVnaXN0ZXJPYmplY3QodGhpcyk7XG5cblx0XHQvLyBOdWxsaWZ5IGFsbCBwaHlzaWNzIGZpZWxkc1xuXHRcdHRoaXMuaGFzUGh5c2ljcyA9IGZhbHNlO1xuXHRcdHRoaXMubW92aW5nID0gZmFsc2U7XG5cdFx0dGhpcy5vbkdyb3VuZCA9IGZhbHNlO1xuXHRcdHRoaXMub25XYWxsID0gZmFsc2U7XG5cdFx0dGhpcy5vbkNlaWxpbmcgPSBmYWxzZTtcblx0XHR0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuXHRcdHRoaXMuaXNDb2xsaWRhYmxlID0gZmFsc2U7XG5cdFx0dGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xuXHRcdHRoaXMuaXNUcmlnZ2VyID0gZmFsc2U7XG5cdFx0dGhpcy50cmlnZ2VyTWFzayA9IDA7XG5cdFx0dGhpcy50cmlnZ2VyRW50ZXJzID0gbnVsbDtcblx0XHR0aGlzLnRyaWdnZXJFeGl0cyA9IG51bGw7XG5cdFx0dGhpcy5fdmVsb2NpdHkgPSBWZWMyLlpFUk87XG5cdFx0dGhpcy5zd2VwdFJlY3QgPSBudWxsO1xuXHRcdHRoaXMuY29sbGlkZWRXaXRoVGlsZW1hcCA9IGZhbHNlO1xuXHRcdHRoaXMuZ3JvdXAgPSAtMTtcblx0XHR0aGlzLmNvbGxpc2lvblNoYXBlID0gbnVsbDtcblx0XHR0aGlzLmNvbGxpZGVyT2Zmc2V0ID0gVmVjMi5aRVJPO1xuXHRcdHRoaXMuc3dlcHRSZWN0ID0gbnVsbDtcblx0fVxuXG5cdC8qKiBEaXNhYmxlcyBwaHlzaWNzIG1vdmVtZW50IGZvciB0aGlzIG5vZGUgKi9cblx0ZnJlZXplKCk6IHZvaWQge1xuXHRcdHRoaXMuZnJvemVuID0gdHJ1ZTtcblx0fVxuXG5cdC8qKiBSZWVuYWJsZXMgcGh5c2ljcyBtb3ZlbWVudCBmb3IgdGhpcyBub2RlICovXG5cdHVuZnJlZXplKCk6IHZvaWQge1xuXHRcdHRoaXMuZnJvemVuID0gZmFsc2U7XG5cdH1cblxuICAgIC8qKiBQcmV2ZW50cyB0aGlzIG9iamVjdCBmcm9tIHBhcnRpY2lwYXRpbmcgaW4gYWxsIGNvbGxpc2lvbnMgYW5kIHRyaWdnZXJzLiBJdCBjYW4gc3RpbGwgbW92ZS4gKi9cbiAgICBkaXNhYmxlUGh5c2ljcygpOiB2b2lkIHtcblx0XHR0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuXHR9XG5cbiAgICAvKiogRW5hYmxlcyB0aGlzIG9iamVjdCB0byBwYXJ0aWNpcGF0ZSBpbiBjb2xsaXNpb25zIGFuZCB0cmlnZ2Vycy4gVGhpcyBpcyBvbmx5IG5lY2Vzc2FyeSBpZiBkaXNhYmxlUGh5c2ljcyB3YXMgY2FsbGVkICovXG4gICAgZW5hYmxlUGh5c2ljcygpOiB2b2lkIHtcblx0XHR0aGlzLmFjdGl2ZSA9IHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgY29sbGlkZXIgZm9yIHRoaXMgR2FtZU5vZGVcblx0ICogQHBhcmFtIGNvbGxpZGVyIFRoZSBuZXcgY29sbGlkZXIgdG8gdXNlXG5cdCAqL1xuXHRzZXRDb2xsaXNpb25TaGFwZShjb2xsaWRlcjogU2hhcGUpOiB2b2lkIHtcblx0XHR0aGlzLmNvbGxpc2lvblNoYXBlID0gY29sbGlkZXI7XG5cdFx0dGhpcy5jb2xsaXNpb25TaGFwZS5jZW50ZXIuY29weSh0aGlzLnBvc2l0aW9uKTtcblx0fVxuXG5cdC8vIEBpbXBsZW1lbnRlZFxuXHQvKipcbiAgICAgKiBTZXRzIHRoaXMgb2JqZWN0IHRvIGJlIGEgdHJpZ2dlciBmb3IgYSBzcGVjaWZpYyBncm91cFxuICAgICAqIEBwYXJhbSBncm91cCBUaGUgbmFtZSBvZiB0aGUgZ3JvdXAgdGhhdCBhY3RpdmF0ZXMgdGhlIHRyaWdnZXJcbiAgICAgKiBAcGFyYW0gb25FbnRlciBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gc2VuZCB3aGVuIHRoaXMgdHJpZ2dlciBpcyBhY3RpdmF0ZWRcbiAgICAgKiBAcGFyYW0gb25FeGl0IFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzZW5kIHdoZW4gdGhpcyB0cmlnZ2VyIHN0b3BzIGJlaW5nIGFjdGl2YXRlZFxuICAgICAqL1xuICAgIHNldFRyaWdnZXIoZ3JvdXA6IHN0cmluZywgb25FbnRlcjogc3RyaW5nLCBvbkV4aXQ6IHN0cmluZyk6IHZvaWQge1xuXHRcdC8vIE1ha2UgdGhpcyBvYmplY3QgYSB0cmlnZ2VyXG5cdFx0dGhpcy5pc1RyaWdnZXIgPSB0cnVlO1xuXG5cdFx0Ly8gR2V0IHRoZSBudW1iZXIgb2YgdGhlIHBoeXNpY3MgbGF5ZXJcblx0XHRsZXQgbGF5ZXJOdW1iZXIgPSB0aGlzLnNjZW5lLmdldFBoeXNpY3NNYW5hZ2VyKCkuZ2V0R3JvdXBOdW1iZXIoZ3JvdXApO1xuXG5cdFx0aWYobGF5ZXJOdW1iZXIgPT09IDApe1xuXHRcdFx0Y29uc29sZS53YXJuKGBUcmlnZ2VyIGZvciBHYW1lTm9kZSAke3RoaXMuaWR9IG5vdCBzZXQgLSBncm91cCBcIiR7Z3JvdXB9XCIgd2FzIG5vdCByZWNvZ25pemVkIGJ5IHRoZSBwaHlzaWNzIG1hbmFnZXIuYCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoaXMgdG8gdGhlIHRyaWdnZXIgbWFza1xuXHRcdHRoaXMudHJpZ2dlck1hc2sgfD0gbGF5ZXJOdW1iZXI7XG5cblx0XHQvLyBMYXllciBudW1iZXJzIGFyZSBiaXRzLCBzbyBnZXQgd2hpY2ggYml0IGl0IGlzXG5cdFx0bGV0IGluZGV4ID0gTWF0aC5sb2cyKGxheWVyTnVtYmVyKTtcblxuXHRcdC8vIFNldCB0aGUgZXZlbnQgbmFtZXNcblx0XHR0aGlzLnRyaWdnZXJFbnRlcnNbaW5kZXhdID0gb25FbnRlcjtcblx0XHR0aGlzLnRyaWdnZXJFeGl0c1tpbmRleF0gPSBvbkV4aXQ7XG5cdH07XG5cblx0Ly8gQGltcGxlbWVudGVkXG5cdC8qKlxuXHQgKiBAcGFyYW0gZ3JvdXAgVGhlIHBoeXNpY3MgZ3JvdXAgdGhpcyBub2RlIHNob3VsZCBiZWxvbmcgdG9cblx0ICovXG5cdHNldEdyb3VwKGdyb3VwOiBzdHJpbmcpOiB2b2lkIHtcblx0XHR0aGlzLnNjZW5lLmdldFBoeXNpY3NNYW5hZ2VyKCkuc2V0R3JvdXAodGhpcywgZ3JvdXApO1xuXHR9XG5cblx0Ly8gQGltcGxlbWVuZWRcblx0Z2V0TGFzdFZlbG9jaXR5KCk6IFZlYzIge1xuXHRcdHJldHVybiB0aGlzLl92ZWxvY2l0eTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLSBBQ1RPUiAtLS0tLS0tLS0tKi9cblx0Z2V0IGFpKCk6IEFJIHwgR29hcEFJIHtcblx0XHRyZXR1cm4gdGhpcy5fYWk7XG5cdH1cblxuXHRzZXQgYWkoYWk6IEFJIHwgR29hcEFJKSB7XG5cdFx0aWYoIXRoaXMuX2FpKXtcblx0XHRcdC8vIElmIHdlIGhhdmVuJ3QgYmVlbiBwcmV2aW91c2x5IGhhZCBhbiBhaSwgcmVnaXN0ZXIgdXMgd2l0aCB0aGUgYWkgbWFuYWdlclxuXHRcdFx0dGhpcy5zY2VuZS5nZXRBSU1hbmFnZXIoKS5yZWdpc3RlckFjdG9yKHRoaXMpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2FpID0gYWk7XG5cdFx0dGhpcy5haUFjdGl2ZSA9IHRydWU7XG5cdH1cblxuXHQvLyBAaW1wbGVtZW50ZWRcblx0YWRkQUk8VCBleHRlbmRzIEFJIHwgR29hcEFJPihhaTogc3RyaW5nIHwgKG5ldyAoKSA9PiBUKSwgb3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4sIHR5cGU/OiBudW1iZXIpOiB2b2lkIHtcblx0XHRpZighdGhpcy5fYWkpe1xuXHRcdFx0dGhpcy5zY2VuZS5nZXRBSU1hbmFnZXIoKS5yZWdpc3RlckFjdG9yKHRoaXMpO1xuXHRcdH1cblxuXHRcdGlmKHR5cGVvZiBhaSA9PT0gXCJzdHJpbmdcIil7XG5cdFx0XHR0aGlzLl9haSA9IHRoaXMuc2NlbmUuZ2V0QUlNYW5hZ2VyKCkuZ2VuZXJhdGVBSShhaSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2FpID0gbmV3IGFpKCk7XG5cdFx0fVxuXG5cdFx0Ly8gUXVlc3Rpb24sIGhvdyBtdWNoIGRvIHdlIHdhbnQgZGlmZmVyZW50IHR5cGUgb2YgQUkgdG8gYmUgaGFuZGxlZCB0aGUgc2FtZSwgaS5lLiBzaG91bGQgR29hcEFJIGFuZCBBSSBzaW1pbGFyIG1ldGhvZHMgYW5kIHNpZ25hdHVyZXMgZm9yIHRoZSBzYWtlIG9mIHVuaXR5XG5cdFx0dGhpcy5fYWkuaW5pdGlhbGl6ZUFJKHRoaXMsIG9wdGlvbnMpO1xuXG5cdFx0dGhpcy5haUFjdGl2ZSA9IHRydWU7XG5cdH1cblxuXHQvLyBAaW1wbGVtZW50ZWRcblx0c2V0QUlBY3RpdmUoYWN0aXZlOiBib29sZWFuLCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XG5cdFx0dGhpcy5haUFjdGl2ZSA9IGFjdGl2ZTtcblx0XHRpZih0aGlzLmFpQWN0aXZlKXtcblx0XHRcdHRoaXMuYWkuYWN0aXZhdGUob3B0aW9ucyk7XG5cdFx0fVxuXHR9XG5cblx0LyotLS0tLS0tLS0tIFRXRUVOQUJMRSBQUk9QRVJUSUVTIC0tLS0tLS0tLS0qL1xuXHRzZXQgcG9zaXRpb25YKHZhbHVlOiBudW1iZXIpIHtcblx0XHR0aGlzLnBvc2l0aW9uLnggPSB2YWx1ZTtcblx0fVxuXG5cdHNldCBwb3NpdGlvblkodmFsdWU6IG51bWJlcikge1xuXHRcdHRoaXMucG9zaXRpb24ueSA9IHZhbHVlO1xuXHR9XG5cblx0YWJzdHJhY3Qgc2V0IHNjYWxlWCh2YWx1ZTogbnVtYmVyKTtcblxuXHRhYnN0cmFjdCBzZXQgc2NhbGVZKHZhbHVlOiBudW1iZXIpO1xuXG5cdC8qLS0tLS0tLS0tLSBHQU1FIE5PREUgLS0tLS0tLS0tLSovXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBzY2VuZSBmb3IgdGhpcyBvYmplY3QuXG5cdCAqIEBwYXJhbSBzY2VuZSBUaGUgc2NlbmUgdGhpcyBvYmplY3QgYmVsb25ncyB0by5cblx0ICovXG5cdHNldFNjZW5lKHNjZW5lOiBTY2VuZSk6IHZvaWQge1xuXHRcdHRoaXMuc2NlbmUgPSBzY2VuZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBzY2VuZSB0aGlzIG9iamVjdCBpcyBpbi4gXG5cdCAqIEByZXR1cm5zIFRoZSBzY2VuZSB0aGlzIG9iamVjdCBiZWxvbmdzIHRvXG5cdCovXG5cdGdldFNjZW5lKCk6IFNjZW5lIHtcblx0XHRyZXR1cm4gdGhpcy5zY2VuZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBsYXllciBvZiB0aGlzIG9iamVjdC5cblx0ICogQHBhcmFtIGxheWVyIFRoZSBsYXllciB0aGlzIG9iamVjdCB3aWxsIGJlIG9uLlxuXHQgKi9cblx0c2V0TGF5ZXIobGF5ZXI6IExheWVyKTogdm9pZCB7XG5cdFx0dGhpcy5sYXllciA9IGxheWVyO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGxheWVyIHRoaXMgb2JqZWN0IGlzIG9uLlxuXHQgKiBAcmV0dXJucyBUaGlzIGxheWVyIHRoaXMgb2JqZWN0IGlzIG9uLlxuXHQqL1xuXHRnZXRMYXllcigpOiBMYXllciB7XG5cdFx0cmV0dXJuIHRoaXMubGF5ZXI7XG5cdH1cblxuXHQvKiogQ2FsbGVkIGlmIHRoZSBwb3NpdGlvbiB2ZWN0b3IgaXMgbW9kaWZpZWQgb3IgcmVwbGFjZWQgKi9cblx0cHJvdGVjdGVkIHBvc2l0aW9uQ2hhbmdlZCgpOiB2b2lkIHtcblx0XHRpZih0aGlzLmNvbGxpc2lvblNoYXBlKXtcblx0XHRcdGlmKHRoaXMuY29sbGlkZXJPZmZzZXQpe1xuXHRcdFx0XHR0aGlzLmNvbGxpc2lvblNoYXBlLmNlbnRlciA9IHRoaXMucG9zaXRpb24uY2xvbmUoKS5hZGQodGhpcy5jb2xsaWRlck9mZnNldCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmNvbGxpc2lvblNoYXBlLmNlbnRlciA9IHRoaXMucG9zaXRpb24uY2xvbmUoKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGlzIEdhbWVOb2RlXG5cdCAqIEBwYXJhbSBkZWx0YVQgVGhlIHRpbWVzdGVwIG9mIHRoZSB1cGRhdGUuXG5cdCAqL1xuXHR1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcblx0XHQvLyBEZWZlciBldmVudCBoYW5kbGluZyB0byBBSS5cblx0XHR3aGlsZSh0aGlzLnJlY2VpdmVyLmhhc05leHRFdmVudCgpKXtcblx0XHRcdHRoaXMuX2FpLmhhbmRsZUV2ZW50KHRoaXMucmVjZWl2ZXIuZ2V0TmV4dEV2ZW50KCkpO1xuXHRcdH1cblx0fVxuXG5cdC8vIEBpbXBsZW1lbnRlZFxuXHRkZWJ1Z1JlbmRlcigpOiB2b2lkIHtcblx0XHQvLyBEcmF3IHRoZSBwb3NpdGlvbiBvZiB0aGlzIEdhbWVOb2RlXG5cdFx0RGVidWcuZHJhd1BvaW50KHRoaXMucmVsYXRpdmVQb3NpdGlvbiwgQ29sb3IuQkxVRSk7XG5cblx0XHQvLyBJZiB2ZWxvY2l0eSBpcyBub3QgemVybywgZHJhdyBhIHZlY3RvciBmb3IgaXRcblx0XHRpZih0aGlzLl92ZWxvY2l0eSAmJiAhdGhpcy5fdmVsb2NpdHkuaXNaZXJvKCkpe1xuXHRcdFx0RGVidWcuZHJhd1JheSh0aGlzLnJlbGF0aXZlUG9zaXRpb24sIHRoaXMuX3ZlbG9jaXR5LmNsb25lKCkuc2NhbGVUbygyMCkuYWRkKHRoaXMucmVsYXRpdmVQb3NpdGlvbiksIENvbG9yLkJMVUUpO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoaXMgaGFzIGEgY29sbGlkZXIsIGRyYXcgaXRcblx0XHRpZih0aGlzLmNvbGxpc2lvblNoYXBlKXtcblx0XHRcdGxldCBjb2xvciA9IHRoaXMuaXNDb2xsaWRpbmcgPyBDb2xvci5SRUQgOiBDb2xvci5HUkVFTjtcblxuXHRcdFx0aWYodGhpcy5pc1RyaWdnZXIpe1xuXHRcdFx0XHRjb2xvciA9IENvbG9yLk1BR0VOVEE7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGNvbG9yLmEgPSAwLjI7XG5cblx0XHRcdGlmKHRoaXMuY29sbGlzaW9uU2hhcGUgaW5zdGFuY2VvZiBBQUJCKXtcblx0XHRcdFx0RGVidWcuZHJhd0JveCh0aGlzLmluUmVsYXRpdmVDb29yZGluYXRlcyh0aGlzLmNvbGxpc2lvblNoYXBlLmNlbnRlciksIHRoaXMuY29sbGlzaW9uU2hhcGUuaGFsZlNpemUuc2NhbGVkKHRoaXMuc2NlbmUuZ2V0Vmlld1NjYWxlKCkpLCB0cnVlLCBjb2xvcik7XG5cdFx0XHR9IGVsc2UgaWYodGhpcy5jb2xsaXNpb25TaGFwZSBpbnN0YW5jZW9mIENpcmNsZSl7XG5cdFx0XHRcdERlYnVnLmRyYXdDaXJjbGUodGhpcy5pblJlbGF0aXZlQ29vcmRpbmF0ZXModGhpcy5jb2xsaXNpb25TaGFwZS5jZW50ZXIpLCB0aGlzLmNvbGxpc2lvblNoYXBlLmh3KnRoaXMuc2NlbmUuZ2V0Vmlld1NjYWxlKCksIHRydWUsIGNvbG9yKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZXhwb3J0IGVudW0gVHdlZW5hYmxlUHJvcGVydGllc3tcblx0cG9zWCA9IFwicG9zaXRpb25YXCIsXG5cdHBvc1kgPSBcInBvc2l0aW9uWVwiLFxuXHRzY2FsZVggPSBcInNjYWxlWFwiLFxuXHRzY2FsZVkgPSBcInNjYWxlWVwiLFxuXHRyb3RhdGlvbiA9IFwicm90YXRpb25cIixcblx0YWxwaGEgPSBcImFscGhhXCJcbn0iLCJpbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi9DYW52YXNOb2RlXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1V0aWxzL0NvbG9yXCI7XG5cbi8qKlxuICogVGhlIHJlcHJlc2VudGF0aW9uIG9mIGEgZ2FtZSBvYmplY3QgdGhhdCBkb2Vzbid0IHJlbHkgb24gYW55IHJlc291cmNlcyB0byByZW5kZXIgLSBpdCBpcyBkcmF3biB0byB0aGUgc2NyZWVuIGJ5IHRoZSBjYW52YXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgR3JhcGhpYyBleHRlbmRzIENhbnZhc05vZGUge1xuICAgIC8qKiBUaGUgY29sb3Igb2YgdGhlIEdyYXBoaWMgKi9cbiAgICBjb2xvcjogQ29sb3I7XG5cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbG9yID0gQ29sb3IuUkVEO1xuICAgIH1cblxuICAgIGdldCBhbHBoYSgpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLmNvbG9yLmE7XG5cdH1cblxuXHRzZXQgYWxwaGEoYTogbnVtYmVyKSB7XG5cdFx0dGhpcy5jb2xvci5hID0gYTtcblx0fVxuXG4gICAgLy8gQGRlcHJlY2F0ZWRcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb2xvciBvZiB0aGUgR3JhcGhpYy4gREVQUkVDQVRFRFxuICAgICAqIEBwYXJhbSBjb2xvciBUaGUgbmV3IGNvbG9yIG9mIHRoZSBHcmFwaGljLlxuICAgICAqL1xuICAgIHNldENvbG9yKGNvbG9yOiBDb2xvcil7XG4gICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICB9XG5cbiAgICBzZXQgY29sb3JSKHI6IG51bWJlcil7XG4gICAgICAgIHRoaXMuY29sb3IuciA9IHI7XG4gICAgfVxuXG4gICAgZ2V0IGNvbG9yUigpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xvci5yO1xuICAgIH1cblxuICAgIHNldCBjb2xvckcoZzogbnVtYmVyKXtcbiAgICAgICAgdGhpcy5jb2xvci5nID0gZztcbiAgICB9XG5cbiAgICBnZXQgY29sb3JHKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbG9yLmc7XG4gICAgfVxuXG4gICAgc2V0IGNvbG9yQihiOiBudW1iZXIpe1xuICAgICAgICB0aGlzLmNvbG9yLmIgPSBiO1xuICAgIH1cblxuICAgIGdldCBjb2xvckIoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sb3IuYjtcbiAgICB9XG59IiwiZXhwb3J0IGVudW0gR3JhcGhpY1R5cGUge1xuXHRQT0lOVCA9IFwiUE9JTlRcIixcblx0UkVDVCA9IFwiUkVDVFwiLFxuXHRMSU5FID0gXCJMSU5FXCIsXG5cdFBBUlRJQ0xFID0gXCJQQVJUSUNMRVwiXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vR3JhcGhpY1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5lIGV4dGVuZHMgR3JhcGhpYyB7XG4gICAgcHJvdGVjdGVkIF9lbmQ6IFZlYzI7XG4gICAgdGhpY2tuZXNzOiBudW1iZXI7XG5cbiAgICBjb25zdHJ1Y3RvcihzdGFydDogVmVjMiwgZW5kOiBWZWMyKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgICAgdGhpcy50aGlja25lc3MgPSAyO1xuXG4gICAgICAgIC8vIERvZXMgdGhpcyByZWFsbHkgaGF2ZSBhIG1lYW5pbmcgZm9yIGxpbmVzP1xuICAgICAgICB0aGlzLnNpemUuc2V0KDUsIDUpO1xuICAgIH1cblxuICAgIHNldCBzdGFydChwb3M6IFZlYzIpe1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zO1xuICAgIH1cblxuICAgIGdldCBzdGFydCgpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb247XG4gICAgfVxuXG4gICAgc2V0IGVuZChwb3M6IFZlYzIpe1xuICAgICAgICB0aGlzLl9lbmQgPSBwb3M7XG4gICAgfVxuXG4gICAgZ2V0IGVuZCgpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZDtcbiAgICB9XG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgUG9pbnQgZnJvbSBcIi4vUG9pbnRcIjtcblxuLyoqXG4gKiAtIFBvc2l0aW9uIFhcbi0gVmVsb2NpdHkgKHNwZWVkIGFuZCBkaXJlY3Rpb24pIFhcbi0gQ29sb3IgWFxuLSBMaWZldGltZSBcbi0gQWdlIGNhbiBiZSBoYW5kbGVkIGFzIGxpZmV0aW1lXG4tIFNoYXBlIFhcbi0gU2l6ZSBYXG4tIFRyYW5zcGFyZW5jeSBYXG4gKi9cblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJ0aWNsZSBleHRlbmRzIFBvaW50IHtcbiAgICBhZ2U6IG51bWJlcjtcblxuICAgIGluVXNlOiBib29sZWFuO1xuXG4gICAgdmVsOiBWZWMyO1xuXG4gICAgbWFzczogbnVtYmVyO1xuXG4gICAgY29uc3RydWN0b3IocG9zaXRpb246IFZlYzIsIHNpemU6IFZlYzIsIG1hc3M6IG51bWJlcikge1xuICAgICAgICAvLyBBcmUgd2UgbWFraW5nIHRoaXMgYSBjaXJjbGU/XG4gICAgICAgIHN1cGVyKHBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5pblVzZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1hc3MgPSBtYXNzO1xuICAgIH1cblxuICAgIHNldFBhcnRpY2xlQWN0aXZlKGxpZmV0aW1lOiBudW1iZXIsIHBvc2l0aW9uOiBWZWMyKSB7XG4gICAgICAgIHRoaXMuYWdlID0gbGlmZXRpbWU7XG4gICAgICAgIHRoaXMuaW5Vc2UgPSB0cnVlO1xuICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgfVxuXG4gICAgZGVjcmVtZW50QWdlKGRlY2F5OiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5hZ2UgLT0gZGVjYXk7XG4gICAgfVxuXG4gICAgc2V0UGFydGljbGVJbmFjdGl2ZSgpe1xuICAgICAgICB0aGlzLmluVXNlID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHNldCB2ZWxZKHk6IG51bWJlcil7XG4gICAgICAgIHRoaXMudmVsLnkgPSB5O1xuICAgIH1cblxuICAgIGdldCB2ZWxZKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnZlbC55O1xuICAgIH1cblxuXG59IiwiaW1wb3J0IEdyYXBoaWMgZnJvbSBcIi4uL0dyYXBoaWNcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuXG4vKiogQSBiYXNpYyBwb2ludCB0byBiZSBkcmF3biBvbiB0aGUgc2NyZWVuLiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9pbnQgZXh0ZW5kcyBHcmFwaGljIHtcblxuICAgIGNvbnN0cnVjdG9yKHBvc2l0aW9uOiBWZWMyKSB7XG4gICAgICAgIC8vIEFyZSB3ZSBtYWtpbmcgdGhpcyBhIGNpcmNsZT9cbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICB0aGlzLnNpemUuc2V0KDUsIDUpO1xuICAgIH1cbn0iLCJpbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vR3JhcGhpY1wiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL1V0aWxzL0NvbG9yXCI7XG5cbi8qKiBBIGJhc2ljIHJlY3RhbmdsZSB0byBiZSBkcmF3biBvbiB0aGUgc2NyZWVuLiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVjdCBleHRlbmRzIEdyYXBoaWMge1xuXG4gICAgLyoqIFRoZSBib3JkZXIgY29sb3Igb2YgdGhlIFJlY3QgKi9cbiAgICBib3JkZXJDb2xvcjogQ29sb3I7XG5cbiAgICAvKiogVGhlIHdpZHRoIG9mIHRoZSBib3JkZXIgKi9cbiAgICBib3JkZXJXaWR0aDogbnVtYmVyO1xuXG4gICAgY29uc3RydWN0b3IocG9zaXRpb246IFZlYzIsIHNpemU6IFZlYzIpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgIHRoaXMuYm9yZGVyQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcbiAgICAgICAgdGhpcy5ib3JkZXJXaWR0aCA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYm9yZGVyIGNvbG9yIG9mIHRoaXMgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGNvbG9yIFRoZSBib3JkZXIgY29sb3JcbiAgICAgKi9cbiAgICBzZXRCb3JkZXJDb2xvcihjb2xvcjogQ29sb3IpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5ib3JkZXJDb2xvciA9IGNvbG9yO1xuICAgIH1cblxuICAgIC8vIEBkZXByZWNhdGVkXG4gICAgZ2V0Qm9yZGVyQ29sb3IoKTogQ29sb3Ige1xuICAgICAgICByZXR1cm4gdGhpcy5ib3JkZXJDb2xvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBib3JkZXIgd2lkdGggb2YgdGhpcyByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUgaW4gcGl4ZWxzXG4gICAgICovXG4gICAgc2V0Qm9yZGVyV2lkdGgod2lkdGg6IG51bWJlcil7XG4gICAgICAgIHRoaXMuYm9yZGVyV2lkdGggPSB3aWR0aDtcbiAgICB9XG5cbiAgICBnZXRCb3JkZXJXaWR0aCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5ib3JkZXJXaWR0aDtcbiAgICB9XG59IiwiaW1wb3J0IFNwcml0ZSBmcm9tIFwiLi9TcHJpdGVcIjtcbmltcG9ydCBBbmltYXRpb25NYW5hZ2VyIGZyb20gXCIuLi8uLi9SZW5kZXJpbmcvQW5pbWF0aW9ucy9BbmltYXRpb25NYW5hZ2VyXCI7XG5pbXBvcnQgU3ByaXRlc2hlZXQgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9TcHJpdGVzaGVldFwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5cbi8qKiBBbiBzcHJpdGUgd2l0aCBzcGVjaWZpZWQgYW5pbWF0aW9uIGZyYW1lcy4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdGVkU3ByaXRlIGV4dGVuZHMgU3ByaXRlIHtcbiAgICAvKiogVGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoaXMgc3ByaXRlIHNoZWV0ICovXG4gICAgcHJvdGVjdGVkIG51bUNvbHM6IG51bWJlcjtcblxuICAgIGdldCBjb2xzKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bUNvbHM7XG4gICAgfVxuXG4gICAgLyoqIFRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGlzIHNwcml0ZSBzaGVldCAqL1xuICAgIHByb3RlY3RlZCBudW1Sb3dzOiBudW1iZXI7XG5cbiAgICBnZXQgcm93cygpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5udW1Sb3dzO1xuICAgIH1cblxuICAgIC8qKiBUaGUgYW5pbWF0aW9uTWFuYWdlciBmb3IgdGhpcyBzcHJpdGUgKi9cbiAgICBhbmltYXRpb246IEFuaW1hdGlvbk1hbmFnZXI7XG5cbiAgICBjb25zdHJ1Y3RvcihzcHJpdGVzaGVldDogU3ByaXRlc2hlZXQpe1xuICAgICAgICBzdXBlcihzcHJpdGVzaGVldC5uYW1lKTtcbiAgICAgICAgdGhpcy5udW1Db2xzID0gc3ByaXRlc2hlZXQuY29sdW1ucztcbiAgICAgICAgdGhpcy5udW1Sb3dzID0gc3ByaXRlc2hlZXQucm93cztcblxuICAgICAgICAvLyBTZXQgdGhlIHNpemUgb2YgdGhlIHNwcml0ZSB0byB0aGUgc3ByaXRlIHNpemUgc3BlY2lmaWVkIGJ5IHRoZSBzcHJpdGVzaGVldFxuICAgICAgICB0aGlzLnNpemUuc2V0KHNwcml0ZXNoZWV0LnNwcml0ZVdpZHRoLCBzcHJpdGVzaGVldC5zcHJpdGVIZWlnaHQpO1xuXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbk1hbmFnZXIodGhpcyk7XG5cbiAgICAgICAgLy8gQWRkIHRoZSBhbmltYXRpb25zIHRvIHRoZSBhbmltYXRlZCBzcHJpdGVcbiAgICAgICAgZm9yKGxldCBhbmltYXRpb24gb2Ygc3ByaXRlc2hlZXQuYW5pbWF0aW9ucyl7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5hZGQoYW5pbWF0aW9uLm5hbWUsIGFuaW1hdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbWFnZSBvZmZzZXQgZm9yIHRoZSBjdXJyZW50IGluZGV4IG9mIGFuaW1hdGlvblxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggd2UncmUgYXQgaW4gdGhlIGFuaW1hdGlvblxuICAgICAqIEByZXR1cm5zIEEgVmVjMiBjb250YWluaW5nIHRoZSBpbWFnZSBvZmZzZXRcbiAgICAgKi9cbiAgICBnZXRBbmltYXRpb25PZmZzZXQoaW5kZXg6IG51bWJlcik6IFZlYzIge1xuICAgICAgICByZXR1cm4gbmV3IFZlYzIoKGluZGV4ICUgdGhpcy5udW1Db2xzKSAqIHRoaXMuc2l6ZS54LCBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5udW1Db2xzKSAqIHRoaXMuc2l6ZS55KTtcbiAgICB9XG59IiwiaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uL0NhbnZhc05vZGVcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuXG4vKipcbiAqIFRoZSByZXByZXNlbnRhdGlvbiBvZiBhIHNwcml0ZSAtIGFuIGluLWdhbWUgaW1hZ2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3ByaXRlIGV4dGVuZHMgQ2FudmFzTm9kZSB7XG4gICAgLyoqIFRoZSBpZCBvZiB0aGUgaW1hZ2UgZnJvbSB0aGUgcmVzb3VyY2VNYW5hZ2VyICovXG4gICAgaW1hZ2VJZDogc3RyaW5nO1xuICAgIC8qKiBUaGUgb2Zmc2V0IG9mIHRoZSBzcHJpdGUgaW4gYW4gYXRsYXMgaW1hZ2UgKi9cbiAgICBpbWFnZU9mZnNldDogVmVjMjtcbiAgICAvKiogV2hldGhlciBvciBub3QgdGhlIHgtYXhpcyBzaG91bGQgYmUgaW52ZXJ0ZWQgb24gcmVuZGVyICovXG4gICAgaW52ZXJ0WDogYm9vbGVhbjtcbiAgICAvKiogV2hldGhlciBvciBub3QgdGhlIHktYXhpcyBzaG91bGQgYmUgaW52ZXJ0ZWQgb24gcmVuZGVyICovXG4gICAgaW52ZXJ0WTogYm9vbGVhbjtcblxuICAgIGNvbnN0cnVjdG9yKGltYWdlSWQ6IHN0cmluZyl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaW1hZ2VJZCA9IGltYWdlSWQ7XG4gICAgICAgIGxldCBpbWFnZSA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpLmdldEltYWdlKHRoaXMuaW1hZ2VJZCk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IG5ldyBWZWMyKGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xuICAgICAgICB0aGlzLmltYWdlT2Zmc2V0ID0gVmVjMi5aRVJPO1xuICAgICAgICB0aGlzLmludmVydFggPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbnZlcnRZID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgb2Zmc2V0IG9mIHRoZSBzcHJpdGUgZnJvbSAoMCwgMCkgaW4gdGhlIGltYWdlJ3MgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IFRoZSBvZmZzZXQgb2YgdGhlIHNwcml0ZSBmcm9tICgwLCAwKSBpbiBpbWFnZSBjb29yZGluYXRlc1xuICAgICAqL1xuICAgIHNldEltYWdlT2Zmc2V0KG9mZnNldDogVmVjMik6IHZvaWQge1xuICAgICAgICB0aGlzLmltYWdlT2Zmc2V0ID0gb2Zmc2V0O1xuICAgIH1cbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBUaWxlc2V0IGZyb20gXCIuLi9EYXRhVHlwZXMvVGlsZXNldHMvVGlsZXNldFwiO1xuaW1wb3J0IHsgVGlsZWRUaWxlbWFwRGF0YSwgVGlsZWRMYXllckRhdGEgfSBmcm9tIFwiLi4vRGF0YVR5cGVzL1RpbGVzZXRzL1RpbGVkRGF0YVwiXG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi9DYW52YXNOb2RlXCI7XG5pbXBvcnQgUGh5c2ljc01hbmFnZXIgZnJvbSBcIi4uL1BoeXNpY3MvUGh5c2ljc01hbmFnZXJcIjtcbmltcG9ydCBTaGFwZSBmcm9tIFwiLi4vRGF0YVR5cGVzL1NoYXBlcy9TaGFwZVwiO1xuaW1wb3J0IEFBQkIgZnJvbSBcIi4uL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xuXG4vKipcbiAqIFRoZSByZXByZXNlbnRhdGlvbiBvZiBhIHRpbGVtYXAgLSB0aGlzIGNhbiBjb25zaXN0IG9mIGEgY29tYmluYXRpb24gb2YgdGlsZXNldHMgaW4gb25lIGxheWVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFRpbGVtYXAgZXh0ZW5kcyBDYW52YXNOb2RlIHtcblxuICAgIC8qKiBBbiBhcnJheSBvZiB0aGUgdGlsZXNldHMgdGhhdCB0aGlzIHRpbGVtYXAgdXNlcyAqL1xuICAgIHByb3RlY3RlZCB0aWxlc2V0czogQXJyYXk8VGlsZXNldD47XG4gICAgLyoqIFRoZSBzaXplIG9mIGEgdGlsZSBpbiB0aGlzIHRpbGVtYXAgKi9cbiAgICBwcm90ZWN0ZWQgdGlsZVNpemU6IFZlYzI7XG4gICAgLyoqIEFuIGFycmF5IG9mIHRpbGUgZGF0YSAqL1xuICAgIHByb3RlY3RlZCBkYXRhOiBBcnJheTxudW1iZXI+O1xuICAgIC8qKiBBbiBhcnJheSBvZiB0aWxlIGNvbGxpc2lvbiBkYXRhICovXG4gICAgcHJvdGVjdGVkIGNvbGxpc2lvbk1hcDogQXJyYXk8Ym9vbGVhbj47XG4gICAgLyoqIFRoZSBuYW1lIG9mIHRoZSB0aWxlbWFwICovXG4gICAgcHJvdGVjdGVkIF9uYW1lOiBzdHJpbmc7XG4gICAgLyoqIFRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgdGlsZW1hcCAqL1xuICAgIHByb3RlY3RlZCBudW1Db2xzOiBudW1iZXI7XG4gICAgLyoqIFRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgdGlsZW1hcCAqL1xuICAgIHByb3RlY3RlZCBudW1Sb3dzOiBudW1iZXI7XG4gICAgXG5cbiAgICAvLyBUT0RPOiBNYWtlIHRoaXMgbm8gbG9uZ2VyIGJlIHNwZWNpZmljIHRvIFRpbGVkXG4gICAgY29uc3RydWN0b3IodGlsZW1hcERhdGE6IFRpbGVkVGlsZW1hcERhdGEsIGxheWVyOiBUaWxlZExheWVyRGF0YSwgdGlsZXNldHM6IEFycmF5PFRpbGVzZXQ+LCBzY2FsZTogVmVjMikge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMudGlsZXNldHMgPSB0aWxlc2V0cztcbiAgICAgICAgdGhpcy50aWxlU2l6ZSA9IG5ldyBWZWMyKDAsIDApO1xuICAgICAgICB0aGlzLm5hbWUgPSBsYXllci5uYW1lO1xuICAgICAgICB0aGlzLm51bUNvbHMgPSB0aWxlbWFwRGF0YS53aWR0aDtcbiAgICAgICAgdGhpcy5udW1Sb3dzID0gdGlsZW1hcERhdGEuaGVpZ2h0O1xuXG4gICAgICAgIGxldCB0aWxlY291bnQgPSAwO1xuICAgICAgICBmb3IobGV0IHRpbGVzZXQgb2YgdGlsZXNldHMpe1xuICAgICAgICAgICAgdGlsZWNvdW50ICs9IHRpbGVzZXQuZ2V0VGlsZUNvdW50KCkgKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb2xsaXNpb25NYXAgPSBuZXcgQXJyYXkodGlsZWNvdW50KTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuY29sbGlzaW9uTWFwLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uTWFwW2ldID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZlciBwYXJzaW5nIG9mIHRoZSBkYXRhIHRvIGNoaWxkIGNsYXNzZXMgLSB0aGlzIGFsbG93cyBmb3IgaXNvbWV0cmljIHZzLiBvcnRob2dyYXBoaWMgdGlsZW1hcHMgYW5kIGhhbmRsaW5nIG9mIFRpbGVkIGRhdGEgb3Igb3RoZXIgZGF0YVxuICAgICAgICB0aGlzLnBhcnNlVGlsZW1hcERhdGEodGlsZW1hcERhdGEsIGxheWVyKTtcbiAgICAgICAgdGhpcy5zY2FsZS5zZXQoc2NhbGUueCwgc2NhbGUueSk7XG4gICAgfVxuICAgIFxuICAgIHB1YmxpYyBnZXQgbmFtZSgpOiBzdHJpbmcgeyByZXR1cm4gdGhpcy5fbmFtZTsgfVxuICAgIHB1YmxpYyBzZXQgbmFtZShuYW1lOiBzdHJpbmcpIHsgdGhpcy5fbmFtZSA9IG5hbWU7IH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRhdGEgdmFsdWUgb2YgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRpbGVcbiAgICAgKiBAcmV0dXJucyBUaGUgZGF0YSB2YWx1ZSBvZiB0aGUgdGlsZVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRUaWxlKGNvbDogbnVtYmVyLCByb3c6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuZ2V0VGlsZUluZGV4KGNvbCwgcm93KTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkgeyByZXR1cm4gLTE7IH1cblxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW2luZGV4XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggb2YgdGhlIHRpbGUgaW4gdGhlIHRpbGVtYXBzIGJhY2tpbmcgYXJyYXkuXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIHRoZSBwb3NpdGlvbiBpbiByb3ctY29sdW1uIGZvcm1hdCBpbiB0aGUgYmFja2luZyBhcnJheSBvZiB0aGUgdGlsZW1hcFxuICAgICAqIEByZXR1cm5zIHRoZSBpbmRleCBvZiBwb3NpdGlvbiBpbiB0aGUgdGlsZW1hcFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRUaWxlSW5kZXgoY29sOiBudW1iZXIsIHJvdzogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKGNvbCA8IDAgfHwgY29sID49IHRoaXMubnVtQ29scyB8fCByb3cgPCAwIHx8IHJvdyA+PSB0aGlzLm51bVJvd3MpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm93ICogdGhpcy5udW1Db2xzICsgY29sO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb2x1bW4gYW5kIHJvdyBvZiBhIHRpbGUgaW4gdGhlIHRpbGVtYXAgZnJvbSB0aGUgaW5kZXggb2YgdGhlIHRpbGVcbiAgICAgKiBpbiB0aGUgYmFja2luZyBhcnJheS5cbiAgICAgKiBAcGFyYW0gaW5kZXggdGhlIGluZGV4IG9mIHRoZSB0aWxlIGluIHRoZSBiYWNraW5nIGFycmF5XG4gICAgICogQHJldHVybiBhIFZlYzIgY29udGFpbmluZyB0aGUgY29sdW1uIGFuZCByb3cgaW5kaWNlcyBvZiB0aGUgdGlsZVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRUaWxlQ29sUm93KGluZGV4OiBudW1iZXIpOiBWZWMyIHtcbiAgICAgICAgbGV0IGNvbCA9IGluZGV4ICUgdGhpcy5udW1Db2xzO1xuICAgICAgICBsZXQgcm93ID0gTWF0aC5mbG9vcihpbmRleCAvIHRoaXMubnVtQ29scyk7XG4gICAgICAgIHJldHVybiBuZXcgVmVjMihjb2wsIHJvdyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uIHRvIHRoZSBnaXZlbiB0aWxlLlxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiB0aGUgcm93IGFuZCBjb2x1bW4gb2YgdGhlIHRpbGUgaW4gdGhlIGJhY2tpbmcgYXJyYXlcbiAgICAgKiBAcGFyYW0gdGlsZSB0aGUgbnVtYmVyIG9mIHRoZSB0aWxlIHRvIHNldFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXRUaWxlKGNvbDogbnVtYmVyLCByb3c6IG51bWJlciwgdGlsZTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuZ2V0VGlsZUluZGV4KGNvbCwgcm93KTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkgeyBcbiAgICAgICAgICAgIHRoaXMuZGF0YVtpbmRleF0gPSB0aWxlO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHRpbGVzZXRzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRpbGVtYXBcbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBhbGwgb2YgdGhlIHRpbGVzZXRzIGFzc29jYWl0ZWQgd2l0aCB0aGlzIHRpbGVtYXAuXG4gICAgICovXG4gICAgcHVibGljIGdldFRpbGVzZXRzKCk6IFRpbGVzZXRbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbGVzZXRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkaW1lbnNpb25zIG9mIHRoZSB0aWxlbWFwXG4gICAgICogQHJldHVybnMgQSBWZWMyIGNvbnRhaW5pbmcgdGhlIG51bWJlciBvZiBjb2x1bW5zIGFuZCB0aGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIHRpbGVtYXAuXG4gICAgICovXG4gICAgcHVibGljIGdldERpbWVuc2lvbnMoKTogVmVjMiB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjMih0aGlzLm51bUNvbHMsIHRoaXMubnVtUm93cyk7XG4gICAgfVxuXG4gICAgLy8gTWV0aG9kcyBmb3IgZ2V0dGluZyB0aGUgc2l6ZSBvZiBhIHRpbGVcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJhdyBzaXplIG9mIHRoZSB0aWxlcywgd2l0aG91dCBhbnkgc2NhbGluZyBvciB6b29taW5nLlxuICAgICAqIEByZXR1cm5zIHRoZSBzaXplIG9mIHRoZSB0aWxlcyBpbiB0aGlzIHRpbGVtYXBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0VGlsZVNpemUoKTogVmVjMiB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbGVTaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRpbGVzIGluIHRoaXMgdGlsZW1hcCBhcyB0aGV5IGFwcGVhciBpbiB0aGUgZ2FtZSB3b3JsZCBhZnRlciBzY2FsaW5nXG4gICAgICogQHJldHVybnMgQSB2ZWN0b3IgY29udGFpbmluZyB0aGUgc2l6ZSBvZiB0aWxlcyBpbiB0aGlzIHRpbGVtYXAgYXMgdGhleSBhcHBlYXIgaW4gdGhlIGdhbWUgd29ybGQgYWZ0ZXIgc2NhbGluZy5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0U2NhbGVkVGlsZVNpemUoKTogVmVjMiB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFRpbGVTaXplKCkuc2NhbGVkKHRoaXMuc2NhbGUueCwgdGhpcy5zY2FsZS55KTtcbiAgICB9XG4gICBcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIHJvdyBhbmQgY29sdW1uIG9mIHRoZSB0aWxlbWFwIGlzIGNvbGxpZGFibGVcbiAgICAgKiBAcGFyYW0gY29sIHRoZSBzcGVjaWZpZWQgY29sdW1uXG4gICAgICogQHBhcmFtIHJvdyB0aGUgc3BlY2lmaWVkIHJvd1xuICAgICAqIEByZXR1cm5zIEEgZmxhZyByZXByZXNlbnRpbmcgd2hldGhlciBvciBub3QgdGhlIHRpbGUgaXMgY29sbGlkYWJsZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgaXNUaWxlQ29sbGlkYWJsZShjb2w6IG51bWJlciwgcm93OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKGNvbCA8IDAgfHwgY29sID49IHRoaXMubnVtQ29scyB8fCByb3cgPCAwIHx8IHJvdyA+PSB0aGlzLm51bVJvd3MpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb2xsaXNpb25NYXBbdGhpcy5nZXRUaWxlKGNvbCwgcm93KV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGlzIHRpbGVtYXAgdG8gdGhlIHBoeXNpY3Mgc3lzdGVtXG4gICAgICovXG4gICAgcHVibGljIGFkZFBoeXNpY3MoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaGFzUGh5c2ljcyA9IHRydWU7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ncm91cCA9IC0xO1xuICAgICAgICB0aGlzLnNjZW5lLmdldFBoeXNpY3NNYW5hZ2VyKCkucmVnaXN0ZXJUaWxlbWFwKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHgveSBjb29yZGluYXRlcyBvZiBhIHRpbGUgb24gdGhlIHNjcmVlbiBmcm9tIHRoZSBwb3NpdGlvbiBvZiB0aGUgdGlsZSBpbiB0aGUgXG4gICAgICogYmFja2luZyBhcnJheSBvZiB0aGUgdGlsZW1hcC5cbiAgICAgKiBAcGFyYW0gcm93IHRoZSByb3cgcG9zaXRpb24gb2YgdGhlIHRpbGUgaW4gdGhlIGJhY2tpbmcgYXJyYXlcbiAgICAgKiBAcGFyYW0gY29sIHRoZSBjb2x1bW4gcG9zaXRpb24gb2YgdGhlIHRpbGUgaW4gdGhlIGJhY2tpbmcgYXJyYXlcbiAgICAgKiBAcmV0dXJucyBhIFZlYzIgY29udGFpbmluZyB0aGUgd29ybGQgcG9zaXRpb24gb2YgdGhlIHRpbGVcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0V29ybGRQb3NpdGlvbihjb2w6IG51bWJlciwgcm93OiBudW1iZXIpOiBWZWMyO1xuICAgIFxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJvdy9jb2x1bW4gcG9zaXRpb24gb2YgYSB0aWxlIGluIHRoZSB0aWxlbWFwIGZyb20gdGhlIHNjcmVlbiBjb29yZGluYXRlcyBvZiB0aGUgdGlsZS5cbiAgICAgKiBAcGFyYW0geCB0aGUgeC1jb29yZGluYXRlIG9mIHRoZSB0aWxlIG9uIHRoZSBzY3JlZW5cbiAgICAgKiBAcGFyYW0geSB0aGUgeS1jb29yZGluYXRlIG9mIHRoZSB0aWxlIG9uIHRoZSBzY3JlZW5cbiAgICAgKiBAcmV0dXJucyBhIFZlYzIgY29udGFpbmluZyB0aGUgY29sdW1uIGFuZCByb3cgcG9zaXRpb24gb2YgdGhlIHRpbGUgaW4gdGhlIHRpbGVtYXBcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0VGlsZW1hcFBvc2l0aW9uKHg6IG51bWJlciwgeTogbnVtYmVyKTogVmVjMjtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNvbGxpc2lvbiBzaGFwZSBmb3IgdGhlIHNwZWNpZmllZCB0aWxlIGF0IHRoZSBzcGVjaWZpZWQgY29sdW1uL3JvdyBpbiB0aGUgdGlsZW1hcFxuICAgICAqIEBwYXJhbSByb3cgdGhlIHJvd1xuICAgICAqIEBwYXJhbSBjb2wgdGhlIGNvbHVtblxuICAgICAqIEByZXR1cm4gYSBuZXcgU2hhcGUgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY29sbGlzaW9uIHNoYXBlIG9mIHRoZSB0aWxlXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IGdldFRpbGVDb2xsaWRlcihjb2w6IG51bWJlciwgcm93OiBudW1iZXIpOiBTaGFwZTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNvbHVtbiBhbmQgcm93IHBvc2l0aW9uIG9mIGZpcnN0IHRpbGUgaW4gdGhlIHJlZ2lvbi4gVGhpcyBtZXRob2QgZ2V0cyBjYWxsZWRcbiAgICAgKiB3aGVuIHJlbmRlcmluZyBpcyBkb25lIHRvIGRldGVybWluZSB3aGljaCB0aWxlcyBzaG91bGQgYmUgcmVuZGVyZWQgaW4gdGhlIHZpZXdwb3J0LlxuICAgICAqIEBwYXJhbSB1cHBlckxlZnQgdGhlIHVwcGVyIGxlZnQgY29ybmVyIG9mIHRoZSByZWdpb25cbiAgICAgKiBAcGFyYW0gYm90dG9tUmlnaHQgdGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIHJlZ2lvblxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXRNaW5Db2xSb3cocmVnaW9uOiBBQUJCKTogVmVjMjtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNvbHVtbiBhbmQgcm93IHBvc2l0aW9uIG9mIHRoZSBsYXN0IHRpbGUgaW4gdGhlIHJlZ2lvbi4gVGhpcyBtZXRob2QgZ2V0cyBjYWxsZWQgXG4gICAgICogd2hlbiByZW5kZXJpbmcgaXMgZG9uZSB0byBkZXRlcm1pbmUgd2hpY2ggdGlsZXMgc2hvdWxkIGJlIHJlbmRlcmVkIGluIHRoZSB2aWV3cG9ydC5cbiAgICAgKiBAcGFyYW0gdXBwZXJMZWZ0IHRoZSB1cHBlciBsZWZ0IGNvcm5lciBvZiB0aGUgcmVnaW9uXG4gICAgICogQHBhcmFtIGJvdHRvbVJpZ2h0IHRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSByZWdpb25cbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0TWF4Q29sUm93KHJlZ2lvbjogQUFCQik6IFZlYzI7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSB0aWxlc2V0IHVzaW5nIHRoZSBkYXRhIGxvYWRlZCBmcm9tIGZpbGVcbiAgICAgKiBAcGFyYW0gdGlsZW1hcERhdGEgVGhlIHRpbGVtYXAgZGF0YSBmcm9tIGZpbGVcbiAgICAgKiBAcGFyYW0gbGF5ZXIgVGhlIGxheWVyIGRhdGEgZnJvbSBmaWxlXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHBhcnNlVGlsZW1hcERhdGEodGlsZW1hcERhdGE6IFRpbGVkVGlsZW1hcERhdGEsIGxheWVyOiBUaWxlZExheWVyRGF0YSk6IHZvaWQ7XG59IiwiaW1wb3J0IEFBQkIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xuaW1wb3J0IFNoYXBlIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvU2hhcGVzL1NoYXBlXCI7XG5pbXBvcnQgeyBUaWxlZFRpbGVtYXBEYXRhLCBUaWxlZExheWVyRGF0YSB9IGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVGlsZXNldHMvVGlsZWREYXRhXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vLi4vRGVidWcvRGVidWdcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vVXRpbHMvQ29sb3JcIjtcbmltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi9UaWxlbWFwXCI7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSXNvbWV0cmljVGlsZW1hcCBleHRlbmRzIFRpbGVtYXAge1xuICAgIHB1YmxpYyBnZXRNaW5Db2xSb3cocmVnaW9uOiBBQUJCKTogVmVjMiB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjMigwLCAwKTtcbiAgICB9XG4gICAgcHVibGljIGdldE1heENvbFJvdyhyZWdpb246IEFBQkIpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMubnVtQ29scywgdGhpcy5udW1Sb3dzKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgZ2V0V29ybGRQb3NpdGlvbihjb2w6IG51bWJlciwgcm93OiBudW1iZXIpOiBWZWMyIHwgbnVsbCB7XG4gICAgICAgIGlmIChjb2wgPCAwIHx8IGNvbCA+IHRoaXMubnVtQ29scyB8fCByb3cgPCAwIHx8IHJvdyA+IHRoaXMubnVtUm93cykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZweCA9IHRoaXMuc2NlbmUuZ2V0Vmlld3BvcnQoKS5nZXRIYWxmU2l6ZSgpLng7XG4gICAgICAgIGxldCB4ID0gTWF0aC5mbG9vcih0aGlzLnNjYWxlLnggKiB0aGlzLnRpbGVTaXplLnggLyAyICogKGNvbCAtIHJvdykgKyB2cHgpO1xuICAgICAgICBsZXQgeSA9IE1hdGguZmxvb3IodGhpcy5zY2FsZS55ICogdGhpcy50aWxlU2l6ZS55IC8gMiAqIChjb2wgKyByb3cpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHgsIHkpO1xuICAgIH1cbiAgICBwdWJsaWMgb3ZlcnJpZGUgZ2V0VGlsZW1hcFBvc2l0aW9uKHg6IG51bWJlciwgeTogbnVtYmVyKTogVmVjMiB8IG51bGwge1xuICAgICAgICBsZXQgdnB4ID0gdGhpcy5zY2VuZS5nZXRWaWV3cG9ydCgpLmdldEhhbGZTaXplKCkueDtcbiAgICAgICAgbGV0IGNvbCA9IE1hdGguZmxvb3IoKHggLSB2cHgpIC8gdGhpcy5zY2FsZS54IC8gdGhpcy50aWxlU2l6ZS54ICsgeSAvIHRoaXMuc2NhbGUueSAvIHRoaXMudGlsZVNpemUueSk7XG4gICAgICAgIGxldCByb3cgPSBNYXRoLmZsb29yKHkgLyB0aGlzLnNjYWxlLnkgLyB0aGlzLnRpbGVTaXplLnkgLSAoeCAtIHZweCkgLyB0aGlzLnNjYWxlLnggLyB0aGlzLnRpbGVTaXplLngpO1xuICAgICAgICBpZiAoY29sIDwgMCB8fCBjb2wgPiB0aGlzLm51bUNvbHMgfHwgcm93IDwgMCB8fCByb3cgPiB0aGlzLm51bVJvd3MpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVmVjMihjb2wsIHJvdyk7XG4gICAgfVxuXG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgZ2V0VGlsZUNvbGxpZGVyKGNvbDogbnVtYmVyLCByb3c6IG51bWJlcik6IFNoYXBlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBwYXJzZVRpbGVtYXBEYXRhKHRpbGVtYXBEYXRhOiBUaWxlZFRpbGVtYXBEYXRhLCBsYXllcjogVGlsZWRMYXllckRhdGEpOiB2b2lkIHtcbiAgICAgICAgLy8gVGhlIHNpemUgb2YgdGhlIHRpbGVtYXAgaW4gbG9jYWwgc3BhY2VcbiAgICAgICAgdGhpcy5udW1Db2xzID0gdGlsZW1hcERhdGEud2lkdGg7XG4gICAgICAgIHRoaXMubnVtUm93cyA9IHRpbGVtYXBEYXRhLmhlaWdodDtcblxuICAgICAgICAvLyBUaGUgc2l6ZSBvZiB0aWxlc1xuICAgICAgICB0aGlzLnRpbGVTaXplLnNldCh0aWxlbWFwRGF0YS50aWxld2lkdGgsIHRpbGVtYXBEYXRhLnRpbGVoZWlnaHQpO1xuXG4gICAgICAgIC8vIFRoZSBzaXplIG9mIHRoZSB0aWxlbWFwIG9uIHRoZSBjYW52YXNcbiAgICAgICAgdGhpcy5zaXplLnNldCh0aGlzLm51bUNvbHMgKiB0aGlzLnRpbGVTaXplLngsIHRoaXMubnVtUm93cyAqIHRoaXMudGlsZVNpemUueSk7XG4gICAgICAgIHRoaXMucG9zaXRpb24uY29weSh0aGlzLnNpemUuc2NhbGVkKDAuNSkpO1xuICAgICAgICB0aGlzLmRhdGEgPSBsYXllci5kYXRhO1xuICAgICAgICB0aGlzLnZpc2libGUgPSBsYXllci52aXNpYmxlO1xuXG4gICAgICAgIC8vIFdoZXRoZXIgdGhlIHRpbGVtYXAgaXMgY29sbGlkYWJsZSBvciBub3RcbiAgICAgICAgdGhpcy5pc0NvbGxpZGFibGUgPSBmYWxzZTtcbiAgICAgICAgaWYobGF5ZXIucHJvcGVydGllcyl7XG4gICAgICAgICAgICBmb3IobGV0IGl0ZW0gb2YgbGF5ZXIucHJvcGVydGllcyl7XG4gICAgICAgICAgICAgICAgaWYoaXRlbS5uYW1lID09PSBcIkNvbGxpZGFibGVcIil7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNDb2xsaWRhYmxlID0gaXRlbS52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgYWxsIHRpbGVzIGJlc2lkZXMgXCJlbXB0eTogMFwiIHRvIGJlIGNvbGxpZGFibGVcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMTsgaSA8IHRoaXMuY29sbGlzaW9uTWFwLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uTWFwW2ldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBwdWJsaWMgb3ZlcnJpZGUgZGVidWdSZW5kZXIoKTogdm9pZCB7XG4gICAgICAgIGZvciAobGV0IHRpbGUgPSAwOyB0aWxlIDwgdGhpcy5kYXRhLmxlbmd0aDsgdGlsZSsrKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gdGhpcy5nZXRUaWxlQ29sUm93KHRpbGUpO1xuICAgICAgICAgICAgRGVidWcuZHJhd1BvaW50KHRoaXMuZ2V0V29ybGRQb3NpdGlvbihwb3MueCwgcG9zLnkpLCBDb2xvci5CTFVFKTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vVGlsZW1hcFwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgeyBUaWxlZFRpbGVtYXBEYXRhLCBUaWxlZExheWVyRGF0YSB9IGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVGlsZXNldHMvVGlsZWREYXRhXCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uLy4uL0RlYnVnL0RlYnVnXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL1V0aWxzL0NvbG9yXCI7XG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XG5cbi8qKlxuICogVGhlIHJlcHJlc2VudGF0aW9uIG9mIGFuIG9ydGhvZ29uYWwgdGlsZW1hcCAtIGkuZS4gYSB0b3AgZG93biBvciBwbGF0Zm9ybWVyIHRpbGVtYXBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3J0aG9nb25hbFRpbGVtYXAgZXh0ZW5kcyBUaWxlbWFwIHtcblxuICAgIHB1YmxpYyBvdmVycmlkZSBnZXRNaW5Db2xSb3cocmVnaW9uOiBBQUJCKTogVmVjMiB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFRpbGVtYXBQb3NpdGlvbihyZWdpb24udG9wTGVmdC54LCByZWdpb24udG9wTGVmdC55KTtcbiAgICB9XG4gICAgcHVibGljIG92ZXJyaWRlIGdldE1heENvbFJvdyhyZWdpb246IEFBQkIpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGlsZW1hcFBvc2l0aW9uKHJlZ2lvbi5ib3R0b21SaWdodC54LCByZWdpb24uYm90dG9tUmlnaHQueSk7XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIGdldFRpbGVtYXBQb3NpdGlvbih4OiBudW1iZXIsIHk6IG51bWJlcik6IFZlYzIge1xuICAgICAgICBsZXQgY29sID0gTWF0aC5mbG9vcih4IC8gdGhpcy50aWxlU2l6ZS54IC8gdGhpcy5zY2FsZS54KTtcbiAgICAgICAgbGV0IHJvdyA9IE1hdGguZmxvb3IoeSAvIHRoaXMudGlsZVNpemUueSAvIHRoaXMuc2NhbGUueSk7XG4gICAgICAgIHJldHVybiBuZXcgVmVjMihjb2wsIHJvdyk7XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIGdldFdvcmxkUG9zaXRpb24oY29sOiBudW1iZXIsIHJvdzogbnVtYmVyKTogVmVjMiB7XG4gICAgICAgIGxldCB4ID0gY29sICogdGhpcy50aWxlU2l6ZS54ICogdGhpcy5zY2FsZS54O1xuICAgICAgICBsZXQgeSA9IHJvdyAqIHRoaXMudGlsZVNpemUueSAqIHRoaXMuc2NhbGUueTtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHgsIHkpO1xuICAgIH1cblxuICAgIHB1YmxpYyBvdmVycmlkZSBnZXRUaWxlQ29sbGlkZXIoY29sOiBudW1iZXIsIHJvdzogbnVtYmVyKTogQUFCQiB7XG4gICAgICAgIGxldCB0aWxlU2l6ZSA9IHRoaXMuZ2V0U2NhbGVkVGlsZVNpemUoKTtcblxuICAgICAgICBsZXQgY2VudGVyWCA9IGNvbCAqIHRpbGVTaXplLnggKyB0aWxlU2l6ZS54IC8gMjtcbiAgICAgICAgbGV0IGNlbnRlclkgPSByb3cgKiB0aWxlU2l6ZS55ICsgdGlsZVNpemUueSAvIDI7XG5cbiAgICAgICAgbGV0IGNlbnRlciA9IG5ldyBWZWMyKGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgICBsZXQgaGFsZlNpemUgPSB0aWxlU2l6ZS5zY2FsZWQoMC41KTtcblxuICAgICAgICByZXR1cm4gbmV3IEFBQkIoY2VudGVyLCBoYWxmU2l6ZSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHBhcnNlVGlsZW1hcERhdGEodGlsZW1hcERhdGE6IFRpbGVkVGlsZW1hcERhdGEsIGxheWVyOiBUaWxlZExheWVyRGF0YSk6IHZvaWQge1xuICAgICAgICAvLyBUaGUgc2l6ZSBvZiB0aGUgdGlsZW1hcCBpbiBsb2NhbCBzcGFjZVxuICAgICAgICB0aGlzLm51bUNvbHMgPSB0aWxlbWFwRGF0YS53aWR0aDtcbiAgICAgICAgdGhpcy5udW1Sb3dzID0gdGlsZW1hcERhdGEuaGVpZ2h0O1xuXG4gICAgICAgIC8vIFRoZSBzaXplIG9mIHRpbGVzXG4gICAgICAgIHRoaXMudGlsZVNpemUuc2V0KHRpbGVtYXBEYXRhLnRpbGV3aWR0aCwgdGlsZW1hcERhdGEudGlsZWhlaWdodCk7XG5cbiAgICAgICAgLy8gVGhlIHNpemUgb2YgdGhlIHRpbGVtYXAgb24gdGhlIGNhbnZhc1xuICAgICAgICB0aGlzLnNpemUuc2V0KHRoaXMubnVtQ29scyAqIHRoaXMudGlsZVNpemUueCwgdGhpcy5udW1Sb3dzICogdGhpcy50aWxlU2l6ZS55KTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi5jb3B5KHRoaXMuc2l6ZS5zY2FsZWQoMC41KSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGxheWVyLmRhdGE7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IGxheWVyLnZpc2libGU7XG5cbiAgICAgICAgLy8gV2hldGhlciB0aGUgdGlsZW1hcCBpcyBjb2xsaWRhYmxlIG9yIG5vdFxuICAgICAgICB0aGlzLmlzQ29sbGlkYWJsZSA9IGZhbHNlO1xuICAgICAgICBpZihsYXllci5wcm9wZXJ0aWVzKXtcbiAgICAgICAgICAgIGZvcihsZXQgaXRlbSBvZiBsYXllci5wcm9wZXJ0aWVzKXtcbiAgICAgICAgICAgICAgICBpZihpdGVtLm5hbWUgPT09IFwiQ29sbGlkYWJsZVwiKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0NvbGxpZGFibGUgPSBpdGVtLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBhbGwgdGlsZXMgYmVzaWRlcyBcImVtcHR5OiAwXCIgdG8gYmUgY29sbGlkYWJsZVxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAxOyBpIDwgdGhpcy5jb2xsaXNpb25NYXAubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25NYXBbaV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7fVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgcHVibGljIG92ZXJyaWRlIGRlYnVnUmVuZGVyKCl7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3IgPSB0aGlzLmdldFRpbGVDb2xSb3coaSk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0NvbGxpZGFibGUgJiYgdGhpcy5pc1RpbGVDb2xsaWRhYmxlKGNyLngsIGNyLnkpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJveCA9IHRoaXMuZ2V0VGlsZUNvbGxpZGVyKGNyLngsIGNyLnkpO1xuICAgICAgICAgICAgICAgIERlYnVnLmRyYXdCb3godGhpcy5pblJlbGF0aXZlQ29vcmRpbmF0ZXMoYm94LmNlbnRlciksIGJveC5oYWxmU2l6ZS5zY2FsZSh0aGlzLnNjZW5lLmdldFZpZXdTY2FsZSgpKSwgZmFsc2UsIENvbG9yLkJMVUUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCBBQUJCIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvU2hhcGVzL0FBQkJcIjtcbmltcG9ydCBTaGFwZSBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1NoYXBlcy9TaGFwZVwiO1xuaW1wb3J0IHsgVGlsZWRUaWxlbWFwRGF0YSwgVGlsZWRMYXllckRhdGEgfSBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1RpbGVzZXRzL1RpbGVkRGF0YVwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uLy4uL0RlYnVnL0RlYnVnXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL1V0aWxzL0NvbG9yXCI7XG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuLi8uLi9VdGlscy9NYXRoVXRpbHNcIjtcbmltcG9ydCB7IEdyYXBoaWNUeXBlIH0gZnJvbSBcIi4uL0dyYXBoaWNzL0dyYXBoaWNUeXBlc1wiO1xuaW1wb3J0IFRpbGVtYXAgZnJvbSBcIi4uL1RpbGVtYXBcIjtcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGFnZ2VyZWRJc29tZXRyaWNUaWxlbWFwIGV4dGVuZHMgVGlsZW1hcCB7XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgZ2V0VGlsZW1hcFBvc2l0aW9uKHg6IG51bWJlciwgeTogbnVtYmVyKTogVmVjMiB7XG4gICAgICAgIGxldCBjb2wgPSB4IC8gdGhpcy50aWxlU2l6ZS54IC8gdGhpcy5zY2FsZS54O1xuICAgICAgICBsZXQgcm93ID0gTWF0aC5mbG9vcih5IC8gdGhpcy50aWxlU2l6ZS55IC8gdGhpcy5zY2FsZS55ICogMik7XG4gICAgICAgIGlmIChyb3cgJSAyICE9PSAwKSB7XG4gICAgICAgICAgICBjb2wgPSAoeCAtIHRoaXMudGlsZVNpemUueCAvIHRoaXMuc2NhbGUueCAvIDIpIC8gdGhpcy50aWxlU2l6ZS54IC8gdGhpcy5zY2FsZS54O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVmVjMihNYXRoLmZsb29yKGNvbCksIHJvdyk7XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIGdldFdvcmxkUG9zaXRpb24oY29sOiBudW1iZXIsIHJvdzogbnVtYmVyKTogVmVjMiB7XG4gICAgICAgIGxldCB4ID0gY29sICogdGhpcy50aWxlU2l6ZS54ICogdGhpcy5zY2FsZS54O1xuICAgICAgICBsZXQgeSA9IHJvdyAqIHRoaXMudGlsZVNpemUueSAvIDIgKiB0aGlzLnNjYWxlLnk7XG4gICAgICAgIGlmIChyb3cgJSAyICE9PSAwKSB7XG4gICAgICAgICAgICB4ICs9IHRoaXMudGlsZVNpemUueCAqIHRoaXMuc2NhbGUueCAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKE1hdGguZmxvb3IoeCksIE1hdGguZmxvb3IoeSkpO1xuICAgIH1cblxuICAgIHB1YmxpYyBvdmVycmlkZSBnZXRUaWxlQ29sbGlkZXIoY29sOiBudW1iZXIsIHJvdzogbnVtYmVyKTogQUFCQiB7XG4gICAgICAgIFxuICAgICAgICBsZXQgdGlsZVNpemUgPSB0aGlzLmdldFNjYWxlZFRpbGVTaXplKCk7XG5cbiAgICAgICAgbGV0IGNlbnRlclggPSBjb2wgKiB0aWxlU2l6ZS54ICsgdGlsZVNpemUueCAvIDJcbiAgICAgICAgbGV0IGNlbnRlclkgPSByb3cgKiB0aWxlU2l6ZS55IC8gMiArIHRpbGVTaXplLnkgKyB0aWxlU2l6ZS55IC8gMjtcbiAgICAgICAgaWYgKHJvdyAlIDIgIT09IDApIHtcbiAgICAgICAgICAgIGNlbnRlclggKz0gdGlsZVNpemUueCAvIDI7XG4gICAgICAgIH0gXG5cbiAgICAgICAgbGV0IGNlbnRlciA9IG5ldyBWZWMyKGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgICBsZXQgaGFsZlNpemUgPSB0aWxlU2l6ZS5zY2FsZWQoMC41KTtcblxuICAgICAgICByZXR1cm4gbmV3IEFBQkIoY2VudGVyLCBoYWxmU2l6ZSk7XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIGdldE1pbkNvbFJvdyhyZWdpb246IEFBQkIpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKDAsIDApO1xuICAgIH0gICBcblxuICAgIHB1YmxpYyBvdmVycmlkZSBnZXRNYXhDb2xSb3cocmVnaW9uOiBBQUJCKTogVmVjMiB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjMih0aGlzLm51bUNvbHMsIHRoaXMubnVtUm93cyk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHBhcnNlVGlsZW1hcERhdGEodGlsZW1hcERhdGE6IFRpbGVkVGlsZW1hcERhdGEsIGxheWVyOiBUaWxlZExheWVyRGF0YSk6IHZvaWQge1xuICAgICAgICAvLyBUaGUgc2l6ZSBvZiB0aGUgdGlsZW1hcCBpbiBsb2NhbCBzcGFjZVxuICAgICAgICB0aGlzLm51bUNvbHMgPSB0aWxlbWFwRGF0YS53aWR0aDtcbiAgICAgICAgdGhpcy5udW1Sb3dzID0gdGlsZW1hcERhdGEuaGVpZ2h0O1xuXG4gICAgICAgIC8vIFRoZSBzaXplIG9mIHRpbGVzXG4gICAgICAgIHRoaXMudGlsZVNpemUuc2V0KHRpbGVtYXBEYXRhLnRpbGV3aWR0aCwgdGlsZW1hcERhdGEudGlsZWhlaWdodCk7XG5cbiAgICAgICAgLy8gVGhlIHNpemUgb2YgdGhlIHRpbGVtYXAgb24gdGhlIGNhbnZhc1xuICAgICAgICB0aGlzLnNpemUuc2V0KHRoaXMubnVtQ29scyAqIHRoaXMudGlsZVNpemUueCwgdGhpcy5udW1Sb3dzICogdGhpcy50aWxlU2l6ZS55KTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi5jb3B5KHRoaXMuc2l6ZS5zY2FsZWQoMC41KSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGxheWVyLmRhdGE7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IGxheWVyLnZpc2libGU7XG5cbiAgICAgICAgLy8gV2hldGhlciB0aGUgdGlsZW1hcCBpcyBjb2xsaWRhYmxlIG9yIG5vdFxuICAgICAgICB0aGlzLmlzQ29sbGlkYWJsZSA9IGZhbHNlO1xuICAgICAgICBpZihsYXllci5wcm9wZXJ0aWVzKXtcbiAgICAgICAgICAgIGZvcihsZXQgaXRlbSBvZiBsYXllci5wcm9wZXJ0aWVzKXtcbiAgICAgICAgICAgICAgICBpZihpdGVtLm5hbWUgPT09IFwiQ29sbGlkYWJsZVwiKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0NvbGxpZGFibGUgPSBpdGVtLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBhbGwgdGlsZXMgYmVzaWRlcyBcImVtcHR5OiAwXCIgdG8gYmUgY29sbGlkYWJsZVxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAxOyBpIDwgdGhpcy5jb2xsaXNpb25NYXAubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25NYXBbaV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHB1YmxpYyBvdmVycmlkZSBkZWJ1Z1JlbmRlcigpOiB2b2lkIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByYyA9IHRoaXMuZ2V0VGlsZUNvbFJvdyhpKTtcbiAgICAgICAgICAgIGxldCBib3ggPSB0aGlzLmdldFRpbGVDb2xsaWRlcihyYy54LCByYy55KTtcbiAgICAgICAgICAgIERlYnVnLmRyYXdCb3godGhpcy5pblJlbGF0aXZlQ29vcmRpbmF0ZXMoYm94LmNlbnRlciksIGJveC5oYWxmU2l6ZS5zY2FsZSh0aGlzLnNjZW5lLmdldFZpZXdTY2FsZSgpKSwgZmFsc2UsIENvbG9yLkJMVUUpO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuL0NhbnZhc05vZGVcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IElucHV0IGZyb20gXCIuLi9JbnB1dC9JbnB1dFwiO1xuXG4vKipcbiAqIFRoZSByZXByZXNlbnRhdGlvbiBvZiBhIFVJRWxlbWVudCAtIHRoZSBwYXJlbnQgY2xhc3Mgb2YgdGhpbmdzIGxpa2UgYnV0dG9uc1xuICovXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBVSUVsZW1lbnQgZXh0ZW5kcyBDYW52YXNOb2RlIHtcblx0Ly8gU3R5bGUgYXR0cmlidXRlcyAtIFRPRE8gLSBhYnN0cmFjdCB0aGlzIGludG8gYSBzdHlsZSBvYmplY3QvaW50ZXJmYWNlXG5cdC8qKiBUaGUgYmFja2dvdW5kIGNvbG9yICovXG5cdGJhY2tncm91bmRDb2xvcjogQ29sb3I7XG5cdC8qKiBUaGUgYm9yZGVyIGNvbG9yICovXG5cdGJvcmRlckNvbG9yOiBDb2xvcjtcblx0LyoqIFRoZSBib3JkZXIgcmFkaXVzICovXG5cdGJvcmRlclJhZGl1czogbnVtYmVyO1xuXHQvKiogVGhlIGJvcmRlciB3aWR0aCAqL1xuXHRib3JkZXJXaWR0aDogbnVtYmVyO1xuXHQvKiogVGhlIHBhZGRpbmcgKi9cblx0cGFkZGluZzogVmVjMjtcblxuXHQvLyBFdmVudEF0dHJpYnV0ZXNcblx0LyoqIFRoZSByZWFjdGlvbiBvZiB0aGlzIFVJRWxlbWVudCBvbiBhIGNsaWNrICovXG5cdG9uQ2xpY2s6IEZ1bmN0aW9uO1xuXHQvKiogVGhlIGV2ZW50IHByb3BhZ2F0ZWQgb24gY2xpY2sgKi9cblx0b25DbGlja0V2ZW50SWQ6IHN0cmluZztcblx0LyoqIFRoZSByZWFjdGlvbiB0byB0aGUgcmVsZWFzZSBvZiBhIGNsaWNrICovXG5cdG9uUmVsZWFzZTogRnVuY3Rpb247XG5cdC8qKiBUaGUgZXZlbnQgcHJvcGFnYXRlZCBvbiB0aGUgcmVsZWFzZSBvZiBhIGNsaWNrICovXG5cdG9uUmVsZWFzZUV2ZW50SWQ6IHN0cmluZztcblx0LyoqIFRoZSByZWFjdGlvbiB3aGVuIGEgbW91c2UgZW50ZXJzIHRoaXMgVUlFbGVtZW50ICovXG5cdG9uRW50ZXI6IEZ1bmN0aW9uO1xuXHQvKiogVGhlIGV2ZW50IHByb3BhZ2F0ZWQgd2hlbiBhIG1vdXNlIGVudGVycyB0aGlzIFVJRWxlbWVudCAqL1xuXHRvbkVudGVyRXZlbnRJZDogc3RyaW5nO1xuXHQvKiogVGhlIHJlYWN0aW9uIHdoZW4gYSBtb3VzZSBsZWF2ZXMgdGhpcyBVSUVsZW1lbnQgKi9cblx0b25MZWF2ZTogRnVuY3Rpb247XG5cdC8qKiBUaGUgZXZlbnQgcHJvcG9nYXRlZCB3aGVuIGEgbW91c2UgbGVhdmVzIHRoaXMgVUlFbGVtZW50ICovXG5cdG9uTGVhdmVFdmVudElkOiBzdHJpbmc7XG5cblx0LyoqIFdoZXRoZXIgb3Igbm90IHRoaXMgVUlFbGVtZW50IGlzIGN1cnJlbnRseSBjbGlja2VkIG9uICovXG5cdHByb3RlY3RlZCBpc0NsaWNrZWQ6IGJvb2xlYW47XG5cdC8qKiBXaGV0aGVyIG9yIG5vdCB0aGlzIFVJRWxlbWVudCBpcyBjdXJyZW50bHkgaG92ZXJlZCBvdmVyICovXG5cdHByb3RlY3RlZCBpc0VudGVyZWQ6IGJvb2xlYW47XG5cblx0Y29uc3RydWN0b3IocG9zaXRpb246IFZlYzIpe1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuXHRcdFxuXHRcdHRoaXMuYmFja2dyb3VuZENvbG9yID0gbmV3IENvbG9yKDAsIDAsIDAsIDApO1xuXHRcdHRoaXMuYm9yZGVyQ29sb3IgPSBuZXcgQ29sb3IoMCwgMCwgMCwgMCk7XG5cdFx0dGhpcy5ib3JkZXJSYWRpdXMgPSA1O1xuXHRcdHRoaXMuYm9yZGVyV2lkdGggPSAxO1xuXHRcdHRoaXMucGFkZGluZyA9IFZlYzIuWkVSTztcblxuXHRcdHRoaXMub25DbGljayA9IG51bGw7XG5cdFx0dGhpcy5vbkNsaWNrRXZlbnRJZCA9IG51bGw7XG5cdFx0dGhpcy5vblJlbGVhc2UgPSBudWxsO1xuXHRcdHRoaXMub25SZWxlYXNlRXZlbnRJZCA9IG51bGw7XG5cblx0XHR0aGlzLm9uRW50ZXIgPSBudWxsO1xuXHRcdHRoaXMub25FbnRlckV2ZW50SWQgPSBudWxsO1xuXHRcdHRoaXMub25MZWF2ZSA9IG51bGw7XG5cdFx0dGhpcy5vbkxlYXZlRXZlbnRJZCA9IG51bGw7XG5cblx0XHR0aGlzLmlzQ2xpY2tlZCA9IGZhbHNlO1xuXHRcdHRoaXMuaXNFbnRlcmVkID0gZmFsc2U7XG5cdH1cblxuXHQvLyBAZGVwcmVjYXRlZFxuXHRzZXRCYWNrZ3JvdW5kQ29sb3IoY29sb3I6IENvbG9yKTogdm9pZCB7XG5cdFx0dGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcblx0fVxuXG5cdC8vIEBkZXByZWNhdGVkXG5cdHNldFBhZGRpbmcocGFkZGluZzogVmVjMik6IHZvaWQge1xuXHRcdHRoaXMucGFkZGluZy5jb3B5KHBhZGRpbmcpO1xuXHR9XG5cblx0dXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG5cdFx0c3VwZXIudXBkYXRlKGRlbHRhVCk7XG5cblx0XHQvLyBTZWUgb2YgdGhpcyBvYmplY3Qgd2FzIGp1c3QgY2xpY2tlZFxuXHRcdGlmKElucHV0LmlzTW91c2VKdXN0UHJlc3NlZCgpKXtcblx0XHRcdGxldCBjbGlja1BvcyA9IElucHV0LmdldE1vdXNlUHJlc3NQb3NpdGlvbigpO1xuXHRcdFx0aWYodGhpcy5jb250YWlucyhjbGlja1Bvcy54LCBjbGlja1Bvcy55KSAmJiB0aGlzLnZpc2libGUgJiYgIXRoaXMubGF5ZXIuaXNIaWRkZW4oKSl7XG5cdFx0XHRcdHRoaXMuaXNDbGlja2VkID0gdHJ1ZTtcblxuXHRcdFx0XHRpZih0aGlzLm9uQ2xpY2sgIT09IG51bGwpe1xuXHRcdFx0XHRcdHRoaXMub25DbGljaygpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHRoaXMub25DbGlja0V2ZW50SWQgIT09IG51bGwpe1xuXHRcdFx0XHRcdGxldCBkYXRhID0ge307XG5cdFx0XHRcdFx0dGhpcy5lbWl0dGVyLmZpcmVFdmVudCh0aGlzLm9uQ2xpY2tFdmVudElkLCBkYXRhKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIElmIHRoZSBtb3VzZSB3YXNuJ3QganVzdCBwcmVzc2VkLCB0aGVuIHdlIGRlZmluaXRlbHkgd2VyZW4ndCBjbGlja2VkXG5cdFx0aWYoIUlucHV0LmlzTW91c2VQcmVzc2VkKCkpe1xuXHRcdFx0aWYodGhpcy5pc0NsaWNrZWQpe1xuXHRcdFx0XHR0aGlzLmlzQ2xpY2tlZCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENoZWNrIGlmIHRoZSBtb3VzZSBpcyBob3ZlcmluZyBvdmVyIHRoaXMgZWxlbWVudFxuXHRcdGxldCBtb3VzZVBvcyA9IElucHV0LmdldE1vdXNlUG9zaXRpb24oKTtcblx0XHRpZihtb3VzZVBvcyAmJiB0aGlzLmNvbnRhaW5zKG1vdXNlUG9zLngsIG1vdXNlUG9zLnkpKXtcblx0XHRcdHRoaXMuaXNFbnRlcmVkID0gdHJ1ZTtcblxuXHRcdFx0aWYodGhpcy5vbkVudGVyICE9PSBudWxsKXtcblx0XHRcdFx0dGhpcy5vbkVudGVyKCk7XG5cdFx0XHR9XG5cdFx0XHRpZih0aGlzLm9uRW50ZXJFdmVudElkICE9PSBudWxsKXtcblx0XHRcdFx0bGV0IGRhdGEgPSB7fTtcblx0XHRcdFx0dGhpcy5lbWl0dGVyLmZpcmVFdmVudCh0aGlzLm9uRW50ZXJFdmVudElkLCBkYXRhKTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZih0aGlzLmlzRW50ZXJlZCkge1xuXHRcdFx0dGhpcy5pc0VudGVyZWQgPSBmYWxzZTtcblxuXHRcdFx0aWYodGhpcy5vbkxlYXZlICE9PSBudWxsKXtcblx0XHRcdFx0dGhpcy5vbkxlYXZlKCk7XG5cdFx0XHR9XG5cdFx0XHRpZih0aGlzLm9uTGVhdmVFdmVudElkICE9PSBudWxsKXtcblx0XHRcdFx0bGV0IGRhdGEgPSB7fTtcblx0XHRcdFx0dGhpcy5lbWl0dGVyLmZpcmVFdmVudCh0aGlzLm9uTGVhdmVFdmVudElkLCBkYXRhKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYodGhpcy5pc0NsaWNrZWQpIHtcblx0XHRcdC8vIElmIG1vdXNlIGlzIGRyYWdnZWQgb2ZmIG9mIGVsZW1lbnQgd2hpbGUgZG93biwgaXQgaXMgbm90IGNsaWNrZWQgYW55bW9yZVxuXHRcdFx0dGhpcy5pc0NsaWNrZWQgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogT3ZlcnJpZGFibGUgbWV0aG9kIGZvciBjYWxjdWxhdGluZyBiYWNrZ3JvdW5kIGNvbG9yIC0gdXNlZnVsIGZvciBlbGVtZW50cyB0aGF0IHdhbnQgdG8gYmUgY29sb3JlZCBvbiBkaWZmZXJlbnQgYWZ0ZXIgY2VydGFpbiBldmVudHNcblx0ICogQHJldHVybnMgVGhlIGJhY2tncm91bmQgY29sb3Igb2YgdGhlIFVJRWxlbWVudFxuXHQgKi9cblx0Y2FsY3VsYXRlQmFja2dyb3VuZENvbG9yKCk6IENvbG9yIHtcblx0XHRyZXR1cm4gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG5cdH1cblxuXHQvKipcblx0ICogT3ZlcnJpZGFibGUgbWV0aG9kIGZvciBjYWxjdWxhdGluZyBib3JkZXIgY29sb3IgLSB1c2VmdWwgZm9yIGVsZW1lbnRzIHRoYXQgd2FudCB0byBiZSBjb2xvcmVkIG9uIGRpZmZlcmVudCBhZnRlciBjZXJ0YWluIGV2ZW50c1xuXHQgKiBAcmV0dXJucyBUaGUgYm9yZGVyIGNvbG9yIG9mIHRoZSBVSUVsZW1lbnRcblx0ICovXG5cdGNhbGN1bGF0ZUJvcmRlckNvbG9yKCk6IENvbG9yIHtcblx0XHRyZXR1cm4gdGhpcy5ib3JkZXJDb2xvcjtcblx0fVxufSIsImltcG9ydCBMYWJlbCBmcm9tIFwiLi9MYWJlbFwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9VdGlscy9Db2xvclwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5cbi8qKiBBIGNsaWNrYWJsZSBidXR0b24gVUlFbGVtZW50ICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdXR0b24gZXh0ZW5kcyBMYWJlbCB7XG5cblx0Y29uc3RydWN0b3IocG9zaXRpb246IFZlYzIsIHRleHQ6IHN0cmluZyl7XG5cdFx0c3VwZXIocG9zaXRpb24sIHRleHQpO1xuXHRcdFxuXHRcdHRoaXMuYmFja2dyb3VuZENvbG9yID0gbmV3IENvbG9yKDE1MCwgNzUsIDIwMyk7XG5cdFx0dGhpcy5ib3JkZXJDb2xvciA9IG5ldyBDb2xvcig0MSwgNDYsIDMwKTtcblx0XHR0aGlzLnRleHRDb2xvciA9IG5ldyBDb2xvcigyNTUsIDI1NSwgMjU1KTtcblx0fVxuXG5cdC8vIEBvdmVycmlkZVxuXHRjYWxjdWxhdGVCYWNrZ3JvdW5kQ29sb3IoKTogQ29sb3Ige1xuXHRcdC8vIENoYW5nZSB0aGUgYmFja2dyb3VuZCBjb2xvciBpZiBjbGlja2VkIG9yIGhvdmVyZWRcblx0XHRpZih0aGlzLmlzRW50ZXJlZCAmJiAhdGhpcy5pc0NsaWNrZWQpe1xuXHRcdFx0cmV0dXJuIHRoaXMuYmFja2dyb3VuZENvbG9yLmxpZ2h0ZW4oKTtcblx0XHR9IGVsc2UgaWYodGhpcy5pc0NsaWNrZWQpe1xuXHRcdFx0cmV0dXJuIHRoaXMuYmFja2dyb3VuZENvbG9yLmRhcmtlbigpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG5cdFx0fVxuXHR9XG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL1V0aWxzL0NvbG9yXCI7XG5pbXBvcnQgVUlFbGVtZW50IGZyb20gXCIuLi9VSUVsZW1lbnRcIjtcblxuLyoqIEEgYmFzaWMgdGV4dC1jb250YWluaW5nIGxhYmVsICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYWJlbCBleHRlbmRzIFVJRWxlbWVudHtcblx0LyoqIFRoZSBjb2xvciBvZiB0aGUgdGV4dCBvZiB0aGlzIFVJRWxlbWVudCAqL1xuXHR0ZXh0Q29sb3I6IENvbG9yO1xuXHQvKiogVGhlIHZhbHVlIG9mIHRoZSB0ZXh0IG9mIHRoaXMgVUlFbGVtZW50ICovXG5cdHRleHQ6IHN0cmluZztcblx0LyoqIFRoZSBuYW1lIG9mIHRoZSBmb250ICovXG5cdGZvbnQ6IHN0cmluZztcblx0LyoqIFRoZSBzaXplIG9mIHRoZSBmb250ICovXG5cdGZvbnRTaXplOiBudW1iZXI7XG5cdC8qKiBUaGUgaG9yaXpvbnRhbCBhbGlnbm1lbnQgb2YgdGhlIHRleHQgd2l0aGluIHRoZSBsYWJlbCAqL1xuXHRwcm90ZWN0ZWQgaEFsaWduOiBzdHJpbmc7XG5cdC8qKiBUaGUgdmVydGljYWwgYWxpZ25tZW50IG9mIHRleHQgd2l0aGluIHRoZSBsYWJlbCAqL1xuXHRwcm90ZWN0ZWQgdkFsaWduOiBzdHJpbmc7XG5cblx0LyoqIEEgZmxhZyBmb3IgaWYgdGhlIHdpZHRoIG9mIHRoZSB0ZXh0IGhhcyBiZWVuIG1lYXN1cmVkIG9uIHRoZSBjYW52YXMgZm9yIGF1dG8gd2lkdGggYXNzaWdubWVudCAqL1xuXHRwcm90ZWN0ZWQgc2l6ZUFzc2lnbmVkOiBib29sZWFuO1xuXG5cdGNvbnN0cnVjdG9yKHBvc2l0aW9uOiBWZWMyLCB0ZXh0OiBzdHJpbmcpe1xuXHRcdHN1cGVyKHBvc2l0aW9uKTtcblx0XHR0aGlzLnRleHQgPSB0ZXh0O1xuXHRcdHRoaXMudGV4dENvbG9yID0gbmV3IENvbG9yKDAsIDAsIDAsIDEpO1xuXHRcdHRoaXMuZm9udCA9IFwiQXJpYWxcIjtcblx0XHR0aGlzLmZvbnRTaXplID0gMzA7XG5cdFx0dGhpcy5oQWxpZ24gPSBcImNlbnRlclwiO1xuXHRcdHRoaXMudkFsaWduID0gXCJjZW50ZXJcIjtcblxuXHRcdHRoaXMuc2l6ZUFzc2lnbmVkID0gZmFsc2U7XG5cdH1cblxuXHQvLyBAZGVwcmVjYXRlZFxuXHRzZXRUZXh0KHRleHQ6IHN0cmluZyk6IHZvaWQge1xuXHRcdHRoaXMudGV4dCA9IHRleHQ7XG5cdH1cblxuXHQvLyBAZGVwcmVjYXRlZFxuXHRzZXRUZXh0Q29sb3IoY29sb3I6IENvbG9yKTogdm9pZCB7XG5cdFx0dGhpcy50ZXh0Q29sb3IgPSBjb2xvcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIGEgc3RyaW5nIGNvbnRhaW5nIHRoZSBmb250IGRldGFpbHMgZm9yIHJlbmRlcmluZ1xuXHQgKiBAcmV0dXJucyBBIHN0cmluZyBjb250YWluaW5nIHRoZSBmb250IGRldGFpbHNcblx0ICovXG5cdGdldEZvbnRTdHJpbmcoKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gdGhpcy5mb250U2l6ZSArIFwicHggXCIgKyB0aGlzLmZvbnQ7XG5cdH1cblxuXHQvKipcblx0ICogT3ZlcnJpZGFibGUgbWV0aG9kIGZvciBjYWxjdWxhdGluZyB0ZXh0IGNvbG9yIC0gdXNlZnVsIGZvciBlbGVtZW50cyB0aGF0IHdhbnQgdG8gYmUgY29sb3JlZCBvbiBkaWZmZXJlbnQgYWZ0ZXIgY2VydGFpbiBldmVudHNcblx0ICogQHJldHVybnMgYSBzdHJpbmcgY29udGFpbmcgdGhlIHRleHQgY29sb3Jcblx0ICovXG5cdGNhbGN1bGF0ZVRleHRDb2xvcigpOiBzdHJpbmcge1xuXHRcdHJldHVybiB0aGlzLnRleHRDb2xvci50b1N0cmluZ1JHQkEoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVc2VzIHRoZSBjYW52YXMgdG8gY2FsY3VsYXRlIHRoZSB3aWR0aCBvZiB0aGUgdGV4dFxuXHQgKiBAcGFyYW0gY3R4IFRoZSByZW5kZXJpbmcgY29udGV4dFxuXHQgKiBAcmV0dXJucyBBIG51bWJlciByZXByZXNlbnRpbmcgdGhlIHJlbmRlcmVkIHRleHQgd2lkdGhcblx0ICovXG5cdHByb3RlY3RlZCBjYWxjdWxhdGVUZXh0V2lkdGgoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpOiBudW1iZXIge1xuXHRcdGN0eC5mb250ID0gdGhpcy5mb250U2l6ZSArIFwicHggXCIgKyB0aGlzLmZvbnQ7XG5cdFx0cmV0dXJuIGN0eC5tZWFzdXJlVGV4dCh0aGlzLnRleHQpLndpZHRoO1xuXHR9XG5cblx0c2V0SEFsaWduKGFsaWduOiBzdHJpbmcpOiB2b2lkIHtcblx0XHR0aGlzLmhBbGlnbiA9IGFsaWduO1xuXHR9XG5cblx0c2V0VkFsaWduKGFsaWduOiBzdHJpbmcpOiB2b2lkIHtcblx0XHR0aGlzLnZBbGlnbiA9IGFsaWduO1xuXHR9XG5cblx0LyoqXG5cdCAqIENhbGN1bGF0ZSB0aGUgb2Zmc2V0IG9mIHRoZSB0ZXh0IC0gdGhpcyBpcyB1c2VkIGZvciByZW5kZXJpbmcgdGV4dCB3aXRoIGRpZmZlcmVudCBhbGlnbm1lbnRzXG5cdCAqIEBwYXJhbSBjdHggVGhlIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqIEByZXR1cm5zIFRoZSBvZmZzZXQgb2YgdGhlIHRleHQgaW4gYSBWZWMyXG5cdCAqL1xuXHRjYWxjdWxhdGVUZXh0T2Zmc2V0KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogVmVjMiB7XG5cdFx0bGV0IHRleHRXaWR0aCA9IHRoaXMuY2FsY3VsYXRlVGV4dFdpZHRoKGN0eCk7XG5cblx0XHRsZXQgb2Zmc2V0ID0gbmV3IFZlYzIoMCwgMCk7XG5cblx0XHRsZXQgaERpZmYgPSB0aGlzLnNpemUueCAtIHRleHRXaWR0aDtcblx0XHRpZih0aGlzLmhBbGlnbiA9PT0gSEFsaWduLkNFTlRFUil7XG5cdFx0XHRvZmZzZXQueCA9IGhEaWZmLzI7XG5cdFx0fSBlbHNlIGlmICh0aGlzLmhBbGlnbiA9PT0gSEFsaWduLlJJR0hUKXtcblx0XHRcdG9mZnNldC54ID0gaERpZmY7XG5cdFx0fVxuXG5cdFx0aWYodGhpcy52QWxpZ24gPT09IFZBbGlnbi5UT1Ape1xuXHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9IFwidG9wXCI7XG5cdFx0XHRvZmZzZXQueSA9IDA7XG5cdFx0fSBlbHNlIGlmICh0aGlzLnZBbGlnbiA9PT0gVkFsaWduLkJPVFRPTSl7XG5cdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gXCJib3R0b21cIjtcblx0XHRcdG9mZnNldC55ID0gdGhpcy5zaXplLnk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuXHRcdFx0b2Zmc2V0LnkgPSB0aGlzLnNpemUueS8yO1xuXHRcdH1cblxuXHRcdHJldHVybiBvZmZzZXQ7XG5cdH1cblxuXHRwcm90ZWN0ZWQgc2l6ZUNoYW5nZWQoKTogdm9pZCB7XG5cdFx0c3VwZXIuc2l6ZUNoYW5nZWQoKTtcblx0XHR0aGlzLnNpemVBc3NpZ25lZCA9IHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogQXV0b21hdGljYWxseSBzaXplcyB0aGUgZWxlbWVudCB0byB0aGUgdGV4dCB3aXRoaW4gaXRcblx0ICogQHBhcmFtIGN0eCBUaGUgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG5cdHByb3RlY3RlZCBhdXRvU2l6ZShjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCk6IHZvaWQge1xuXHRcdGxldCB3aWR0aCA9IHRoaXMuY2FsY3VsYXRlVGV4dFdpZHRoKGN0eCk7XG5cdFx0bGV0IGhlaWdodCA9IHRoaXMuZm9udFNpemU7XG5cdFx0dGhpcy5zaXplLnNldCh3aWR0aCArIHRoaXMucGFkZGluZy54KjIsIGhlaWdodCArIHRoaXMucGFkZGluZy55KjIpO1xuXHRcdHRoaXMuc2l6ZUFzc2lnbmVkID0gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbml0aWFsbHkgYXNzaWducyBhIHNpemUgdG8gdGhlIFVJRWxlbWVudCBpZiBub25lIGlzIHByb3ZpZGVkXG5cdCAqIEBwYXJhbSBjdHggVGhlIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqL1xuXHRoYW5kbGVJbml0aWFsU2l6aW5nKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogdm9pZCB7XG5cdFx0aWYoIXRoaXMuc2l6ZUFzc2lnbmVkKXtcblx0XHRcdHRoaXMuYXV0b1NpemUoY3R4KTtcblx0XHR9XG5cdH1cblxuXHQvKiogT24gdGhlIG5leHQgcmVuZGVyLCBzaXplIHRoaXMgZWxlbWVudCB0byBpdCdzIGN1cnJlbnQgdGV4dCB1c2luZyBpdHMgY3VycmVudCBmb250IHNpemUgKi9cblx0c2l6ZVRvVGV4dCgpOiB2b2lkIHtcblx0XHR0aGlzLnNpemVBc3NpZ25lZCA9IGZhbHNlO1xuXHR9XG59XG5cbmV4cG9ydCBlbnVtIFZBbGlnbiB7XG5cdFRPUCA9IFwidG9wXCIsXG5cdENFTlRFUiA9IFwiY2VudGVyXCIsXG5cdEJPVFRPTSA9IFwiYm90dG9tXCJcbn1cblxuZXhwb3J0IGVudW0gSEFsaWduIHtcblx0TEVGVCA9IFwibGVmdFwiLFxuXHRDRU5URVIgPSBcImNlbnRlclwiLFxuXHRSSUdIVCA9IFwicmlnaHRcIlxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IElucHV0IGZyb20gXCIuLi8uLi9JbnB1dC9JbnB1dFwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9VdGlscy9Db2xvclwiO1xuaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vLi4vVXRpbHMvTWF0aFV0aWxzXCI7XG5pbXBvcnQgVUlFbGVtZW50IGZyb20gXCIuLi9VSUVsZW1lbnRcIjtcblxuLyoqIEEgc2xpZGVyIFVJRWxlbWVudCAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2xpZGVyIGV4dGVuZHMgVUlFbGVtZW50IHtcbiAgICAvKiogVGhlIHZhbHVlIG9mIHRoZSBzbGlkZXIgZnJvbSBbMCwgMV0gKi9cbiAgICBwcm90ZWN0ZWQgdmFsdWU6IG51bWJlcjtcbiAgICAvKiogVGhlIGNvbG9yIG9mIHRoZSBzbGlkZXIgbmliICovXG4gICAgcHVibGljIG5pYkNvbG9yOiBDb2xvcjtcbiAgICAvKiogVGhlIHNpemUgb2YgdGhlIG5pYiAqL1xuICAgIHB1YmxpYyBuaWJTaXplOiBWZWMyO1xuICAgIC8qKiBUaGUgY29sb3Igb2YgdGhlIHNsaWRlciB0cmFjayAqL1xuICAgIHB1YmxpYyBzbGlkZXJDb2xvcjogQ29sb3I7XG4gICAgLyoqIFRoZSByZWFjdGlvbiBvZiB0aGlzIFVJRWxlbWVudCB0byBhIHZhbHVlIGNoYW5nZSAqL1xuICAgIHB1YmxpYyBvblZhbHVlQ2hhbmdlOiBGdW5jdGlvbjtcbiAgICAvKiogVGhlIGV2ZW50IHByb3BhZ2F0ZWQgYnkgdGhpcyBVSUVsZW1lbnQgd2hlbiB2YWx1ZSBjaGFuZ2VzICovXG4gICAgcHVibGljIG9uVmFsdWVDaGFuZ2VFdmVudElkOiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3Rvcihwb3NpdGlvbjogVmVjMiwgaW5pdFZhbHVlOiBudW1iZXIpe1xuICAgICAgICBzdXBlcihwb3NpdGlvbik7XG5cbiAgICAgICAgdGhpcy52YWx1ZSA9IGluaXRWYWx1ZTtcbiAgICAgICAgdGhpcy5uaWJDb2xvciA9IENvbG9yLlJFRDtcbiAgICAgICAgdGhpcy5zbGlkZXJDb2xvciA9IENvbG9yLkJMQUNLO1xuICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xuICAgICAgICB0aGlzLmJvcmRlckNvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XG4gICAgICAgIHRoaXMubmliU2l6ZSA9IG5ldyBWZWMyKDEwLCAyMCk7XG5cbiAgICAgICAgLy8gU2V0IGEgZGVmYXVsdCBzaXplXG4gICAgICAgIHRoaXMuc2l6ZS5zZXQoMjAwLCAyMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB2YWx1ZSBvZiB0aGUgc2xpZGVyXG4gICAgICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSBzbGlkZXJcbiAgICAgKi9cbiAgICBnZXRWYWx1ZSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG5cbiAgICAvKiogQSBtZXRob2QgY2FsbGVkIGluIHJlc3BvbnNlIHRvIHRoZSB2YWx1ZSBjaGFuZ2luZyAqL1xuICAgIHByb3RlY3RlZCB2YWx1ZUNoYW5nZWQoKTogdm9pZCB7XG4gICAgICAgIGlmKHRoaXMub25WYWx1ZUNoYW5nZSl7XG4gICAgICAgICAgICB0aGlzLm9uVmFsdWVDaGFuZ2UodGhpcy52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLm9uVmFsdWVDaGFuZ2VFdmVudElkKXtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQodGhpcy5vblZhbHVlQ2hhbmdlRXZlbnRJZCwge3RhcmdldDogdGhpcywgdmFsdWU6IHRoaXMudmFsdWV9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBzdXBlci51cGRhdGUoZGVsdGFUKTtcblxuICAgICAgICBpZih0aGlzLmlzQ2xpY2tlZCl7XG4gICAgICAgICAgICBsZXQgdmFsID0gTWF0aFV0aWxzLmludkxlcnAodGhpcy5wb3NpdGlvbi54IC0gdGhpcy5zaXplLngvMiwgdGhpcy5wb3NpdGlvbi54ICsgdGhpcy5zaXplLngvMiwgSW5wdXQuZ2V0TW91c2VQb3NpdGlvbigpLngpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IE1hdGhVdGlscy5jbGFtcDAxKHZhbCk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9VdGlscy9Db2xvclwiO1xuaW1wb3J0IExhYmVsIGZyb20gXCIuL0xhYmVsXCI7XG5pbXBvcnQgSW5wdXQgZnJvbSBcIi4uLy4uL0lucHV0L0lucHV0XCI7XG5cbi8qKiBBIHRleHQgaW5wdXQgVUlFbGVtZW50ICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0SW5wdXQgZXh0ZW5kcyBMYWJlbCB7XG4gICAgLyoqIEEgZmxhZyB0aGUgcmVwcmVzZW50cyB3aGV0aGVyIHRoZSB1c2VyIGNhbiB0eXBlIGluIHRoaXMgVGV4dElucHV0ICovXG4gICAgZm9jdXNlZDogYm9vbGVhbjtcbiAgICAvKiogVGhlIHBvc2l0aW9uIG9mIHRoZSBjdXJzb3IgaW4gdGhpcyBUZXh0SW5wdXQgKi9cbiAgICBjdXJzb3JDb3VudGVyOiBudW1iZXI7XG5cbiAgICBjb25zdHJ1Y3Rvcihwb3NpdGlvbjogVmVjMil7XG4gICAgICAgIHN1cGVyKHBvc2l0aW9uLCBcIlwiKTtcblxuICAgICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJzb3JDb3VudGVyID0gMDtcblxuICAgICAgICAvLyBHaXZlIGEgZGVmYXVsdCBzaXplIHRvIHRoZSB4IG9ubHlcbiAgICAgICAgdGhpcy5zaXplLnNldCgyMDAsIHRoaXMuZm9udFNpemUpO1xuICAgICAgICB0aGlzLmhBbGlnbiA9IFwibGVmdFwiO1xuXG4gICAgICAgIHRoaXMuYm9yZGVyQ29sb3IgPSBDb2xvci5CTEFDSztcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5XSElURTtcbiAgICB9XG5cbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgc3VwZXIudXBkYXRlKGRlbHRhVCk7XG5cbiAgICAgICAgaWYoSW5wdXQuaXNNb3VzZUp1c3RQcmVzc2VkKCkpe1xuXHRcdFx0bGV0IGNsaWNrUG9zID0gSW5wdXQuZ2V0TW91c2VQcmVzc1Bvc2l0aW9uKCk7XG5cdFx0XHRpZih0aGlzLmNvbnRhaW5zKGNsaWNrUG9zLngsIGNsaWNrUG9zLnkpKXtcbiAgICAgICAgICAgICAgICB0aGlzLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yQ291bnRlciA9IDMwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuZm9jdXNlZCl7XG4gICAgICAgICAgICBsZXQga2V5cyA9IElucHV0LmdldEtleXNKdXN0UHJlc3NlZCgpO1xuICAgICAgICAgICAgbGV0IG51bXMgPSBcIjEyMzQ1Njc4OTBcIjtcbiAgICAgICAgICAgIGxldCBzcGVjaWFsQ2hhcnMgPSBcImB+IUAjJCVeJiooKS1fPStbe119XFxcXHw7OidcXFwiLDwuPi8/XCI7XG4gICAgICAgICAgICBsZXQgbGV0dGVycyA9IFwicXdlcnR5dWlvcGFzZGZnaGprbHp4Y3Zibm1cIjtcbiAgICAgICAgICAgIGxldCBtYXNrID0gbnVtcyArIHNwZWNpYWxDaGFycyArIGxldHRlcnM7XG4gICAgICAgICAgICBrZXlzID0ga2V5cy5maWx0ZXIoa2V5ID0+IG1hc2suaW5jbHVkZXMoa2V5KSk7XG4gICAgICAgICAgICBsZXQgc2hpZnRQcmVzc2VkID0gSW5wdXQuaXNLZXlQcmVzc2VkKFwic2hpZnRcIik7XG4gICAgICAgICAgICBsZXQgYmFja3NwYWNlUHJlc3NlZCA9IElucHV0LmlzS2V5SnVzdFByZXNzZWQoXCJiYWNrc3BhY2VcIik7XG4gICAgICAgICAgICBsZXQgc3BhY2VQcmVzc2VkID0gSW5wdXQuaXNLZXlKdXN0UHJlc3NlZChcInNwYWNlXCIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihiYWNrc3BhY2VQcmVzc2VkKXtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHQgPSB0aGlzLnRleHQuc3Vic3RyaW5nKDAsIHRoaXMudGV4dC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZihzcGFjZVByZXNzZWQpe1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dCArPSBcIiBcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZihrZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZihzaGlmdFByZXNzZWQpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHQgKz0ga2V5c1swXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dCArPSBrZXlzWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0iLCJleHBvcnQgZW51bSBVSUVsZW1lbnRUeXBlIHtcblx0QlVUVE9OID0gXCJCVVRUT05cIixcblx0TEFCRUwgPSBcIkxBQkVMXCIsXG5cdFNMSURFUiA9IFwiU0xJREVSXCIsXG5cdFRFWFRfSU5QVVQgPSBcIlRFWFRJTlBVVFwiXG59IiwiaW1wb3J0IE5hdmlnYWJsZSBmcm9tIFwiLi4vRGF0YVR5cGVzL1BhdGhmaW5kaW5nL05hdmlnYWJsZVwiO1xuaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL0NvbGxlY3Rpb25zL01hcFwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgTmF2aWdhdGlvblBhdGggZnJvbSBcIi4vTmF2aWdhdGlvblBhdGhcIjtcbmltcG9ydCBOYXZtZXNoIGZyb20gXCIuL05hdm1lc2hcIjtcblxuLyoqXG4gKiBUaGUgbWFuYWdlciBjbGFzcyBmb3IgbmF2aWdhdGlvbi5cbiAqIEhhbmRsZXMgYWxsIG5hdmlnYWJsZSBlbnRpdGllcywgc3VjaCBhbmQgYWxsb3dzIHRoZW0gdG8gYmUgYWNjZXNzZWQgYnkgb3V0c2lkZSBzeXN0ZW1zIGJ5IHJlcXVlc3RpbmcgYSBwYXRoXG4gKiBmcm9tIG9uZSBwb3NpdGlvbiB0byBhbm90aGVyLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOYXZpZ2F0aW9uTWFuYWdlciB7XG5cdC8qKiBUaGUgbGlzdCBvZiBhbGwgbmF2aWdhYmxlIGVudGl0aWVzICovXG5cdHByb3RlY3RlZCBuYXZpZ2FibGVFbnRpdGllczogTWFwPE5hdm1lc2g+O1xuXG5cdGNvbnN0cnVjdG9yKCl7XG5cdFx0dGhpcy5uYXZpZ2FibGVFbnRpdGllcyA9IG5ldyBNYXAoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgbmF2aWdhYmxlIGVudGl0eSB0byB0aGUgTmF2aWdhdGlvbk1hbmFnZXJcblx0ICogQHBhcmFtIG5hdk5hbWUgVGhlIG5hbWUgb2YgdGhlIG5hdmlnYWJsZSBlbnRpdHJ5XG5cdCAqIEBwYXJhbSBuYXYgVGhlIGFjdHVhbCBOYXZpZ2FibGUgaW5zdGFuY2Vcblx0ICovXG5cdGFkZE5hdmlnYWJsZUVudGl0eShuYXZOYW1lOiBzdHJpbmcsIG5hdjogTmF2bWVzaCk6IHZvaWQge1xuXHRcdHRoaXMubmF2aWdhYmxlRW50aXRpZXMuYWRkKG5hdk5hbWUsIG5hdik7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyBhIHBhdGggZnJvbWUgb25lIHBvaW50IHRvIGFub3RoZXIgdXNpbmcgYSBzcGVjaWZpZWQgTmF2aWdhYmxlIG9iamVjdFxuXHQgKiBAcGFyYW0gbmF2TmFtZSBUaGUgbmFtZSBvZiB0aGUgcmVnaXN0ZXJlZCBOYXZpZ2FibGUgb2JqZWN0XG5cdCAqIEBwYXJhbSBmcm9tUG9zaXRpb24gVGhlIHN0YXJ0aW5nIHBvc2l0aW9uIG9mIG5hdmlnYXRpb25cblx0ICogQHBhcmFtIHRvUG9zaXRpb24gVGhlIGVuZGluZyBwb3NpdGlvbiBvZiBOYXZpZ2F0aW9uXG5cdCAqIEBwYXJhbSBkaXJlY3QgSWYgdHJ1ZSwgZ28gZGlyZWN0IGZyb20gZnJvbVBvc2l0aW9uIHRvIHRvUG9zaXRpb24sIGRvbid0IHVzZSBOYXZNZXNoXG5cdCAqIEByZXR1cm5zIEEgTmF2aWdhdGlvblBhdGggY29udGFpbmluZyB0aGUgcm91dGUgdG8gdGFrZSBvdmVyIHRoZSBOYXZpZ2FibGUgZW50aXR5IHRvIGdldCBiZXR3ZWVuIHRoZSBwcm92aWRlZCBwb3NpdGlvbnMuXG5cdCAqL1xuXHRnZXRQYXRoKG5hdk5hbWU6IHN0cmluZywgZnJvbVBvc2l0aW9uOiBWZWMyLCB0b1Bvc2l0aW9uOiBWZWMyKTogTmF2aWdhdGlvblBhdGgge1xuXHRcdGxldCBuYXYgPSB0aGlzLm5hdmlnYWJsZUVudGl0aWVzLmdldChuYXZOYW1lKTtcblx0XHRyZXR1cm4gbmF2LmdldE5hdmlnYXRpb25QYXRoKGZyb21Qb3NpdGlvbi5jbG9uZSgpLCB0b1Bvc2l0aW9uLmNsb25lKCkpO1xuXHR9XG59IiwiaW1wb3J0IFN0YWNrIGZyb20gXCIuLi9EYXRhVHlwZXMvQ29sbGVjdGlvbnMvU3RhY2tcIjtcbmltcG9ydCBQYXRoIGZyb20gXCIuLi9EYXRhVHlwZXMvUGF0aGZpbmRpbmcvUGF0aFwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uL05vZGVzL0dhbWVOb2RlXCI7XG5cbi8qKlxuICogQSBwYXRoIHRoYXQgQUlzIGNhbiBmb2xsb3cuIFVzZXMgZmluaXNoTW92ZSgpIGluIFBoeXNpY2FsIHRvIGRldGVybWluZSBwcm9ncmVzcyBvbiB0aGUgcm91dGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmF2aWdhdGlvblBhdGggaW1wbGVtZW50cyBQYXRoPFZlYzI+IHtcblx0LyoqIFRoZSBuYXZpZ2F0aW9uIHBhdGgsIHN0b3JlZCBhcyBhIHN0YWNrIG9mIG5leHQgcG9zaXRpb25zICovXG5cdHByb3RlY3RlZCBwYXRoOiBTdGFjazxWZWMyPjtcblx0LyoqIFRoZSBjdXJyZW50IGRpcmVjdGlvbiBvZiBtb3ZlbWVudCAqL1xuXHRwcm90ZWN0ZWQgY3VycmVudE1vdmVEaXJlY3Rpb246IFZlYzI7XG5cdC8qKiBUaGUgZGlzdGFuY2UgYSBub2RlIG11c3QgYmUgdG8gYSBwb2ludCB0byBjb25zaWRlciBpdCBhcyBoYXZpbmcgYXJyaXZlZCAqL1xuXHRwcm90ZWN0ZWQgZGlzdGFuY2VUaHJlc2hvbGQ6IG51bWJlcjtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBOYXZpZ2F0aW9uUGF0aFxuXHQgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCBvZiBub2RlcyB0byB0YWtlXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihwYXRoOiBTdGFjazxWZWMyPil7XG5cdFx0dGhpcy5wYXRoID0gcGF0aDtcblx0XHR0aGlzLmN1cnJlbnRNb3ZlRGlyZWN0aW9uID0gVmVjMi5aRVJPO1xuXHRcdHRoaXMuZGlzdGFuY2VUaHJlc2hvbGQgPSA0O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHN0YXR1cyBvZiBuYXZpZ2F0aW9uIGFsb25nIHRoaXMgTmF2aWdhdGlvblBhdGhcblx0ICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgbm9kZSBoYXMgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBwYXRoLCBmYWxzZSBvdGhlcndpc2Vcblx0ICovXG5cdGlzRG9uZSgpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy5wYXRoLmlzRW1wdHkoKTtcblx0fVxuXG4gICAgbmV4dCgpOiBWZWMyIHwgbnVsbCB7IHJldHVybiB0aGlzLnBhdGguaXNFbXB0eSgpID8gbnVsbCA6IHRoaXMucGF0aC5wZWVrKCk7IH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgbW92ZW1lbnQgZGlyZWN0aW9uIGluIHRoZSBjdXJyZW50IHBvc2l0aW9uIGFsb25nIHRoZSBwYXRoXG5cdCAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIG1vdmUgYWxvbmcgdGhlIHBhdGhcblx0ICogQHJldHVybnMgVGhlIG1vdmVtZW50IGRpcmVjdGlvbiBhcyBhIFZlYzJcblx0ICovXG5cdGdldE1vdmVEaXJlY3Rpb24obm9kZTogR2FtZU5vZGUpOiBWZWMyIHtcblx0XHQvLyBSZXR1cm4gZGlyZWN0aW9uIHRvIG5leHQgcG9pbnQgaW4gdGhlIG5hdlxuXHRcdHJldHVybiBub2RlLnBvc2l0aW9uLmRpclRvKHRoaXMucGF0aC5wZWVrKCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhpcyBOYXZpZ2F0aW9uUGF0aCB0byB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgR2FtZU5vZGVcblx0ICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgbW92aW5nIGFsb25nIHRoZSBwYXRoXG5cdCAqL1xuXHRoYW5kbGVQYXRoUHJvZ3Jlc3Mobm9kZTogR2FtZU5vZGUpOiB2b2lkIHtcblx0XHRpZighdGhpcy5wYXRoLmlzRW1wdHkoKSAmJiBub2RlLnBvc2l0aW9uLmRpc3RhbmNlU3FUbyh0aGlzLnBhdGgucGVlaygpKSA8IHRoaXMuZGlzdGFuY2VUaHJlc2hvbGQqdGhpcy5kaXN0YW5jZVRocmVzaG9sZCl7XG5cdFx0XHQvLyBXZSd2ZSByZWFjaGVkIG91ciBub2RlLCBtb3ZlIG9uIHRvIHRoZSBuZXh0IGRlc3RpbmF0aW9uXG5cdFx0XHR0aGlzLnBhdGgucG9wKCk7XG5cdFx0fVxuXHR9XG5cblx0dG9TdHJpbmcoKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gdGhpcy5wYXRoLnRvU3RyaW5nKClcblx0fVxufSIsImltcG9ydCBQb3NpdGlvbkdyYXBoIGZyb20gXCIuLi9EYXRhVHlwZXMvR3JhcGhzL1Bvc2l0aW9uR3JhcGhcIjtcbmltcG9ydCBOYXZpZ2FibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9QYXRoZmluZGluZy9OYXZpZ2FibGVcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IE5hdmlnYXRpb25QYXRoIGZyb20gXCIuL05hdmlnYXRpb25QYXRoXCI7XG5pbXBvcnQgTmF2aWdhdGlvblN0cmF0ZWd5IGZyb20gXCIuL1N0cmF0ZWdpZXMvTmF2aWdhdGlvblN0cmF0ZWd5XCI7XG5cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgYSBOYXZtZXNoLiBOYXZtZXNoZXMgYXJlIGdyYXBocyBpbiB0aGUgZ2FtZSB3b3JsZCBhbG9uZyB3aGljaCBub2RlcyBjYW4gbW92ZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmF2bWVzaCBpbXBsZW1lbnRzIE5hdmlnYWJsZTxWZWMyLCBOYXZpZ2F0aW9uUGF0aD4ge1xuXHQvKiogVGhlIGdyYXBoIG9mIHBvaW50cyBpbiB0aGUgTmF2TWVzaCAqL1xuXHRwcm90ZWN0ZWQgX2dyYXBoOiBQb3NpdGlvbkdyYXBoO1xuICAgIC8qKiBUaGUgc3RyYXRlZ3kgdXNlZCB0byBnZW5lcmF0ZSB0aGUgTmF2aWdhdGlvblBhdGggKi9cbiAgICBwcm90ZWN0ZWQgX3N0cmF0ZWdpZXM6IE1hcDxzdHJpbmcsIE5hdmlnYXRpb25TdHJhdGVneT47XG4gICAgLyoqIFRoZSBzdHJhdGVneSBjdXJyZW50bHkgYmVpbmcgdXNlZCB0byBnZW5lcmF0ZSBwYXRocyBvbiB0aGlzIE5hdm1lc2ggKi9cbiAgICBwcm90ZWN0ZWQgX3N0cmF0ZWd5OiBOYXZpZ2F0aW9uU3RyYXRlZ3kgfCB1bmRlZmluZWQ7XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgTmF2bWVzaCBmcm9tIHRoZSBwb2ludHMgaW4gdGhlIHNwZWVjaWZpZWQgZ3JhcGguIE5hdmlnYXRpb24gaXMgZG9uZSB1c2luZyB0aGUgXG4gICAgICogZ2l2ZW4gTmF2aWdhdGlvblN0cmF0ZWd5LiBcblx0ICogQHBhcmFtIGdyYXBoIHRoZSBncmFwaCB0byBjb25zdHJ1Y3QgYSBuYXZtZXNoIGZyb21cbiAgICAgKiBAcGFyYW0gc3RyYXRlZ3kgYSBjb25zdHJ1Y3RvciBmb3Igc3RyYXRlZ3kgdG8gdXNlIHRvIGJ1aWxkIHBhdGhzIGZvciB0aGlzIG5hdm1lc2hcblx0ICovXG5cdHB1YmxpYyBjb25zdHJ1Y3RvcihncmFwaDogUG9zaXRpb25HcmFwaCl7XG5cdFx0dGhpcy5fZ3JhcGggPSBncmFwaDtcbiAgICAgICAgdGhpcy5fc3RyYXRlZ2llcyA9IG5ldyBNYXA8c3RyaW5nLCBOYXZpZ2F0aW9uU3RyYXRlZ3k+KCk7XG4gICAgICAgIHRoaXMuX3N0cmF0ZWd5ID0gdW5kZWZpbmVkO1xuXHR9XG5cbiAgICBwdWJsaWMgZ2V0IGdyYXBoKCk6IFBvc2l0aW9uR3JhcGggeyByZXR1cm4gdGhpcy5fZ3JhcGg7IH1cblxuICAgIHB1YmxpYyBzZXRTdHJhdGVneShzdHJhdGVneTogc3RyaW5nKSB7IHRoaXMuX3N0cmF0ZWd5ID0gdGhpcy5fc3RyYXRlZ2llcy5nZXQoc3RyYXRlZ3kpOyB9XG5cblx0Ly8gQGltcGxlbWVudGVkXG5cdGdldE5hdmlnYXRpb25QYXRoKGZyb21Qb3NpdGlvbjogVmVjMiwgdG9Qb3NpdGlvbjogVmVjMik6IE5hdmlnYXRpb25QYXRoIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0cmF0ZWd5ID09PSB1bmRlZmluZWQpIHsgXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvci5ObyBwYXRoZmluZGluZyBzdHJhdGVneSBzZXQgZm9yIHRoaXMgbmF2bWVzaC5cIik7XG4gICAgICAgIH1cblx0XHRyZXR1cm4gdGhpcy5fc3RyYXRlZ3kuYnVpbGRQYXRoKHRvUG9zaXRpb24sIGZyb21Qb3NpdGlvbik7XG5cdH1cblxuICAgIHJlZ2lzdGVyU3RyYXRlZ3koa2V5OiBzdHJpbmcsIHN0cmF0ZWd5OiBOYXZpZ2F0aW9uU3RyYXRlZ3kpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3RyYXRlZ2llcy5zZXQoa2V5LCBzdHJhdGVneSk7XG4gICAgfVxuXG59IiwiaW1wb3J0IFN0YWNrIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvQ29sbGVjdGlvbnMvU3RhY2tcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IE5hdmlnYXRpb25QYXRoIGZyb20gXCIuLi9OYXZpZ2F0aW9uUGF0aFwiO1xuaW1wb3J0IE5hdlBhdGhTdHJhdCBmcm9tIFwiLi9OYXZpZ2F0aW9uU3RyYXRlZ3lcIjtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmF2aWdhdGlvbiBwYXRoIHRoYXQgZ29lcyBkaXJlY3RseSBmcm9tIHBvaW50IEEgdG8gcG9pbnQgQi4gSW4gdGhlIFxuICogb3JpZ2luYWwgaW1wbGVtZW50YXRpb24gb2YgdGhlIE5hdmlnYXRpb25QYXRoLCB5b3UgY291bGQgc2V0IGEgZmxhZyB0byB0ZWxsIGl0IHRvXG4gKiBjcmVhdGUgYSBkaXJlY3QgcGF0aC4gSSd2ZSBiYXNpY2FsbHkgcmVtb3ZlZCB0aGF0IGZsYWcgYW5kIGNyZWF0ZWQgdGhpcyBjbGFzcyBpbiBcbiAqIGl0J3MgcGxhY2UuXG4gKiBAYXV0aG9yIFBldGV5THVtcGtpbnNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGlyZWN0UGF0aFN0cmF0IGV4dGVuZHMgTmF2UGF0aFN0cmF0IHtcblxuICAgIC8qKlxuICAgICAqIEBzZWUgTmF2UGF0aFN0cmF0LmJ1aWxkUGF0aCgpXG4gICAgICovXG4gICAgcHVibGljIGJ1aWxkUGF0aCh0bzogVmVjMiwgZnJvbTogVmVjMik6IE5hdmlnYXRpb25QYXRoIHtcbiAgICAgICAgbGV0IHN0YWNrID0gbmV3IFN0YWNrPFZlYzI+KCk7XG4gICAgICAgIHN0YWNrLnB1c2godG8uY2xvbmUoKSk7XG4gICAgICAgIHJldHVybiBuZXcgTmF2aWdhdGlvblBhdGgoc3RhY2spO1xuICAgIH1cbiAgICBcbn0iLCJpbXBvcnQgU3RhY2sgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9Db2xsZWN0aW9ucy9TdGFja1wiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgR3JhcGhVdGlscyBmcm9tIFwiLi4vLi4vVXRpbHMvR3JhcGhVdGlsc1wiO1xuaW1wb3J0IE5hdmlnYXRpb25QYXRoIGZyb20gXCIuLi9OYXZpZ2F0aW9uUGF0aFwiO1xuaW1wb3J0IE5hdlBhdGhTdHJhdCBmcm9tIFwiLi9OYXZpZ2F0aW9uU3RyYXRlZ3lcIjtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmF2aWdhdGlvbiBwYXRoIGZvciBXb2xmaWUyRCB1c2luZyBkamlrc3RyYXMgc2hvcnRlc3QgcGF0aCBhbGdvcml0aG0uIFRoaXNcbiAqIHdhcyB0aGUgb3JpZ2luYWwgaW1wbGVtZW50YXRpb24gdXNlZCBpbiB0aGUgTmF2aWdhdGlvblBhdGggY2xhc3MuXG4gKiBAYXV0aG9yIFBldGV5THVtcGtpbnNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGppa3N0cmFQYXRoU3RyYXQgZXh0ZW5kcyBOYXZQYXRoU3RyYXQge1xuXG4gICAgLyoqXG4gICAgICogQHNlZSBOYXZQYXRoU3RyYXQuYnVpbGRQYXRoKClcbiAgICAgKi9cbiAgICBwdWJsaWMgYnVpbGRQYXRoKHRvOiBWZWMyLCBmcm9tOiBWZWMyKTogTmF2aWdhdGlvblBhdGgge1xuICAgICAgICAvLyBHZXQgdGhlIGNsb3Nlc3Qgbm9kZXMgaW4gdGhlIGdyYXBoIHRvIG91ciB0byBhbmQgZnJvbSBwb3NpdGlvbnNcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5tZXNoLmdyYXBoLnNuYXAoZnJvbSk7XG5cdFx0bGV0IGVuZCA9IHRoaXMubWVzaC5ncmFwaC5zbmFwKHRvKTtcblxuXHRcdGxldCBwYXRoU3RhY2sgPSBuZXcgU3RhY2s8VmVjMj4odGhpcy5tZXNoLmdyYXBoLm51bVZlcnRpY2VzKTtcblx0XHRcblx0XHQvLyBQdXNoIHRoZSBmaW5hbCBwb3NpdGlvbiBhbmQgdGhlIGZpbmFsIHBvc2l0aW9uIGluIHRoZSBncmFwaFxuXHRcdHBhdGhTdGFjay5wdXNoKHRvLmNsb25lKCkpO1xuXHRcdHBhdGhTdGFjay5wdXNoKHRoaXMubWVzaC5ncmFwaC5wb3NpdGlvbnNbZW5kXSk7XG5cbiAgICAgICAgLy8gVXNlIERqaWtzdHJhcyB0byBjb25zdHJ1Y3QgdGhlIHBhdGhcblx0XHRsZXQgcGFyZW50ID0gR3JhcGhVdGlscy5kamlrc3RyYSh0aGlzLm1lc2guZ3JhcGgsIHN0YXJ0KTtcblxuXHRcdC8vIEFkZCBhbGwgcGFyZW50cyBhbG9uZyB0aGUgcGF0aFxuXHRcdGxldCBpID0gZW5kO1xuXHRcdHdoaWxlKHBhcmVudFtpXSAhPT0gLTEpe1xuXHRcdFx0cGF0aFN0YWNrLnB1c2godGhpcy5tZXNoLmdyYXBoLnBvc2l0aW9uc1twYXJlbnRbaV1dKTtcblx0XHRcdGkgPSBwYXJlbnRbaV07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBOYXZpZ2F0aW9uUGF0aChwYXRoU3RhY2spO1xuICAgIH1cbiAgICBcbn0iLCJpbXBvcnQgUGF0aFN0cmF0IGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvUGF0aGZpbmRpbmcvUGF0aFN0cmF0ZWd5XCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBOYXZpZ2F0aW9uUGF0aCBmcm9tIFwiLi4vTmF2aWdhdGlvblBhdGhcIjtcbmltcG9ydCBOYXZtZXNoIGZyb20gXCIuLi9OYXZtZXNoXCI7XG5cbi8qKlxuICogQW4gYWJzdHJhY3QgbmF2aWdhdGlvbiBzdHJhdGVneSBmb3IgV29sZmllMkRzIG5hdmlnYXRpb24gc3lzdGVtLiBZb3UgY2FuIGV4dGVuZCB0aGlzIGNsYXNzIHRvIGNyZWF0ZVxuICogeW91ciBvd24gc3RyYXRlZ3kgZm9yIGNvbnN0cnVjdGluZyBhIE5hdmlnYXRpb25QYXRoIGZvciB0aGUgbmF2aWdhdGlvbiBzeXN0ZW0uXG4gKiBAYXV0aG9yIFBldGV5THVtcGtpbnNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgTmF2aWdhdGlvblN0cmF0ZWd5IGltcGxlbWVudHMgUGF0aFN0cmF0PFZlYzIsIE5hdmlnYXRpb25QYXRoPiB7XG5cbiAgICAvKiogVGhlIE5hdm1lc2ggd2UncmUgY3JlYXRpbmcgcGF0aHMgZm9yICovXG4gICAgcHJvdGVjdGVkIF9tZXNoOiBOYXZtZXNoO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKG1lc2g6IE5hdm1lc2gpIHtcbiAgICAgICAgdGhpcy5tZXNoID0gbWVzaFxuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXQgbWVzaCgpOiBOYXZtZXNoeyByZXR1cm4gdGhpcy5fbWVzaDsgfVxuICAgIHByb3RlY3RlZCBzZXQgbWVzaChtZXNoOiBOYXZtZXNoKSB7IHRoaXMuX21lc2ggPSBtZXNoOyB9XG4gICAgXG4gICAgLyoqXG4gICAgICogQnVpbGRzIGEgbmV3IE5hdmlnYXRpb25QYXRoLiBIb3cgdGhlIHBhdGggaXMgY29uc3RydWN0ZWQgaXMgaW1wbGVtZW50YXRpb24gc3BlY2lmaWMuXG4gICAgICogQHBhcmFtIHRvIHRoZSBwb3NpdGlvbiB0byBuYXZpZ2F0ZSB0b1xuICAgICAqIEBwYXJhbSBmcm9tIHRoZSBwb3NpdGlvbiB0byBuYXZpZ2F0ZSBmcm9tXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IGJ1aWxkUGF0aCh0bzogVmVjMiwgZnJvbTogVmVjMik6IE5hdmlnYXRpb25QYXRoO1xuICAgIFxufSIsImltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vTm9kZXMvR2FtZU5vZGVcIjtcbmltcG9ydCBQaHlzaWNhbCBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvUGh5c2ljYWxcIjtcbmltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwXCI7XG5pbXBvcnQgUGh5c2ljc01hbmFnZXIgZnJvbSBcIi4vUGh5c2ljc01hbmFnZXJcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IEFBQkIgZnJvbSBcIi4uL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xuaW1wb3J0IE9ydGhvZ29uYWxUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwcy9PcnRob2dvbmFsVGlsZW1hcFwiO1xuaW1wb3J0IEFyZWFDb2xsaXNpb24gZnJvbSBcIi4uL0RhdGFUeXBlcy9QaHlzaWNzL0FyZWFDb2xsaXNpb25cIjtcbmltcG9ydCBVbmlxdWUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VuaXF1ZVwiO1xuXG4vKipcbiAqIEFMR09SSVRITTpcbiAqIFx0SW4gYW4gZWZmb3J0IHRvIGtlZXAgdGhpbmdzIHNpbXBsZSBhbmQgd29ya2luZyBlZmZlY3RpdmVseSwgZWFjaCBkeW5hbWljIG5vZGUgd2lsbCByZXNvbHZlIGl0c1xuICogXHRjb2xsaXNpb25zIGNvbnNpZGVyaW5nIHRoZSByZXN0IG9mIHRoZSB3b3JsZCBhcyBzdGF0aWMuXG4gKiBcbiAqIFx0Q29sbGlzaW9uIGRldGVjdGluZyB3aWxsIGhhcHBlbiBmaXJzdC4gVGhpcyBjYW4gYmUgY29uc2lkZXJlZCBhIGJyb2FkIHBoYXNlLCBidXQgaXQgaXMgbm90IGVzcGVjaWFsbHlcbiAqIFx0ZWZmaWNpZW50LCBhcyBpdCBkb2VzIG5vdCBuZWVkIHRvIGJlIGZvciB0aGlzIGdhbWUgZW5naW5lLiBFdmVyeSBkeW5hbWljIG5vZGUgaXMgY2hlY2tlZCBhZ2FpbnN0IGV2ZXJ5XG4gKiBcdG90aGVyIG5vZGUgZm9yIGNvbGxpc2lvbiBhcmVhLiBJZiBjb2xsaXNpb24gYXJlYSBpcyBub24temVybyAobWVhbmluZyB0aGUgY3VycmVudCBub2RlIHN3ZWVwcyBpbnRvIGFub3RoZXIpLFxuICogXHRpdCBpcyBhZGRlZCB0byBhIGxpc3Qgb2YgaGl0cy5cbiAqIFxuICogXHRJTklUSUFMSVpBVElPTjpcbiAqIFx0XHQtIFBoeXNpY3MgY29uc3RhbnRzIGFyZSByZXNldFxuICogXHRcdC0gU3dlcHQgc2hhcGVzIGFyZSByZWNhbGN1bGF0ZWQuIElmIGEgbm9kZSBpc24ndCBtb3ZpbmcsIGl0IGlzIHNraXBwZWQuXG4gKiBcbiAqIFx0Q09MTElTSU9OIERFVEVDVElPTjpcbiAqIFx0XHQtIEZvciBhIG5vZGUsIGNvbGxpc2lvbiBhcmVhIHdpbGwgYmUgY2FsY3VsYXRlZCB1c2luZyB0aGUgc3dlcHQgQUFCQiBvZiB0aGUgbm9kZSBhZ2FpbnN0IGV2ZXJ5IG90aGVyIEFBQkIgaW4gYSBzdGF0aWMgc3RhdGVcbiAqIFx0XHQtIFRoZXNlIGNvbGxpc2lvbnMgd2lsbCBiZSBzb3J0ZWQgYnkgYXJlYSBpbiBkZXNjZW5kaW5nIG9yZGVyXG4gKiBcdFxuICogXHRDT0xMSVNJT04gUkVTT0xVVElPTjpcbiAqIFx0XHQtIEZvciBlYWNoIGhpdCwgdGltZSBvZiBjb2xsaXNpb24gaXMgY2FsY3VsYXRlZCB1c2luZyBhIHN3ZXB0IGxpbmUgdGhyb3VnaCB0aGUgQUFCQiBvZiB0aGUgc3RhdGljIG5vZGUgZXhwYW5kZWRcbiAqIFx0XHRcdHdpdGggbWlua293c2tpIHN1bXMgKGRpc2NyZXRlbHksIGJ1dCB0aGUgY29uY2VwdCBpcyB0aGVyZSlcbiAqIFx0XHQtIFRoZSBjb2xsaXNpb24gaXMgcmVzb2x2ZWQgYmFzZWQgb24gdGhlIG5lYXIgdGltZSBvZiB0aGUgY29sbGlzaW9uIChmcm9tIG1ldGhvZCBvZiBzZXBhcmF0ZWQgYXhlcylcbiAqIFx0XHRcdC0gWCBpcyByZXNvbHZlZCBieSBuZWFyIHgsIFkgYnkgbmVhciB5LlxuICogXHRcdFx0LSBUaGVyZSBpcyBzb21lIGZ1ZGdpbmcgdG8gYWxsb3cgZm9yIHNsaWRpbmcgYWxvbmcgd2FsbHMgb2Ygc2VwYXJhdGUgY29sbGlkZXJzLiBTb3J0aW5nIGJ5IGFyZWEgYWxzbyBoZWxwcyB3aXRoIHRoaXMuXG4gKiBcdFx0XHQtIENvcm5lciB0byBjb3JuZXIgY29sbGlzaW9ucyBhcmUgcmVzb2x2ZSB0byBmYXZvciB4LW1vdmVtZW50LiBUaGlzIGlzIGluIGNvbnNpZGVyYXRpb24gb2YgcGxhdGZvcm1lcnMsIHRvIGdpdmVcbiAqIFx0XHRcdFx0dGhlIHBsYXllciBzb21lIGhlbHAgd2l0aCBqdW1wc1xuICogXG4gKiBcdFByb3M6XG4gKiBcdFx0LSBFdmVyeXRoaW5nIGhhcHBlbnMgd2l0aCBhIGNvbnNpc3RlbnQgdGltZS4gVGhlcmUgaXMgYSBkaXN0aW5jdCBiZWZvcmUgYW5kIGFmdGVyIGZvciBlYWNoIHJlc29sdXRpb24uXG4gKiBcdFx0LSBObyBiYWNrLXRyYWNraW5nIG5lZWRzIHRvIGJlIGRvbmUuIE9uY2Ugd2UgcmVzb2x2ZSBhIG5vZGUsIGl0IGlzIGRlZmluaXRpdmVseSByZXNvbHZlZC5cbiAqIFx0XG4gKiBcdENvbnM6XG4gKiBcdFx0LSBOb2RlcyB0aGF0IGFyZSBwcm9jZXNzZWQgZWFybHkgaGF2ZSBtb3ZlbWVudCBwcmlvcml0eSBvdmVyIG90aGVyIG5vZGVzLiBUaGlzIGNhbiBsZWFkIHRvIHNvbWUgdW5kZXNpcmFibGUgaW50ZXJhY3Rpb25zLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNpY1BoeXNpY3NNYW5hZ2VyIGV4dGVuZHMgUGh5c2ljc01hbmFnZXIge1xuXG5cdC8qKiBUaGUgYXJyYXkgb2Ygc3RhdGljIG5vZGVzICovXG5cdHByb3RlY3RlZCBzdGF0aWNOb2RlczogQXJyYXk8UGh5c2ljYWw+O1xuXG5cdC8qKiBUaGUgYXJyYXkgb2YgZHluYW1pYyBub2RlcyAqL1xuXHRwcm90ZWN0ZWQgZHluYW1pY05vZGVzOiBBcnJheTxQaHlzaWNhbD47XG5cblx0LyoqIFRoZSBhcnJheSBvZiB0aWxlbWFwcyAqL1xuXHRwcm90ZWN0ZWQgdGlsZW1hcHM6IEFycmF5PFRpbGVtYXA+O1xuXG5cdC8qKiBBbiBhcnJheSBvZiB0aGUgY29sbGlzaW9uIG1hc2tzIGZvciBlYWNoIGdyb3VwICovXG5cdHByb3RlY3RlZCBjb2xsaXNpb25NYXNrczogQXJyYXk8bnVtYmVyPjtcblxuXHRjb25zdHJ1Y3RvcihvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KXtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuc3RhdGljTm9kZXMgPSBuZXcgQXJyYXkoKTtcblx0XHR0aGlzLmR5bmFtaWNOb2RlcyA9IG5ldyBBcnJheSgpO1xuXHRcdHRoaXMudGlsZW1hcHMgPSBuZXcgQXJyYXkoKTtcblx0XHR0aGlzLmNvbGxpc2lvbk1hc2tzID0gbmV3IEFycmF5KDMyKTtcblxuXHRcdC8vIFBhcnNlIG9wdGlvbnNcblx0XHR0aGlzLnBhcnNlT3B0aW9ucyhvcHRpb25zKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQYXJzZXMgdGhlIG9wdGlvbnMgZm9yIGNvbnN0cnVjdGluZyB0aGUgcGh5c2ljcyBtYW5hZ2VyXG5cdCAqIEBwYXJhbSBvcHRpb25zIEEgcmVjb3JkIG9mIG9wdGlvbnNcblx0ICovXG5cdHByb3RlY3RlZCBwYXJzZU9wdGlvbnMob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xuXHRcdGlmKG9wdGlvbnMuZ3JvdXBOYW1lcyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuY29sbGlzaW9ucyAhPT0gdW5kZWZpbmVkKXtcblx0XHRcdGZvcihsZXQgaSA9IDA7IGkgPCBvcHRpb25zLmdyb3VwTmFtZXMubGVuZ3RoOyBpKyspe1xuXHRcdFx0XHRsZXQgZ3JvdXAgPSBvcHRpb25zLmdyb3VwTmFtZXNbaV07XG5cblx0XHRcdFx0Ly8gUmVnaXN0ZXIgdGhlIGdyb3VwIG5hbWUgYW5kIG51bWJlclxuXHRcdFx0XHR0aGlzLmdyb3VwTmFtZXNbaV0gPSBncm91cDtcblxuXHRcdFx0XHR0aGlzLmdyb3VwTWFwLnNldChncm91cCwgMSA8PCBpKTtcblxuXHRcdFx0XHRsZXQgY29sbGlzaW9uTWFzayA9IDA7XG5cblx0XHRcdFx0Zm9yKGxldCBqID0gMDsgaiA8IG9wdGlvbnMuY29sbGlzaW9uc1tpXS5sZW5ndGg7IGorKyl7XG5cdFx0XHRcdFx0aWYob3B0aW9ucy5jb2xsaXNpb25zW2ldW2pdKXtcblx0XHRcdFx0XHRcdGNvbGxpc2lvbk1hc2sgfD0gMSA8PCBqO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuY29sbGlzaW9uTWFza3NbaV0gPSBjb2xsaXNpb25NYXNrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEBvdmVycmlkZVxuXHRyZWdpc3Rlck9iamVjdChub2RlOiBQaHlzaWNhbCk6IHZvaWQge1xuXHRcdGlmKG5vZGUuaXNTdGF0aWMpe1xuXHRcdFx0Ly8gU3RhdGljIGFuZCBub3QgY29sbGlkYWJsZVxuXHRcdFx0dGhpcy5zdGF0aWNOb2Rlcy5wdXNoKG5vZGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBEeW5hbWljIGFuZCBub3QgY29sbGlkYWJsZVxuXHRcdFx0dGhpcy5keW5hbWljTm9kZXMucHVzaChub2RlKTtcblx0XHR9XG5cdH1cblxuXHQvLyBAb3ZlcnJpZGVcblx0ZGVyZWdpc3Rlck9iamVjdChub2RlOiBQaHlzaWNhbCk6IHZvaWQge1xuXHRcdGlmKG5vZGUuaXNTdGF0aWMpe1xuXHRcdFx0Ly8gUmVtb3ZlIHRoZSBub2RlIGZyb20gdGhlIHN0YXRpYyBsaXN0XG5cdFx0XHRjb25zdCBpbmRleCA9IHRoaXMuc3RhdGljTm9kZXMuaW5kZXhPZihub2RlKTtcblx0XHRcdHRoaXMuc3RhdGljTm9kZXMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gUmVtb3ZlIHRoZSBub2RlIGZyb20gdGhlIGR5bmFtaWMgbGlzdFxuXHRcdFx0Y29uc3QgaW5kZXggPSB0aGlzLmR5bmFtaWNOb2Rlcy5pbmRleE9mKG5vZGUpO1xuXHRcdFx0dGhpcy5keW5hbWljTm9kZXMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHR9XG5cdH1cblxuXHQvLyBAb3ZlcnJpZGVcblx0cmVnaXN0ZXJUaWxlbWFwKHRpbGVtYXA6IFRpbGVtYXApOiB2b2lkIHtcblx0XHR0aGlzLnRpbGVtYXBzLnB1c2godGlsZW1hcCk7XG5cdH1cblxuXHQvLyBAb3ZlcnJpZGVcblx0ZGVyZWdpc3RlclRpbGVtYXAodGlsZW1hcDogVGlsZW1hcCk6IHZvaWQge1xuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy50aWxlbWFwcy5pbmRleE9mKHRpbGVtYXApO1xuXHRcdHRoaXMudGlsZW1hcHMuc3BsaWNlKGluZGV4LCAxKTtcblx0fVxuXG5cdC8vIEBvdmVycmlkZVxuXHR1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcblx0XHRmb3IobGV0IG5vZGUgb2YgdGhpcy5keW5hbWljTm9kZXMpe1xuXHRcdFx0LyotLS0tLS0tLS0tIElOSVRJQUxJWkFUSU9OIFBIQVNFIC0tLS0tLS0tLS0qL1xuXHRcdFx0Ly8gQ2xlYXIgZnJhbWUgZGVwZW5kZW50IGJvb2xlYW4gdmFsdWVzIGZvciBlYWNoIG5vZGVcblx0XHRcdG5vZGUub25Hcm91bmQgPSBmYWxzZTtcblx0XHRcdG5vZGUub25DZWlsaW5nID0gZmFsc2U7XG5cdFx0XHRub2RlLm9uV2FsbCA9IGZhbHNlO1xuXHRcdFx0bm9kZS5jb2xsaWRlZFdpdGhUaWxlbWFwID0gZmFsc2U7XG5cdFx0XHRub2RlLmlzQ29sbGlkaW5nID0gZmFsc2U7XG5cblx0XHRcdC8vIElmIHRoaXMgbm9kZSBpcyBub3QgYWN0aXZlLCBkb24ndCBwcm9jZXNzIGl0XG5cdFx0XHRpZighbm9kZS5hY3RpdmUpe1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVXBkYXRlIHRoZSBzd2VwdCBzaGFwZXMgb2YgZWFjaCBub2RlXG5cdFx0XHRpZihub2RlLm1vdmluZyl7XG5cdFx0XHRcdC8vIElmIG1vdmluZywgcmVmbGVjdCB0aGF0IGluIHRoZSBzd2VwdCBzaGFwZVxuXHRcdFx0XHRub2RlLnN3ZXB0UmVjdC5zd2VlcChub2RlLl92ZWxvY2l0eSwgbm9kZS5jb2xsaXNpb25TaGFwZS5jZW50ZXIsIG5vZGUuY29sbGlzaW9uU2hhcGUuaGFsZlNpemUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSWYgb3VyIG5vZGUgaXNuJ3QgbW92aW5nLCBkb24ndCBib3RoZXIgdG8gY2hlY2sgaXQgKG90aGVyIG5vZGVzIHdpbGwgZGV0ZWN0IGlmIHRoZXkgcnVuIGludG8gaXQpXG5cdFx0XHRcdG5vZGUuX3ZlbG9jaXR5Lnplcm8oKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8qLS0tLS0tLS0tLSBERVRFQ1RJT04gUEhBU0UgLS0tLS0tLS0tLSovXG5cdFx0XHQvLyBHYXRoZXIgYSBzZXQgb2Ygb3ZlcmxhcHNcblx0XHRcdGxldCBvdmVybGFwcyA9IG5ldyBBcnJheTxBcmVhQ29sbGlzaW9uPigpO1xuXG5cdFx0XHRsZXQgZ3JvdXBJbmRleCA9IG5vZGUuZ3JvdXAgPT09IC0xID8gLTEgOiBNYXRoLmxvZzIobm9kZS5ncm91cCk7XG5cblx0XHRcdC8vIEZpcnN0LCBjaGVjayB0aGlzIG5vZGUgYWdhaW5zdCBldmVyeSBzdGF0aWMgbm9kZSAob3JkZXIgZG9lc24ndCBhY3R1YWxseSBtYXR0ZXIgaGVyZSwgc2luY2Ugd2Ugc29ydCBhbnl3YXlzKVxuXHRcdFx0Zm9yKGxldCBvdGhlciBvZiB0aGlzLnN0YXRpY05vZGVzKXtcblx0XHRcdFx0Ly8gSWdub3JlIGluYWN0aXZlIG5vZGVzXG5cdFx0XHRcdGlmKCFvdGhlci5hY3RpdmUpIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGxldCBjb2xsaWRlciA9IG90aGVyLmNvbGxpc2lvblNoYXBlLmdldEJvdW5kaW5nUmVjdCgpO1xuXHRcdFx0XHRsZXQgYXJlYSA9IG5vZGUuc3dlcHRSZWN0Lm92ZXJsYXBBcmVhKGNvbGxpZGVyKTtcblx0XHRcdFx0aWYoYXJlYSA+IDApe1xuXHRcdFx0XHRcdC8vIFdlIGhhZCBhIGNvbGxpc2lvblxuXHRcdFx0XHRcdG92ZXJsYXBzLnB1c2gobmV3IEFyZWFDb2xsaXNpb24oYXJlYSwgY29sbGlkZXIsIG90aGVyLCBcIkdhbWVOb2RlXCIsIG51bGwpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGVuLCBjaGVjayBpdCBhZ2FpbnN0IGV2ZXJ5IGR5bmFtaWMgbm9kZVxuXHRcdFx0Zm9yKGxldCBvdGhlciBvZiB0aGlzLmR5bmFtaWNOb2Rlcyl7XG5cdFx0XHRcdC8vIElnbm9yZSBvdXJzZWx2ZXNcblx0XHRcdFx0aWYobm9kZSA9PT0gb3RoZXIpIGNvbnRpbnVlO1xuXG5cdFx0XHRcdC8vIElnbm9yZSBpbmFjdGl2ZSBub2Rlc1xuXHRcdFx0XHRpZighb3RoZXIuYWN0aXZlKSBjb250aW51ZTtcblxuXHRcdFx0XHRsZXQgY29sbGlkZXIgPSBvdGhlci5jb2xsaXNpb25TaGFwZS5nZXRCb3VuZGluZ1JlY3QoKTtcblx0XHRcdFx0bGV0IGFyZWEgPSBub2RlLnN3ZXB0UmVjdC5vdmVybGFwQXJlYShjb2xsaWRlcik7XG5cdFx0XHRcdGlmKGFyZWEgPiAwKXtcblx0XHRcdFx0XHQvLyBXZSBoYWQgYSBjb2xsaXNpb25cblx0XHRcdFx0XHRvdmVybGFwcy5wdXNoKG5ldyBBcmVhQ29sbGlzaW9uKGFyZWEsIGNvbGxpZGVyLCBvdGhlciwgXCJHYW1lTm9kZVwiLCBudWxsKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTGFzdGx5LCBnYXRoZXIgYSBzZXQgb2YgQUFCQnMgZnJvbSB0aGUgdGlsZW1hcC5cblx0XHRcdC8vIFRoaXMgc3RlcCBpbnZvbHZlcyB0aGUgbW9zdCBleHRyYSB3b3JrLCBzbyBpdCBpcyBhYnN0cmFjdGVkIGludG8gYSBtZXRob2Rcblx0XHRcdGZvcihsZXQgdGlsZW1hcCBvZiB0aGlzLnRpbGVtYXBzKXtcblx0XHRcdFx0Ly8gSWdub3JlIGluYWN0aXZlIHRpbGVtYXBzXG5cdFx0XHRcdGlmKCF0aWxlbWFwLmFjdGl2ZSkgY29udGludWU7XG5cblx0XHRcdFx0aWYodGlsZW1hcCBpbnN0YW5jZW9mIE9ydGhvZ29uYWxUaWxlbWFwKXtcblx0XHRcdFx0XHR0aGlzLmNvbGxpZGVXaXRoT3J0aG9nb25hbFRpbGVtYXAobm9kZSwgdGlsZW1hcCwgb3ZlcmxhcHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNvcnQgdGhlIG92ZXJsYXBzIGJ5IGFyZWFcblx0XHRcdG92ZXJsYXBzID0gb3ZlcmxhcHMuc29ydCgoYSwgYikgPT4gYi5hcmVhIC0gYS5hcmVhKTtcblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiBoaXRzIHRvIHVzZSBsYXRlclxuXHRcdFx0bGV0IGhpdHMgPSBbXTtcblxuXHRcdFx0LyotLS0tLS0tLS0tIFJFU09MVVRJT04gUEhBU0UgLS0tLS0tLS0tLSovXG5cdFx0XHQvLyBGb3IgZXZlcnkgb3ZlcmxhcCwgZGV0ZXJtaW5lIGlmIHdlIG5lZWQgdG8gY29sbGlkZSB3aXRoIGl0IGFuZCB3aGVuXG5cdFx0XHRmb3IobGV0IG92ZXJsYXAgb2Ygb3ZlcmxhcHMpe1xuXHRcdFx0XHQvLyBJZ25vcmUgbm9kZXMgd2UgZG9uJ3QgaW50ZXJhY3Qgd2l0aFxuXHRcdFx0XHRpZiggZ3JvdXBJbmRleCAhPT0gLTEgJiYgb3ZlcmxhcC5vdGhlci5ncm91cCAhPT0gLTEgJiYgKCh0aGlzLmNvbGxpc2lvbk1hc2tzW2dyb3VwSW5kZXhdICYgb3ZlcmxhcC5vdGhlci5ncm91cCkgPT09IDApICkgY29udGludWU7XG5cblx0XHRcdFx0Ly8gRG8gYSBzd2VwdCBsaW5lIHRlc3Qgb24gdGhlIHN0YXRpYyBBQUJCIHdpdGggdGhpcyBBQUJCIHNpemUgYXMgcGFkZGluZyAodGhpcyBpcyBiYXNpY2FsbHkgdXNpbmcgYSBtaW5rb3dza2kgc3VtISlcblx0XHRcdFx0Ly8gU3RhcnQgdGhlIHN3ZWVwIGF0IHRoZSBwb3NpdGlvbiBvZiB0aGlzIG5vZGUgd2l0aCBhIGRlbHRhIG9mIF92ZWxvY2l0eVxuXHRcdFx0XHRjb25zdCBwb2ludCA9IG5vZGUuY29sbGlzaW9uU2hhcGUuY2VudGVyO1xuXHRcdFx0XHRjb25zdCBkZWx0YSA9IG5vZGUuX3ZlbG9jaXR5O1xuXHRcdFx0XHRjb25zdCBwYWRkaW5nID0gbm9kZS5jb2xsaXNpb25TaGFwZS5oYWxmU2l6ZTtcblx0XHRcdFx0Y29uc3Qgb3RoZXJBQUJCID0gb3ZlcmxhcC5jb2xsaWRlcjtcblxuXG5cdFx0XHRcdGNvbnN0IGhpdCA9IG90aGVyQUFCQi5pbnRlcnNlY3RTZWdtZW50KG5vZGUuY29sbGlzaW9uU2hhcGUuY2VudGVyLCBub2RlLl92ZWxvY2l0eSwgbm9kZS5jb2xsaXNpb25TaGFwZS5oYWxmU2l6ZSk7XG5cblx0XHRcdFx0b3ZlcmxhcC5oaXQgPSBoaXQ7XG5cblx0XHRcdFx0aWYoaGl0ICE9PSBudWxsKXtcblx0XHRcdFx0XHRoaXRzLnB1c2goaGl0KTtcblxuXHRcdFx0XHRcdC8vIFdlIGdvdCBhIGhpdCwgcmVzb2x2ZSB3aXRoIHRoZSB0aW1lIGluc2lkZSBvZiB0aGUgaGl0XG5cdFx0XHRcdFx0bGV0IHRuZWFyeCA9IGhpdC5uZWFyVGltZXMueDtcblx0XHRcdFx0XHRsZXQgdG5lYXJ5ID0gaGl0Lm5lYXJUaW1lcy55O1xuXG5cdFx0XHRcdFx0Ly8gQWxsb3cgZWRnZSBjbGlwcGluZyAoZWRnZSBvdmVybGFwcyBkb24ndCBjb3VudCwgb25seSBhcmVhIG92ZXJsYXBzKVxuXHRcdFx0XHRcdC8vIEltcG9ydGFudGx5IGRvbid0IGFsbG93IGJvdGggY2FzZXMgdG8gYmUgdHJ1ZS4gVGhlbiB3ZSBjbGlwIHRocm91Z2ggY29ybmVycy4gRmF2b3IgeCB0byBoZWxwIHBsYXllcnMgbGFuZCBqdW1wc1xuXHRcdFx0XHRcdGlmKHRuZWFyeCA8IDEuMCAmJiAocG9pbnQueSA9PT0gb3RoZXJBQUJCLnRvcCAtIHBhZGRpbmcueSB8fCBwb2ludC55ID09PSBvdGhlckFBQkIuYm90dG9tICsgcGFkZGluZy55KSAmJiBkZWx0YS54ICE9PSAwKSB7XG5cdFx0XHRcdFx0XHR0bmVhcnggPSAxLjA7XG5cdFx0XHRcdFx0fSBlbHNlIGlmKHRuZWFyeSA8IDEuMCAmJiAocG9pbnQueCA9PT0gb3RoZXJBQUJCLmxlZnQgLSBwYWRkaW5nLnggfHwgcG9pbnQueCA9PT0gb3RoZXJBQUJCLnJpZ2h0ICsgcGFkZGluZy54KSAmJiBkZWx0YS55ICE9PSAwKSB7XG5cdFx0XHRcdFx0XHR0bmVhcnkgPSAxLjA7XG5cdFx0XHRcdFx0fVxuXG5cblx0XHRcdFx0XHRpZihoaXQubmVhclRpbWVzLnggPj0gMCAmJiBoaXQubmVhclRpbWVzLnggPCAxKXtcblx0XHRcdFx0XHRcdC8vIEFueSB0aWxlbWFwIG9iamVjdHMgdGhhdCBtYWRlIGl0IGhlcmUgYXJlIGNvbGxpZGFibGVcblx0XHRcdFx0XHRcdGlmKG92ZXJsYXAudHlwZSA9PT0gXCJUaWxlbWFwXCIgfHwgb3ZlcmxhcC5vdGhlci5pc0NvbGxpZGFibGUpe1xuXHRcdFx0XHRcdFx0XHRub2RlLl92ZWxvY2l0eS54ID0gbm9kZS5fdmVsb2NpdHkueCAqIHRuZWFyeDtcblx0XHRcdFx0XHRcdFx0bm9kZS5pc0NvbGxpZGluZyA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYoaGl0Lm5lYXJUaW1lcy55ID49IDAgJiYgaGl0Lm5lYXJUaW1lcy55IDwgMSl7XG5cdFx0XHRcdFx0XHQvLyBBbnkgdGlsZW1hcCBvYmplY3RzIHRoYXQgbWFkZSBpdCBoZXJlIGFyZSBjb2xsaWRhYmxlXG5cdFx0XHRcdFx0XHRpZihvdmVybGFwLnR5cGUgPT09IFwiVGlsZW1hcFwiIHx8IG92ZXJsYXAub3RoZXIuaXNDb2xsaWRhYmxlKXtcblx0XHRcdFx0XHRcdFx0bm9kZS5fdmVsb2NpdHkueSA9IG5vZGUuX3ZlbG9jaXR5LnkgKiB0bmVhcnk7XG5cdFx0XHRcdFx0XHRcdG5vZGUuaXNDb2xsaWRpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKi0tLS0tLS0tLS0gSU5GT1JNQVRJT04vVFJJR0dFUiBQSEFTRSAtLS0tLS0tLS0tKi9cblx0XHRcdC8vIENoZWNrIGlmIHdlIGVuZGVkIHVwIG9uIHRoZSBncm91bmQsIGNlaWxpbmcgb3Igd2FsbFxuXHRcdFx0Ly8gQWxzbyBjaGVjayBmb3IgdHJpZ2dlcnNcblx0XHRcdGZvcihsZXQgb3ZlcmxhcCBvZiBvdmVybGFwcyl7XG5cdFx0XHRcdC8vIENoZWNrIGZvciBhIHRyaWdnZXIuIElmIHdlIGNhcmUgYWJvdXQgdGhlIHRyaWdnZXIsIHJlYWN0XG5cdFx0XHRcdGlmKG92ZXJsYXAub3RoZXIuaXNUcmlnZ2VyICYmIChvdmVybGFwLm90aGVyLnRyaWdnZXJNYXNrICYgbm9kZS5ncm91cCkgJiYgbm9kZS5ncm91cCAhPSAtMSl7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBiaXQgdGhhdCB0aGlzIGdyb3VwIGlzIHJlcHJlc2VudGVkIGJ5XG5cdFx0XHRcdFx0bGV0IGluZGV4ID0gTWF0aC5mbG9vcihNYXRoLmxvZzIobm9kZS5ncm91cCkpO1xuXG5cdFx0XHRcdFx0Ly8gRXh0cmFjdCB0aGUgdHJpZ2dlckVudGVyIGV2ZW50IG5hbWVcblx0XHRcdFx0XHR0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KG92ZXJsYXAub3RoZXIudHJpZ2dlckVudGVyc1tpbmRleF0sIHtcblx0XHRcdFx0XHRcdG5vZGU6ICg8R2FtZU5vZGU+bm9kZSkuaWQsXG5cdFx0XHRcdFx0XHRvdGhlcjogKDxHYW1lTm9kZT5vdmVybGFwLm90aGVyKS5pZFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWdub3JlIGNvbGxpc2lvbiBzaWRlcyBmb3Igbm9kZXMgd2UgZG9uJ3QgaW50ZXJhY3Qgd2l0aFxuXHRcdFx0XHRpZiggZ3JvdXBJbmRleCAhPT0gLTEgJiYgb3ZlcmxhcC5vdGhlci5ncm91cCAhPT0gLTEgJiYgKCh0aGlzLmNvbGxpc2lvbk1hc2tzW2dyb3VwSW5kZXhdICYgb3ZlcmxhcC5vdGhlci5ncm91cCkgPT09IDApKSBjb250aW51ZTtcblxuXHRcdFx0XHQvLyBPbmx5IGNoZWNrIGZvciBkaXJlY3Rpb24gaWYgdGhlIG92ZXJsYXAgd2FzIGNvbGxpZGFibGVcblx0XHRcdFx0aWYob3ZlcmxhcC50eXBlID09PSBcIlRpbGVtYXBcIiB8fCBvdmVybGFwLm90aGVyLmlzQ29sbGlkYWJsZSl7XG5cdFx0XHRcdFx0bGV0IGNvbGxpc2lvblNpZGUgPSBvdmVybGFwLmNvbGxpZGVyLnRvdWNoZXNBQUJCV2l0aG91dENvcm5lcnMobm9kZS5jb2xsaXNpb25TaGFwZS5nZXRCb3VuZGluZ1JlY3QoKSk7XG5cdFx0XHRcdFx0aWYoY29sbGlzaW9uU2lkZSAhPT0gbnVsbCl7XG5cdFx0XHRcdFx0XHQvLyBJZiB3ZSB0b3VjaCwgbm90IGluY2x1ZGluZyBjb3JuZXIgY2FzZXMsIGNoZWNrIHRoZSBjb2xsaXNpb24gbm9ybWFsXG5cdFx0XHRcdFx0XHRpZihvdmVybGFwLmhpdCAhPT0gbnVsbCl7XG5cdFx0XHRcdFx0XHRcdC8vIElmIHdlIGhpdCBhIHRpbGVtYXAsIGtlZXAgdHJhY2sgb2YgaXRcblx0XHRcdFx0XHRcdFx0aWYob3ZlcmxhcC50eXBlID09IFwiVGlsZW1hcFwiKXtcblx0XHRcdFx0XHRcdFx0XHRub2RlLmNvbGxpZGVkV2l0aFRpbGVtYXAgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYoY29sbGlzaW9uU2lkZS55ID09PSAtMSl7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gTm9kZSBpcyBvbiB0b3Agb2Ygb3ZlcmxhcCwgc28gb25Hcm91bmRcblx0XHRcdFx0XHRcdFx0XHRub2RlLm9uR3JvdW5kID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmKGNvbGxpc2lvblNpZGUueSA9PT0gMSl7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gTm9kZSBpcyBvbiBib3R0b20gb2Ygb3ZlcmxhcCwgc28gb25DZWlsaW5nXG5cdFx0XHRcdFx0XHRcdFx0bm9kZS5vbkNlaWxpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdC8vIE5vZGUgd2Fzbid0IHRvdWNoaW5nIG9uIHksIHNvIGl0IGlzIHRvdWNoaW5nIG9uIHhcblx0XHRcdFx0XHRcdFx0XHRub2RlLm9uV2FsbCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVzb2x2ZSB0aGUgY29sbGlzaW9uIHdpdGggdGhlIG5vZGUsIGFuZCBtb3ZlIGl0XG5cdFx0XHRub2RlLmZpbmlzaE1vdmUoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogSGFuZGxlcyBhIGNvbGxpc2lvbiBiZXR3ZWVuIHRoaXMgbm9kZSBhbmQgYW4gb3J0aG9nb25hbCB0aWxlbWFwXG5cdCAqIEBwYXJhbSBub2RlIFRoZSBub2RlXG5cdCAqIEBwYXJhbSB0aWxlbWFwIFRoZSB0aWxlbWFwIHRoZSBub2RlIG1heSBiZSBjb2xsaWRpbmcgd2l0aFxuXHQgKiBAcGFyYW0gb3ZlcmxhcHMgVGhlIGxpc3Qgb2Ygb3ZlcmxhcHNcblx0ICovXG5cdHByb3RlY3RlZCBjb2xsaWRlV2l0aE9ydGhvZ29uYWxUaWxlbWFwKG5vZGU6IFBoeXNpY2FsLCB0aWxlbWFwOiBPcnRob2dvbmFsVGlsZW1hcCwgb3ZlcmxhcHM6IEFycmF5PEFyZWFDb2xsaXNpb24+KTogdm9pZCB7XG5cdFx0Ly8gR2V0IHRoZSBtaW4gYW5kIG1heCB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBtb3Zpbmcgbm9kZVxuXHRcdGxldCBtaW4gPSBuZXcgVmVjMihub2RlLnN3ZXB0UmVjdC5sZWZ0LCBub2RlLnN3ZXB0UmVjdC50b3ApO1xuXHRcdGxldCBtYXggPSBuZXcgVmVjMihub2RlLnN3ZXB0UmVjdC5yaWdodCwgbm9kZS5zd2VwdFJlY3QuYm90dG9tKTtcblxuXHRcdC8vIENvbnZlcnQgdGhlIG1pbi9tYXggeC95IHRvIHRoZSBtaW4gYW5kIG1heCByb3cvY29sIGluIHRoZSB0aWxlbWFwIGFycmF5XG5cdFx0bGV0IG1pbkluZGV4ID0gdGlsZW1hcC5nZXRNaW5Db2xSb3cobm9kZS5zd2VwdFJlY3QpO1xuXHRcdGxldCBtYXhJbmRleCA9IHRpbGVtYXAuZ2V0TWF4Q29sUm93KG5vZGUuc3dlcHRSZWN0KTtcblxuXHRcdC8vIExvb3Agb3ZlciBhbGwgcG9zc2libGUgdGlsZXMgKHdoaWNoIGlzbid0IG1hbnkgaW4gdGhlIHNjb3BlIG9mIHRoZSB2ZWxvY2l0eSBwZXIgZnJhbWUpXG5cdFx0Zm9yKGxldCBjb2wgPSBtaW5JbmRleC54OyBjb2wgPD0gbWF4SW5kZXgueDsgY29sKyspe1xuXHRcdFx0Zm9yKGxldCByb3cgPSBtaW5JbmRleC55OyByb3cgPD0gbWF4SW5kZXgueTsgcm93Kyspe1xuXHRcdFx0XHRpZih0aWxlbWFwLmlzVGlsZUNvbGxpZGFibGUoY29sLCByb3cpKXtcblx0XHRcdFx0XHQvLyBDcmVhdGUgYSBuZXcgY29sbGlkZXIgZm9yIHRoaXMgdGlsZVxuXHRcdFx0XHRcdGxldCBjb2xsaWRlciA9IHRpbGVtYXAuZ2V0VGlsZUNvbGxpZGVyKGNvbCwgcm93KTtcblx0XHRcdFx0XHQvLyBDYWxjdWxhdGUgY29sbGlzaW9uIGFyZWEgYmV0d2VlbiB0aGUgbm9kZSBhbmQgdGhlIHRpbGVcblx0XHRcdFx0XHRsZXQgYXJlYSA9IG5vZGUuc3dlcHRSZWN0Lm92ZXJsYXBBcmVhKGNvbGxpZGVyKTtcblx0XHRcdFx0XHRpZihhcmVhID4gMCl7XG5cdFx0XHRcdFx0XHQvLyBXZSBoYWQgYSBjb2xsaXNpb25cblx0XHRcdFx0XHRcdG92ZXJsYXBzLnB1c2gobmV3IEFyZWFDb2xsaXNpb24oYXJlYSwgY29sbGlkZXIsIHRpbGVtYXAsIFwiVGlsZW1hcFwiLCBuZXcgVmVjMihjb2wsIHJvdykpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0iLCJpbXBvcnQgVXBkYXRlYWJsZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvVXBkYXRlYWJsZVwiO1xuaW1wb3J0IFRpbGVtYXAgZnJvbSBcIi4uL05vZGVzL1RpbGVtYXBcIjtcbmltcG9ydCBSZWNlaXZlciBmcm9tIFwiLi4vRXZlbnRzL1JlY2VpdmVyXCI7XG5pbXBvcnQgRW1pdHRlciBmcm9tIFwiLi4vRXZlbnRzL0VtaXR0ZXJcIjtcbmltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9Db2xsZWN0aW9ucy9NYXBcIjtcbmltcG9ydCBQaHlzaWNhbCBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvUGh5c2ljYWxcIjtcblxuLyoqXG4gKiBBbiBhYnN0cmFjdCBwaHlzaWNzIG1hbmFnZXIuXG4gKiBUaGlzIGNsYXNzIGV4cG9zZXMgZnVuY3Rpb25zIGZvciBzdWJjbGFzc2VzIHRvIGltcGxlbWVudCB0aGF0IHNob3VsZCBhbGxvdyBmb3IgYSB3b3JraW5nIHBoeXNpY3Mgc3lzdGVtIHRvIGJlIGNyZWF0ZWQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFBoeXNpY3NNYW5hZ2VyIGltcGxlbWVudHMgVXBkYXRlYWJsZSB7XG5cdC8qKiBUaGUgZXZlbnQgcmVjZWl2ZXIgZm9yIHRoZSBwaHlzaWNzIHN5c3RlbSAqL1xuXHRwcm90ZWN0ZWQgcmVjZWl2ZXI6IFJlY2VpdmVyO1xuXHQvKiogVGhlIGV2ZW50IGVtaXR0ZXIgZm9yIHRoZSBwaHlzaWNzIHN5c3RlbSAqL1xuXHRwcm90ZWN0ZWQgZW1pdHRlcjogRW1pdHRlcjtcblxuXHQvKiogTWFwcyBsYXllciBuYW1lcyB0byBudW1iZXJzICovXG5cdHByb3RlY3RlZCBncm91cE1hcDogTWFwPG51bWJlcj47XG5cblx0LyoqIE1hcHMgbGF5ZXIgbnVtYmVycyB0byBuYW1lcyAqL1xuXHRwcm90ZWN0ZWQgZ3JvdXBOYW1lczogQXJyYXk8c3RyaW5nPjtcblxuXHQvKiogVGhlIGRlZmF1bHQgZ3JvdXAgbmFtZSAqL1xuXHRwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IERFRkFVTFRfR1JPVVA6IHN0cmluZyA9IFwiRGVmYXVsdFwiO1xuXG5cdGNvbnN0cnVjdG9yKCl7XG5cdFx0dGhpcy5yZWNlaXZlciA9IG5ldyBSZWNlaXZlcigpO1xuXHRcdHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG5cblx0XHQvLyBUaGUgY3JlYXRpb24gYW5kIGltcGxlbWVudGF0aW9uIG9mIGxheWVycyBpcyBkZWZlcnJlZCB0byB0aGUgc3ViY2xhc3Ncblx0XHR0aGlzLmdyb3VwTWFwID0gbmV3IE1hcCgpO1xuXHRcdHRoaXMuZ3JvdXBOYW1lcyA9IG5ldyBBcnJheSgpO1xuXHR9XG5cblx0ZGVzdHJveSgpOiB2b2lkIHtcblx0XHR0aGlzLnJlY2VpdmVyLmRlc3Ryb3koKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgYSBnYW1lbm9kZSB3aXRoIHRoaXMgcGh5c2ljcyBtYW5hZ2VyXG5cdCAqIEBwYXJhbSBvYmplY3QgVGhlIG9iamVjdCB0byByZWdpc3RlclxuXHQgKi9cblx0YWJzdHJhY3QgcmVnaXN0ZXJPYmplY3Qob2JqZWN0OiBQaHlzaWNhbCk6IHZvaWQ7XG5cblxuXHQvKipcblx0ICogUmVtb3ZlcyByZWZlcmVuY2VzIHRvIHRoaXMgb2JqZWN0IGZyb20gdGhlIHBoeXNpY3MgbWFuYWdlcnJcblx0ICogQHBhcmFtIG9iamVjdCBUaGUgb2JqZWN0IHRvIGRlcmVnaXN0ZXJcblx0ICovXG5cdGFic3RyYWN0IGRlcmVnaXN0ZXJPYmplY3Qob2JqZWN0OiBQaHlzaWNhbCk6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVycyBhIHRpbGVtYXAgd2l0aCB0aGlzIHBoeXNpY3MgbWFuYWdlclxuXHQgKiBAcGFyYW0gdGlsZW1hcCBUaGUgdGlsZW1hcCB0byByZWdpc3RlclxuXHQgKi9cblx0YWJzdHJhY3QgcmVnaXN0ZXJUaWxlbWFwKHRpbGVtYXA6IFRpbGVtYXApOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHJlZmVyZW5jZXMgdG8gdGhpcyB0aWxlbWFwIGZyb20gdGhlIHBoeXNpY3MgbWFuYWdlcnJcblx0ICogQHBhcmFtIHRpbGVtYXAgVGhlIG9iamVjdCB0byBkZXJlZ2lzdGVyXG5cdCAqL1xuXHRhYnN0cmFjdCBkZXJlZ2lzdGVyVGlsZW1hcCh0aWxlbWFwOiBUaWxlbWFwKTogdm9pZDtcblxuXHRhYnN0cmFjdCB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBwaHlzaWNzIGxheWVyIG9mIHRoZSBHYW1lTm9kZVxuXHQgKiBAcGFyYW0gbm9kZSBUaGUgR2FtZU5vZGVcblx0ICogQHBhcmFtIGdyb3VwIFRoZSBncm91cCB0aGF0IHRoZSBHYW1lTm9kZSBzaG91bGQgYmUgb25cblx0ICovXG5cdHNldEdyb3VwKG5vZGU6IFBoeXNpY2FsLCBncm91cDogc3RyaW5nKTogdm9pZCB7XG5cdFx0bm9kZS5ncm91cCA9IHRoaXMuZ3JvdXBNYXAuZ2V0KGdyb3VwKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXRyaWV2ZXMgdGhlIGxheWVyIG51bWJlciBhc3NvY2lhdGVkIHdpdGggdGhlIHByb3ZpZGVkIG5hbWVcblx0ICogQHBhcmFtIGxheWVyIFRoZSBuYW1lIG9mIHRoZSBsYXllclxuXHQgKiBAcmV0dXJucyBUaGUgbGF5ZXIgbnVtYmVyLCBvciAwIGlmIHRoZXJlIGlzIG5vdCBhIGxheWVyIHdpdGggdGhhdCBuYW1lIHJlZ2lzdGVyZWRcblx0ICovXG5cdGdldEdyb3VwTnVtYmVyKGdyb3VwOiBzdHJpbmcpOiBudW1iZXIge1xuXHRcdGlmKHRoaXMuZ3JvdXBNYXAuaGFzKGdyb3VwKSl7XG5cdFx0XHRyZXR1cm4gdGhpcy5ncm91cE1hcC5nZXQoZ3JvdXApO1xuXHRcdH0gZWxzZXtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIGFsbCBncm91cCBuYW1lcyBhc3NvY2lhdGVkIHdpdGggdGhlIG51bWJlciBwcm92aWRlZFxuXHQgKiBAcGFyYW0gZ3JvdXBzIEEgbWFzayBvZiBncm91cHNcblx0ICogQHJldHVybnMgQWxsIGdyb3VwcyBjb250YWluZWQgaW4gdGhlIG1hc2tcblx0ICovXG5cdGdldEdyb3VwTmFtZXMoZ3JvdXBzOiBudW1iZXIpOiBBcnJheTxzdHJpbmc+IHtcblx0XHRpZihncm91cHMgPT09IC0xKXtcblx0XHRcdHJldHVybiBbUGh5c2ljc01hbmFnZXIuREVGQVVMVF9HUk9VUF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxldCBnID0gMTtcblx0XHRcdGxldCBuYW1lcyA9IFtdO1xuXG5cdFx0XHRmb3IobGV0IGkgPSAwOyBpIDwgMzI7IGkrKyl7XG5cdFx0XHRcdGlmKGcgJiBncm91cHMpe1xuXHRcdFx0XHRcdC8vIFRoaXMgZ3JvdXAgaXMgaW4gdGhlIGdyb3VwcyBudW1iZXJcblx0XHRcdFx0XHRuYW1lcy5wdXNoKHRoaXMuZ3JvdXBOYW1lc1tpXSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTaGlmdCB0aGUgYml0IG92ZXJcblx0XHRcdFx0ZyA9IGcgPDwgMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0iLCJpbXBvcnQgVXBkYXRlYWJsZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvVXBkYXRlYWJsZVwiO1xuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vRXZlbnRzL0dhbWVFdmVudFwiO1xuaW1wb3J0IHsgR2FtZUV2ZW50VHlwZSB9IGZyb20gXCIuLi9FdmVudHMvR2FtZUV2ZW50VHlwZVwiO1xuaW1wb3J0IFJlY2VpdmVyIGZyb20gXCIuLi9FdmVudHMvUmVjZWl2ZXJcIjtcblxuaW1wb3J0IEFic3RyYWN0UmVwbGF5ZXIgZnJvbSBcIi4uL0RhdGFUeXBlcy9QbGF5YmFjay9BYnN0cmFjdC9BYnN0cmFjdFJlcGxheWVyXCI7XG5pbXBvcnQgQWJzdHJhY3RMb2dJdGVtIGZyb20gXCIuLi9EYXRhVHlwZXMvUGxheWJhY2svQWJzdHJhY3QvQWJzdHJhY3RMb2dJdGVtXCI7XG5pbXBvcnQgQWJzdHJhY3RSZWNvcmRpbmcgZnJvbSBcIi4uL0RhdGFUeXBlcy9QbGF5YmFjay9BYnN0cmFjdC9BYnN0cmFjdFJlY29yZGluZ1wiO1xuaW1wb3J0IEFic3RyYWN0UmVjb3JkZXIgZnJvbSBcIi4uL0RhdGFUeXBlcy9QbGF5YmFjay9BYnN0cmFjdC9BYnN0cmFjdFJlY29yZGVyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBsYXliYWNrTWFuYWdlciBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xuXG4gICAgcHJvdGVjdGVkIHJlY29yZGVyOiBBYnN0cmFjdFJlY29yZGVyPEFic3RyYWN0UmVjb3JkaW5nPEFic3RyYWN0TG9nSXRlbT4sIEFic3RyYWN0TG9nSXRlbT47XG4gICAgcHJvdGVjdGVkIHJlY29yZGluZzogYm9vbGVhbjtcblxuICAgIHByb3RlY3RlZCByZXBsYXllcjogQWJzdHJhY3RSZXBsYXllcjxBYnN0cmFjdFJlY29yZGluZzxBYnN0cmFjdExvZ0l0ZW0+LCBBYnN0cmFjdExvZ0l0ZW0+O1xuICAgIHByb3RlY3RlZCBwbGF5aW5nOiBib29sZWFuO1xuXG4gICAgcHJvdGVjdGVkIGxhc3RSZWNvcmRpbmc6IEFic3RyYWN0UmVjb3JkaW5nPEFic3RyYWN0TG9nSXRlbT47XG5cbiAgICBwcm90ZWN0ZWQgcmVjZWl2ZXI6IFJlY2VpdmVyO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucmVjb3JkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGxheWluZyA9IGZhbHNlO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IG5ldyBSZWNlaXZlcigpO1xuICAgICAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZShbR2FtZUV2ZW50VHlwZS5TVEFSVF9SRUNPUkRJTkcsIEdhbWVFdmVudFR5cGUuU1RPUF9SRUNPUkRJTkcsIEdhbWVFdmVudFR5cGUuUExBWV9SRUNPUkRJTkddKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHdoaWxlICh0aGlzLnJlY2VpdmVyLmhhc05leHRFdmVudCgpKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUV2ZW50KHRoaXMucmVjZWl2ZXIuZ2V0TmV4dEV2ZW50KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucmVjb3JkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5yZWNvcmRlci51cGRhdGUoZGVsdGFUKTtcbiAgICAgICAgICAgIHRoaXMucmVjb3JkaW5nID0gdGhpcy5yZWNvcmRlci5hY3RpdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXBsYXllciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlcGxheWVyLnVwZGF0ZShkZWx0YVQpO1xuICAgICAgICAgICAgdGhpcy5wbGF5aW5nID0gdGhpcy5yZXBsYXllci5hY3RpdmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBoYW5kbGVFdmVudChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIHN3aXRjaChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIEdhbWVFdmVudFR5cGUuU1RBUlRfUkVDT1JESU5HOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVTdGFydFJlY29yZGluZ0V2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgR2FtZUV2ZW50VHlwZS5TVE9QX1JFQ09SRElORzoge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlU3RvcFJlY29yZGluZ0V2ZW50KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEdhbWVFdmVudFR5cGUuUExBWV9SRUNPUkRJTkc6IHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVBsYXlSZWNvcmRpbmdFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvdGVjdGVkIGhhbmRsZVN0YXJ0UmVjb3JkaW5nRXZlbnQoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQge1xuICAgICAgICBsZXQgcmVjb3JkaW5nID0gZXZlbnQuZGF0YS5nZXQoXCJyZWNvcmRpbmdcIik7XG4gICAgICAgIGlmICghdGhpcy5wbGF5aW5nICYmICF0aGlzLnJlY29yZGluZyAmJiByZWNvcmRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5sYXN0UmVjb3JkaW5nID0gcmVjb3JkaW5nO1xuICAgICAgICAgICAgbGV0IFJlY29yZGVyOiBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBBYnN0cmFjdFJlY29yZGVyPEFic3RyYWN0UmVjb3JkaW5nPEFic3RyYWN0TG9nSXRlbT4sIEFic3RyYWN0TG9nSXRlbT4gPSB0aGlzLmxhc3RSZWNvcmRpbmcucmVjb3JkZXIoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlY29yZGVyID09PSB1bmRlZmluZWQgfHwgdGhpcy5yZWNvcmRlci5jb25zdHJ1Y3RvciAhPT0gUmVjb3JkZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlY29yZGVyID0gbmV3IFJlY29yZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlY29yZGVyLnN0YXJ0KHRoaXMubGFzdFJlY29yZGluZyk7XG4gICAgICAgICAgICB0aGlzLnJlY29yZGluZyA9IHRoaXMucmVjb3JkZXIuYWN0aXZlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvdGVjdGVkIGhhbmRsZVN0b3BSZWNvcmRpbmdFdmVudCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5yZWNvcmRlci5zdG9wKCk7XG4gICAgICAgIHRoaXMucmVjb3JkaW5nID0gdGhpcy5yZWNvcmRlci5hY3RpdmUoKTtcbiAgICB9XG4gICAgcHJvdGVjdGVkIGhhbmRsZVBsYXlSZWNvcmRpbmdFdmVudChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5yZWNvcmRpbmcgJiYgdGhpcy5sYXN0UmVjb3JkaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBSZXBsYXllcjogbmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gQWJzdHJhY3RSZXBsYXllcjxBYnN0cmFjdFJlY29yZGluZzxBYnN0cmFjdExvZ0l0ZW0+LCBBYnN0cmFjdExvZ0l0ZW0+ID0gdGhpcy5sYXN0UmVjb3JkaW5nLnJlcGxheWVyKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXBsYXllciA9PT0gdW5kZWZpbmVkIHx8IHRoaXMucmVwbGF5ZXIuY29uc3RydWN0b3IgIT09IFJlcGxheWVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBsYXllciA9IG5ldyBSZXBsYXllcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXBsYXllci5zdGFydCh0aGlzLmxhc3RSZWNvcmRpbmcsIGV2ZW50LmRhdGEuZ2V0KFwib25FbmRcIikpO1xuICAgICAgICAgICAgdGhpcy5wbGF5aW5nID0gdGhpcy5yZXBsYXllci5hY3RpdmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCBNYXAgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9Db2xsZWN0aW9ucy9NYXBcIjtcblxuLyoqICovXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBSZWdpc3RyeTxUPiBleHRlbmRzIE1hcDxUPntcblxuICAgIC8qKiBQcmVsb2FkcyByZWdpc3RyeSBkYXRhICovXG4gICAgcHVibGljIGFic3RyYWN0IHByZWxvYWQoKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhbiBpdGVtIGFuZCBwcmVsb2FkcyBhbnkgbmVjZXNzYXJ5IGZpbGVzXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIHJlZ2lzdGVyIHRoaXMgaXRlbSB3aXRoXG4gICAgICogQHBhcmFtIGFyZ3MgQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIG5lZWRlZCBmb3IgcmVnaXN0cmF0aW9uXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IHJlZ2lzdGVyQW5kUHJlbG9hZEl0ZW0oa2V5OiBzdHJpbmcsIC4uLmFyZ3M6IGFueSk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYW4gaXRlbSBhbmQgcHJlbG9hZHMgYW55IG5lY2Vzc2FyeSBmaWxlc1xuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byByZWdpc3RlciB0aGlzIGl0ZW0gd2l0aFxuICAgICAqIEBwYXJhbSBhcmdzIEFueSBhZGl0aW9uYWwgYXJndW1lbnRzIG5lZWRlZCBmb3IgcmVnaXN0cmF0aW9uXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IHJlZ2lzdGVySXRlbShrZXk6IHN0cmluZywgLi4uYXJnczogYW55KTogdm9pZDtcbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvQ29sbGVjdGlvbnMvTWFwXCI7XG5pbXBvcnQgU2hhZGVyVHlwZSBmcm9tIFwiLi4vLi4vUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVcIjtcbmltcG9ydCBMYWJlbFNoYWRlclR5cGUgZnJvbSBcIi4uLy4uL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9MYWJlbFNoYWRlclR5cGVcIjtcbmltcG9ydCBQb2ludFNoYWRlclR5cGUgZnJvbSBcIi4uLy4uL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9Qb2ludFNoYWRlclR5cGVcIjtcbmltcG9ydCBSZWN0U2hhZGVyVHlwZSBmcm9tIFwiLi4vLi4vUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVzL1JlY3RTaGFkZXJUeXBlXCI7XG5pbXBvcnQgU3ByaXRlU2hhZGVyVHlwZSBmcm9tIFwiLi4vLi4vUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVzL1Nwcml0ZVNoYWRlclR5cGVcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBSZWdpc3RyeSBmcm9tIFwiLi9SZWdpc3RyeVwiO1xuXG4vKipcbiAqIEEgcmVnaXN0cnkgdGhhdCBoYW5kbGVzIHNoYWRlcnNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhZGVyUmVnaXN0cnkgZXh0ZW5kcyBSZWdpc3RyeTxTaGFkZXJUeXBlPiB7XG5cblx0Ly8gU2hhZGVyIG5hbWVzXG5cdHB1YmxpYyBzdGF0aWMgUE9JTlRfU0hBREVSID0gXCJwb2ludFwiO1xuXHRwdWJsaWMgc3RhdGljIFJFQ1RfU0hBREVSID0gXCJyZWN0XCI7XG5cdHB1YmxpYyBzdGF0aWMgU1BSSVRFX1NIQURFUiA9IFwic3ByaXRlXCI7XG5cdHB1YmxpYyBzdGF0aWMgTEFCRUxfU0hBREVSID0gXCJsYWJlbFwiO1xuXG5cdHByaXZhdGUgcmVnaXN0cnlJdGVtczogQXJyYXk8U2hhZGVyUmVnaXN0cnlJdGVtPiA9IG5ldyBBcnJheSgpO1xuXG5cdC8qKlxuXHQgKiBQcmVsb2FkcyBhbGwgYnVpbHQtaW4gc2hhZGVyc1xuXHQgKi9cblx0cHVibGljIHByZWxvYWQoKXtcblx0XHQvLyBHZXQgdGhlIHJlc291cmNlTWFuYWdlciBhbmQgcXVldWUgYWxsIGJ1aWx0LWluIHNoYWRlcnMgZm9yIHByZWxvYWRpbmdcblx0XHRjb25zdCBybSA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xuXG5cdFx0Ly8gUXVldWUgYSBsb2FkIGZvciB0aGUgcG9pbnQgc2hhZGVyXG5cdFx0dGhpcy5yZWdpc3RlckFuZFByZWxvYWRJdGVtKFNoYWRlclJlZ2lzdHJ5LlBPSU5UX1NIQURFUiwgUG9pbnRTaGFkZXJUeXBlLCBcImJ1aWx0aW4vc2hhZGVycy9wb2ludC52c2hhZGVyXCIsIFwiYnVpbHRpbi9zaGFkZXJzL3BvaW50LmZzaGFkZXJcIik7XG5cblx0XHQvLyBRdWV1ZSBhIGxvYWQgZm9yIHRoZSByZWN0IHNoYWRlclxuXHRcdHRoaXMucmVnaXN0ZXJBbmRQcmVsb2FkSXRlbShTaGFkZXJSZWdpc3RyeS5SRUNUX1NIQURFUiwgUmVjdFNoYWRlclR5cGUsIFwiYnVpbHRpbi9zaGFkZXJzL3JlY3QudnNoYWRlclwiLCBcImJ1aWx0aW4vc2hhZGVycy9yZWN0LmZzaGFkZXJcIik7XG5cblx0XHQvLyBRdWV1ZSBhIGxvYWQgZm9yIHRoZSBzcHJpdGUgc2hhZGVyXG5cdFx0dGhpcy5yZWdpc3RlckFuZFByZWxvYWRJdGVtKFNoYWRlclJlZ2lzdHJ5LlNQUklURV9TSEFERVIsIFNwcml0ZVNoYWRlclR5cGUsIFwiYnVpbHRpbi9zaGFkZXJzL3Nwcml0ZS52c2hhZGVyXCIsIFwiYnVpbHRpbi9zaGFkZXJzL3Nwcml0ZS5mc2hhZGVyXCIpO1xuXHRcblx0XHQvLyBRdWV1ZSBhIGxvYWQgZm9yIHRoZSBsYWJlbCBzaGFkZXJcblx0XHR0aGlzLnJlZ2lzdGVyQW5kUHJlbG9hZEl0ZW0oU2hhZGVyUmVnaXN0cnkuTEFCRUxfU0hBREVSLCBMYWJlbFNoYWRlclR5cGUsIFwiYnVpbHRpbi9zaGFkZXJzL2xhYmVsLnZzaGFkZXJcIiwgXCJidWlsdGluL3NoYWRlcnMvbGFiZWwuZnNoYWRlclwiKTtcblxuXHRcdC8vIFF1ZXVlIGEgbG9hZCBmb3IgYW55IHByZWxvYWRlZCBpdGVtc1xuXHRcdGZvcihsZXQgaXRlbSBvZiB0aGlzLnJlZ2lzdHJ5SXRlbXMpe1xuXHRcdFx0Y29uc3Qgc2hhZGVyID0gbmV3IGl0ZW0uY29uc3RyKGl0ZW0ua2V5KTtcblx0XHRcdHNoYWRlci5pbml0QnVmZmVyT2JqZWN0KCk7XG5cdFx0XHR0aGlzLmFkZChpdGVtLmtleSwgc2hhZGVyKTtcblxuXHRcdFx0Ly8gTG9hZCBpZiBkZXNpcmVkXG5cdFx0XHRpZihpdGVtLnByZWxvYWQgIT09IHVuZGVmaW5lZCl7XG5cdFx0XHRcdHJtLnNoYWRlcihpdGVtLmtleSwgaXRlbS5wcmVsb2FkLnZzaGFkZXJMb2NhdGlvbiwgaXRlbS5wcmVsb2FkLmZzaGFkZXJMb2NhdGlvbik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVycyBhIHNoYWRlciBpbiB0aGUgcmVnaXN0cnkgYW5kIGxvYWRzIGl0IGJlZm9yZSB0aGUgZ2FtZSBiZWdpbnNcblx0ICogQHBhcmFtIGtleSBUaGUga2V5IHlvdSB3aXNoIHRvIGFzc2lnbiB0byB0aGUgc2hhZGVyXG5cdCAqIEBwYXJhbSBjb25zdHIgVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBTaGFkZXJUeXBlXG5cdCAqIEBwYXJhbSB2c2hhZGVyTG9jYXRpb24gVGhlIGxvY2F0aW9uIG9mIHRoZSB2ZXJ0ZXggc2hhZGVyXG5cdCAqIEBwYXJhbSBmc2hhZGVyTG9jYXRpb24gdGhlIGxvY2F0aW9uIG9mIHRoZSBmcmFnbWVudCBzaGFkZXJcblx0ICovXG5cdHB1YmxpYyByZWdpc3RlckFuZFByZWxvYWRJdGVtKGtleTogc3RyaW5nLCBjb25zdHI6IG5ldyAocHJvZ3JhbUtleTogc3RyaW5nKSA9PiBTaGFkZXJUeXBlLCB2c2hhZGVyTG9jYXRpb246IHN0cmluZywgZnNoYWRlckxvY2F0aW9uOiBzdHJpbmcpOiB2b2lkIHtcblx0XHRsZXQgc2hhZGVyUHJlbG9hZCA9IG5ldyBTaGFkZXJQcmVsb2FkKCk7XG5cdFx0c2hhZGVyUHJlbG9hZC52c2hhZGVyTG9jYXRpb24gPSB2c2hhZGVyTG9jYXRpb247XG5cdFx0c2hhZGVyUHJlbG9hZC5mc2hhZGVyTG9jYXRpb24gPSBmc2hhZGVyTG9jYXRpb247XG5cblx0XHRsZXQgcmVnaXN0cnlJdGVtID0gbmV3IFNoYWRlclJlZ2lzdHJ5SXRlbSgpO1xuXHRcdHJlZ2lzdHJ5SXRlbS5rZXkgPSBrZXk7XG5cdFx0cmVnaXN0cnlJdGVtLmNvbnN0ciA9IGNvbnN0cjtcblx0XHRyZWdpc3RyeUl0ZW0ucHJlbG9hZCA9IHNoYWRlclByZWxvYWQ7XG5cblx0XHR0aGlzLnJlZ2lzdHJ5SXRlbXMucHVzaChyZWdpc3RyeUl0ZW0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVycyBhIHNoYWRlciBpbiB0aGUgcmVnaXN0cnkuIE5PVEU6IElmIHlvdSB1c2UgdGhpcywgeW91IE1VU1QgbG9hZCB0aGUgc2hhZGVyIGJlZm9yZSB1c2UuXG5cdCAqIElmIHlvdSB3aXNoIHRvIHByZWxvYWQgdGhlIHNoYWRlciwgdXNlIHJlZ2lzdGVyQW5kUHJlbG9hZEl0ZW0oKVxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgeW91IHdpc2ggdG8gYXNzaWduIHRvIHRoZSBzaGFkZXJcblx0ICogQHBhcmFtIGNvbnN0ciBUaGUgY29uc3RydWN0b3Igb2YgdGhlIFNoYWRlclR5cGVcblx0ICovXG5cdHB1YmxpYyByZWdpc3Rlckl0ZW0oa2V5OiBzdHJpbmcsIGNvbnN0cjogbmV3IChwcm9ncmFtS2V5OiBzdHJpbmcpID0+IFNoYWRlclR5cGUpOiB2b2lkIHtcblx0XHRsZXQgcmVnaXN0cnlJdGVtID0gbmV3IFNoYWRlclJlZ2lzdHJ5SXRlbSgpO1xuXHRcdHJlZ2lzdHJ5SXRlbS5rZXkgPSBrZXk7XG5cdFx0cmVnaXN0cnlJdGVtLmNvbnN0ciA9IGNvbnN0cjtcblxuXHRcdHRoaXMucmVnaXN0cnlJdGVtcy5wdXNoKHJlZ2lzdHJ5SXRlbSk7XG5cdH1cbn1cblxuY2xhc3MgU2hhZGVyUmVnaXN0cnlJdGVtIHtcblx0a2V5OiBzdHJpbmc7XG5cdGNvbnN0cjogbmV3IChwcm9ncmFtS2V5OiBzdHJpbmcpID0+IFNoYWRlclR5cGU7XG5cdHByZWxvYWQ6IFNoYWRlclByZWxvYWQ7XG59XG5cbmNsYXNzIFNoYWRlclByZWxvYWQge1xuXHR2c2hhZGVyTG9jYXRpb246IHN0cmluZztcblx0ZnNoYWRlckxvY2F0aW9uOiBzdHJpbmc7XG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL0NvbGxlY3Rpb25zL01hcFwiO1xuaW1wb3J0IFJlZ2lzdHJ5IGZyb20gXCIuL1JlZ2lzdHJpZXMvUmVnaXN0cnlcIjtcbmltcG9ydCBTaGFkZXJSZWdpc3RyeSBmcm9tIFwiLi9SZWdpc3RyaWVzL1NoYWRlclJlZ2lzdHJ5XCI7XG5cbi8qKlxuICogVGhlIFJlZ2lzdHJ5IGlzIHRoZSBzeXN0ZW0ncyB3YXkgb2YgY29udmVydGluZyBjbGFzc2VzIGFuZCB0eXBlcyBpbnRvIHN0cmluZ1xuICogcmVwcmVzZW50YXRpb25zIGZvciB1c2UgZWxzZXdoZXJlIGluIHRoZSBhcHBsaWNhdGlvbi5cbiAqIEl0IGFsbG93cyBjbGFzc2VzIHRvIGJlIGFjY2Vzc2VkIHdpdGhvdXQgZXhwbGljaXRseSB1c2luZyBjb25zdHJ1Y3RvcnMgaW4gY29kZSxcbiAqIGFuZCBmb3IgcmVzb3VyY2VzIHRvIGJlIGxvYWRlZCBhdCBHYW1lIGNyZWF0aW9uIHRpbWUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlZ2lzdHJ5TWFuYWdlciB7XG5cblx0cHVibGljIHN0YXRpYyBzaGFkZXJzID0gbmV3IFNoYWRlclJlZ2lzdHJ5KCk7XG5cblx0LyoqIEFkZGl0aW9uYWwgY3VzdG9tIHJlZ2lzdHJpZXMgdG8gYWRkIHRvIHRoZSByZWdpc3RyeSBtYW5hZ2VyICovXG5cdHByb3RlY3RlZCBzdGF0aWMgcmVnaXN0cmllczogTWFwPFJlZ2lzdHJ5PGFueT4+ID0gbmV3IE1hcCgpO1xuXG5cdHN0YXRpYyBwcmVsb2FkKCl7XG5cdFx0dGhpcy5zaGFkZXJzLnByZWxvYWQoKTtcblxuXHRcdHRoaXMucmVnaXN0cmllcy5mb3JFYWNoKChrZXk6IHN0cmluZykgPT4gdGhpcy5yZWdpc3RyaWVzLmdldChrZXkpLnByZWxvYWQoKSk7XG5cdH1cblxuXHRzdGF0aWMgYWRkQ3VzdG9tUmVnaXN0cnkobmFtZTogc3RyaW5nLCByZWdpc3RyeTogUmVnaXN0cnk8YW55Pil7XG5cdFx0dGhpcy5yZWdpc3RyaWVzLmFkZChuYW1lLCByZWdpc3RyeSk7XG5cdH1cblxuXHRzdGF0aWMgZ2V0UmVnaXN0cnkoa2V5OiBzdHJpbmcpe1xuXHRcdHJldHVybiB0aGlzLnJlZ2lzdHJpZXMuZ2V0KGtleSk7XG5cdH1cbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvQ29sbGVjdGlvbnMvTWFwXCI7XG5pbXBvcnQgRW1pdHRlciBmcm9tIFwiLi4vLi4vRXZlbnRzL0VtaXR0ZXJcIjtcbmltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuLi8uLi9Ob2Rlcy9DYW52YXNOb2RlXCI7XG5pbXBvcnQgeyBBbmltYXRpb25EYXRhLCBBbmltYXRpb25TdGF0ZSB9IGZyb20gXCIuL0FuaW1hdGlvblR5cGVzXCI7XG5cbi8qKlxuICogQW4gYW5pbWF0aW9uIG1hbmFnZXIgY2xhc3MgZm9yIGFuIGFuaW1hdGVkIENhbnZhc05vZGUuXG4gKiBUaGlzIGNsYXNzIGtlZXBzIHRyYWNrIG9mIHRoZSBwb3NzaWJsZSBhbmltYXRpb25zLCBhcyB3ZWxsIGFzIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBzdGF0ZSxcbiAqIGFuZCBhYnN0cmFjdHMgYWxsIGludGVyYWN0aW9ucyB3aXRoIHBsYXlpbmcsIHBhdXNpbmcsIGFuZCBzdG9wcGluZyBhbmltYXRpb25zIGFzIHdlbGwgYXMgXG4gKiBjcmVhdGluZyBuZXcgYW5pbWF0aW9ucyBmcm9tIHRoZSBDYW52YXNOb2RlLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltYXRpb25NYW5hZ2VyIHtcbiAgICAvKiogVGhlIG93bmVyIG9mIHRoaXMgYW5pbWF0aW9uIG1hbmFnZXIgKi9cbiAgICBwcm90ZWN0ZWQgb3duZXI6IENhbnZhc05vZGU7XG4gICAgXG4gICAgLyoqIFRoZSBjdXJyZW50IGFuaW1hdGlvbiBzdGF0ZSBvZiB0aGlzIHNwcml0ZSAqL1xuICAgIHByb3RlY3RlZCBhbmltYXRpb25TdGF0ZTogQW5pbWF0aW9uU3RhdGU7XG5cbiAgICAvKiogVGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIG9mIHRoaXMgc3ByaXRlICovXG4gICAgcHJvdGVjdGVkIGN1cnJlbnRBbmltYXRpb246IHN0cmluZztcblxuICAgIC8qKiBUaGUgY3VycmVudCBmcmFtZSBvZiB0aGlzIGFuaW1hdGlvbiAqL1xuICAgIHByb3RlY3RlZCBjdXJyZW50RnJhbWU6IG51bWJlcjtcblxuICAgIC8qKiBUaGUgcHJvZ3Jlc3Mgb2YgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIHRocm91Z2ggdGhlIGN1cnJlbnQgZnJhbWUgKi9cbiAgICBwcm90ZWN0ZWQgZnJhbWVQcm9ncmVzczogbnVtYmVyO1xuXG4gICAgLyoqIFdoZXRoZXIgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGlzIGxvb3Bpbmcgb3Igbm90ICovXG4gICAgcHJvdGVjdGVkIGxvb3A6IGJvb2xlYW47XG5cbiAgICAvKiogVGhlIG1hcCBvZiBhbmltYXRpb25zICovXG4gICAgcHJvdGVjdGVkIGFuaW1hdGlvbnM6IE1hcDxBbmltYXRpb25EYXRhPjtcblxuICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKGlmIGFueSkgdG8gc2VuZCB3aGVuIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBzdG9wcyBwbGF5aW5nLiAqL1xuICAgIHByb3RlY3RlZCBvbkVuZEV2ZW50OiBzdHJpbmc7XG5cbiAgICAvKiogVGhlIGV2ZW50IGVtaXR0ZXIgZm9yIHRoaXMgYW5pbWF0aW9uIG1hbmFnZXIgKi9cbiAgICBwcm90ZWN0ZWQgZW1pdHRlcjogRW1pdHRlcjtcblxuICAgIC8qKiBBIHF1ZXVlZCBhbmltYXRpb24gKi9cbiAgICBwcm90ZWN0ZWQgcGVuZGluZ0FuaW1hdGlvbjogc3RyaW5nO1xuXG4gICAgLyoqIFRoZSBsb29wIHN0YXR1cyBvZiBhIHBlbmRpbmcgYW5pbWF0aW9uICovXG4gICAgcHJvdGVjdGVkIHBlbmRpbmdMb29wOiBib29sZWFuO1xuXG4gICAgLyoqIFRoZSBvbkVuZCBldmVudCBvZiBhIHBlbmRpbmcgYW5pbWF0aW9uICovXG4gICAgcHJvdGVjdGVkIHBlbmRpbmdPbkVuZDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBBbmltYXRpb25NYW5hZ2VyXG4gICAgICogQHBhcmFtIG93bmVyIFRoZSBvd25lciBvZiB0aGUgQW5pbWF0aW9uTWFuYWdlclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG93bmVyOiBDYW52YXNOb2RlKXtcbiAgICAgICAgdGhpcy5vd25lciA9IG93bmVyO1xuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gQW5pbWF0aW9uU3RhdGUuU1RPUFBFRDtcbiAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uID0gXCJcIjtcbiAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPSAwO1xuICAgICAgICB0aGlzLmZyYW1lUHJvZ3Jlc3MgPSAwO1xuICAgICAgICB0aGlzLmxvb3AgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm9uRW5kRXZlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBhbmltYXRpb24gdG8gdGhpcyBzcHJpdGVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSB1bmlxdWUga2V5IG9mIHRoZSBhbmltYXRpb25cbiAgICAgKiBAcGFyYW0gYW5pbWF0aW9uIFRoZSBhbmltYXRpb24gZGF0YVxuICAgICAqL1xuICAgIGFkZChrZXk6IHN0cmluZywgYW5pbWF0aW9uOiBBbmltYXRpb25EYXRhKTogdm9pZCB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucy5hZGQoa2V5LCBhbmltYXRpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IHNwZWNpZmllZCBieSB0aGUgY3VycmVudCBhbmltYXRpb24gYW5kIGN1cnJlbnQgZnJhbWVcbiAgICAgKiBAcmV0dXJucyBUaGUgaW5kZXggaW4gdGhlIGN1cnJlbnQgYW5pbWF0aW9uXG4gICAgICovXG4gICAgZ2V0SW5kZXgoKTogbnVtYmVyIHtcbiAgICAgICAgaWYodGhpcy5hbmltYXRpb25zLmhhcyh0aGlzLmN1cnJlbnRBbmltYXRpb24pKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbnMuZ2V0KHRoaXMuY3VycmVudEFuaW1hdGlvbikuZnJhbWVzW3RoaXMuY3VycmVudEZyYW1lXS5pbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vIGN1cnJlbnQgYW5pbWF0aW9uLCB3YXJuIHRoZSB1c2VyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEFuaW1hdGlvbiBpbmRleCB3YXMgcmVxdWVzdGVkLCBidXQgdGhlIGN1cnJlbnQgYW5pbWF0aW9uOiAke3RoaXMuY3VycmVudEFuaW1hdGlvbn0gd2FzIGludmFsaWRgKTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgYW5pbWF0aW9uIGlzIGN1cnJlbnRseSBwbGF5aW5nXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBhbmltYXRpb24gdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgYW5pbWF0aW9uIGlzIHBsYXlpbmcsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGlzUGxheWluZyhrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50QW5pbWF0aW9uID09PSBrZXkgJiYgdGhpcy5hbmltYXRpb25TdGF0ZSA9PT0gQW5pbWF0aW9uU3RhdGUuUExBWUlORztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGluZGV4IGFuZCBhZHZhbmNlcyB0aGUgYW5pbWF0aW9uIGZyYW1lXG4gICAgICogQHJldHVybnMgVGhlIGluZGV4IG9mIHRoZSBhbmltYXRpb24gZnJhbWVcbiAgICAgKi9cbiAgICBnZXRJbmRleEFuZEFkdmFuY2VBbmltYXRpb24oKTogbnVtYmVyIHtcbiAgICAgICAgLy8gSWYgd2UgYXJlbid0IHBsYXlpbmcsIHdlIHdvbid0IGJlIGFkdmFuY2luZyB0aGUgYW5pbWF0aW9uXG4gICAgICAgIGlmKCEodGhpcy5hbmltYXRpb25TdGF0ZSA9PT0gQW5pbWF0aW9uU3RhdGUuUExBWUlORykpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5kZXgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuYW5pbWF0aW9ucy5oYXModGhpcy5jdXJyZW50QW5pbWF0aW9uKSl7XG4gICAgICAgICAgICBsZXQgY3VycmVudEFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9ucy5nZXQodGhpcy5jdXJyZW50QW5pbWF0aW9uKTtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGN1cnJlbnRBbmltYXRpb24uZnJhbWVzW3RoaXMuY3VycmVudEZyYW1lXS5pbmRleDtcblxuICAgICAgICAgICAgLy8gQWR2YW5jZSB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAgICB0aGlzLmZyYW1lUHJvZ3Jlc3MgKz0gMTtcbiAgICAgICAgICAgIGlmKHRoaXMuZnJhbWVQcm9ncmVzcyA+PSBjdXJyZW50QW5pbWF0aW9uLmZyYW1lc1t0aGlzLmN1cnJlbnRGcmFtZV0uZHVyYXRpb24pe1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYmVlbiBvbiB0aGlzIGZyYW1lIGZvciBpdHMgd2hvbGUgZHVyYXRpb24sIGdvIHRvIHRoZSBuZXh0IG9uZVxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVQcm9ncmVzcyA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgKz0gMTtcblxuICAgICAgICAgICAgICAgIGlmKHRoaXMuY3VycmVudEZyYW1lID49IGN1cnJlbnRBbmltYXRpb24uZnJhbWVzLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoaXMgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMubG9vcCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYW1lUHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRDdXJyZW50QW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgY3VycmVudCBpbmRleFxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gY3VycmVudCBhbmltYXRpb24sIGNhbid0IGFkdmFuY2UuIFdhcm4gdGhlIHVzZXJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQW5pbWF0aW9uIGluZGV4IGFuZCBhZHZhbmNlIHdhcyByZXF1ZXN0ZWQsIGJ1dCB0aGUgY3VycmVudCBhbmltYXRpb24gKCR7dGhpcy5jdXJyZW50QW5pbWF0aW9ufSkgaW4gbm9kZSB3aXRoIGlkOiAke3RoaXMub3duZXIuaWR9IHdhcyBpbnZhbGlkYCk7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBFbmRzIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBhbmQgZmlyZXMgYW55IG5lY2Vzc2FyeSBldmVudHMsIGFzIHdlbGwgYXMgc3RhcnRpbmcgYW55IG5ldyBhbmltYXRpb25zICovXG4gICAgcHJvdGVjdGVkIGVuZEN1cnJlbnRBbmltYXRpb24oKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gMDtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlNUT1BQRUQ7XG5cbiAgICAgICAgaWYodGhpcy5vbkVuZEV2ZW50ICE9PSBudWxsKXtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQodGhpcy5vbkVuZEV2ZW50LCB7b3duZXI6IHRoaXMub3duZXIuaWQsIGFuaW1hdGlvbjogdGhpcy5jdXJyZW50QW5pbWF0aW9ufSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHBlbmRpbmcgYW5pbWF0aW9uLCBwbGF5IGl0XG4gICAgICAgIGlmKHRoaXMucGVuZGluZ0FuaW1hdGlvbiAhPT0gbnVsbCl7XG4gICAgICAgICAgICB0aGlzLnBsYXkodGhpcy5wZW5kaW5nQW5pbWF0aW9uLCB0aGlzLnBlbmRpbmdMb29wLCB0aGlzLnBlbmRpbmdPbkVuZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQbGF5cyB0aGUgc3BlY2lmaWVkIGFuaW1hdGlvbi4gRG9lcyBub3QgcmVzdGFydCBpdCBpZiBpdCBpcyBhbHJlYWR5IHBsYXlpbmdcbiAgICAgKiBAcGFyYW0gYW5pbWF0aW9uIFRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gdG8gcGxheVxuICAgICAqIEBwYXJhbSBsb29wIFdoZXRoZXIgb3Igbm90IHRvIGxvb3AgdGhlIGFuaW1hdGlvbi4gRmFsc2UgYnkgZGVmYXVsdFxuICAgICAqIEBwYXJhbSBvbkVuZCBUaGUgbmFtZSBvZiBhbiBldmVudCB0byBzZW5kIHdoZW4gdGhpcyBhbmltYXRpb24gbmF0dXJhbGx5IHN0b3BzIHBsYXlpbmcuIFRoaXMgb25seSBtYXR0ZXJzIGlmIGxvb3AgaXMgZmFsc2UuXG4gICAgICovXG4gICAgcGxheUlmTm90QWxyZWFkeShhbmltYXRpb246IHN0cmluZywgbG9vcD86IGJvb2xlYW4sIG9uRW5kPzogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGlmKHRoaXMuY3VycmVudEFuaW1hdGlvbiAhPT0gYW5pbWF0aW9uKXtcbiAgICAgICAgICAgIHRoaXMucGxheShhbmltYXRpb24sIGxvb3AsIG9uRW5kKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBsYXlzIHRoZSBzcGVjaWZpZWQgYW5pbWF0aW9uXG4gICAgICogQHBhcmFtIGFuaW1hdGlvbiBUaGUgbmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRvIHBsYXlcbiAgICAgKiBAcGFyYW0gbG9vcCBXaGV0aGVyIG9yIG5vdCB0byBsb29wIHRoZSBhbmltYXRpb24uIEZhbHNlIGJ5IGRlZmF1bHRcbiAgICAgKiBAcGFyYW0gb25FbmQgVGhlIG5hbWUgb2YgYW4gZXZlbnQgdG8gc2VuZCB3aGVuIHRoaXMgYW5pbWF0aW9uIG5hdHVyYWxseSBzdG9wcyBwbGF5aW5nLiBUaGlzIG9ubHkgbWF0dGVycyBpZiBsb29wIGlzIGZhbHNlLlxuICAgICAqL1xuICAgIHBsYXkoYW5pbWF0aW9uOiBzdHJpbmcsIGxvb3A/OiBib29sZWFuLCBvbkVuZD86IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24gPSBhbmltYXRpb247XG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gMDtcbiAgICAgICAgdGhpcy5mcmFtZVByb2dyZXNzID0gMDtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlBMQVlJTkc7XG5cbiAgICAgICAgLy8gSWYgbG9vcCBhcmcgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdFxuICAgICAgICBpZihsb29wICE9PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgdGhpcy5sb29wID0gbG9vcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdXNlIHdoYXQgdGhlIGpzb24gZmlsZSBzcGVjaWZpZWRcbiAgICAgICAgICAgIHRoaXMubG9vcCA9IHRoaXMuYW5pbWF0aW9ucy5nZXQoYW5pbWF0aW9uKS5yZXBlYXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZihvbkVuZCAhPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIHRoaXMub25FbmRFdmVudCA9IG9uRW5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vbkVuZEV2ZW50ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc2V0IHBlbmRpbmcgYW5pbWF0aW9uXG4gICAgICAgIHRoaXMucGVuZGluZ0FuaW1hdGlvbiA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUXVldWVzIGEgc2luZ2xlIGFuaW1hdGlvbiB0byBiZSBwbGF5ZWQgYWZ0ZXIgdGhlIGN1cnJlbnQgb25lLiBEb2VzIE5PVCBzdGFjay5cbiAgICAgKiBRdWV1ZWluZyBhZGRpdGlvbmFsIGFuaW1hdGlvbnMgcGFzdCAxIHdpbGwganVzdCByZXBsYWNlIHRoZSBxdWV1ZWQgYW5pbWF0aW9uXG4gICAgICogQHBhcmFtIGFuaW1hdGlvbiBUaGUgYW5pbWF0aW9uIHRvIHF1ZXVlXG4gICAgICogQHBhcmFtIGxvb3AgV2hldGhlciBvciBub3QgdGhlIGxvb3AgdGhlIHF1ZXVlZCBhbmltYXRpb25cbiAgICAgKiBAcGFyYW0gb25FbmQgVGhlIGV2ZW50IHRvIGZpcmUgd2hlbiB0aGUgcXVldWVkIGFuaW1hdGlvbiBlbmRzXG4gICAgICovXG4gICAgcXVldWUoYW5pbWF0aW9uOiBzdHJpbmcsIGxvb3A6IGJvb2xlYW4gPSBmYWxzZSwgb25FbmQ/OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nQW5pbWF0aW9uID0gYW5pbWF0aW9uO1xuICAgICAgICB0aGlzLnBlbmRpbmdMb29wID0gbG9vcDtcbiAgICAgICAgaWYob25FbmQgIT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdPbkVuZCA9IG9uRW5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nT25FbmQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFBhdXNlcyB0aGUgY3VycmVudCBhbmltYXRpb24gKi9cbiAgICBwYXVzZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlBBVVNFRDtcbiAgICB9XG5cbiAgICAvKiogUmVzdW1lcyB0aGUgY3VycmVudCBhbmltYXRpb24gaWYgcG9zc2libGUgKi9cbiAgICByZXN1bWUoKTogdm9pZCB7XG4gICAgICAgIGlmKHRoaXMuYW5pbWF0aW9uU3RhdGUgPT09IEFuaW1hdGlvblN0YXRlLlBBVVNFRCl7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gQW5pbWF0aW9uU3RhdGUuUExBWUlORztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBTdG9wcyB0aGUgY3VycmVudCBhbmltYXRpb24uIFRoZSBhbmltYXRpb24gY2Fubm90IGJlIHJlc3VtZWQgYWZ0ZXIgdGhpcy4gKi9cbiAgICBzdG9wKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gQW5pbWF0aW9uU3RhdGUuU1RPUFBFRDtcbiAgICB9XG59IiwiaW1wb3J0IHsgVHdlZW5hYmxlUHJvcGVydGllcyB9IGZyb20gXCIuLi8uLi9Ob2Rlcy9HYW1lTm9kZVwiO1xuaW1wb3J0IHsgRWFzZUZ1bmN0aW9uVHlwZSB9IGZyb20gXCIuLi8uLi9VdGlscy9FYXNlRnVuY3Rpb25zXCI7XG5cbi8vIEBpZ25vcmVQYWdlXG5cbmV4cG9ydCBlbnVtIEFuaW1hdGlvblN0YXRlIHtcbiAgICBTVE9QUEVEID0gMCxcbiAgICBQQVVTRUQgPSAxLFxuICAgIFBMQVlJTkcgPSAyLFxufVxuXG5leHBvcnQgY2xhc3MgQW5pbWF0aW9uRGF0YSB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIGZyYW1lczogQXJyYXk8e2luZGV4OiBudW1iZXIsIGR1cmF0aW9uOiBudW1iZXJ9PjtcbiAgICByZXBlYXQ6IGJvb2xlYW4gPSBmYWxzZTtcbn1cblxuZXhwb3J0IGNsYXNzIFR3ZWVuRWZmZWN0IHtcbiAgICAvKiogVGhlIHByb3BlcnR5IHRvIHR3ZWVuICovXG4gICAgcHJvcGVydHk6IFR3ZWVuYWJsZVByb3BlcnRpZXM7XG5cbiAgICAvKiogV2hldGhlciBvciBub3QgdGhlIFR3ZWVuIHNob3VsZCByZXNldCB0aGUgcHJvcGVydHkgdG8gaXRzIG9yaWdpbmFsIHZhbHVlIGFmdGVyIHBsYXlpbmcgKi9cbiAgICByZXNldE9uQ29tcGxldGU6IGJvb2xlYW47XG5cbiAgICAvKiogVGhlIHN0YXJ0aW5nIHZhbHVlIGZvciB0aGUgdHdlZW4gKi9cbiAgICBzdGFydDogYW55O1xuXG4gICAgLyoqIFRoZSBlbmRpbmcgdmFsdWUgZm9yIHRoZSB0d2VlbiAqL1xuICAgIGVuZDogYW55O1xuXG4gICAgLyoqIFRoZSBlYXNlIGZ1bmN0aW9uIHRvIHVzZSAqL1xuICAgIGVhc2U6IEVhc2VGdW5jdGlvblR5cGU7XG5cbiAgICAvKiogRE8gTk9UIE1PRElGWSAtIFRoZSBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgLSBzZXQgYXV0b21hdGljYWxseSAqL1xuICAgIGluaXRpYWxWYWx1ZTogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgVHdlZW5EYXRhIHtcbiAgICAvLyBNZW1iZXJzIGZvciBpbml0aWFsaXphdGlvbiBieSB0aGUgdXNlclxuICAgIC8qKiBUaGUgYW1vdW50IG9mIHRpbWUgaW4gbXMgdG8gd2FpdCBiZWZvcmUgZXhlY3V0aW5nIHRoZSB0d2VlbiAqL1xuICAgIHN0YXJ0RGVsYXk6IG51bWJlcjtcbiAgICAvKiogVGhlIGR1cmF0aW9uIG9mIHRpbWUgb3ZlciB3aGljaCB0aGUgdmFsdWUgd2l0aCBjaGFuZ2UgZnJvbSBzdGFydCB0byBlbmQgKi9cbiAgICBkdXJhdGlvbjogbnVtYmVyO1xuICAgIC8qKiBBbiBhcnJheSBvZiB0aGUgZWZmZWN0cyBvbiB0aGUgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0ICovXG4gICAgZWZmZWN0czogQXJyYXk8VHdlZW5FZmZlY3Q+O1xuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGlzIHR3ZWVuIHNob3VsZCByZXZlcnNlIGZyb20gZW5kIHRvIHN0YXJ0IGZvciBlYWNoIHByb3BlcnR5IHdoZW4gaXQgZmluaXNoZXMgKi9cbiAgICByZXZlcnNlT25Db21wbGV0ZTogYm9vbGVhbjtcbiAgICAvKiogV2hldGhlciBvciBub3QgdGhpcyB0d2VlbiBzaG91bGQgbG9vcCB3aGVuIGl0IGNvbXBsZXRlcyAqL1xuICAgIGxvb3A6IGJvb2xlYW47XG4gICAgLyoqIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzZW5kIChpZiBhbnkpIHdoZW4gdGhlIHR3ZWVuIGZpbmlzaGVzIHBsYXlpbmcgKi9cbiAgICBvbkVuZDogc3RyaW5nXG5cbiAgICAvKiogRXh0cmEgZGF0YSB0byBiZSBzZW50IHdoZW4gdGhlIG9uRW5kIGV2ZW50IGlzIGZpcmVkLiBLZXlzIHdpdGggdGhlIG5hbWUgJ2tleScgb3IgJ25vZGUnIGFyZSByZXNlcnZlZCBhbmQgY2FuJ3QgYmUgdXNlZCBhcyBuYW1lcyBmb3IgeW91ciBleHRyYSBkYXRhICovXG4gICAgb25FbmREYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICAgIFxuICAgIC8vIE1lbWJlcnMgZm9yIG1hbmFnZW1lbnQgYnkgdGhlIHR3ZWVuIG1hbmFnZXJcbiAgICAvKiogVGhlIHByb2dyZXNzIG9mIHRoaXMgdHdlZW4gdGhyb3VnaCBpdHMgZWZmZWN0cyAqL1xuICAgIHByb2dyZXNzOiBudW1iZXI7XG5cbiAgICAvKiogVGhlIGFtb3VudCBvZiB0aW1lIGluIG1zIHRoYXQgaGFzIHBhc3NlZCBmcm9tIHdoZW4gdGhpcyB0d2VlbiBzdGFydGVkIHJ1bm5pbmcgKi9cbiAgICBlbGFwc2VkVGltZTogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSBzdGF0ZSBvZiB0aGlzIHR3ZWVuICovXG4gICAgYW5pbWF0aW9uU3RhdGU6IEFuaW1hdGlvblN0YXRlO1xuXG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoaXMgdHdlZW4gaXMgY3VycmVudGx5IHJldmVyc2luZyAqL1xuICAgIHJldmVyc2luZzogYm9vbGVhbjtcbn0iLCJpbXBvcnQgVXBkYXRlYWJsZSBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvVXBkYXRlYWJsZVwiO1xuaW1wb3J0IFBhcnRpY2xlU3lzdGVtIGZyb20gXCIuL1BhcnRpY2xlU3lzdGVtXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhcnRpY2xlU3lzdGVtTWFuYWdlciBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xuXG4gICAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IFBhcnRpY2xlU3lzdGVtTWFuYWdlciA9IG51bGw7XG4gICAgXG4gICAgcHJvdGVjdGVkIHBhcnRpY2xlU3lzdGVtczogQXJyYXk8UGFydGljbGVTeXN0ZW0+O1xuXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLnBhcnRpY2xlU3lzdGVtcyA9IG5ldyBBcnJheSgpO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBQYXJ0aWNsZVN5c3RlbU1hbmFnZXIge1xuICAgICAgICBpZihQYXJ0aWNsZVN5c3RlbU1hbmFnZXIuaW5zdGFuY2UgPT09IG51bGwpe1xuICAgICAgICAgICAgUGFydGljbGVTeXN0ZW1NYW5hZ2VyLmluc3RhbmNlID0gbmV3IFBhcnRpY2xlU3lzdGVtTWFuYWdlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFBhcnRpY2xlU3lzdGVtTWFuYWdlci5pbnN0YW5jZTtcbiAgICB9XG5cbiAgICByZWdpc3RlclBhcnRpY2xlU3lzdGVtKHN5c3RlbTogUGFydGljbGVTeXN0ZW0pe1xuICAgICAgICB0aGlzLnBhcnRpY2xlU3lzdGVtcy5wdXNoKHN5c3RlbSk7XG4gICAgfVxuXG4gICAgZGVyZWdpc3RlclBhcnRpY2xlU3lzdGVtKHN5c3RlbTogUGFydGljbGVTeXN0ZW0pe1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLnBhcnRpY2xlU3lzdGVtcy5pbmRleE9mKHN5c3RlbSk7XG4gICAgICAgIHRoaXMucGFydGljbGVTeXN0ZW1zLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuXG4gICAgY2xlYXJQYXJ0aWNsZVN5c3RlbXMoKXtcbiAgICAgICAgdGhpcy5wYXJ0aWNsZVN5c3RlbXMgPSBuZXcgQXJyYXkoKTtcbiAgICB9XG5cbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgZm9yKGxldCBwYXJ0aWNsZVN5c3RlbSBvZiB0aGlzLnBhcnRpY2xlU3lzdGVtcyl7XG4gICAgICAgICAgICBwYXJ0aWNsZVN5c3RlbS51cGRhdGUoZGVsdGFUKTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvQ29sbGVjdGlvbnMvTWFwXCI7XG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uLy4uL05vZGVzL0dhbWVOb2RlXCI7XG5pbXBvcnQgeyBBbmltYXRpb25TdGF0ZSwgVHdlZW5EYXRhIH0gZnJvbSBcIi4vQW5pbWF0aW9uVHlwZXNcIjtcbmltcG9ydCBFYXNlRnVuY3Rpb25zIGZyb20gXCIuLi8uLi9VdGlscy9FYXNlRnVuY3Rpb25zXCI7XG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuLi8uLi9VdGlscy9NYXRoVXRpbHNcIjtcbmltcG9ydCBUd2Vlbk1hbmFnZXIgZnJvbSBcIi4vVHdlZW5NYW5hZ2VyXCI7XG5pbXBvcnQgRW1pdHRlciBmcm9tIFwiLi4vLi4vRXZlbnRzL0VtaXR0ZXJcIjtcblxuLyoqXG4gKiBBIG1hbmFnZXIgZm9yIHRoZSB0d2VlbnMgb2YgYSBHYW1lTm9kZS5cbiAqIFR3ZWVucyBhcmUgc2hvcnQgYW5pbWF0aW9ucyBwbGF5ZWQgYnkgaW50ZXJwb2xhdGluZyBiZXR3ZWVuIHR3byBwcm9wZXJ0aWVzIHVzaW5nIGFuIGVhc2luZyBmdW5jdGlvbi5cbiAqIEZvciBhIGdvb2QgdmlzdWFsIHJlcHJlc2VudGF0aW9uIG9mIGVhc2luZyBmdW5jdGlvbnMsIGNoZWNrIG91dCBAbGluayhodHRwczovL2Vhc2luZ3MubmV0LykoaHR0cHM6Ly9lYXNpbmdzLm5ldC8pLlxuICogTXVsdGlwbGUgdHdlZW4gY2FuIGJlIHBsYXllZCBhdCB0aGUgc2FtZSB0aW1lLCBhcyBsb25nIGFzIHRoZXkgZG9uJ3QgY2hhbmdlIHRoZSBzYW1lIHByb3BlcnR5LlxuICogVGhpcyBhbGxvd3MgZm9yIHNvbWUgaW50ZXJlc3RpbmcgcG9saXNoZXMgb3IgYW5pbWF0aW9ucyB0aGF0IG1heSBiZSB2ZXJ5IGRpZmZpY3VsdCB0byBkbyB3aXRoIHNwcml0ZSB3b3JrIGFsb25lXG4gKiAtIGVzcGVjaWFsbHkgcGl4ZWwgYXJ0IChzdWNoIGFzIHJvdGF0aW9ucyBvciBzY2FsaW5nKS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHdlZW5Db250cm9sbGVyIHtcbiAgICAvKiogVGhlIEdhbWVOb2RlIHRoaXMgVHdlZW5Db250cm9sbGVyIGFjdHMgdXBvbiAqL1xuICAgIHByb3RlY3RlZCBvd25lcjogR2FtZU5vZGU7XG4gICAgLyoqIFRoZSBsaXN0IG9mIGNyZWF0ZWQgdHdlZW5zICovXG4gICAgcHJvdGVjdGVkIHR3ZWVuczogTWFwPFR3ZWVuRGF0YT47XG4gICAgLyoqIEFuIGV2ZW50IGVtaXR0ZXIgKi9cbiAgICBwcm90ZWN0ZWQgZW1pdHRlcjogRW1pdHRlcjtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVHdlZW5Db250cm9sbGVyXG4gICAgICogQHBhcmFtIG93bmVyIFRoZSBvd25lciBvZiB0aGUgVHdlZW5Db250cm9sbGVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3duZXI6IEdhbWVOb2RlKXtcbiAgICAgICAgdGhpcy5vd25lciA9IG93bmVyO1xuICAgICAgICB0aGlzLnR3ZWVucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcblxuICAgICAgICAvLyBHaXZlIG91cnNlbHZlcyB0byB0aGUgVHdlZW5NYW5hZ2VyXG4gICAgICAgIFR3ZWVuTWFuYWdlci5nZXRJbnN0YW5jZSgpLnJlZ2lzdGVyVHdlZW5Db250cm9sbGVyKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoaXMgVHdlZW5Db250cm9sbGVyXG4gICAgICovXG4gICAgZGVzdHJveSgpe1xuICAgICAgICAvLyBPbmx5IHRoZSBnYW1lbm9kZSBhbmQgdGhlIHR3ZWVuIG1hbmFnZXIgc2hvdWxkIGhhdmUgYSByZWZlcmVuY2UgdG8gdGhpc1xuICAgICAgICBkZWxldGUgdGhpcy5vd25lci50d2VlbnM7XG4gICAgICAgIFR3ZWVuTWFuYWdlci5nZXRJbnN0YW5jZSgpLmRlcmVnaXN0ZXJUd2VlbkNvbnRyb2xsZXIodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgdHdlZW4gdG8gdGhpcyBnYW1lIG5vZGVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBuYW1lIG9mIHRoZSB0d2VlblxuICAgICAqIEBwYXJhbSB0d2VlbiBUaGUgZGF0YSBvZiB0aGUgdHdlZW5cbiAgICAgKi9cbiAgICBhZGQoa2V5OiBzdHJpbmcsIHR3ZWVuOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgVHdlZW5EYXRhKTogdm9pZCB7XG4gICAgICAgIGxldCB0eXBlZFR3ZWVuID0gPFR3ZWVuRGF0YT50d2VlbjtcblxuICAgICAgICAvLyBJbml0aWFsaXplIG1lbWJlcnMgdGhhdCB3ZSBuZWVkIChhbmQgdGhlIHVzZXIgZGlkbid0IHByb3ZpZGUpXG4gICAgICAgIHR5cGVkVHdlZW4ucHJvZ3Jlc3MgPSAwO1xuICAgICAgICB0eXBlZFR3ZWVuLmVsYXBzZWRUaW1lID0gMDtcbiAgICAgICAgdHlwZWRUd2Vlbi5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlNUT1BQRUQ7XG5cbiAgICAgICAgdGhpcy50d2VlbnMuYWRkKGtleSwgdHlwZWRUd2Vlbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGxheSBhIHR3ZWVuIHdpdGggYSBjZXJ0YWluIG5hbWVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBuYW1lIG9mIHRoZSB0d2VlbiB0byBwbGF5XG4gICAgICogQHBhcmFtIGxvb3AgV2hldGhlciBvciBub3QgdGhlIHR3ZWVuIHNob3VsZCBsb29wXG4gICAgICovXG4gICAgcGxheShrZXk6IHN0cmluZywgbG9vcD86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgaWYodGhpcy50d2VlbnMuaGFzKGtleSkpe1xuICAgICAgICAgICAgbGV0IHR3ZWVuID0gdGhpcy50d2VlbnMuZ2V0KGtleSk7XG5cbiAgICAgICAgICAgIC8vIFNldCBsb29wIGlmIG5lZWRlZFxuICAgICAgICAgICAgaWYobG9vcCAhPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgICAgICB0d2Vlbi5sb29wID0gbG9vcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0IHRoZSBpbml0aWFsIHZhbHVlc1xuICAgICAgICAgICAgZm9yKGxldCBlZmZlY3Qgb2YgdHdlZW4uZWZmZWN0cyl7XG4gICAgICAgICAgICAgICAgaWYoZWZmZWN0LnJlc2V0T25Db21wbGV0ZSl7XG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdC5pbml0aWFsVmFsdWUgPSB0aGlzLm93bmVyW2VmZmVjdC5wcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdGFydCB0aGUgdHdlZW4gcnVubmluZ1xuICAgICAgICAgICAgdHdlZW4uYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5QTEFZSU5HO1xuICAgICAgICAgICAgdHdlZW4uZWxhcHNlZFRpbWUgPSAwO1xuICAgICAgICAgICAgdHdlZW4ucHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgdHdlZW4ucmV2ZXJzaW5nID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFRyaWVkIHRvIHBsYXkgdHdlZW4gXCIke2tleX1cIiBvbiBub2RlIHdpdGggaWQgJHt0aGlzLm93bmVyLmlkfSwgYnV0IG5vIHN1Y2ggdHdlZW4gZXhpc3RzYCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXVzZXMgYSBwbGF5aW5nIHR3ZWVuLiBEb2VzIG5vdCBhZmZlY3QgdHdlZW5zIHRoYXQgYXJlIHN0b3BwZWQuXG4gICAgICogQHBhcmFtIGtleSBUaGUgbmFtZSBvZiB0aGUgdHdlZW4gdG8gcGF1c2UuXG4gICAgICovXG4gICAgcGF1c2Uoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgaWYodGhpcy50d2VlbnMuaGFzKGtleSkpe1xuICAgICAgICAgICAgdGhpcy50d2VlbnMuZ2V0KGtleSkuYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5QQVVTRUQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXN1bWVzIGEgcGF1c2VkIHR3ZWVuLlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIG5hbWUgb2YgdGhlIHR3ZWVuIHRvIHJlc3VtZVxuICAgICAqL1xuICAgIHJlc3VtZShrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBpZih0aGlzLnR3ZWVucy5oYXMoa2V5KSl7XG4gICAgICAgICAgICBsZXQgdHdlZW4gPSB0aGlzLnR3ZWVucy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmKHR3ZWVuLmFuaW1hdGlvblN0YXRlID09PSBBbmltYXRpb25TdGF0ZS5QQVVTRUQpXG4gICAgICAgICAgICAgICAgdHdlZW4uYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5QTEFZSU5HO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RvcHMgYSBjdXJyZW50bHkgcGxheWluZyB0d2VlblxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgdHdlZW5cbiAgICAgKi9cbiAgICBzdG9wKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGlmKHRoaXMudHdlZW5zLmhhcyhrZXkpKXtcbiAgICAgICAgICAgIGxldCB0d2VlbiA9IHRoaXMudHdlZW5zLmdldChrZXkpO1xuICAgICAgICAgICAgdHdlZW4uYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5TVE9QUEVEO1xuXG4gICAgICAgICAgICAvLyBSZXR1cm4gdG8gdGhlIGluaXRpYWwgdmFsdWVzXG4gICAgICAgICAgICBmb3IobGV0IGVmZmVjdCBvZiB0d2Vlbi5lZmZlY3RzKXtcbiAgICAgICAgICAgICAgICBpZihlZmZlY3QucmVzZXRPbkNvbXBsZXRlKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vd25lcltlZmZlY3QucHJvcGVydHldID0gZWZmZWN0LmluaXRpYWxWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmF0dXJhbCBzdG9wIG9mIGEgY3VycmVudGx5IHBsYXlpbmcgdHdlZW5cbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHR3ZWVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGVuZChrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLnN0b3Aoa2V5KTtcbiAgICAgICAgaWYodGhpcy50d2VlbnMuaGFzKGtleSkpe1xuICAgICAgICAgICAgLy8gR2V0IHRoZSB0d2VlblxuICAgICAgICAgICAgbGV0IHR3ZWVuID0gdGhpcy50d2VlbnMuZ2V0KGtleSk7XG5cbiAgICAgICAgICAgIC8vIElmIGl0IGhhcyBhbiBvbkVuZCwgc2VuZCBhbiBldmVudFxuICAgICAgICAgICAgaWYodHdlZW4ub25FbmQpe1xuICAgICAgICAgICAgICAgIGxldCBkYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge2tleToga2V5LCBub2RlOiB0aGlzLm93bmVyLmlkfVxuICAgICAgICAgICAgICAgIC8vIElmIGl0IGhhcyBvbkVuZCBldmVudCBkYXRhLCBhZGQgZWFjaCBlbnRyeSwgYXMgbG9uZyBhcyB0aGUga2V5IGlzIG5vdCBuYW1lZCAna2V5JyBvciAnbm9kZSdcbiAgICAgICAgICAgICAgICBpZiAodHdlZW4ub25FbmREYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHR3ZWVuLm9uRW5kRGF0YSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gXCJrZXlcIiAmJiBrZXkgIT09IFwibm9kZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtrZXldID0gdHdlZW4ub25FbmREYXRhW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQodHdlZW4ub25FbmQsIGRhdGEpOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3BzIGFsbCBjdXJyZW50bHkgcGxheWluZyB0d2VlbnNcbiAgICAgKi9cbiAgICBzdG9wQWxsKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnR3ZWVucy5mb3JFYWNoKGtleSA9PiB0aGlzLnN0b3Aoa2V5KSk7XG4gICAgfVxuICAgIFxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLnR3ZWVucy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdHdlZW4gPSB0aGlzLnR3ZWVucy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmKHR3ZWVuLmFuaW1hdGlvblN0YXRlID09PSBBbmltYXRpb25TdGF0ZS5QTEFZSU5HKXtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHByb2dyZXNzIG9mIHRoZSB0d2VlblxuICAgICAgICAgICAgICAgIHR3ZWVuLmVsYXBzZWRUaW1lICs9IGRlbHRhVCoxMDAwO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgcGFzdCB0aGUgc3RhcnREZWxheSwgZG8gdGhlIHR3ZWVuXG4gICAgICAgICAgICAgICAgaWYodHdlZW4uZWxhcHNlZFRpbWUgPj0gdHdlZW4uc3RhcnREZWxheSl7XG4gICAgICAgICAgICAgICAgICAgIGlmKCF0d2Vlbi5yZXZlcnNpbmcgJiYgdHdlZW4uZWxhcHNlZFRpbWUgPj0gdHdlZW4uc3RhcnREZWxheSArIHR3ZWVuLmR1cmF0aW9uKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIG92ZXIgdGltZSwgc3RvcCB0aGUgdHdlZW4sIGxvb3AsIG9yIHJldmVyc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHR3ZWVuLnJldmVyc2VPbkNvbXBsZXRlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBvdmVyIHRpbWUgYW5kIGNhbiByZXZlcnNlLCBkbyBzb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR3ZWVuLnJldmVyc2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYodHdlZW4ubG9vcCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgY2FuJ3QgcmV2ZXJzZSBhbmQgY2FuIGxvb3AsIGRvIHNvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW4uZWxhcHNlZFRpbWUgLT0gdHdlZW4uZHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGFyZW4ndCBsb29waW5nIGFuZCBjYW4ndCByZXZlcnNlLCBzbyBzdG9wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciB0aGUgZW5kIG9mIHJldmVyc2luZ1xuICAgICAgICAgICAgICAgICAgICBpZih0d2Vlbi5yZXZlcnNpbmcgJiYgdHdlZW4uZWxhcHNlZFRpbWUgPj0gdHdlZW4uc3RhcnREZWxheSArIDIqdHdlZW4uZHVyYXRpb24pe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodHdlZW4ubG9vcCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW4ucmV2ZXJzaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW4uZWxhcHNlZFRpbWUgLT0gMip0d2Vlbi5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJvZ3Jlc3MsIG1ha2Ugc3VyZSBpdCBpcyBiZXR3ZWVuIDAgYW5kIDEuIEVycm9ycyBmcm9tIHRoaXMgc2hvdWxkIG5ldmVyIGJlIGxhcmdlXG4gICAgICAgICAgICAgICAgICAgIGlmKHR3ZWVuLnJldmVyc2luZyl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0d2Vlbi5wcm9ncmVzcyA9IE1hdGhVdGlscy5jbGFtcDAxKCgyKnR3ZWVuLmR1cmF0aW9uIC0gKHR3ZWVuLmVsYXBzZWRUaW1lLSB0d2Vlbi5zdGFydERlbGF5KSkvdHdlZW4uZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW4ucHJvZ3Jlc3MgPSBNYXRoVXRpbHMuY2xhbXAwMSgodHdlZW4uZWxhcHNlZFRpbWUgLSB0d2Vlbi5zdGFydERlbGF5KS90d2Vlbi5kdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGVmZmVjdCBvZiB0d2Vlbi5lZmZlY3RzKXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBlYXNlIGZ1bmN0aW9uIHRoYXQgY29ycmVzcG9uZHMgdG8gb3VyIHByb2dyZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWFzZSA9IEVhc2VGdW5jdGlvbnNbZWZmZWN0LmVhc2VdKHR3ZWVuLnByb2dyZXNzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSB2YWx1ZSB0byBsZXJwIHRoZSBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gTWF0aFV0aWxzLmxlcnAoZWZmZWN0LnN0YXJ0LCBlZmZlY3QuZW5kLCBlYXNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXNzaWduIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3duZXJbZWZmZWN0LnByb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59IiwiaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcbmltcG9ydCBUd2VlbkNvbnRyb2xsZXIgZnJvbSBcIi4vVHdlZW5Db250cm9sbGVyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFR3ZWVuTWFuYWdlciBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xuXG4gICAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IFR3ZWVuTWFuYWdlciA9IG51bGw7XG4gICAgXG4gICAgcHJvdGVjdGVkIHR3ZWVuQ29udHJvbGxlcnM6IEFycmF5PFR3ZWVuQ29udHJvbGxlcj47XG5cbiAgICBwcml2YXRlIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMudHdlZW5Db250cm9sbGVycyA9IG5ldyBBcnJheSgpO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBUd2Vlbk1hbmFnZXIge1xuICAgICAgICBpZihUd2Vlbk1hbmFnZXIuaW5zdGFuY2UgPT09IG51bGwpe1xuICAgICAgICAgICAgVHdlZW5NYW5hZ2VyLmluc3RhbmNlID0gbmV3IFR3ZWVuTWFuYWdlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFR3ZWVuTWFuYWdlci5pbnN0YW5jZTtcbiAgICB9XG5cbiAgICByZWdpc3RlclR3ZWVuQ29udHJvbGxlcihjb250cm9sbGVyOiBUd2VlbkNvbnRyb2xsZXIpe1xuICAgICAgICB0aGlzLnR3ZWVuQ29udHJvbGxlcnMucHVzaChjb250cm9sbGVyKTtcbiAgICB9XG5cbiAgICBkZXJlZ2lzdGVyVHdlZW5Db250cm9sbGVyKGNvbnRyb2xsZXI6IFR3ZWVuQ29udHJvbGxlcil7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMudHdlZW5Db250cm9sbGVycy5pbmRleE9mKGNvbnRyb2xsZXIpO1xuICAgICAgICB0aGlzLnR3ZWVuQ29udHJvbGxlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG5cbiAgICBjbGVhclR3ZWVuQ29udHJvbGxlcnMoKXtcbiAgICAgICAgdGhpcy50d2VlbkNvbnRyb2xsZXJzID0gbmV3IEFycmF5KCk7XG4gICAgfVxuXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGZvcihsZXQgdHdlZW5Db250cm9sbGVyIG9mIHRoaXMudHdlZW5Db250cm9sbGVycyl7XG4gICAgICAgICAgICB0d2VlbkNvbnRyb2xsZXIudXBkYXRlKGRlbHRhVCk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL0NvbGxlY3Rpb25zL01hcFwiO1xuaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uL05vZGVzL0NhbnZhc05vZGVcIjtcbmltcG9ydCBHcmFwaGljIGZyb20gXCIuLi9Ob2Rlcy9HcmFwaGljXCI7XG5pbXBvcnQgUG9pbnQgZnJvbSBcIi4uL05vZGVzL0dyYXBoaWNzL1BvaW50XCI7XG5pbXBvcnQgUmVjdCBmcm9tIFwiLi4vTm9kZXMvR3JhcGhpY3MvUmVjdFwiO1xuaW1wb3J0IFNwcml0ZSBmcm9tIFwiLi4vTm9kZXMvU3ByaXRlcy9TcHJpdGVcIjtcbmltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwXCI7XG5pbXBvcnQgT3J0aG9nb25hbFRpbGVtYXAgZnJvbSBcIi4uL05vZGVzL1RpbGVtYXBzL09ydGhvZ29uYWxUaWxlbWFwXCI7XG5pbXBvcnQgVUlFbGVtZW50IGZyb20gXCIuLi9Ob2Rlcy9VSUVsZW1lbnRcIjtcbmltcG9ydCBVSUxheWVyIGZyb20gXCIuLi9TY2VuZS9MYXllcnMvVUlMYXllclwiO1xuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZS9TY2VuZVwiO1xuaW1wb3J0IEdyYXBoaWNSZW5kZXJlciBmcm9tIFwiLi9DYW52YXNSZW5kZXJpbmcvR3JhcGhpY1JlbmRlcmVyXCI7XG5pbXBvcnQgUmVuZGVyaW5nTWFuYWdlciBmcm9tIFwiLi9SZW5kZXJpbmdNYW5hZ2VyXCJcbmltcG9ydCBUaWxlbWFwUmVuZGVyZXIgZnJvbSBcIi4vQ2FudmFzUmVuZGVyaW5nL1RpbGVtYXBSZW5kZXJlclwiO1xuaW1wb3J0IFVJRWxlbWVudFJlbmRlcmVyIGZyb20gXCIuL0NhbnZhc1JlbmRlcmluZy9VSUVsZW1lbnRSZW5kZXJlclwiO1xuaW1wb3J0IExhYmVsIGZyb20gXCIuLi9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsXCI7XG5pbXBvcnQgQnV0dG9uIGZyb20gXCIuLi9Ob2Rlcy9VSUVsZW1lbnRzL0J1dHRvblwiO1xuaW1wb3J0IFNsaWRlciBmcm9tIFwiLi4vTm9kZXMvVUlFbGVtZW50cy9TbGlkZXJcIjtcbmltcG9ydCBUZXh0SW5wdXQgZnJvbSBcIi4uL05vZGVzL1VJRWxlbWVudHMvVGV4dElucHV0XCI7XG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi9VdGlscy9Db2xvclwiO1xuaW1wb3J0IExpbmUgZnJvbSBcIi4uL05vZGVzL0dyYXBoaWNzL0xpbmVcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vRGVidWcvRGVidWdcIjtcbmltcG9ydCBJc29tZXRyaWNUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwcy9Jc29tZXRyaWNUaWxlbWFwXCI7XG5pbXBvcnQgU3RhZ2dlcmVkSXNvbWV0cmljVGlsZW1hcCBmcm9tIFwiLi4vTm9kZXMvVGlsZW1hcHMvU3RhZ2dlcmVkSXNvbWV0cmljVGlsZW1hcFwiO1xuXG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBSZW5kZXJpbmdNYW5hZ2VyIGNsYXNzIHVzaW5nIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FudmFzUmVuZGVyZXIgZXh0ZW5kcyBSZW5kZXJpbmdNYW5hZ2VyIHtcbiAgICBwcm90ZWN0ZWQgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XG4gICAgcHJvdGVjdGVkIGdyYXBoaWNSZW5kZXJlcjogR3JhcGhpY1JlbmRlcmVyO1xuICAgIHByb3RlY3RlZCB0aWxlbWFwUmVuZGVyZXI6IFRpbGVtYXBSZW5kZXJlcjtcbiAgICBwcm90ZWN0ZWQgdWlFbGVtZW50UmVuZGVyZXI6IFVJRWxlbWVudFJlbmRlcmVyO1xuXG4gICAgcHJvdGVjdGVkIG9yaWdpbjogVmVjMjtcbiAgICBwcm90ZWN0ZWQgem9vbTogbnVtYmVyO1xuXG4gICAgcHJvdGVjdGVkIHdvcmxkU2l6ZTogVmVjMjtcblxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgc2V0U2NlbmUoc2NlbmU6IFNjZW5lKXtcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgICAgICB0aGlzLmdyYXBoaWNSZW5kZXJlci5zZXRTY2VuZShzY2VuZSk7XG4gICAgICAgIHRoaXMudGlsZW1hcFJlbmRlcmVyLnNldFNjZW5lKHNjZW5lKTtcbiAgICAgICAgdGhpcy51aUVsZW1lbnRSZW5kZXJlci5zZXRTY2VuZShzY2VuZSk7XG4gICAgfVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgaW5pdGlhbGl6ZUNhbnZhcyhjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIHRoaXMud29ybGRTaXplID0gbmV3IFZlYzIod2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgdGhpcy5jdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG4gICAgICAgIHRoaXMuZ3JhcGhpY1JlbmRlcmVyID0gbmV3IEdyYXBoaWNSZW5kZXJlcih0aGlzLmN0eCk7XG4gICAgICAgIHRoaXMudGlsZW1hcFJlbmRlcmVyID0gbmV3IFRpbGVtYXBSZW5kZXJlcih0aGlzLmN0eCk7XG4gICAgICAgIHRoaXMudWlFbGVtZW50UmVuZGVyZXIgPSBuZXcgVUlFbGVtZW50UmVuZGVyZXIodGhpcy5jdHgpXG5cbiAgICAgICAgLy8gRm9yIGNyaXNwIHBpeGVsIGFydFxuICAgICAgICB0aGlzLmN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcblxuICAgICAgICByZXR1cm4gdGhpcy5jdHg7XG4gICAgfVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgcmVuZGVyKHZpc2libGVTZXQ6IENhbnZhc05vZGVbXSwgdGlsZW1hcHM6IFRpbGVtYXBbXSwgdWlMYXllcnM6IE1hcDxVSUxheWVyPik6IHZvaWQge1xuICAgICAgICAvLyBTb3J0IGJ5IGRlcHRoLCB0aGVuIGJ5IHZpc2libGUgc2V0IGJ5IHktdmFsdWVcbiAgICAgICAgdmlzaWJsZVNldC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICBpZihhLmdldExheWVyKCkuZ2V0RGVwdGgoKSA9PT0gYi5nZXRMYXllcigpLmdldERlcHRoKCkpe1xuICAgICAgICAgICAgICAgIHJldHVybiAoYS5ib3VuZGFyeS5ib3R0b20pIC0gKGIuYm91bmRhcnkuYm90dG9tKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuZ2V0TGF5ZXIoKS5nZXREZXB0aCgpIC0gYi5nZXRMYXllcigpLmdldERlcHRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxldCB0aWxlbWFwSW5kZXggPSAwO1xuICAgICAgICBsZXQgdGlsZW1hcExlbmd0aCA9IHRpbGVtYXBzLmxlbmd0aDtcblxuICAgICAgICBsZXQgdmlzaWJsZVNldEluZGV4ID0gMDtcbiAgICAgICAgbGV0IHZpc2libGVTZXRMZW5ndGggPSB2aXNpYmxlU2V0Lmxlbmd0aDtcblxuICAgICAgICB3aGlsZSh0aWxlbWFwSW5kZXggPCB0aWxlbWFwTGVuZ3RoIHx8IHZpc2libGVTZXRJbmRleCA8IHZpc2libGVTZXRMZW5ndGgpe1xuICAgICAgICAgICAgLy8gQ2hlY2sgY29uZGl0aW9ucyB3aGVyZSB3ZSd2ZSBhbHJlYWR5IHJlYWNoZWQgdGhlIGVkZ2Ugb2Ygb25lIGxpc3RcbiAgICAgICAgICAgIGlmKHRpbGVtYXBJbmRleCA+PSB0aWxlbWFwTGVuZ3RoKXtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHJlbmRlciB0aGUgcmVtYWluaW5nIHZpc2libGUgc2V0XG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSB2aXNpYmxlU2V0W3Zpc2libGVTZXRJbmRleCsrXTtcbiAgICAgICAgICAgICAgICBpZihub2RlLnZpc2libGUpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlck5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih2aXNpYmxlU2V0SW5kZXggPj0gdmlzaWJsZVNldExlbmd0aCl7XG4gICAgICAgICAgICAgICAgLy8gT25seSByZW5kZXIgdGlsZW1hcHNcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclRpbGVtYXAodGlsZW1hcHNbdGlsZW1hcEluZGV4KytdKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVuZGVyIHdoaWNoZXZlciBpcyBmdXJ0aGVyIGRvd25cbiAgICAgICAgICAgIGlmKHRpbGVtYXBzW3RpbGVtYXBJbmRleF0uZ2V0TGF5ZXIoKS5nZXREZXB0aCgpIDw9IHZpc2libGVTZXRbdmlzaWJsZVNldEluZGV4XS5nZXRMYXllcigpLmdldERlcHRoKCkpe1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVGlsZW1hcCh0aWxlbWFwc1t0aWxlbWFwSW5kZXgrK10pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IHZpc2libGVTZXRbdmlzaWJsZVNldEluZGV4KytdO1xuICAgICAgICAgICAgICAgIGlmKG5vZGUudmlzaWJsZSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW5kZXIgdGhlIHVpTGF5ZXJzIG9uIHRvcCBvZiBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgbGV0IHNvcnRlZFVJTGF5ZXJzID0gbmV3IEFycmF5PFVJTGF5ZXI+KCk7XG5cbiAgICAgICAgdWlMYXllcnMuZm9yRWFjaChrZXkgPT4gc29ydGVkVUlMYXllcnMucHVzaCh1aUxheWVycy5nZXQoa2V5KSkpO1xuXG4gICAgICAgIHNvcnRlZFVJTGF5ZXJzID0gc29ydGVkVUlMYXllcnMuc29ydCgodWkxLCB1aTIpID0+IHVpMS5nZXREZXB0aCgpIC0gdWkyLmdldERlcHRoKCkpO1xuXG4gICAgICAgIHNvcnRlZFVJTGF5ZXJzLmZvckVhY2godWlMYXllciA9PiB7XG5cdFx0XHRpZighdWlMYXllci5pc0hpZGRlbigpKVxuXHRcdFx0XHR1aUxheWVyLmdldEl0ZW1zKCkuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYoKDxDYW52YXNOb2RlPm5vZGUpLnZpc2libGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJOb2RlKDxDYW52YXNOb2RlPm5vZGUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuXHRcdH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYSBzcGVjaWZpZWQgQ2FudmFzTm9kZVxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBDYW52YXNOb2RlIHRvIHJlbmRlclxuICAgICAqL1xuICAgIHByb3RlY3RlZCByZW5kZXJOb2RlKG5vZGU6IENhbnZhc05vZGUpOiB2b2lkIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBvcmlnaW4gb2YgdGhlIHZpZXdwb3J0IGFjY29yZGluZyB0byB0aGlzIHNwcml0ZVxuICAgICAgICB0aGlzLm9yaWdpbiA9IHRoaXMuc2NlbmUuZ2V0Vmlld1RyYW5zbGF0aW9uKG5vZGUpO1xuXG4gICAgICAgIC8vIEdldCB0aGUgem9vbSBsZXZlbCBvZiB0aGUgc2NlbmVcbiAgICAgICAgdGhpcy56b29tID0gdGhpcy5zY2VuZS5nZXRWaWV3U2NhbGUoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIE1vdmUgdGhlIGNhbnZhcyB0byB0aGUgcG9zaXRpb24gb2YgdGhlIG5vZGUgYW5kIHJvdGF0ZVxuICAgICAgICBsZXQgeFNjYWxlID0gMTtcbiAgICAgICAgbGV0IHlTY2FsZSA9IDE7XG4gICAgICAgIFxuICAgICAgICBpZihub2RlIGluc3RhbmNlb2YgU3ByaXRlKXtcbiAgICAgICAgICAgIHhTY2FsZSA9IG5vZGUuaW52ZXJ0WCA/IC0xIDogMTtcbiAgICAgICAgICAgIHlTY2FsZSA9IG5vZGUuaW52ZXJ0WSA/IC0xIDogMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSh4U2NhbGUsIDAsIDAsIHlTY2FsZSwgKG5vZGUucG9zaXRpb24ueCAtIHRoaXMub3JpZ2luLngpKnRoaXMuem9vbSwgKG5vZGUucG9zaXRpb24ueSAtIHRoaXMub3JpZ2luLnkpKnRoaXMuem9vbSk7XG4gICAgICAgIHRoaXMuY3R4LnJvdGF0ZSgtbm9kZS5yb3RhdGlvbik7XG4gICAgICAgIGxldCBnbG9iYWxBbHBoYSA9IHRoaXMuY3R4Lmdsb2JhbEFscGhhO1xuICAgICAgICBpZihub2RlIGluc3RhbmNlb2YgUmVjdCl7XG4gICAgICAgICAgICBEZWJ1Zy5sb2coXCJub2RlXCIgKyBub2RlLmlkLCBcIk5vZGVcIiArIG5vZGUuaWQgKyBcIiBBbHBoYTogXCIgKyBub2RlLmFscGhhKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IG5vZGUuYWxwaGE7XG4gICAgICAgIFxuICAgICAgICBpZihub2RlIGluc3RhbmNlb2YgQW5pbWF0ZWRTcHJpdGUpe1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJBbmltYXRlZFNwcml0ZSg8QW5pbWF0ZWRTcHJpdGU+bm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZihub2RlIGluc3RhbmNlb2YgU3ByaXRlKXtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyU3ByaXRlKDxTcHJpdGU+bm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZihub2RlIGluc3RhbmNlb2YgR3JhcGhpYyl7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckdyYXBoaWMoPEdyYXBoaWM+bm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZihub2RlIGluc3RhbmNlb2YgVUlFbGVtZW50KXtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyVUlFbGVtZW50KDxVSUVsZW1lbnQ+bm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IGdsb2JhbEFscGhhO1xuICAgICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgfVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgcHJvdGVjdGVkIHJlbmRlclNwcml0ZShzcHJpdGU6IFNwcml0ZSk6IHZvaWQge1xuICAgICAgICAvLyBHZXQgdGhlIGltYWdlIGZyb20gdGhlIHJlc291cmNlIG1hbmFnZXJcbiAgICAgICAgbGV0IGltYWdlID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0SW1hZ2Uoc3ByaXRlLmltYWdlSWQpO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAgICBDb29yZGluYXRlcyBpbiB0aGUgc3BhY2Ugb2YgdGhlIGltYWdlOlxuICAgICAgICAgICAgICAgIGltYWdlIGNyb3Agc3RhcnQgLT4geCwgeVxuICAgICAgICAgICAgICAgIGltYWdlIGNyb3Agc2l6ZSAgLT4gdywgaFxuICAgICAgICAgICAgQ29vcmRpbmF0ZXMgaW4gdGhlIHNwYWNlIG9mIHRoZSB3b3JsZFxuICAgICAgICAgICAgICAgIGltYWdlIGRyYXcgc3RhcnQgLT4geCwgeVxuICAgICAgICAgICAgICAgIGltYWdlIGRyYXcgc2l6ZSAgLT4gdywgaFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoaW1hZ2UsXG4gICAgICAgICAgICBzcHJpdGUuaW1hZ2VPZmZzZXQueCwgc3ByaXRlLmltYWdlT2Zmc2V0LnksXG4gICAgICAgICAgICBzcHJpdGUuc2l6ZS54LCBzcHJpdGUuc2l6ZS55LFxuICAgICAgICAgICAgKC1zcHJpdGUuc2l6ZS54KnNwcml0ZS5zY2FsZS54LzIpKnRoaXMuem9vbSwgKC1zcHJpdGUuc2l6ZS55KnNwcml0ZS5zY2FsZS55LzIpKnRoaXMuem9vbSxcbiAgICAgICAgICAgIHNwcml0ZS5zaXplLnggKiBzcHJpdGUuc2NhbGUueCp0aGlzLnpvb20sIHNwcml0ZS5zaXplLnkgKiBzcHJpdGUuc2NhbGUueSp0aGlzLnpvb20pO1xuICAgIH1cblxuICAgIC8vIEBvdmVycmlkZVxuICAgIHByb3RlY3RlZCByZW5kZXJBbmltYXRlZFNwcml0ZShzcHJpdGU6IEFuaW1hdGVkU3ByaXRlKTogdm9pZCB7XG4gICAgICAgIC8vIEdldCB0aGUgaW1hZ2UgZnJvbSB0aGUgcmVzb3VyY2UgbWFuYWdlclxuICAgICAgICBsZXQgaW1hZ2UgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRJbWFnZShzcHJpdGUuaW1hZ2VJZCk7XG5cbiAgICAgICAgbGV0IGFuaW1hdGlvbkluZGV4ID0gc3ByaXRlLmFuaW1hdGlvbi5nZXRJbmRleEFuZEFkdmFuY2VBbmltYXRpb24oKTtcblxuICAgICAgICBsZXQgYW5pbWF0aW9uT2Zmc2V0ID0gc3ByaXRlLmdldEFuaW1hdGlvbk9mZnNldChhbmltYXRpb25JbmRleCk7XG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIENvb3JkaW5hdGVzIGluIHRoZSBzcGFjZSBvZiB0aGUgaW1hZ2U6XG4gICAgICAgICAgICAgICAgaW1hZ2UgY3JvcCBzdGFydCAtPiB4LCB5XG4gICAgICAgICAgICAgICAgaW1hZ2UgY3JvcCBzaXplICAtPiB3LCBoXG4gICAgICAgICAgICBDb29yZGluYXRlcyBpbiB0aGUgc3BhY2Ugb2YgdGhlIHdvcmxkIChnaXZlbiB3ZSBtb3ZlZClcbiAgICAgICAgICAgICAgICBpbWFnZSBkcmF3IHN0YXJ0IC0+IC13LzIsIC1oLzJcbiAgICAgICAgICAgICAgICBpbWFnZSBkcmF3IHNpemUgIC0+IHcsIGhcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKGltYWdlLFxuICAgICAgICAgICAgc3ByaXRlLmltYWdlT2Zmc2V0LnggKyBhbmltYXRpb25PZmZzZXQueCwgc3ByaXRlLmltYWdlT2Zmc2V0LnkgKyBhbmltYXRpb25PZmZzZXQueSxcbiAgICAgICAgICAgIHNwcml0ZS5zaXplLngsIHNwcml0ZS5zaXplLnksXG4gICAgICAgICAgICAoLXNwcml0ZS5zaXplLngqc3ByaXRlLnNjYWxlLngvMikqdGhpcy56b29tLCAoLXNwcml0ZS5zaXplLnkqc3ByaXRlLnNjYWxlLnkvMikqdGhpcy56b29tLFxuICAgICAgICAgICAgc3ByaXRlLnNpemUueCAqIHNwcml0ZS5zY2FsZS54KnRoaXMuem9vbSwgc3ByaXRlLnNpemUueSAqIHNwcml0ZS5zY2FsZS55KnRoaXMuem9vbSk7XG4gICAgfVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgcHJvdGVjdGVkIHJlbmRlckdyYXBoaWMoZ3JhcGhpYzogR3JhcGhpYyk6IHZvaWQge1xuICAgICAgICBpZihncmFwaGljIGluc3RhbmNlb2YgUG9pbnQpe1xuICAgICAgICAgICAgdGhpcy5ncmFwaGljUmVuZGVyZXIucmVuZGVyUG9pbnQoPFBvaW50PmdyYXBoaWMsIHRoaXMuem9vbSk7XG4gICAgICAgIH0gZWxzZSBpZihncmFwaGljIGluc3RhbmNlb2YgTGluZSl7XG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNSZW5kZXJlci5yZW5kZXJMaW5lKDxMaW5lPmdyYXBoaWMsIHRoaXMub3JpZ2luLCB0aGlzLnpvb20pO1xuICAgICAgICB9IGVsc2UgaWYoZ3JhcGhpYyBpbnN0YW5jZW9mIFJlY3Qpe1xuICAgICAgICAgICAgdGhpcy5ncmFwaGljUmVuZGVyZXIucmVuZGVyUmVjdCg8UmVjdD5ncmFwaGljLCB0aGlzLnpvb20pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgcHJvdGVjdGVkIHJlbmRlclRpbGVtYXAodGlsZW1hcDogVGlsZW1hcCk6IHZvaWQge1xuICAgICAgICB0aGlzLnRpbGVtYXBSZW5kZXJlci5yZW5kZXJUaWxlbWFwKHRpbGVtYXApO1xuICAgICAgICBcbiAgICB9XG5cbiAgICAvLyBAb3ZlcnJpZGVcbiAgICBwcm90ZWN0ZWQgcmVuZGVyVUlFbGVtZW50KHVpRWxlbWVudDogVUlFbGVtZW50KTogdm9pZCB7XG4gICAgICAgIGlmKHVpRWxlbWVudCBpbnN0YW5jZW9mIExhYmVsKXtcbiAgICAgICAgICAgIHRoaXMudWlFbGVtZW50UmVuZGVyZXIucmVuZGVyTGFiZWwodWlFbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIGlmKHVpRWxlbWVudCBpbnN0YW5jZW9mIEJ1dHRvbil7XG4gICAgICAgICAgICB0aGlzLnVpRWxlbWVudFJlbmRlcmVyLnJlbmRlckJ1dHRvbih1aUVsZW1lbnQpO1xuICAgICAgICB9IGVsc2UgaWYodWlFbGVtZW50IGluc3RhbmNlb2YgU2xpZGVyKXtcbiAgICAgICAgICAgIHRoaXMudWlFbGVtZW50UmVuZGVyZXIucmVuZGVyU2xpZGVyKHVpRWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSBpZih1aUVsZW1lbnQgaW5zdGFuY2VvZiBUZXh0SW5wdXQpe1xuICAgICAgICAgICAgdGhpcy51aUVsZW1lbnRSZW5kZXJlci5yZW5kZXJUZXh0SW5wdXQodWlFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsZWFyKGNsZWFyQ29sb3I6IENvbG9yKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndvcmxkU2l6ZS54LCB0aGlzLndvcmxkU2l6ZS55KTtcbiAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gY2xlYXJDb2xvci50b1N0cmluZygpO1xuICAgICAgICB0aGlzLmN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLndvcmxkU2l6ZS54LCB0aGlzLndvcmxkU2l6ZS55KTtcbiAgICB9XG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgTGluZSBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY3MvTGluZVwiO1xuaW1wb3J0IFBvaW50IGZyb20gXCIuLi8uLi9Ob2Rlcy9HcmFwaGljcy9Qb2ludFwiO1xuaW1wb3J0IFJlY3QgZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL1JlY3RcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vLi4vU2NlbmUvU2NlbmVcIjtcblxuLyoqXG4gKiBBIHV0aWxpdHkgY2xhc3MgdG8gaGVscCB0aGUgQHJlZmVyZW5jZVtDYW52YXNSZW5kZXJlcl0gcmVuZGVyIEByZWZlcmVuY2VbR3JhcGhpY11zXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyYXBoaWNSZW5kZXJlciB7XG4gICAgLyoqIFRoZSByZXNvdXJjZSBtYW5hZ2VyIG9mIHRoZSBnYW1lIGVuZ2luZSAqL1xuICAgIHByb3RlY3RlZCByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcbiAgICAvKiogVGhlIGN1cnJlbnQgc2NlbmUgKi9cbiAgICBwcm90ZWN0ZWQgc2NlbmU6IFNjZW5lO1xuICAgIC8qKiBUaGUgcmVuZGVyaW5nIGNvbnRleHQgKi9cbiAgICBwcm90ZWN0ZWQgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XG5cbiAgICBjb25zdHJ1Y3RvcihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCl7XG4gICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNjZW5lIG9mIHRoaXMgR3JhcGhpY1JlbmRlcmVyXG4gICAgICogQHBhcmFtIHNjZW5lIFRoZSBjdXJyZW50IHNjZW5lXG4gICAgICovXG4gICAgc2V0U2NlbmUoc2NlbmU6IFNjZW5lKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgcG9pbnRcbiAgICAgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IHRvIHJlbmRlclxuICAgICAqIEBwYXJhbSB6b29tIFRoZSB6b29tIGxldmVsXG4gICAgICovXG4gICAgcmVuZGVyUG9pbnQocG9pbnQ6IFBvaW50LCB6b29tOiBudW1iZXIpOiB2b2lkIHtcblx0XHR0aGlzLmN0eC5maWxsU3R5bGUgPSBwb2ludC5jb2xvci50b1N0cmluZ1JHQkEoKTtcbiAgICAgICAgdGhpcy5jdHguZmlsbFJlY3QoKC1wb2ludC5zaXplLngvMikqem9vbSwgKC1wb2ludC5zaXplLnkvMikqem9vbSxcbiAgICAgICAgcG9pbnQuc2l6ZS54Knpvb20sIHBvaW50LnNpemUueSp6b29tKTtcbiAgICB9XG5cbiAgICByZW5kZXJMaW5lKGxpbmU6IExpbmUsIG9yaWdpbjogVmVjMiwgem9vbTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gbGluZS5jb2xvci50b1N0cmluZ1JHQkEoKTtcbiAgICAgICAgdGhpcy5jdHgubGluZVdpZHRoID0gbGluZS50aGlja25lc3M7XG4gICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLmN0eC5tb3ZlVG8oMCwgMCk7XG4gICAgICAgIHRoaXMuY3R4LmxpbmVUbygobGluZS5lbmQueCAtIGxpbmUuc3RhcnQueCkqem9vbSwgKGxpbmUuZW5kLnkgLSBsaW5lLnN0YXJ0LnkpKnpvb20pO1xuICAgICAgICB0aGlzLmN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIHJlY3RcbiAgICAgKiBAcGFyYW0gcmVjdCBUaGUgcmVjdCB0byByZW5kZXJcbiAgICAgKiBAcGFyYW0gem9vbSBUaGUgem9vbSBsZXZlbFxuICAgICAqL1xuICAgIHJlbmRlclJlY3QocmVjdDogUmVjdCwgem9vbTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIC8vIERyYXcgdGhlIGludGVyaW9yIG9mIHRoZSByZWN0XG4gICAgICAgIGlmKHJlY3QuY29sb3IuYSAhPT0gMCl7XG4gICAgICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSByZWN0LmNvbG9yLnRvU3RyaW5nUkdCKCk7XG4gICAgICAgICAgICB0aGlzLmN0eC5maWxsUmVjdCgoLXJlY3Quc2l6ZS54LzIpKnpvb20sICgtcmVjdC5zaXplLnkvMikqem9vbSwgcmVjdC5zaXplLngqem9vbSwgcmVjdC5zaXplLnkqem9vbSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEcmF3IHRoZSBib3JkZXIgb2YgdGhlIHJlY3QgaWYgaXQgaXNuJ3QgdHJhbnNwYXJlbnRcbiAgICAgICAgaWYocmVjdC5ib3JkZXJDb2xvci5hICE9PSAwKXtcbiAgICAgICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gcmVjdC5nZXRCb3JkZXJDb2xvcigpLnRvU3RyaW5nUkdCKCk7XG4gICAgICAgICAgICB0aGlzLmN0eC5saW5lV2lkdGggPSByZWN0LmdldEJvcmRlcldpZHRoKCk7XG4gICAgICAgICAgICB0aGlzLmN0eC5zdHJva2VSZWN0KCgtcmVjdC5zaXplLngvMikqem9vbSwgKC1yZWN0LnNpemUueS8yKSp6b29tLCByZWN0LnNpemUueCp6b29tLCByZWN0LnNpemUueSp6b29tKTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uLy4uL1NjZW5lL1NjZW5lXCI7XG5pbXBvcnQgT3J0aG9nb25hbFRpbGVtYXAgZnJvbSBcIi4uLy4uL05vZGVzL1RpbGVtYXBzL09ydGhvZ29uYWxUaWxlbWFwXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBUaWxlc2V0IGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVGlsZXNldHMvVGlsZXNldFwiO1xuaW1wb3J0IFRpbGVtYXAgZnJvbSBcIi4uLy4uL05vZGVzL1RpbGVtYXBcIjtcbmltcG9ydCBJc29tZXRyaWNUaWxlbWFwIGZyb20gXCIuLi8uLi9Ob2Rlcy9UaWxlbWFwcy9Jc29tZXRyaWNUaWxlbWFwXCI7XG5pbXBvcnQgU3RhZ2dlcmVkSXNvbWV0cmljVGlsZW1hcCBmcm9tIFwiLi4vLi4vTm9kZXMvVGlsZW1hcHMvU3RhZ2dlcmVkSXNvbWV0cmljVGlsZW1hcFwiO1xuXG4vKipcbiAqIEEgdXRpbGl0eSBjbGFzcyBmb3IgdGhlIEByZWZlcmVuY2VbQ2FudmFzUmVuZGVyZXJdIHRvIHJlbmRlciBAcmVmZXJlbmNlW1RpbGVtYXBdc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaWxlbWFwUmVuZGVyZXIge1xuICAgIHByb3RlY3RlZCByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcbiAgICBwcm90ZWN0ZWQgc2NlbmU6IFNjZW5lO1xuICAgIHByb3RlY3RlZCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcblxuICAgIGNvbnN0cnVjdG9yKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKXtcbiAgICAgICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgdGhpcy5jdHggPSBjdHg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2NlbmUgb2YgdGhpcyBUaWxlbWFwUmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gc2NlbmUgVGhlIGN1cnJlbnQgc2NlbmVcbiAgICAgKi9cbiAgICBzZXRTY2VuZShzY2VuZTogU2NlbmUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYW4gb3J0aG9nb25hbCB0aWxlbWFwXG4gICAgICogQHBhcmFtIHRpbGVtYXAgVGhlIHRpbGVtYXAgdG8gcmVuZGVyXG4gICAgICovXG4gICAgcmVuZGVyVGlsZW1hcCh0aWxlbWFwOiBUaWxlbWFwKTogdm9pZCB7XG4gICAgICAgIGxldCBwcmV2aW91c0FscGhhID0gdGhpcy5jdHguZ2xvYmFsQWxwaGE7XG4gICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gdGlsZW1hcC5nZXRMYXllcigpLmdldEFscGhhKCk7XG4gICAgICAgIFxuICAgICAgICBsZXQgb3JpZ2luID0gdGhpcy5zY2VuZS5nZXRWaWV3VHJhbnNsYXRpb24odGlsZW1hcCk7XG4gICAgICAgIGxldCBzaXplID0gdGhpcy5zY2VuZS5nZXRWaWV3cG9ydCgpLmdldEhhbGZTaXplKCk7XG4gICAgICAgIGxldCB6b29tID0gdGhpcy5zY2VuZS5nZXRWaWV3U2NhbGUoKTtcbiAgICAgICAgbGV0IGJvdHRvbVJpZ2h0ID0gb3JpZ2luLmNsb25lKCkuYWRkKHNpemUuc2NhbGVkKDIqem9vbSkpO1xuXG4gICAgICAgIGlmKHRpbGVtYXAudmlzaWJsZSl7XG4gICAgICAgICAgICBsZXQgbWluQ29sUm93ID0gdGlsZW1hcC5nZXRNaW5Db2xSb3codGhpcy5zY2VuZS5nZXRWaWV3cG9ydCgpLmdldFZpZXcoKSk7XG4gICAgICAgICAgICBsZXQgbWF4Q29sUm93ID0gdGlsZW1hcC5nZXRNYXhDb2xSb3codGhpcy5zY2VuZS5nZXRWaWV3cG9ydCgpLmdldFZpZXcoKSk7XG4gICAgICAgICAgICBmb3IobGV0IHJvdyA9IG1pbkNvbFJvdy55OyByb3cgPD0gbWF4Q29sUm93Lnk7IHJvdysrKXtcbiAgICAgICAgICAgICAgICBmb3IobGV0IGNvbCA9IG1pbkNvbFJvdy54OyBjb2wgPD0gbWF4Q29sUm93Lng7IGNvbCsrKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB0aWxlIGF0IHRoaXMgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgbGV0IHRpbGUgPSB0aWxlbWFwLmdldFRpbGUoY29sLCByb3cpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIHJvdC9mbGlwIHBhcmFtZXRlcnMgaWYgdGhlcmUgYXJlIGFueVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXNrID0gKDB4RSA8PCAyOCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdEZsaXAgPSAoKG1hc2sgJiB0aWxlKSA+PiAyOCkgJiAweEY7XG4gICAgICAgICAgICAgICAgICAgIHRpbGUgPSB0aWxlICYgfm1hc2s7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgdGlsZXNldCB0aGF0IG93bnMgdGhpcyB0aWxlIGluZGV4IGFuZCByZW5kZXJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCB0aWxlc2V0IG9mIHRpbGVtYXAuZ2V0VGlsZXNldHMoKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0aWxlc2V0Lmhhc1RpbGUodGlsZSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVGlsZSh0aWxlbWFwLCB0aWxlc2V0LCB0aWxlLCBjb2wsIHJvdywgb3JpZ2luLCB0aWxlbWFwLnNjYWxlLCB6b29tLCByb3RGbGlwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gcHJldmlvdXNBbHBoYTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgdGlsZVxuICAgICAqIEBwYXJhbSB0aWxlc2V0IFRoZSB0aWxlc2V0IHRoaXMgdGlsZSBiZWxvbmdzIHRvIFxuICAgICAqIEBwYXJhbSB0aWxlSW5kZXggVGhlIGluZGV4IG9mIHRoZSB0aWxlXG4gICAgICogQHBhcmFtIHRpbGVtYXBSb3cgVGhlIHJvdyBvZiB0aGUgdGlsZSBpbiB0aGUgdGlsZW1hcFxuICAgICAqIEBwYXJhbSB0aWxlbWFwQ29sIFRoZSBjb2x1bW4gb2YgdGhlIHRpbGUgaW4gdGhlIHRpbGVtYXBcbiAgICAgKiBAcGFyYW0gb3JpZ2luIFRoZSBvcmlnaW4gb2YgdGhlIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHNjYWxlIFRoZSBzY2FsZSBvZiB0aGUgdGlsZW1hcFxuICAgICAqIEBwYXJhbSB6b29tIFRoZSB6b29tIGxldmVsIG9mIHRoZSB2aWV3cG9ydFxuICAgICAqL1xuICAgIHByb3RlY3RlZCByZW5kZXJUaWxlKHRpbGVtYXA6IFRpbGVtYXAsIHRpbGVzZXQ6IFRpbGVzZXQsIHRpbGVJbmRleDogbnVtYmVyLCB0aWxlbWFwQ29sOiBudW1iZXIsIHRpbGVtYXBSb3c6IG51bWJlciwgb3JpZ2luOiBWZWMyLCBzY2FsZTogVmVjMiwgem9vbTogbnVtYmVyLCByb3RGbGlwOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgbGV0IGltYWdlID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0SW1hZ2UodGlsZXNldC5nZXRJbWFnZUtleSgpKTtcblxuICAgICAgICAvLyBHZXQgdGhlIHNpemUgb2YgdGhlIHRpbGUgdG8gcmVuZGVyXG4gICAgICAgIGxldCB0aWxlU2l6ZSA9IHRpbGVzZXQuZ2V0VGlsZVNpemUoKTtcbiAgICAgICAgbGV0IHdpZHRoID0gdGlsZVNpemUueDtcbiAgICAgICAgbGV0IGhlaWdodCA9IHRpbGVTaXplLnk7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiB0byBzdGFydCBhIGNyb3AgaW4gdGhlIHRpbGVzZXQgaW1hZ2VcbiAgICAgICAgbGV0IGltYWdlUG9zaXRpb24gPSB0aWxlc2V0LmdldEltYWdlT2Zmc2V0Rm9yVGlsZSh0aWxlSW5kZXgpO1xuICAgICAgICBsZXQgbGVmdCA9IGltYWdlUG9zaXRpb24ueFxuICAgICAgICBsZXQgdG9wID0gaW1hZ2VQb3NpdGlvbi55O1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcG9zaXRpb24gaW4gdGhlIHdvcmxkIHRvIHJlbmRlciB0aGUgdGlsZVxuICAgICAgICBsZXQgd29ybGRQb3NpdGlvbiA9IHRpbGVtYXAuZ2V0V29ybGRQb3NpdGlvbih0aWxlbWFwQ29sLCB0aWxlbWFwUm93KTtcblxuICAgICAgICBsZXQgd29ybGRYID0gTWF0aC5mbG9vcigod29ybGRQb3NpdGlvbi54IC0gb3JpZ2luLngpKnpvb20pO1xuICAgICAgICBsZXQgd29ybGRZID0gTWF0aC5mbG9vcigod29ybGRQb3NpdGlvbi55IC0gb3JpZ2luLnkpKnpvb20pO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgc2l6ZSBvZiB0aGUgd29ybGQgdG8gcmVuZGVyIHRoZSB0aWxlIGluXG4gICAgICAgIGxldCB3b3JsZFdpZHRoID0gTWF0aC5jZWlsKHdpZHRoICogc2NhbGUueCAqIHpvb20pO1xuICAgICAgICBsZXQgd29ybGRIZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0ICogc2NhbGUueSAqIHpvb20pO1xuXG4gICAgICAgIGlmKHJvdEZsaXAgIT09IDApe1xuICAgICAgICAgICAgbGV0IHNjYWxlWCA9IDE7XG4gICAgICAgICAgICBsZXQgc2NhbGVZID0gMTtcbiAgICAgICAgICAgIGxldCBzaGVhclggPSAwO1xuICAgICAgICAgICAgbGV0IHNoZWFyWSA9IDA7XG5cbiAgICAgICAgICAgIC8vIEZsaXAgb24gdGhlIHgtYXhpc1xuICAgICAgICAgICAgaWYocm90RmxpcCAmIDgpe1xuICAgICAgICAgICAgICAgIHNjYWxlWCA9IC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGbGlwIG9uIHRoZSB5LWF4aXNcbiAgICAgICAgICAgIGlmKHJvdEZsaXAgJiA0KXtcbiAgICAgICAgICAgICAgICBzY2FsZVkgPSAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmxpcCBvdmVyIHRoZSBsaW5lIHk9eFxuICAgICAgICAgICAgaWYocm90RmxpcCAmIDIpe1xuICAgICAgICAgICAgICAgIHNoZWFyWCA9IHNjYWxlWTtcbiAgICAgICAgICAgICAgICBzaGVhclkgPSBzY2FsZVg7XG4gICAgICAgICAgICAgICAgc2NhbGVYID0gMDtcbiAgICAgICAgICAgICAgICBzY2FsZVkgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oc2NhbGVYLCBzaGVhclgsIHNoZWFyWSwgc2NhbGVZLCB3b3JsZFggKyB3b3JsZFdpZHRoLzIsIHdvcmxkWSArIHdvcmxkSGVpZ2h0LzIpO1xuICAgICAgICBcbiAgICAgICAgICAgIC8vIFJlbmRlciB0aGUgdGlsZVxuICAgICAgICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKGltYWdlLFxuICAgICAgICAgICAgICAgIGxlZnQsIHRvcCxcbiAgICAgICAgICAgICAgICB3aWR0aCwgaGVpZ2h0LFxuICAgICAgICAgICAgICAgIC13b3JsZFdpZHRoLzIsIC13b3JsZEhlaWdodC8yLFxuICAgICAgICAgICAgICAgIHdvcmxkV2lkdGgsIHdvcmxkSGVpZ2h0KTtcblxuICAgICAgICAgICAgaWYocm90RmxpcCAhPT0gMCl7XG4gICAgICAgICAgICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gcm90YXRpb25zLCBkb24ndCBkbyB0aGUgY2FsY3VsYXRpb25zLCBqdXN0IHJlbmRlciB0aGUgdGlsZVxuICAgICAgICAgICAgLy8gUmVuZGVyIHRoZSB0aWxlXG4gICAgICAgICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoaW1hZ2UsXG4gICAgICAgICAgICAgICAgbGVmdCwgdG9wLFxuICAgICAgICAgICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgICAgICAgICAgd29ybGRYLCB3b3JsZFksXG4gICAgICAgICAgICAgICAgd29ybGRXaWR0aCwgd29ybGRIZWlnaHQpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBwcm90ZWN0ZWQgZ2V0T3J0aG9nb25hbFRpbGVEcmF3UG9zKG1hcDogT3J0aG9nb25hbFRpbGVtYXAsIHNldDogVGlsZXNldCwgY29sOiBudW1iZXIsIHJvdzogbnVtYmVyKTogVmVjMiB7XG4gICAgICAgIGxldCBpbWdzaXplOiBWZWMyID0gc2V0LmdldFRpbGVTaXplKCkubXVsdChtYXAuc2NhbGUpO1xuICAgICAgICBsZXQgbWFwc2l6ZTogVmVjMiA9IG1hcC5nZXRTY2FsZWRUaWxlU2l6ZSgpO1xuICAgICAgICByZXR1cm4gbWFwLmdldFdvcmxkUG9zaXRpb24oY29sLCByb3cpLnN1YihpbWdzaXplLnN1YihtYXBzaXplKSk7XG4gICAgfVxuICAgIHByb3RlY3RlZCBnZXRJc29tZXRyaWNUaWxlRHJhd1BvcyhtYXA6IFRpbGVtYXAsIHNldDogVGlsZXNldCwgY29sOiBudW1iZXIsIHJvdzogbnVtYmVyKTogVmVjMiB7XG4gICAgICAgIGxldCBzaXplOiBWZWMyID0gc2V0LmdldFRpbGVTaXplKCk7XG4gICAgICAgIGxldCBkcmF3UG9zOiBWZWMyID0gbWFwLmdldFNjYWxlZFRpbGVTaXplKCkuc3ViKG5ldyBWZWMyKHNpemUueCptYXAuc2NhbGUueCwgc2l6ZS55Km1hcC5zY2FsZS55KSk7XG4gICAgICAgIGRyYXdQb3MuaW5jKC1zaXplLngqbWFwLnNjYWxlLngvMiwgMCk7XG4gICAgICAgIGRyYXdQb3MuYWRkKG1hcC5nZXRXb3JsZFBvc2l0aW9uKGNvbCwgcm93KSk7XG4gICAgICAgIHJldHVybiBkcmF3UG9zO1xuICAgIH1cbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBCdXR0b24gZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvQnV0dG9uXCI7XG5pbXBvcnQgTGFiZWwgZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvTGFiZWxcIjtcbmltcG9ydCBTbGlkZXIgZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvU2xpZGVyXCI7XG5pbXBvcnQgVGV4dElucHV0IGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL1RleHRJbnB1dFwiO1xuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi8uLi9TY2VuZS9TY2VuZVwiO1xuaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vLi4vVXRpbHMvTWF0aFV0aWxzXCI7XG5cbi8qKlxuICogQSB1dGlsaXR5IGNsYXNzIHRvIGhlbHAgdGhlIEByZWZlcmVuY2VbQ2FudmFzUmVuZGVyZXJdIHJlbmRlciBAcmVmZXJlbmNlW1VJRWxlbWVudF1zXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVJRWxlbWVudFJlbmRlcmVyIHtcbiAgICBwcm90ZWN0ZWQgcmVzb3VyY2VNYW5hZ2VyOiBSZXNvdXJjZU1hbmFnZXI7XG4gICAgcHJvdGVjdGVkIHNjZW5lOiBTY2VuZTtcbiAgICBwcm90ZWN0ZWQgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XG5cbiAgICBjb25zdHJ1Y3RvcihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCl7XG4gICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNjZW5lIG9mIHRoaXMgVUlFbGVtZW50UmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gc2NlbmUgVGhlIGN1cnJlbnQgc2NlbmVcbiAgICAgKi9cbiAgICBzZXRTY2VuZShzY2VuZTogU2NlbmUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYSBsYWJlbFxuICAgICAqIEBwYXJhbSBsYWJlbCBUaGUgbGFiZWwgdG8gcmVuZGVyXG4gICAgICovXG4gICAgcmVuZGVyTGFiZWwobGFiZWw6IExhYmVsKTogdm9pZCB7XG4gICAgICAgIC8vIElmIHRoZSBzaXplIGlzIHVuYXNzaWduZWQgKGJ5IHRoZSB1c2VyIG9yIGF1dG9tYXRpY2FsbHkpIGFzc2lnbiBpdFxuICAgICAgICBsYWJlbC5oYW5kbGVJbml0aWFsU2l6aW5nKHRoaXMuY3R4KTtcblx0XHRcblx0XHQvLyBHcmFiIHRoZSBnbG9iYWwgYWxwaGEgc28gd2UgY2FuIGFkanVzdCBpdCBmb3IgdGhpcyByZW5kZXJcblx0XHRsZXQgcHJldmlvdXNBbHBoYSA9IHRoaXMuY3R4Lmdsb2JhbEFscGhhO1xuXG4gICAgICAgIC8vIEdldCB0aGUgZm9udCBhbmQgdGV4dCBwb3NpdGlvbiBpbiBsYWJlbFxuXHRcdHRoaXMuY3R4LmZvbnQgPSBsYWJlbC5nZXRGb250U3RyaW5nKCk7XG5cdFx0bGV0IG9mZnNldCA9IGxhYmVsLmNhbGN1bGF0ZVRleHRPZmZzZXQodGhpcy5jdHgpO1xuXG5cdFx0Ly8gU3Ryb2tlIGFuZCBmaWxsIGEgcm91bmRlZCByZWN0IGFuZCBnaXZlIGl0IHRleHRcblx0XHR0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IGxhYmVsLmJhY2tncm91bmRDb2xvci5hO1xuXHRcdHRoaXMuY3R4LmZpbGxTdHlsZSA9IGxhYmVsLmNhbGN1bGF0ZUJhY2tncm91bmRDb2xvcigpLnRvU3RyaW5nUkdCQSgpO1xuXHRcdHRoaXMuY3R4LmZpbGxSb3VuZGVkUmVjdCgtbGFiZWwuc2l6ZS54LzIsIC1sYWJlbC5zaXplLnkvMixcblx0XHRcdGxhYmVsLnNpemUueCwgbGFiZWwuc2l6ZS55LCBsYWJlbC5ib3JkZXJSYWRpdXMpO1xuXHRcdFxuXHRcdHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gbGFiZWwuY2FsY3VsYXRlQm9yZGVyQ29sb3IoKS50b1N0cmluZ1JHQkEoKTtcblx0XHR0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IGxhYmVsLmJvcmRlckNvbG9yLmE7XG5cdFx0dGhpcy5jdHgubGluZVdpZHRoID0gbGFiZWwuYm9yZGVyV2lkdGg7XG5cdFx0dGhpcy5jdHguc3Ryb2tlUm91bmRlZFJlY3QoLWxhYmVsLnNpemUueC8yLCAtbGFiZWwuc2l6ZS55LzIsXG5cdFx0XHRsYWJlbC5zaXplLngsIGxhYmVsLnNpemUueSwgbGFiZWwuYm9yZGVyUmFkaXVzKTtcblxuXHRcdHRoaXMuY3R4LmZpbGxTdHlsZSA9IGxhYmVsLmNhbGN1bGF0ZVRleHRDb2xvcigpO1xuXHRcdHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gbGFiZWwudGV4dENvbG9yLmE7XG5cdFx0dGhpcy5jdHguZmlsbFRleHQobGFiZWwudGV4dCwgb2Zmc2V0LnggLSBsYWJlbC5zaXplLngvMiwgb2Zmc2V0LnkgLSBsYWJlbC5zaXplLnkvMik7XG5cdFxuXHRcdHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gcHJldmlvdXNBbHBoYTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgYnV0dG9uXG4gICAgICogQHBhcmFtIGJ1dHRvbiBUaGUgYnV0dG9uIHRvIHJlbmRlclxuICAgICAqL1xuICAgIHJlbmRlckJ1dHRvbihidXR0b246IEJ1dHRvbik6IHZvaWQge1xuICAgICAgICB0aGlzLnJlbmRlckxhYmVsKGJ1dHRvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIHNsaWRlclxuICAgICAqIEBwYXJhbSBzbGlkZXIgVGhlIHNsaWRlciB0byByZW5kZXJcbiAgICAgKi9cbiAgICByZW5kZXJTbGlkZXIoc2xpZGVyOiBTbGlkZXIpOiB2b2lkIHtcblx0XHQvLyBHcmFiIHRoZSBnbG9iYWwgYWxwaGEgc28gd2UgY2FuIGFkanVzdCBpdCBmb3IgdGhpcyByZW5kZXJcblx0XHRsZXQgcHJldmlvdXNBbHBoYSA9IHRoaXMuY3R4Lmdsb2JhbEFscGhhO1xuXHRcdHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gc2xpZGVyLmdldExheWVyKCkuZ2V0QWxwaGEoKTtcblxuICAgICAgICAvLyBDYWxjdWFsYXRlIHRoZSBzbGlkZXIgc2l6ZVxuICAgICAgICBsZXQgc2xpZGVyU2l6ZSA9IG5ldyBWZWMyKHNsaWRlci5zaXplLngsIDIpO1xuXG4gICAgICAgIC8vIERyYXcgdGhlIHNsaWRlclxuXHRcdHRoaXMuY3R4LmZpbGxTdHlsZSA9IHNsaWRlci5zbGlkZXJDb2xvci50b1N0cmluZygpO1xuXHRcdHRoaXMuY3R4LmZpbGxSb3VuZGVkUmVjdCgtc2xpZGVyU2l6ZS54LzIsIC1zbGlkZXJTaXplLnkvMixcbiAgICAgICAgICAgIHNsaWRlclNpemUueCwgc2xpZGVyU2l6ZS55LCBzbGlkZXIuYm9yZGVyUmFkaXVzKTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG5pYiBzaXplIGFuZCBwb3NpdGlvblxuICAgICAgICBsZXQgeCA9IE1hdGhVdGlscy5sZXJwKC1zbGlkZXIuc2l6ZS54LzIsIHNsaWRlci5zaXplLngvMiwgc2xpZGVyLmdldFZhbHVlKCkpO1xuXG4gICAgICAgIC8vIERyYXcgdGhlIG5pYlxuXHRcdHRoaXMuY3R4LmZpbGxTdHlsZSA9IHNsaWRlci5uaWJDb2xvci50b1N0cmluZygpO1xuXHRcdHRoaXMuY3R4LmZpbGxSb3VuZGVkUmVjdCh4LXNsaWRlci5uaWJTaXplLngvMiwgLXNsaWRlci5uaWJTaXplLnkvMixcbiAgICAgICAgICAgIHNsaWRlci5uaWJTaXplLngsIHNsaWRlci5uaWJTaXplLnksIHNsaWRlci5ib3JkZXJSYWRpdXMpO1xuXG4gICAgICAgIC8vIFJlc2V0IHRoZSBhbHBoYVxuICAgICAgICB0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IHByZXZpb3VzQWxwaGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIHRleHRJbnB1dFxuICAgICAqIEBwYXJhbSB0ZXh0SW5wdXQgVGhlIHRleHRJbnB1dCB0byByZW5kZXJcbiAgICAgKi9cbiAgICByZW5kZXJUZXh0SW5wdXQodGV4dElucHV0OiBUZXh0SW5wdXQpOiB2b2lkIHtcbiAgICAgICAgLy8gU2hvdyBhIGN1cnNvciBzb21ldGltZXNcbiAgICAgICAgaWYodGV4dElucHV0LmZvY3VzZWQgJiYgdGV4dElucHV0LmN1cnNvckNvdW50ZXIgJSA2MCA+IDMwKXtcbiAgICAgICAgICAgIHRleHRJbnB1dC50ZXh0ICs9IFwifFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZW5kZXJMYWJlbCh0ZXh0SW5wdXQpO1xuXG4gICAgICAgIGlmKHRleHRJbnB1dC5mb2N1c2VkKXtcbiAgICAgICAgICAgIGlmKHRleHRJbnB1dC5jdXJzb3JDb3VudGVyICUgNjAgPiAzMCl7XG4gICAgICAgICAgICAgICAgdGV4dElucHV0LnRleHQgPSB0ZXh0SW5wdXQudGV4dC5zdWJzdHJpbmcoMCwgdGV4dElucHV0LnRleHQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRleHRJbnB1dC5jdXJzb3JDb3VudGVyICs9IDE7XG4gICAgICAgICAgICBpZih0ZXh0SW5wdXQuY3Vyc29yQ291bnRlciA+PSA2MCl7XG4gICAgICAgICAgICAgICAgdGV4dElucHV0LmN1cnNvckNvdW50ZXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL0NvbGxlY3Rpb25zL01hcFwiO1xuaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uL05vZGVzL0NhbnZhc05vZGVcIjtcbmltcG9ydCBHcmFwaGljIGZyb20gXCIuLi9Ob2Rlcy9HcmFwaGljXCI7XG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XG5pbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vTm9kZXMvVGlsZW1hcFwiO1xuaW1wb3J0IFVJRWxlbWVudCBmcm9tIFwiLi4vTm9kZXMvVUlFbGVtZW50XCI7XG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5pbXBvcnQgVUlMYXllciBmcm9tIFwiLi4vU2NlbmUvTGF5ZXJzL1VJTGF5ZXJcIjtcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vU2NlbmUvU2NlbmVcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcblxuLyoqXG4gKiBBbiBhYnN0cmFjdCBmcmFtZXdvcmsgdG8gcHV0IGFsbCByZW5kZXJpbmcgaW4gb25jZSBwbGFjZSBpbiB0aGUgYXBwbGljYXRpb25cbiAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgUmVuZGVyaW5nTWFuYWdlciB7XG4gICAgLyoqIFRoZSBSZXNvdXJjZU1hbmFnZXIgKi9cbiAgICBwcm90ZWN0ZWQgcmVzb3VyY2VNYW5hZ2VyOiBSZXNvdXJjZU1hbmFnZXI7XG5cbiAgICAvKiogVGhlIHNjZW5lIGN1cnJlbnRseSBiZWluZyByZW5kZXJlZCAqL1xuICAgIHByb3RlY3RlZCBzY2VuZTogU2NlbmU7XG5cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNjZW5lIGN1cnJlbnRseSBiZWluZyByZW5kZXJlZFxuICAgICAqIEBwYXJhbSBzY2VuZSBUaGUgY3VycmVudCBTY2VuZVxuICAgICAqL1xuICAgIHNldFNjZW5lKHNjZW5lOiBTY2VuZSk6IHZvaWQge1xuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgY2FudmFzIGZvciB0aGUgZ2FtZVxuICAgICAqIEBwYXJhbSBjYW52YXMgVGhlIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHdpZHRoIFRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IFRoZSBkZXNpcmVkIGhlaWdodCBvZiB0aGUgY2FudmFzXG4gICAgICogQHJldHVybnMgVGhlIHJlbmRlcmluZyBjb250ZXh0IG9mIHRoZSBjYW52YXNcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBpbml0aWFsaXplQ2FudmFzKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogYW55O1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgdmlzaWJsZSBzZXQgb2YgQ2FudmFzTm9kZXMgYW5kIHZpc2libGUgcG9ydGlvbnMgb2YgdGlsZW1hcHMsIGFzIHdlbGwgYXMgYW55IFVJRWxlbWVudCBpbiBVSUxheWVyc1xuICAgICAqIEBwYXJhbSB2aXNpYmxlU2V0IFRoZSB2aXNpYmxlIHNldCBvZiBDYW52YXNOb2Rlc1xuICAgICAqIEBwYXJhbSB0aWxlbWFwcyBUaGUgdGlsZW1hcHMgdXNlZCBpbiB0aGUgYXBwbGljYXRpb25cbiAgICAgKiBAcGFyYW0gdWlMYXllcnMgVGhlIHVzZXIgaW50ZXJmYWNlIGxheWVyc1xuICAgICAqL1xuICAgIGFic3RyYWN0IHJlbmRlcih2aXNpYmxlU2V0OiBBcnJheTxDYW52YXNOb2RlPiwgdGlsZW1hcHM6IEFycmF5PFRpbGVtYXA+LCB1aUxheWVyczogTWFwPFVJTGF5ZXI+KTogdm9pZDtcblxuICAgIC8qKiBDbGVhcnMgdGhlIGNhbnZhcyAqL1xuICAgIGFic3RyYWN0IGNsZWFyKGNvbG9yOiBDb2xvcik6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgc3ByaXRlXG4gICAgICogQHBhcmFtIHNwcml0ZSBUaGUgc3ByaXRlIHRvIHJlbmRlclxuICAgICAqL1xuICAgIHByb3RlY3RlZCBhYnN0cmFjdCByZW5kZXJTcHJpdGUoc3ByaXRlOiBTcHJpdGUpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhbiBhbmltYXRlZCBzcHJpdGVcbiAgICAgKiBAcGFyYW0gc3ByaXRlIFRoZSBhbmltYXRlZCBzcHJpdGUgdG8gcmVuZGVyXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHJlbmRlckFuaW1hdGVkU3ByaXRlKHNwcml0ZTogQW5pbWF0ZWRTcHJpdGUpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIGdyYXBoaWNcbiAgICAgKiBAcGFyYW0gZ3JhcGhpYyBUaGUgZ3JhcGhpYyB0byByZW5kZXJcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVuZGVyR3JhcGhpYyhncmFwaGljOiBHcmFwaGljKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYSB0aWxlbWFwXG4gICAgICogQHBhcmFtIHRpbGVtYXAgVGhlIHRpbGVtYXAgdG8gcmVuZGVyXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHJlbmRlclRpbGVtYXAodGlsZW1hcDogVGlsZW1hcCk6IHZvaWQ7XG5cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYSBVSUVsZW1lbnRcbiAgICAgKiBAcGFyYW0gdWlFbGVtZW50IFRoZSBVSUVsZW1lbnQgdG8gcmVuZGVyXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHJlbmRlclVJRWxlbWVudCh1aUVsZW1lbnQ6IFVJRWxlbWVudCk6IHZvaWQ7XG59IiwiaW1wb3J0IEdyYXBoIGZyb20gXCIuLi9EYXRhVHlwZXMvR3JhcGhzL0dyYXBoXCI7XG5pbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvQ29sbGVjdGlvbnMvTWFwXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vRGVidWcvRGVidWdcIjtcbmltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuLi9Ob2Rlcy9DYW52YXNOb2RlXCI7XG5pbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vTm9kZXMvR3JhcGhpY1wiO1xuaW1wb3J0IHsgR3JhcGhpY1R5cGUgfSBmcm9tIFwiLi4vTm9kZXMvR3JhcGhpY3MvR3JhcGhpY1R5cGVzXCI7XG5pbXBvcnQgUG9pbnQgZnJvbSBcIi4uL05vZGVzL0dyYXBoaWNzL1BvaW50XCI7XG5pbXBvcnQgUmVjdCBmcm9tIFwiLi4vTm9kZXMvR3JhcGhpY3MvUmVjdFwiO1xuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XG5pbXBvcnQgU3ByaXRlIGZyb20gXCIuLi9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZVwiO1xuaW1wb3J0IFRpbGVtYXAgZnJvbSBcIi4uL05vZGVzL1RpbGVtYXBcIjtcbmltcG9ydCBVSUVsZW1lbnQgZnJvbSBcIi4uL05vZGVzL1VJRWxlbWVudFwiO1xuaW1wb3J0IExhYmVsIGZyb20gXCIuLi9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsXCI7XG5pbXBvcnQgU2hhZGVyUmVnaXN0cnkgZnJvbSBcIi4uL1JlZ2lzdHJ5L1JlZ2lzdHJpZXMvU2hhZGVyUmVnaXN0cnlcIjtcbmltcG9ydCBSZWdpc3RyeU1hbmFnZXIgZnJvbSBcIi4uL1JlZ2lzdHJ5L1JlZ2lzdHJ5TWFuYWdlclwiO1xuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xuaW1wb3J0IFBhcmFsbGF4TGF5ZXIgZnJvbSBcIi4uL1NjZW5lL0xheWVycy9QYXJhbGxheExheWVyXCI7XG5pbXBvcnQgVUlMYXllciBmcm9tIFwiLi4vU2NlbmUvTGF5ZXJzL1VJTGF5ZXJcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcbmltcG9ydCBSZW5kZXJpbmdVdGlscyBmcm9tIFwiLi4vVXRpbHMvUmVuZGVyaW5nVXRpbHNcIjtcbmltcG9ydCBSZW5kZXJpbmdNYW5hZ2VyIGZyb20gXCIuL1JlbmRlcmluZ01hbmFnZXJcIjtcbmltcG9ydCBTaGFkZXJUeXBlIGZyb20gXCIuL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2ViR0xSZW5kZXJlciBleHRlbmRzIFJlbmRlcmluZ01hbmFnZXIge1xuXG5cdHByb3RlY3RlZCBvcmlnaW46IFZlYzI7XG5cdHByb3RlY3RlZCB6b29tOiBudW1iZXI7XG5cdHByb3RlY3RlZCB3b3JsZFNpemU6IFZlYzI7XG5cblx0cHJvdGVjdGVkIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQ7XG5cdHByb3RlY3RlZCB0ZXh0Q3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XG5cblx0aW5pdGlhbGl6ZUNhbnZhcyhjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCB7XG5cdFx0Y2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cblx0XHR0aGlzLndvcmxkU2l6ZSA9IFZlYzIuWkVSTztcblx0XHR0aGlzLndvcmxkU2l6ZS54ID0gd2lkdGg7XG5cdFx0dGhpcy53b3JsZFNpemUueSA9IGhlaWdodDtcblxuXHRcdC8vIEdldCB0aGUgV2ViR0wgY29udGV4dFxuICAgICAgICB0aGlzLmdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiKTtcblxuXHRcdHRoaXMuZ2wudmlld3BvcnQoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuXHRcdHRoaXMuZ2wuZGlzYWJsZSh0aGlzLmdsLkRFUFRIX1RFU1QpO1xuICAgICAgICB0aGlzLmdsLmVuYWJsZSh0aGlzLmdsLkJMRU5EKTtcbiAgICAgICAgdGhpcy5nbC5ibGVuZEZ1bmModGhpcy5nbC5TUkNfQUxQSEEsIHRoaXMuZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgICAgIHRoaXMuZ2wuZW5hYmxlKHRoaXMuZ2wuQ1VMTF9GQUNFKTtcblxuXHRcdC8vIFRlbGwgdGhlIHJlc291cmNlIG1hbmFnZXIgd2UncmUgdXNpbmcgV2ViR0xcblx0XHRSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKS51c2VXZWJHTCh0cnVlLCB0aGlzLmdsKTtcblxuXHRcdC8vIFNob3cgdGhlIHRleHQgY2FudmFzIGFuZCBnZXQgaXRzIGNvbnRleHRcblx0XHRsZXQgdGV4dENhbnZhcyA9IDxIVE1MQ2FudmFzRWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRleHQtY2FudmFzXCIpO1xuXHRcdHRleHRDYW52YXMuaGlkZGVuID0gZmFsc2U7XG5cdFx0dGhpcy50ZXh0Q3R4ID0gdGV4dENhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cblx0XHQvLyBTaXplIHRoZSB0ZXh0IGNhbnZhcyB0byBiZSB0aGUgc2FtZSBhcyB0aGUgZ2FtZSBjYW52YXNcblx0XHR0ZXh0Q2FudmFzLmhlaWdodCA9IGhlaWdodDtcblx0XHR0ZXh0Q2FudmFzLndpZHRoID0gd2lkdGg7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2w7XG5cdH1cblxuXHRyZW5kZXIodmlzaWJsZVNldDogQ2FudmFzTm9kZVtdLCB0aWxlbWFwczogVGlsZW1hcFtdLCB1aUxheWVyczogTWFwPFVJTGF5ZXI+KTogdm9pZCB7XG5cdFx0Zm9yKGxldCBub2RlIG9mIHZpc2libGVTZXQpe1xuXHRcdFx0dGhpcy5yZW5kZXJOb2RlKG5vZGUpO1xuXHRcdH1cblxuXHRcdHVpTGF5ZXJzLmZvckVhY2goa2V5ID0+IHtcblx0XHRcdGlmKCF1aUxheWVycy5nZXQoa2V5KS5pc0hpZGRlbigpKVxuXHRcdFx0XHR1aUxheWVycy5nZXQoa2V5KS5nZXRJdGVtcygpLmZvckVhY2gobm9kZSA9PiB0aGlzLnJlbmRlck5vZGUoPENhbnZhc05vZGU+bm9kZSkpXG5cdFx0fSk7XG5cdH1cblxuXHRjbGVhcihjb2xvcjogQ29sb3IpOiB2b2lkIHtcblx0XHR0aGlzLmdsLmNsZWFyQ29sb3IoY29sb3IuciwgY29sb3IuZywgY29sb3IuYiwgY29sb3IuYSk7XG5cdFx0dGhpcy5nbC5jbGVhcih0aGlzLmdsLkNPTE9SX0JVRkZFUl9CSVQgfCB0aGlzLmdsLkRFUFRIX0JVRkZFUl9CSVQpO1xuXG5cdFx0dGhpcy50ZXh0Q3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndvcmxkU2l6ZS54LCB0aGlzLndvcmxkU2l6ZS55KTtcblx0fVxuXG5cdHByb3RlY3RlZCByZW5kZXJOb2RlKG5vZGU6IENhbnZhc05vZGUpOiB2b2lkIHtcblx0XHQvLyBDYWxjdWxhdGUgdGhlIG9yaWdpbiBvZiB0aGUgdmlld3BvcnQgYWNjb3JkaW5nIHRvIHRoaXMgc3ByaXRlXG4gICAgICAgIHRoaXMub3JpZ2luID0gdGhpcy5zY2VuZS5nZXRWaWV3VHJhbnNsYXRpb24obm9kZSk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSB6b29tIGxldmVsIG9mIHRoZSBzY2VuZVxuICAgICAgICB0aGlzLnpvb20gPSB0aGlzLnNjZW5lLmdldFZpZXdTY2FsZSgpO1xuXHRcdFxuXHRcdGlmKG5vZGUuaGFzQ3VzdG9tU2hhZGVyKXtcblx0XHRcdC8vIElmIHRoZSBub2RlIGhhcyBhIGN1c3RvbSBzaGFkZXIsIHJlbmRlciB1c2luZyB0aGF0XG5cdFx0XHR0aGlzLnJlbmRlckN1c3RvbShub2RlKTtcblx0XHR9IGVsc2UgaWYobm9kZSBpbnN0YW5jZW9mIEdyYXBoaWMpe1xuXHRcdFx0dGhpcy5yZW5kZXJHcmFwaGljKG5vZGUpO1xuXHRcdH0gZWxzZSBpZihub2RlIGluc3RhbmNlb2YgU3ByaXRlKXtcblx0XHRcdGlmKG5vZGUgaW5zdGFuY2VvZiBBbmltYXRlZFNwcml0ZSl7XG5cdFx0XHRcdHRoaXMucmVuZGVyQW5pbWF0ZWRTcHJpdGUobm9kZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnJlbmRlclNwcml0ZShub2RlKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYobm9kZSBpbnN0YW5jZW9mIFVJRWxlbWVudCl7XG5cdFx0XHR0aGlzLnJlbmRlclVJRWxlbWVudChub2RlKTtcblx0XHR9XG5cdH1cblxuXHRwcm90ZWN0ZWQgcmVuZGVyU3ByaXRlKHNwcml0ZTogU3ByaXRlKTogdm9pZCB7XG5cdFx0bGV0IHNoYWRlciA9IFJlZ2lzdHJ5TWFuYWdlci5zaGFkZXJzLmdldChTaGFkZXJSZWdpc3RyeS5TUFJJVEVfU0hBREVSKTtcblx0XHRsZXQgb3B0aW9ucyA9IHRoaXMuYWRkT3B0aW9ucyhzaGFkZXIuZ2V0T3B0aW9ucyhzcHJpdGUpLCBzcHJpdGUpO1xuXHRcdHNoYWRlci5yZW5kZXIodGhpcy5nbCwgb3B0aW9ucyk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgcmVuZGVyQW5pbWF0ZWRTcHJpdGUoc3ByaXRlOiBBbmltYXRlZFNwcml0ZSk6IHZvaWQge1xuXHRcdGxldCBzaGFkZXIgPSBSZWdpc3RyeU1hbmFnZXIuc2hhZGVycy5nZXQoU2hhZGVyUmVnaXN0cnkuU1BSSVRFX1NIQURFUik7XG5cdFx0bGV0IG9wdGlvbnMgPSB0aGlzLmFkZE9wdGlvbnMoc2hhZGVyLmdldE9wdGlvbnMoc3ByaXRlKSwgc3ByaXRlKTtcblx0XHRzaGFkZXIucmVuZGVyKHRoaXMuZ2wsIG9wdGlvbnMpO1xuXHR9XG5cblx0cHJvdGVjdGVkIHJlbmRlckdyYXBoaWMoZ3JhcGhpYzogR3JhcGhpYyk6IHZvaWQge1xuXG5cdFx0aWYoZ3JhcGhpYyBpbnN0YW5jZW9mIFBvaW50KXtcblx0XHRcdGxldCBzaGFkZXIgPSBSZWdpc3RyeU1hbmFnZXIuc2hhZGVycy5nZXQoU2hhZGVyUmVnaXN0cnkuUE9JTlRfU0hBREVSKTtcblx0XHRcdGxldCBvcHRpb25zID0gdGhpcy5hZGRPcHRpb25zKHNoYWRlci5nZXRPcHRpb25zKGdyYXBoaWMpLCBncmFwaGljKTtcblx0XHRcdHNoYWRlci5yZW5kZXIodGhpcy5nbCwgb3B0aW9ucyk7XG5cdFx0fSBlbHNlIGlmKGdyYXBoaWMgaW5zdGFuY2VvZiBSZWN0KSB7XG5cdFx0XHRsZXQgc2hhZGVyID0gUmVnaXN0cnlNYW5hZ2VyLnNoYWRlcnMuZ2V0KFNoYWRlclJlZ2lzdHJ5LlJFQ1RfU0hBREVSKTtcblx0XHRcdGxldCBvcHRpb25zID0gdGhpcy5hZGRPcHRpb25zKHNoYWRlci5nZXRPcHRpb25zKGdyYXBoaWMpLCBncmFwaGljKTtcblx0XHRcdHNoYWRlci5yZW5kZXIodGhpcy5nbCwgb3B0aW9ucyk7XG5cdFx0fSBcblx0fVxuXG5cdHByb3RlY3RlZCByZW5kZXJUaWxlbWFwKHRpbGVtYXA6IFRpbGVtYXApOiB2b2lkIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcblx0fVxuXG5cdHByb3RlY3RlZCByZW5kZXJVSUVsZW1lbnQodWlFbGVtZW50OiBVSUVsZW1lbnQpOiB2b2lkIHtcblx0XHRpZih1aUVsZW1lbnQgaW5zdGFuY2VvZiBMYWJlbCl7XG5cdFx0XHRsZXQgc2hhZGVyID0gUmVnaXN0cnlNYW5hZ2VyLnNoYWRlcnMuZ2V0KFNoYWRlclJlZ2lzdHJ5LkxBQkVMX1NIQURFUik7XG5cdFx0XHRsZXQgb3B0aW9ucyA9IHRoaXMuYWRkT3B0aW9ucyhzaGFkZXIuZ2V0T3B0aW9ucyh1aUVsZW1lbnQpLCB1aUVsZW1lbnQpO1xuXHRcdFx0c2hhZGVyLnJlbmRlcih0aGlzLmdsLCBvcHRpb25zKTtcblxuXHRcdFx0dGhpcy50ZXh0Q3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAodWlFbGVtZW50LnBvc2l0aW9uLnggLSB0aGlzLm9yaWdpbi54KSp0aGlzLnpvb20sICh1aUVsZW1lbnQucG9zaXRpb24ueSAtIHRoaXMub3JpZ2luLnkpKnRoaXMuem9vbSk7XG5cdFx0XHR0aGlzLnRleHRDdHgucm90YXRlKC11aUVsZW1lbnQucm90YXRpb24pO1xuXHRcdFx0bGV0IGdsb2JhbEFscGhhID0gdGhpcy50ZXh0Q3R4Lmdsb2JhbEFscGhhO1xuXHRcdFx0dGhpcy50ZXh0Q3R4Lmdsb2JhbEFscGhhID0gdWlFbGVtZW50LmFscGhhO1xuXG5cdFx0XHQvLyBSZW5kZXIgdGV4dFxuXHRcdFx0dGhpcy50ZXh0Q3R4LmZvbnQgPSB1aUVsZW1lbnQuZ2V0Rm9udFN0cmluZygpO1xuXHRcdFx0bGV0IG9mZnNldCA9IHVpRWxlbWVudC5jYWxjdWxhdGVUZXh0T2Zmc2V0KHRoaXMudGV4dEN0eCk7XG5cdFx0XHR0aGlzLnRleHRDdHguZmlsbFN0eWxlID0gdWlFbGVtZW50LmNhbGN1bGF0ZVRleHRDb2xvcigpO1xuXHRcdFx0dGhpcy50ZXh0Q3R4Lmdsb2JhbEFscGhhID0gdWlFbGVtZW50LnRleHRDb2xvci5hO1xuXHRcdFx0dGhpcy50ZXh0Q3R4LmZpbGxUZXh0KHVpRWxlbWVudC50ZXh0LCBvZmZzZXQueCAtIHVpRWxlbWVudC5zaXplLngvMiwgb2Zmc2V0LnkgLSB1aUVsZW1lbnQuc2l6ZS55LzIpO1xuXG5cdFx0XHR0aGlzLnRleHRDdHguZ2xvYmFsQWxwaGEgPSBnbG9iYWxBbHBoYTtcbiAgICAgICAgXHR0aGlzLnRleHRDdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXHRcdH1cblx0fVxuXG5cdHByb3RlY3RlZCByZW5kZXJDdXN0b20obm9kZTogQ2FudmFzTm9kZSk6IHZvaWQge1xuXHRcdGxldCBzaGFkZXIgPSBSZWdpc3RyeU1hbmFnZXIuc2hhZGVycy5nZXQobm9kZS5jdXN0b21TaGFkZXJLZXkpO1xuXHRcdGxldCBvcHRpb25zID0gdGhpcy5hZGRPcHRpb25zKHNoYWRlci5nZXRPcHRpb25zKG5vZGUpLCBub2RlKTtcblx0XHRzaGFkZXIucmVuZGVyKHRoaXMuZ2wsIG9wdGlvbnMpO1xuXHR9XG5cblx0cHJvdGVjdGVkIGFkZE9wdGlvbnMob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Piwgbm9kZTogQ2FudmFzTm9kZSk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuXHRcdC8vIEdpdmUgdGhlIHNoYWRlciBhY2Nlc3MgdG8gdGhlIHdvcmxkIHNpemVcblx0XHRvcHRpb25zLndvcmxkU2l6ZSA9IHRoaXMud29ybGRTaXplO1xuXG5cdFx0Ly8gQWRqdXN0IHRoZSBvcmlnaW4gcG9zaXRpb24gdG8gdGhlIHBhcmFsbGF4XG5cdFx0bGV0IGxheWVyID0gbm9kZS5nZXRMYXllcigpO1xuXHRcdGxldCBwYXJhbGxheCA9IG5ldyBWZWMyKDEsIDEpO1xuXHRcdGlmKGxheWVyIGluc3RhbmNlb2YgUGFyYWxsYXhMYXllcil7XG5cdFx0XHRwYXJhbGxheCA9ICg8UGFyYWxsYXhMYXllcj5sYXllcikucGFyYWxsYXg7XG5cdFx0fVxuXG5cdFx0b3B0aW9ucy5vcmlnaW4gPSB0aGlzLm9yaWdpbi5jbG9uZSgpLm11bHQocGFyYWxsYXgpO1xuXG5cdFx0cmV0dXJuIG9wdGlvbnM7XG5cdH1cblxufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9Db2xsZWN0aW9ucy9NYXBcIjtcbmltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuLi8uLi9Ob2Rlcy9DYW52YXNOb2RlXCI7XG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5cbi8qKlxuICogQSB3cmFwcGVyIGNsYXNzIGZvciBXZWJHTCBzaGFkZXJzLlxuICogVGhpcyBjbGFzcyBpcyBhIHNpbmdsZXRvbiwgYW5kIHRoZXJlIGlzIG9ubHkgb25lIGZvciBlYWNoIHNoYWRlciB0eXBlLlxuICogQWxsIG9iamVjdHMgdGhhdCB1c2UgdGhpcyBzaGFkZXIgdHlwZSB3aWxsIHJlZmVyIHRvIGFuZCBtb2RpZnkgdGhpcyBzYW1lIHR5cGUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFNoYWRlclR5cGUge1xuXHQvKiogVGhlIG5hbWUgb2YgdGhpcyBzaGFkZXIgKi9cblx0cHJvdGVjdGVkIG5hbWU6IHN0cmluZztcblxuXHQvKiogVGhlIGtleSB0byB0aGUgV2ViR0xQcm9ncmFtIGluIHRoZSBSZXNvdXJjZU1hbmFnZXIgKi9cblx0cHJvdGVjdGVkIHByb2dyYW1LZXk6IHN0cmluZztcblxuXHQvKiogQSByZWZlcmVuY2UgdG8gdGhlIHJlc291cmNlIG1hbmFnZXIgKi9cblx0cHJvdGVjdGVkIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xuXG5cdGNvbnN0cnVjdG9yKHByb2dyYW1LZXk6IHN0cmluZyl7XG5cdFx0dGhpcy5wcm9ncmFtS2V5ID0gcHJvZ3JhbUtleTtcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemVzIGFueSBidWZmZXIgb2JqZWN0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBzaGFkZXIgdHlwZS5cblx0ICogQHBhcmFtIGdsIFRoZSBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxuXHQgKi9cblx0YWJzdHJhY3QgaW5pdEJ1ZmZlck9iamVjdCgpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBMb2FkcyBhbnkgdW5pZm9ybXNcblx0ICogQHBhcmFtIGdsIFRoZSBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxuXHQgKiBAcGFyYW0gb3B0aW9ucyBJbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IHdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmdcblx0ICovXG5cdGFic3RyYWN0IHJlbmRlcihnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZDtcblxuXHQvKipcblx0ICogRXh0cmFjdHMgdGhlIG9wdGlvbnMgZnJvbSB0aGUgQ2FudmFzTm9kZSBhbmQgZ2l2ZXMgdGhlbSB0byB0aGUgcmVuZGVyIGZ1bmN0aW9uXG5cdCAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIGdldCBvcHRpb25zIGZyb21cblx0ICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9wdGlvbnMgdGhhdCBzaG91bGQgYmUgcGFzc2VkIHRvIHRoZSByZW5kZXIgZnVuY3Rpb25cblx0ICovXG5cdGdldE9wdGlvbnMobm9kZTogQ2FudmFzTm9kZSk6IFJlY29yZDxzdHJpbmcsIGFueT4ge3JldHVybiB7fTt9XG59IiwiaW1wb3J0IE1hdDR4NCBmcm9tIFwiLi4vLi4vLi4vRGF0YVR5cGVzL01hdDR4NFwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uLy4uLy4uL0RlYnVnL0RlYnVnXCI7XG5pbXBvcnQgUmVjdCBmcm9tIFwiLi4vLi4vLi4vTm9kZXMvR3JhcGhpY3MvUmVjdFwiO1xuaW1wb3J0IExhYmVsIGZyb20gXCIuLi8uLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsXCI7XG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5pbXBvcnQgUXVhZFNoYWRlclR5cGUgZnJvbSBcIi4vUXVhZFNoYWRlclR5cGVcIjtcblxuLyoqICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYWJlbFNoYWRlclR5cGUgZXh0ZW5kcyBRdWFkU2hhZGVyVHlwZSB7XG5cblx0Y29uc3RydWN0b3IocHJvZ3JhbUtleTogc3RyaW5nKXtcblx0XHRzdXBlcihwcm9ncmFtS2V5KTtcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xuXHR9XG5cblx0aW5pdEJ1ZmZlck9iamVjdCgpOiB2b2lkIHtcblx0XHR0aGlzLmJ1ZmZlck9iamVjdEtleSA9IFwibGFiZWxcIjtcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlci5jcmVhdGVCdWZmZXIodGhpcy5idWZmZXJPYmplY3RLZXkpO1xuXHR9XG5cblx0cmVuZGVyKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcblx0XHRjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvci50b1dlYkdMKCk7XG5cdFx0Y29uc3QgYm9yZGVyQ29sb3IgPSBvcHRpb25zLmJvcmRlckNvbG9yLnRvV2ViR0woKTtcblxuXHRcdGNvbnN0IHByb2dyYW0gPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRTaGFkZXJQcm9ncmFtKHRoaXMucHJvZ3JhbUtleSk7XG5cdFx0Y29uc3QgYnVmZmVyID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0QnVmZmVyKHRoaXMuYnVmZmVyT2JqZWN0S2V5KTtcblxuXHRcdGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG5cblx0XHRjb25zdCB2ZXJ0ZXhEYXRhID0gdGhpcy5nZXRWZXJ0aWNlcyhvcHRpb25zLnNpemUueCwgb3B0aW9ucy5zaXplLnkpO1xuXG5cdFx0Y29uc3QgRlNJWkUgPSB2ZXJ0ZXhEYXRhLkJZVEVTX1BFUl9FTEVNRU5UO1xuXG5cdFx0Ly8gQmluZCB0aGUgYnVmZmVyXG5cdFx0Z2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG5cdFx0Z2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHZlcnRleERhdGEsIGdsLlNUQVRJQ19EUkFXKTtcblxuXHRcdC8vIEF0dHJpYnV0ZXNcblx0XHRjb25zdCBhX1Bvc2l0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgXCJhX1Bvc2l0aW9uXCIpO1xuXHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYV9Qb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogRlNJWkUsIDAgKiBGU0laRSk7XG5cdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYV9Qb3NpdGlvbik7XG5cblx0XHQvLyBVbmlmb3Jtc1xuXHRcdGNvbnN0IHVfQmFja2dyb3VuZENvbG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9CYWNrZ3JvdW5kQ29sb3JcIik7XG5cdFx0Z2wudW5pZm9ybTRmdih1X0JhY2tncm91bmRDb2xvciwgYmFja2dyb3VuZENvbG9yKTtcblxuICAgICAgICBjb25zdCB1X0JvcmRlckNvbG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9Cb3JkZXJDb2xvclwiKTtcblx0XHRnbC51bmlmb3JtNGZ2KHVfQm9yZGVyQ29sb3IsIGJvcmRlckNvbG9yKTtcblxuICAgICAgICBjb25zdCB1X01heFNpemUgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X01heFNpemVcIik7XG4gICAgICAgIGdsLnVuaWZvcm0yZih1X01heFNpemUsIC12ZXJ0ZXhEYXRhWzBdLCB2ZXJ0ZXhEYXRhWzFdKTtcblxuXHRcdC8vIEdldCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcblx0XHQvLyBXZSB3YW50IGEgc3F1YXJlIGZvciBvdXIgcmVuZGVyaW5nIHNwYWNlLCBzbyBnZXQgdGhlIG1heGltdW0gZGltZW5zaW9uIG9mIG91ciBxdWFkXG5cdFx0bGV0IG1heERpbWVuc2lvbiA9IE1hdGgubWF4KG9wdGlvbnMuc2l6ZS54LCBvcHRpb25zLnNpemUueSk7XG5cbiAgICAgICAgY29uc3QgdV9Cb3JkZXJXaWR0aCA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfQm9yZGVyV2lkdGhcIik7XG5cdFx0Z2wudW5pZm9ybTFmKHVfQm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgvbWF4RGltZW5zaW9uKTtcblxuICAgICAgICBjb25zdCB1X0JvcmRlclJhZGl1cyA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfQm9yZGVyUmFkaXVzXCIpO1xuXHRcdGdsLnVuaWZvcm0xZih1X0JvcmRlclJhZGl1cywgb3B0aW9ucy5ib3JkZXJSYWRpdXMvbWF4RGltZW5zaW9uKTtcblxuXHRcdC8vIFRoZSBzaXplIG9mIHRoZSByZW5kZXJpbmcgc3BhY2Ugd2lsbCBiZSBhIHNxdWFyZSB3aXRoIHRoaXMgbWF4aW11bSBkaW1lbnNpb25cblx0XHRsZXQgc2l6ZSA9IG5ldyBWZWMyKG1heERpbWVuc2lvbiwgbWF4RGltZW5zaW9uKS5zY2FsZSgyL29wdGlvbnMud29ybGRTaXplLngsIDIvb3B0aW9ucy53b3JsZFNpemUueSk7XG5cblx0XHQvLyBDZW50ZXIgb3VyIHRyYW5zbGF0aW9ucyBhcm91bmQgKDAsIDApXG5cdFx0Y29uc3QgdHJhbnNsYXRlWCA9IChvcHRpb25zLnBvc2l0aW9uLnggLSBvcHRpb25zLm9yaWdpbi54IC0gb3B0aW9ucy53b3JsZFNpemUueC8yKS9tYXhEaW1lbnNpb247XG5cdFx0Y29uc3QgdHJhbnNsYXRlWSA9IC0ob3B0aW9ucy5wb3NpdGlvbi55IC0gb3B0aW9ucy5vcmlnaW4ueSAtIG9wdGlvbnMud29ybGRTaXplLnkvMikvbWF4RGltZW5zaW9uO1xuXG5cdFx0Ly8gQ3JlYXRlIG91ciB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcblx0XHR0aGlzLnRyYW5zbGF0aW9uLnRyYW5zbGF0ZShuZXcgRmxvYXQzMkFycmF5KFt0cmFuc2xhdGVYLCB0cmFuc2xhdGVZXSkpO1xuXHRcdHRoaXMuc2NhbGUuc2NhbGUoc2l6ZSk7XG5cdFx0dGhpcy5yb3RhdGlvbi5yb3RhdGUob3B0aW9ucy5yb3RhdGlvbik7XG5cdFx0bGV0IHRyYW5zZm9ybWF0aW9uID0gTWF0NHg0Lk1VTFQodGhpcy50cmFuc2xhdGlvbiwgdGhpcy5zY2FsZSwgdGhpcy5yb3RhdGlvbik7XG5cblx0XHQvLyBQYXNzIHRoZSB0cmFuc2xhdGlvbiBtYXRyaXggdG8gb3VyIHNoYWRlclxuXHRcdGNvbnN0IHVfVHJhbnNmb3JtID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9UcmFuc2Zvcm1cIik7XG5cdFx0Z2wudW5pZm9ybU1hdHJpeDRmdih1X1RyYW5zZm9ybSwgZmFsc2UsIHRyYW5zZm9ybWF0aW9uLnRvQXJyYXkoKSk7XG5cblx0XHQvLyBEcmF3IHRoZSBxdWFkXG5cdFx0Z2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIHJlbmRlcmluZyBzcGFjZSBhbHdheXMgaGFzIHRvIGJlIGEgc3F1YXJlLCBzbyBtYWtlIHN1cmUgaXRzIHNxdWFyZSB3LnIudCB0byB0aGUgbGFyZ2VzdCBkaW1lbnNpb25cblx0ICogQHBhcmFtIHcgVGhlIHdpZHRoIG9mIHRoZSBxdWFkIGluIHBpeGVsc1xuXHQgKiBAcGFyYW0gaCBUaGUgaGVpZ2h0IG9mIHRoZSBxdWFkIGluIHBpeGVsc1xuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB0aGUgdmVydGljZXMgb2YgdGhlIHF1YWRcblx0ICovXG5cdGdldFZlcnRpY2VzKHc6IG51bWJlciwgaDogbnVtYmVyKTogRmxvYXQzMkFycmF5IHtcblx0XHRsZXQgeCwgeTtcblxuXHRcdGlmKGggPiB3KXtcblx0XHRcdHkgPSAwLjU7XG5cdFx0XHR4ID0gdy8oMipoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0eCA9IDAuNTtcblx0XHRcdHkgPSBoLygyKncpO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFtcblx0XHRcdC14LCAgeSxcblx0XHRcdC14LCAteSxcblx0XHRcdCB4LCAgeSxcblx0XHRcdCB4LCAteVxuXHRcdF0pO1xuXHR9XG5cblx0Z2V0T3B0aW9ucyhyZWN0OiBMYWJlbCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuXHRcdGxldCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge1xuXHRcdFx0cG9zaXRpb246IHJlY3QucG9zaXRpb24sXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IHJlY3QuY2FsY3VsYXRlQmFja2dyb3VuZENvbG9yKCksXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogcmVjdC5jYWxjdWxhdGVCb3JkZXJDb2xvcigpLFxuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IHJlY3QuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IHJlY3QuYm9yZGVyUmFkaXVzLFxuXHRcdFx0c2l6ZTogcmVjdC5zaXplLFxuXHRcdFx0cm90YXRpb246IHJlY3Qucm90YXRpb25cblx0XHR9XG5cblx0XHRyZXR1cm4gb3B0aW9ucztcblx0fVxufSIsImltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vLi4vLi4vRGVidWcvRGVidWdcIjtcbmltcG9ydCBQb2ludCBmcm9tIFwiLi4vLi4vLi4vTm9kZXMvR3JhcGhpY3MvUG9pbnRcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBSZW5kZXJpbmdVdGlscyBmcm9tIFwiLi4vLi4vLi4vVXRpbHMvUmVuZGVyaW5nVXRpbHNcIjtcbmltcG9ydCBTaGFkZXJUeXBlIGZyb20gXCIuLi9TaGFkZXJUeXBlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvaW50U2hhZGVyVHlwZSBleHRlbmRzIFNoYWRlclR5cGUge1xuXG5cdHByb3RlY3RlZCBidWZmZXJPYmplY3RLZXk6IHN0cmluZztcblxuXHRjb25zdHJ1Y3Rvcihwcm9ncmFtS2V5OiBzdHJpbmcpe1xuXHRcdHN1cGVyKHByb2dyYW1LZXkpO1xuXHR9XG5cblx0aW5pdEJ1ZmZlck9iamVjdCgpOiB2b2lkIHtcblx0XHR0aGlzLmJ1ZmZlck9iamVjdEtleSA9IFwicG9pbnRcIjtcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlci5jcmVhdGVCdWZmZXIodGhpcy5idWZmZXJPYmplY3RLZXkpO1xuXHR9XG5cblx0cmVuZGVyKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcblx0XHRsZXQgcG9zaXRpb24gPSBSZW5kZXJpbmdVdGlscy50b1dlYkdMQ29vcmRzKG9wdGlvbnMucG9zaXRpb24sIG9wdGlvbnMub3JpZ2luLCBvcHRpb25zLndvcmxkU2l6ZSk7XG5cdFx0bGV0IGNvbG9yID0gUmVuZGVyaW5nVXRpbHMudG9XZWJHTENvbG9yKG9wdGlvbnMuY29sb3IpO1xuXG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldFNoYWRlclByb2dyYW0odGhpcy5wcm9ncmFtS2V5KTtcblx0XHRjb25zdCBidWZmZXIgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRCdWZmZXIodGhpcy5idWZmZXJPYmplY3RLZXkpO1xuXG5cdFx0Z2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcblxuXHRcdGNvbnN0IHZlcnRleERhdGEgPSBwb3NpdGlvbjtcblxuXHRcdGNvbnN0IEZTSVpFID0gdmVydGV4RGF0YS5CWVRFU19QRVJfRUxFTUVOVDtcblxuXHRcdC8vIEJpbmQgdGhlIGJ1ZmZlclxuXHRcdGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuXHRcdGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhEYXRhLCBnbC5TVEFUSUNfRFJBVyk7XG5cblx0XHQvLyBBdHRyaWJ1dGVzXG5cdFx0Y29uc3QgYV9Qb3NpdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwiYV9Qb3NpdGlvblwiKTtcblx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFfUG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIEZTSVpFLCAwICogRlNJWkUpO1xuXHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGFfUG9zaXRpb24pO1xuXG5cdFx0Ly8gVW5pZm9ybXNcblx0XHRjb25zdCB1X0NvbG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9Db2xvclwiKTtcblx0XHRnbC51bmlmb3JtNGZ2KHVfQ29sb3IsIGNvbG9yKTtcblxuXHRcdGNvbnN0IHVfUG9pbnRTaXplID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9Qb2ludFNpemVcIik7XG5cdFx0Z2wudW5pZm9ybTFmKHVfUG9pbnRTaXplLCBvcHRpb25zLnBvaW50U2l6ZSk7XG5cblx0XHRnbC5kcmF3QXJyYXlzKGdsLlBPSU5UUywgMCwgMSk7XG5cdH1cblxuXHRnZXRPcHRpb25zKHBvaW50OiBQb2ludCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuXHRcdGxldCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge1xuXHRcdFx0cG9zaXRpb246IHBvaW50LnBvc2l0aW9uLFxuXHRcdFx0Y29sb3I6IHBvaW50LmNvbG9yLFxuXHRcdFx0cG9pbnRTaXplOiBwb2ludC5zaXplLFxuXHRcdH1cblxuXHRcdHJldHVybiBvcHRpb25zO1xuXHR9XG59IiwiaW1wb3J0IE1hdDR4NCBmcm9tIFwiLi4vLi4vLi4vRGF0YVR5cGVzL01hdDR4NFwiO1xuaW1wb3J0IFNoYWRlclR5cGUgZnJvbSBcIi4uL1NoYWRlclR5cGVcIjtcblxuLyoqIFJlcHJlc2VudHMgYW55IFdlYkdMIG9iamVjdHMgdGhhdCBoYXZlIGEgcXVhZCBtZXNoIChpLmUuIGEgcmVjdGFuZ3VsYXIgZ2FtZSBvYmplY3QgY29tcG9zZWQgb2Ygb25seSB0d28gdHJpYW5nbGVzKSAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgUXVhZFNoYWRlclR5cGUgZXh0ZW5kcyBTaGFkZXJUeXBlIHtcblx0LyoqIFRoZSBrZXkgdG8gdGhlIGJ1ZmZlciBvYmplY3QgZm9yIHRoaXMgc2hhZGVyICovXG5cdHByb3RlY3RlZCBidWZmZXJPYmplY3RLZXk6IHN0cmluZztcblxuXHQvKiogVGhlIHNjYWxlIG1hdHJpYyAqL1xuXHRwcm90ZWN0ZWQgc2NhbGU6IE1hdDR4NDtcblxuXHQvKiogVGhlIHJvdGF0aW9uIG1hdHJpeCAqL1xuXHRwcm90ZWN0ZWQgcm90YXRpb246IE1hdDR4NDtcblxuXHQvKiogVGhlIHRyYW5zbGF0aW9uIG1hdHJpeCAqL1xuXHRwcm90ZWN0ZWQgdHJhbnNsYXRpb246IE1hdDR4NDtcblxuXHRjb25zdHJ1Y3Rvcihwcm9ncmFtS2V5OiBzdHJpbmcpe1xuXHRcdHN1cGVyKHByb2dyYW1LZXkpO1xuXG5cdFx0dGhpcy5zY2FsZSA9IE1hdDR4NC5JREVOVElUWTtcblx0XHR0aGlzLnJvdGF0aW9uID0gTWF0NHg0LklERU5USVRZO1xuXHRcdHRoaXMudHJhbnNsYXRpb24gPSBNYXQ0eDQuSURFTlRJVFk7XG5cdH1cbn0iLCJpbXBvcnQgTWF0NHg0IGZyb20gXCIuLi8uLi8uLi9EYXRhVHlwZXMvTWF0NHg0XCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBSZWN0IGZyb20gXCIuLi8uLi8uLi9Ob2Rlcy9HcmFwaGljcy9SZWN0XCI7XG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5pbXBvcnQgUXVhZFNoYWRlclR5cGUgZnJvbSBcIi4vUXVhZFNoYWRlclR5cGVcIjtcblxuLyoqICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWN0U2hhZGVyVHlwZSBleHRlbmRzIFF1YWRTaGFkZXJUeXBlIHtcblxuXHRjb25zdHJ1Y3Rvcihwcm9ncmFtS2V5OiBzdHJpbmcpe1xuXHRcdHN1cGVyKHByb2dyYW1LZXkpO1xuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XG5cdH1cblxuXHRpbml0QnVmZmVyT2JqZWN0KCk6IHZvaWQge1xuXHRcdHRoaXMuYnVmZmVyT2JqZWN0S2V5ID0gXCJyZWN0XCI7XG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlQnVmZmVyKHRoaXMuYnVmZmVyT2JqZWN0S2V5KTtcblx0fVxuXG5cdHJlbmRlcihnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XG5cdFx0Y29uc3QgY29sb3IgPSBvcHRpb25zLmNvbG9yLnRvV2ViR0woKTtcblxuXHRcdGNvbnN0IHByb2dyYW0gPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRTaGFkZXJQcm9ncmFtKHRoaXMucHJvZ3JhbUtleSk7XG5cdFx0Y29uc3QgYnVmZmVyID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0QnVmZmVyKHRoaXMuYnVmZmVyT2JqZWN0S2V5KTtcblxuXHRcdGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG5cblx0XHRjb25zdCB2ZXJ0ZXhEYXRhID0gdGhpcy5nZXRWZXJ0aWNlcyhvcHRpb25zLnNpemUueCwgb3B0aW9ucy5zaXplLnkpO1xuXG5cdFx0Y29uc3QgRlNJWkUgPSB2ZXJ0ZXhEYXRhLkJZVEVTX1BFUl9FTEVNRU5UO1xuXG5cdFx0Ly8gQmluZCB0aGUgYnVmZmVyXG5cdFx0Z2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG5cdFx0Z2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHZlcnRleERhdGEsIGdsLlNUQVRJQ19EUkFXKTtcblxuXHRcdC8vIEF0dHJpYnV0ZXNcblx0XHRjb25zdCBhX1Bvc2l0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgXCJhX1Bvc2l0aW9uXCIpO1xuXHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYV9Qb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogRlNJWkUsIDAgKiBGU0laRSk7XG5cdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYV9Qb3NpdGlvbik7XG5cblx0XHQvLyBVbmlmb3Jtc1xuXHRcdGNvbnN0IHVfQ29sb3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X0NvbG9yXCIpO1xuXHRcdGdsLnVuaWZvcm00ZnYodV9Db2xvciwgY29sb3IpO1xuXG5cdFx0Ly8gR2V0IHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuXHRcdC8vIFdlIHdhbnQgYSBzcXVhcmUgZm9yIG91ciByZW5kZXJpbmcgc3BhY2UsIHNvIGdldCB0aGUgbWF4aW11bSBkaW1lbnNpb24gb2Ygb3VyIHF1YWRcblx0XHRsZXQgbWF4RGltZW5zaW9uID0gTWF0aC5tYXgob3B0aW9ucy5zaXplLngsIG9wdGlvbnMuc2l6ZS55KTtcblxuXHRcdC8vIFRoZSBzaXplIG9mIHRoZSByZW5kZXJpbmcgc3BhY2Ugd2lsbCBiZSBhIHNxdWFyZSB3aXRoIHRoaXMgbWF4aW11bSBkaW1lbnNpb25cblx0XHRsZXQgc2l6ZSA9IG5ldyBWZWMyKG1heERpbWVuc2lvbiwgbWF4RGltZW5zaW9uKS5zY2FsZSgyL29wdGlvbnMud29ybGRTaXplLngsIDIvb3B0aW9ucy53b3JsZFNpemUueSk7XG5cblx0XHQvLyBDZW50ZXIgb3VyIHRyYW5zbGF0aW9ucyBhcm91bmQgKDAsIDApXG5cdFx0Y29uc3QgdHJhbnNsYXRlWCA9IChvcHRpb25zLnBvc2l0aW9uLnggLSBvcHRpb25zLm9yaWdpbi54IC0gb3B0aW9ucy53b3JsZFNpemUueC8yKS9tYXhEaW1lbnNpb247XG5cdFx0Y29uc3QgdHJhbnNsYXRlWSA9IC0ob3B0aW9ucy5wb3NpdGlvbi55IC0gb3B0aW9ucy5vcmlnaW4ueSAtIG9wdGlvbnMud29ybGRTaXplLnkvMikvbWF4RGltZW5zaW9uO1xuXG5cdFx0Ly8gQ3JlYXRlIG91ciB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcblx0XHR0aGlzLnRyYW5zbGF0aW9uLnRyYW5zbGF0ZShuZXcgRmxvYXQzMkFycmF5KFt0cmFuc2xhdGVYLCB0cmFuc2xhdGVZXSkpO1xuXHRcdHRoaXMuc2NhbGUuc2NhbGUoc2l6ZSk7XG5cdFx0dGhpcy5yb3RhdGlvbi5yb3RhdGUob3B0aW9ucy5yb3RhdGlvbik7XG5cdFx0bGV0IHRyYW5zZm9ybWF0aW9uID0gTWF0NHg0Lk1VTFQodGhpcy50cmFuc2xhdGlvbiwgdGhpcy5zY2FsZSwgdGhpcy5yb3RhdGlvbik7XG5cblx0XHQvLyBQYXNzIHRoZSB0cmFuc2xhdGlvbiBtYXRyaXggdG8gb3VyIHNoYWRlclxuXHRcdGNvbnN0IHVfVHJhbnNmb3JtID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9UcmFuc2Zvcm1cIik7XG5cdFx0Z2wudW5pZm9ybU1hdHJpeDRmdih1X1RyYW5zZm9ybSwgZmFsc2UsIHRyYW5zZm9ybWF0aW9uLnRvQXJyYXkoKSk7XG5cblx0XHQvLyBEcmF3IHRoZSBxdWFkXG5cdFx0Z2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XG5cdH1cblxuXG5cdC8qXG5cdFx0U28gYXMgaXQgdHVybnMgb3V0LCBXZWJHTCBoYXMgYW4gaXNzdWUgd2l0aCBub24tc3F1YXJlIHF1YWRzLlxuXHRcdEl0IGRvZXNuJ3QgbGlrZSB3aGVuIHlvdSBkb24ndCBoYXZlIGEgMS0xIHNjYWxlLCBhbmQgcm90YXRpb25zIGFyZSBlbnRpcmVseSBtZXNzZWQgdXAgaWYgdGhpcyBpcyBub3QgdGhlIGNhc2UuXG5cdFx0VG8gc29sdmUgdGhpcywgSSB1c2VkIHRoZSBzY2FsZSBvZiB0aGUgTEFSR0VTVCBkaW1lbnNpb24gb2YgdGhlIHF1YWQgdG8gbWFrZSBhIHNxdWFyZSwgdGhlbiBhZGp1c3RlZCB0aGUgdmVydGV4IGNvb3JkaW5hdGVzIGluc2lkZSBvZiB0aGF0LlxuXHRcdEEgZGlhZ3JhbSBvZiB0aGUgc29sdXRpb24gZm9sbG93cy5cblxuXHRcdFRoZXJlIGlzIGEgYm91bmRpbmcgc3F1YXJlIGZvciB0aGUgcXVhZCB3aXRoIGRpbWVuc2lvbnMgaHhoIChpbiB0aGlzIGNhc2UsIHNpbmNlIGhlaWdodCBpcyB0aGUgbGFyZ2VzdCBkaW1lbnNpb24pLlxuXHRcdFRoZSBvZmZzZXQgaW4gdGhlIHZlcnRpY2FsIGRpcmVjdGlvbiBpcyB0aGVyZWZvcmUgMC41LCBhcyBpdCBpcyBub3JtYWxseS5cblx0XHRIb3dldmVyLCB0aGUgb2Zmc2V0IGluIHRoZSBob3Jpem9udGFsIGRpcmVjdGlvbiBpcyBub3Qgc28gc3RyYWlnaHRmb3J3YXJkLCBidXQgaXNuJ3QgY29uY2VwdHVhbGx5IGhhcmQuXG5cdFx0QWxsIHdlIHJlYWxseSBoYXZlIHRvIGRvIGlzIGEgcmFuZ2UgY2hhbmdlIGZyb20gWzAsIGhlaWdodC8yXSB0byBbMCwgMC41XSwgd2hlcmUgb3VyIHZhbHVlIGlzIHQgPSB3aWR0aC8yLCBhbmQgMCA8PSB0IDw9IGhlaWdodC8yLlxuXG5cdFx0U28gbm93IHdlIGhhdmUgb3VyIHJlY3QsIGluIGEgc3BhY2Ugc2NhbGVkIHdpdGggcmVzcGVjdCB0byB0aGUgbGFyZ2VzdCBkaW1lbnNpb24uXG5cdFx0Um90YXRpb25zIHdvcmsgYXMgeW91IHdvdWxkIGV4cGVjdCwgZXZlbiBmb3IgbG9uZyByZWN0YW5nbGVzLlxuXG5cdFx0XHRcdFx0MC41XG5cdFx0XHRfXyBfXyBfXyBfXyBfXyBfXyBfX1xuXHRcdFx0fFx0fDg4ODg4ODg4ODg4fFx0fFxuXHRcdFx0fFx0fDg4ODg4ODg4ODg4fFx0fFxuXHRcdFx0fFx0fDg4ODg4ODg4ODg4fFx0fFxuXHRcdC0wLjV8XyBffDg4ODg4ODg4ODg4fF8gX3wwLjVcblx0XHRcdHxcdHw4ODg4ODg4ODg4OHxcdHxcblx0XHRcdHxcdHw4ODg4ODg4ODg4OHxcdHxcblx0XHRcdHxcdHw4ODg4ODg4ODg4OHxcdHxcblx0ICBcdFx0fF9fX3w4ODg4ODg4ODg4OHxfX198XG5cdFx0XHQgIFx0XHQtMC41XG5cblx0XHRUaGUgZ2V0VmVydGljZXMgZnVuY3Rpb24gYmVsb3cgZG9lcyBhcyBkZXNjcmliZWQsIGFuZCBjb252ZXJ0cyB0aGUgcmFuZ2Vcblx0Ki9cblx0LyoqXG5cdCAqIFRoZSByZW5kZXJpbmcgc3BhY2UgYWx3YXlzIGhhcyB0byBiZSBhIHNxdWFyZSwgc28gbWFrZSBzdXJlIGl0cyBzcXVhcmUgdy5yLnQgdG8gdGhlIGxhcmdlc3QgZGltZW5zaW9uXG5cdCAqIEBwYXJhbSB3IFRoZSB3aWR0aCBvZiB0aGUgcXVhZCBpbiBwaXhlbHNcblx0ICogQHBhcmFtIGggVGhlIGhlaWdodCBvZiB0aGUgcXVhZCBpbiBwaXhlbHNcblx0ICogQHJldHVybnMgQW4gYXJyYXkgb2YgdGhlIHZlcnRpY2VzIG9mIHRoZSBxdWFkXG5cdCAqL1xuXHRnZXRWZXJ0aWNlcyh3OiBudW1iZXIsIGg6IG51bWJlcik6IEZsb2F0MzJBcnJheSB7XG5cdFx0bGV0IHgsIHk7XG5cblx0XHRpZihoID4gdyl7XG5cdFx0XHR5ID0gMC41O1xuXHRcdFx0eCA9IHcvKDIqaCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHggPSAwLjU7XG5cdFx0XHR5ID0gaC8oMip3KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXG5cdFx0XHQteCwgIHksXG5cdFx0XHQteCwgLXksXG5cdFx0XHQgeCwgIHksXG5cdFx0XHQgeCwgLXlcblx0XHRdKTtcblx0fVxuXG5cdGdldE9wdGlvbnMocmVjdDogUmVjdCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuXHRcdGxldCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge1xuXHRcdFx0cG9zaXRpb246IHJlY3QucG9zaXRpb24sXG5cdFx0XHRjb2xvcjogcmVjdC5jb2xvcixcblx0XHRcdHNpemU6IHJlY3Quc2l6ZSxcblx0XHRcdHJvdGF0aW9uOiByZWN0LnJvdGF0aW9uXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9wdGlvbnM7XG5cdH1cbn0iLCJpbXBvcnQgTWF0NHg0IGZyb20gXCIuLi8uLi8uLi9EYXRhVHlwZXMvTWF0NHg0XCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vLi4vLi4vRGVidWcvRGVidWdcIjtcbmltcG9ydCBBbmltYXRlZFNwcml0ZSBmcm9tIFwiLi4vLi4vLi4vTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZVwiO1xuaW1wb3J0IFNwcml0ZSBmcm9tIFwiLi4vLi4vLi4vTm9kZXMvU3ByaXRlcy9TcHJpdGVcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBRdWFkU2hhZGVyVHlwZSBmcm9tIFwiLi9RdWFkU2hhZGVyVHlwZVwiO1xuXG4vKiogQSBzaGFkZXIgZm9yIHNwcml0ZXMgYW5kIGFuaW1hdGVkIHNwcml0ZXMgKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwcml0ZVNoYWRlclR5cGUgZXh0ZW5kcyBRdWFkU2hhZGVyVHlwZSB7XG5cdGNvbnN0cnVjdG9yKHByb2dyYW1LZXk6IHN0cmluZyl7XG5cdFx0c3VwZXIocHJvZ3JhbUtleSk7XG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcblx0fVxuXG5cdGluaXRCdWZmZXJPYmplY3QoKTogdm9pZCB7XG5cdFx0dGhpcy5idWZmZXJPYmplY3RLZXkgPSBcInNwcml0ZVwiO1xuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZUJ1ZmZlcih0aGlzLmJ1ZmZlck9iamVjdEtleSk7XG5cdH1cblxuXHRyZW5kZXIoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xuXHRcdGNvbnN0IHByb2dyYW0gPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRTaGFkZXJQcm9ncmFtKHRoaXMucHJvZ3JhbUtleSk7XG5cdFx0Y29uc3QgYnVmZmVyID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0QnVmZmVyKHRoaXMuYnVmZmVyT2JqZWN0S2V5KTtcblx0XHRjb25zdCB0ZXh0dXJlID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0VGV4dHVyZShvcHRpb25zLmltYWdlS2V5KTtcblxuXHRcdGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG5cblx0XHRjb25zdCB2ZXJ0ZXhEYXRhID0gdGhpcy5nZXRWZXJ0aWNlcyhvcHRpb25zLnNpemUueCwgb3B0aW9ucy5zaXplLnksIG9wdGlvbnMuc2NhbGUpO1xuXG5cdFx0Y29uc3QgRlNJWkUgPSB2ZXJ0ZXhEYXRhLkJZVEVTX1BFUl9FTEVNRU5UO1xuXG5cdFx0Ly8gQmluZCB0aGUgYnVmZmVyXG5cdFx0Z2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG5cdFx0Z2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHZlcnRleERhdGEsIGdsLlNUQVRJQ19EUkFXKTtcblxuXHRcdC8vIEF0dHJpYnV0ZXNcblx0XHRjb25zdCBhX1Bvc2l0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgXCJhX1Bvc2l0aW9uXCIpO1xuXHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYV9Qb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCA0ICogRlNJWkUsIDAgKiBGU0laRSk7XG5cdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYV9Qb3NpdGlvbik7XG5cblx0XHRjb25zdCBhX1RleENvb3JkID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgXCJhX1RleENvb3JkXCIpO1xuXHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYV9UZXhDb29yZCwgMiwgZ2wuRkxPQVQsIGZhbHNlLCA0ICogRlNJWkUsIDIqRlNJWkUpO1xuXHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGFfVGV4Q29vcmQpO1xuXG5cdFx0Ly8gVW5pZm9ybXNcblx0XHQvLyBHZXQgdHJhbnNmb3JtYXRpb24gbWF0cml4XG5cdFx0Ly8gV2Ugd2FudCBhIHNxdWFyZSBmb3Igb3VyIHJlbmRlcmluZyBzcGFjZSwgc28gZ2V0IHRoZSBtYXhpbXVtIGRpbWVuc2lvbiBvZiBvdXIgcXVhZFxuXHRcdGxldCBtYXhEaW1lbnNpb24gPSBNYXRoLm1heChvcHRpb25zLnNpemUueCwgb3B0aW9ucy5zaXplLnkpO1xuXG5cdFx0Ly8gVGhlIHNpemUgb2YgdGhlIHJlbmRlcmluZyBzcGFjZSB3aWxsIGJlIGEgc3F1YXJlIHdpdGggdGhpcyBtYXhpbXVtIGRpbWVuc2lvblxuXHRcdGxldCBzaXplID0gbmV3IFZlYzIobWF4RGltZW5zaW9uLCBtYXhEaW1lbnNpb24pLnNjYWxlKDIvb3B0aW9ucy53b3JsZFNpemUueCwgMi9vcHRpb25zLndvcmxkU2l6ZS55KTtcblxuXHRcdC8vIENlbnRlciBvdXIgdHJhbnNsYXRpb25zIGFyb3VuZCAoMCwgMClcblx0XHRjb25zdCB0cmFuc2xhdGVYID0gKG9wdGlvbnMucG9zaXRpb24ueCAtIG9wdGlvbnMub3JpZ2luLnggLSBvcHRpb25zLndvcmxkU2l6ZS54LzIpL21heERpbWVuc2lvbjtcblx0XHRjb25zdCB0cmFuc2xhdGVZID0gLShvcHRpb25zLnBvc2l0aW9uLnkgLSBvcHRpb25zLm9yaWdpbi55IC0gb3B0aW9ucy53b3JsZFNpemUueS8yKS9tYXhEaW1lbnNpb247XG5cblx0XHQvLyBDcmVhdGUgb3VyIHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuXHRcdHRoaXMudHJhbnNsYXRpb24udHJhbnNsYXRlKG5ldyBGbG9hdDMyQXJyYXkoW3RyYW5zbGF0ZVgsIHRyYW5zbGF0ZVldKSk7XG5cdFx0dGhpcy5zY2FsZS5zY2FsZShzaXplKTtcblx0XHR0aGlzLnJvdGF0aW9uLnJvdGF0ZShvcHRpb25zLnJvdGF0aW9uKTtcblx0XHRsZXQgdHJhbnNmb3JtYXRpb24gPSBNYXQ0eDQuTVVMVCh0aGlzLnRyYW5zbGF0aW9uLCB0aGlzLnNjYWxlLCB0aGlzLnJvdGF0aW9uKTtcblxuXHRcdC8vIFBhc3MgdGhlIHRyYW5zbGF0aW9uIG1hdHJpeCB0byBvdXIgc2hhZGVyXG5cdFx0Y29uc3QgdV9UcmFuc2Zvcm0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X1RyYW5zZm9ybVwiKTtcblx0XHRnbC51bmlmb3JtTWF0cml4NGZ2KHVfVHJhbnNmb3JtLCBmYWxzZSwgdHJhbnNmb3JtYXRpb24udG9BcnJheSgpKTtcblxuXHRcdC8vIFNldCB1cCBvdXIgc2FtcGxlciB3aXRoIG91ciBhc3NpZ25lZCB0ZXh0dXJlIHVuaXRcblx0XHRjb25zdCB1X1NhbXBsZXIgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X1NhbXBsZXJcIik7XG5cdFx0Z2wudW5pZm9ybTFpKHVfU2FtcGxlciwgdGV4dHVyZSk7XG5cblx0XHQvLyBQYXNzIGluIHRleFNoaWZ0XG5cdFx0Y29uc3QgdV90ZXhTaGlmdCA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfdGV4U2hpZnRcIik7XG5cdFx0Z2wudW5pZm9ybTJmdih1X3RleFNoaWZ0LCBvcHRpb25zLnRleFNoaWZ0KTtcblxuXHRcdC8vIFBhc3MgaW4gdGV4U2NhbGVcblx0XHRjb25zdCB1X3RleFNjYWxlID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV90ZXhTY2FsZVwiKTtcblx0XHRnbC51bmlmb3JtMmZ2KHVfdGV4U2NhbGUsIG9wdGlvbnMudGV4U2NhbGUpO1xuXG5cdFx0Ly8gRHJhdyB0aGUgcXVhZFxuXHRcdGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSByZW5kZXJpbmcgc3BhY2UgYWx3YXlzIGhhcyB0byBiZSBhIHNxdWFyZSwgc28gbWFrZSBzdXJlIGl0cyBzcXVhcmUgdy5yLnQgdG8gdGhlIGxhcmdlc3QgZGltZW5zaW9uXG5cdCAqIEBwYXJhbSB3IFRoZSB3aWR0aCBvZiB0aGUgcXVhZCBpbiBwaXhlbHNcblx0ICogQHBhcmFtIGggVGhlIGhlaWdodCBvZiB0aGUgcXVhZCBpbiBwaXhlbHNcblx0ICogQHJldHVybnMgQW4gYXJyYXkgb2YgdGhlIHZlcnRpY2VzIG9mIHRoZSBxdWFkXG5cdCAqL1xuXHRnZXRWZXJ0aWNlcyh3OiBudW1iZXIsIGg6IG51bWJlciwgc2NhbGU6IEZsb2F0MzJBcnJheSk6IEZsb2F0MzJBcnJheSB7XG5cdFx0bGV0IHgsIHk7XG5cblx0XHRpZihoID4gdyl7XG5cdFx0XHR5ID0gMC41O1xuXHRcdFx0eCA9IHcvKDIqaCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHggPSAwLjU7XG5cdFx0XHR5ID0gaC8oMip3KTtcblx0XHR9XG5cblx0XHQvLyBTY2FsZSB0aGUgcmVuZGVyaW5nIHNwYWNlIGlmIG5lZWRlZFxuXHRcdHggKj0gc2NhbGVbMF07XG5cdFx0eSAqPSBzY2FsZVsxXTtcblxuXHRcdHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFtcblx0XHRcdC14LCAgeSwgMC4wLCAwLjAsXG5cdFx0XHQteCwgLXksIDAuMCwgMS4wLFxuXHRcdFx0IHgsICB5LCAxLjAsIDAuMCxcblx0XHRcdCB4LCAteSwgMS4wLCAxLjBcblx0XHRdKTtcblx0fVxuXG5cdGdldE9wdGlvbnMoc3ByaXRlOiBTcHJpdGUpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcblx0XHRsZXQgdGV4U2hpZnQ7XG5cdFx0bGV0IHRleFNjYWxlO1xuXG5cdFx0aWYoc3ByaXRlIGluc3RhbmNlb2YgQW5pbWF0ZWRTcHJpdGUpe1xuXHRcdFx0bGV0IGFuaW1hdGlvbkluZGV4ID0gc3ByaXRlLmFuaW1hdGlvbi5nZXRJbmRleEFuZEFkdmFuY2VBbmltYXRpb24oKTtcblx0XHRcdGxldCBvZmZzZXQgPSBzcHJpdGUuZ2V0QW5pbWF0aW9uT2Zmc2V0KGFuaW1hdGlvbkluZGV4KTtcblx0XHRcdHRleFNoaWZ0ID0gbmV3IEZsb2F0MzJBcnJheShbb2Zmc2V0LnggLyAoc3ByaXRlLmNvbHMgKiBzcHJpdGUuc2l6ZS54KSwgb2Zmc2V0LnkgLyAoc3ByaXRlLnJvd3MgKiBzcHJpdGUuc2l6ZS55KV0pO1xuXHRcdFx0dGV4U2NhbGUgPSBuZXcgRmxvYXQzMkFycmF5KFsxLyhzcHJpdGUuY29scyksIDEvKHNwcml0ZS5yb3dzKV0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0ZXhTaGlmdCA9IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDBdKTtcblx0XHRcdHRleFNjYWxlID0gbmV3IEZsb2F0MzJBcnJheShbMSwgMV0pO1xuXHRcdH1cblxuXHRcdGxldCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge1xuXHRcdFx0cG9zaXRpb246IHNwcml0ZS5wb3NpdGlvbixcblx0XHRcdHJvdGF0aW9uOiBzcHJpdGUucm90YXRpb24sXG5cdFx0XHRzaXplOiBzcHJpdGUuc2l6ZSxcblx0XHRcdHNjYWxlOiBzcHJpdGUuc2NhbGUudG9BcnJheSgpLFxuXHRcdFx0aW1hZ2VLZXk6IHNwcml0ZS5pbWFnZUlkLFxuXHRcdFx0dGV4U2hpZnQsXG5cdFx0XHR0ZXhTY2FsZVxuXHRcdH1cblxuXHRcdHJldHVybiBvcHRpb25zO1xuXHR9XG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL0NvbGxlY3Rpb25zL01hcFwiO1xuaW1wb3J0IFF1ZXVlIGZyb20gXCIuLi9EYXRhVHlwZXMvQ29sbGVjdGlvbnMvUXVldWVcIjtcbmltcG9ydCB7IFRpbGVkVGlsZW1hcERhdGEgfSBmcm9tIFwiLi4vRGF0YVR5cGVzL1RpbGVzZXRzL1RpbGVkRGF0YVwiO1xuaW1wb3J0IFN0cmluZ1V0aWxzIGZyb20gXCIuLi9VdGlscy9TdHJpbmdVdGlsc1wiO1xuaW1wb3J0IEF1ZGlvTWFuYWdlciBmcm9tIFwiLi4vU291bmQvQXVkaW9NYW5hZ2VyXCI7XG5pbXBvcnQgU3ByaXRlc2hlZXQgZnJvbSBcIi4uL0RhdGFUeXBlcy9TcHJpdGVzaGVldFwiO1xuaW1wb3J0IFdlYkdMUHJvZ3JhbVR5cGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9SZW5kZXJpbmcvV2ViR0xQcm9ncmFtVHlwZVwiO1xuXG4vKipcbiAqIFRoZSByZXNvdXJjZSBtYW5hZ2VyIGZvciB0aGUgZ2FtZSBlbmdpbmUuXG4gKiBUaGUgcmVzb3VyY2UgbWFuYWdlciBpbnRlcmZhY2VzIHdpdGggdGhlIGxvYWRhYmxlIGFzc2V0cyBvZiBhIGdhbWUgc3VjaCBhcyBpbWFnZXMsIGRhdGEgZmlsZXMsXG4gKiBhbmQgc291bmRzLCB3aGljaCBhcmUgYWxsIGZvdW5kIGluIHRoZSBkaXN0IGZvbGRlci5cbiAqIFRoaXMgY2xhc3MgY29udHJvbHMgbG9hZGluZyBhbmQgdXBkYXRlcyB0aGUgQHJlZmVyZW5jZVtTY2VuZV0gd2l0aCB0aGUgbG9hZGluZyBwcm9ncmVzcywgc28gdGhhdCB0aGUgc2NlbmUgZG9lcyBcbiAqIG5vdCBzdGFydCBiZWZvcmUgYWxsIG5lY2Vzc2FyeSBhc3NldHMgYXJlIGxvYWRlZC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVzb3VyY2VNYW5hZ2VyIHtcbiAgICAvLyBJbnN0YW5jZSBmb3IgdGhlIHNpbmdsZXRvbiBjbGFzc1xuICAgIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBSZXNvdXJjZU1hbmFnZXI7XG4gICAgXG4gICAgLy8gQm9vbGVhbnMgdG8ga2VlcCB0cmFjayBvZiB3aGV0aGVyIG9yIG5vdCB0aGUgUmVzb3VyY2VNYW5hZ2VyIGlzIGN1cnJlbnRseSBsb2FkaW5nIHNvbWV0aGluZ1xuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCBhbnkgcmVzb3VyY2VzIGFyZSBsb2FkaW5nICovXG4gICAgcHJpdmF0ZSBsb2FkaW5nOiBib29sZWFuO1xuICAgIC8qKiBBIGJvb2xlYW4gdG8gaW5kaWNhdGUgdGhhdCB0aGUgYXNzZXRzIGp1c3QgZmluaXNoZWQgbG9hZGluZyAqL1xuICAgIHByaXZhdGUganVzdExvYWRlZDogYm9vbGVhbjtcblxuICAgIC8vIEZ1bmN0aW9ucyB0byBkbyBzb21ldGhpbmcgd2hlbiBsb2FkaW5nIHByb2dyZXNzZXMgb3IgaXMgY29tcGxldGVkIHN1Y2ggYXMgcmVuZGVyIGEgbG9hZGluZyBzY3JlZW5cbiAgICAvKiogQSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIGxvYWRpbmcgcHJvZ3Jlc3NlcyAqL1xuICAgIHB1YmxpYyBvbkxvYWRQcm9ncmVzczogRnVuY3Rpb247XG4gICAgLyoqIEEgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiBsb2FkaW5nIGNvbXBsZXRlcyAqL1xuICAgIHB1YmxpYyBvbkxvYWRDb21wbGV0ZTogRnVuY3Rpb247XG5cblxuICAgIC8qKiBOdW1iZXIgdG8ga2VlcCB0cmFjayBvZiBob3cgbWFueSBpbWFnZXMgbmVlZCB0byBiZSBsb2FkZWQqL1xuICAgIHByaXZhdGUgbG9hZG9ubHlfaW1hZ2VzTG9hZGVkOiBudW1iZXI7XG4gICAgLyoqIE51bWJlciB0byBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IGltYWdlcyBhcmUgbG9hZGVkICovXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9pbWFnZXNUb0xvYWQ6IG51bWJlcjtcbiAgICAvKiogVGhlIHF1ZXVlIG9mIGltYWdlcyB3ZSBtdXN0IGxvYWQgKi9cbiAgICBwcml2YXRlIGxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlOiBRdWV1ZTxLZXlQYXRoUGFpcj47XG4gICAgLyoqIEEgbWFwIG9mIHRoZSBpbWFnZXMgdGhhdCBhcmUgY3VycmVudGx5IGxvYWRlZCBhbmQgYmVpbmcgdXNlZCBieSB0aGUgc2NlbmUuIFRoZSByZWZlcmVuY2UgdG8gdGhlc2UgaW1hZ2VzIG9ubHkgZXhpc3QgaGVyZSBmb3IgZWFzeSBjbGVhbnVwLiAqL1xuICAgIHByaXZhdGUgaW1hZ2VzOiBNYXA8SFRNTEltYWdlRWxlbWVudD47XG5cbiAgICAvKiogTnVtYmVyIHRvIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgdGlsZW1hcHMgbmVlZCB0byBiZSBsb2FkZWQgKi9cbiAgICBwcml2YXRlIGxvYWRvbmx5X3Nwcml0ZXNoZWV0c0xvYWRlZDogbnVtYmVyO1xuICAgIC8qKiBOdW1iZXIgdG8ga2VlcCB0cmFjayBvZiBob3cgbWFueSB0aWxlbWFwcyBhcmUgbG9hZGVkICovXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9zcHJpdGVzaGVldHNUb0xvYWQ6IG51bWJlcjtcbiAgICAvKiogVGhlIHF1ZXVlIG9mIHRpbGVtYXBzIHdlIG11c3QgbG9hZCAqL1xuICAgIHByaXZhdGUgbG9hZG9ubHlfc3ByaXRlc2hlZXRMb2FkaW5nUXVldWU6IFF1ZXVlPEtleVBhdGhQYWlyPjtcbiAgICAvKiogQSBtYXAgb2YgdGhlIHRpbGVtYXBzIHRoYXQgYXJlIGN1cnJlbnRseSBsb2FkZWQgYW5kIChwcmVzdW1hYmx5KSBiZWluZyB1c2VkIGJ5IHRoZSBzY2VuZSAqL1xuICAgIHByaXZhdGUgc3ByaXRlc2hlZXRzOiBNYXA8U3ByaXRlc2hlZXQ+O1xuXG4gICAgLyoqIE51bWJlciB0byBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IHRpbGVtYXBzIG5lZWQgdG8gYmUgbG9hZGVkICovXG4gICAgcHJpdmF0ZSBsb2Fkb25seV90aWxlbWFwc0xvYWRlZDogbnVtYmVyO1xuICAgIC8qKiBOdW1iZXIgdG8ga2VlcCB0cmFjayBvZiBob3cgbWFueSB0aWxlbWFwcyBhcmUgbG9hZGVkICovXG4gICAgcHJpdmF0ZSBsb2Fkb25seV90aWxlbWFwc1RvTG9hZDogbnVtYmVyO1xuICAgIC8qKiBUaGUgcXVldWUgb2YgdGlsZW1hcHMgd2UgbXVzdCBsb2FkICovXG4gICAgcHJpdmF0ZSBsb2Fkb25seV90aWxlbWFwTG9hZGluZ1F1ZXVlOiBRdWV1ZTxLZXlQYXRoUGFpcj47XG4gICAgLyoqIEEgbWFwIG9mIHRoZSB0aWxlbWFwcyB0aGF0IGFyZSBjdXJyZW50bHkgbG9hZGVkIGFuZCAocHJlc3VtYWJseSkgYmVpbmcgdXNlZCBieSB0aGUgc2NlbmUgKi9cbiAgICBwcml2YXRlIHRpbGVtYXBzOiBNYXA8VGlsZWRUaWxlbWFwRGF0YT47XG5cbiAgICAvKiogTnVtYmVyIHRvIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgc291bmRzIG5lZWQgdG8gYmUgbG9hZGVkICovXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9hdWRpb0xvYWRlZDogbnVtYmVyO1xuICAgIC8qKiBOdW1iZXIgdG8ga2VlcCB0cmFjayBvZiBob3cgbWFueSBzb3VuZHMgYXJlIGxvYWRlZCAqL1xuICAgIHByaXZhdGUgbG9hZG9ubHlfYXVkaW9Ub0xvYWQ6IG51bWJlcjtcbiAgICAvKiogVGhlIHF1ZXVlIG9mIHNvdW5kcyB3ZSBtdXN0IGxvYWQgKi9cbiAgICBwcml2YXRlIGxvYWRvbmx5X2F1ZGlvTG9hZGluZ1F1ZXVlOiBRdWV1ZTxLZXlQYXRoUGFpcj47XG4gICAgLyoqIEEgbWFwIG9mIHRoZSBzb3VuZHMgdGhhdCBhcmUgY3VycmVudGx5IGxvYWRlZCBhbmQgKHByZXN1bWFibHkpIGJlaW5nIHVzZWQgYnkgdGhlIHNjZW5lICovXG4gICAgcHJpdmF0ZSBhdWRpb0J1ZmZlcnM6IE1hcDxBdWRpb0J1ZmZlcj47XG5cbiAgICAvKiogVGhlIHRvdGFsIG51bWJlciBvZiBcInR5cGVzXCIgb2YgdGhpbmdzIHRoYXQgbmVlZCB0byBiZSBsb2FkZWQgKGkuZS4gaW1hZ2VzIGFuZCB0aWxlbWFwcykgKi9cbiAgICBwcml2YXRlIGxvYWRvbmx5X3R5cGVzVG9Mb2FkOiBudW1iZXI7XG5cbiAgICBwcml2YXRlIGxvYWRvbmx5X2pzb25Mb2FkZWQ6IG51bWJlcjtcbiAgICBwcml2YXRlIGxvYWRvbmx5X2pzb25Ub0xvYWQ6IG51bWJlcjtcbiAgICBwcml2YXRlIGxvYWRvbmx5X2pzb25Mb2FkaW5nUXVldWU6IFF1ZXVlPEtleVBhdGhQYWlyPjtcbiAgICBwcml2YXRlIGpzb25PYmplY3RzOiBNYXA8UmVjb3JkPHN0cmluZywgYW55Pj47XG5cbiAgICAvKiAjIyMjIyMjIyMjIElORk9STUFUSU9OIFNQRUNJQUwgVE8gV0VCR0wgIyMjIyMjIyMjIyAqL1xuICAgIHByaXZhdGUgZ2xfV2ViR0xBY3RpdmU6IGJvb2xlYW47XG5cbiAgICBwcml2YXRlIGxvYWRvbmx5X2dsX1NoYWRlclByb2dyYW1zTG9hZGVkOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBsb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc1RvTG9hZDogbnVtYmVyO1xuICAgIHByaXZhdGUgbG9hZG9ubHlfZ2xfU2hhZGVyTG9hZGluZ1F1ZXVlOiBRdWV1ZTxLZXlQYXRoX1NoYWRlcj47XG5cbiAgICBwcml2YXRlIGdsX1NoYWRlclByb2dyYW1zOiBNYXA8V2ViR0xQcm9ncmFtVHlwZT47XG5cbiAgICBwcml2YXRlIGdsX1RleHR1cmVzOiBNYXA8bnVtYmVyPjtcbiAgICBwcml2YXRlIGdsX05leHRUZXh0dXJlSUQ6IG51bWJlcjtcbiAgICBwcml2YXRlIGdsX0J1ZmZlcnM6IE1hcDxXZWJHTEJ1ZmZlcj47IFxuXG4gICAgcHJpdmF0ZSBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xuXG4gICAgLyogIyMjIyMjIyMjIyBVTkxPQURJTkcgQU5EIEVYQ0xVU0lPTiBMSVNUICMjIyMjIyMjIyMgKi9cbiAgICAvKiogQSBsaXN0IG9mIHJlc291cmNlcyB0aGF0IHdpbGwgYmUgdW5sb2FkZWQgYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBzY2VuZSAqL1xuICAgIHByaXZhdGUgcmVzb3VyY2VzVG9VbmxvYWQ6IEFycmF5PFJlc291cmNlUmVmZXJlbmNlPjtcblxuICAgIC8qKiBBIGxpc3Qgb2YgcmVzb3VyY2VzIHRvIGtlZXAgdW50aWwgZnVydGhlciBub3RpY2UgKi9cbiAgICBwcml2YXRlIHJlc291cmNlc1RvS2VlcDogQXJyYXk8UmVzb3VyY2VSZWZlcmVuY2U+O1xuXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5qdXN0TG9hZGVkID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5sb2Fkb25seV9pbWFnZXNMb2FkZWQgPSAwO1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlc1RvTG9hZCA9IDA7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWUgPSBuZXcgUXVldWUoKTtcbiAgICAgICAgdGhpcy5pbWFnZXMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNMb2FkZWQgPSAwO1xuICAgICAgICB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c1RvTG9hZCA9IDA7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRMb2FkaW5nUXVldWUgPSBuZXcgUXVldWUoKTtcbiAgICAgICAgdGhpcy5zcHJpdGVzaGVldHMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgdGhpcy5sb2Fkb25seV90aWxlbWFwc0xvYWRlZCA9IDA7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfdGlsZW1hcHNUb0xvYWQgPSAwO1xuICAgICAgICB0aGlzLmxvYWRvbmx5X3RpbGVtYXBMb2FkaW5nUXVldWUgPSBuZXcgUXVldWUoKTtcbiAgICAgICAgdGhpcy50aWxlbWFwcyA9IG5ldyBNYXAoKTtcblxuICAgICAgICB0aGlzLmxvYWRvbmx5X2F1ZGlvTG9hZGVkID0gMDtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9hdWRpb1RvTG9hZCA9IDA7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkaW5nUXVldWUgPSBuZXcgUXVldWUoKTtcbiAgICAgICAgdGhpcy5hdWRpb0J1ZmZlcnMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgdGhpcy5sb2Fkb25seV9qc29uTG9hZGVkID0gMDtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9qc29uVG9Mb2FkID0gMDtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9qc29uTG9hZGluZ1F1ZXVlID0gbmV3IFF1ZXVlKCk7XG4gICAgICAgIHRoaXMuanNvbk9iamVjdHMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc0xvYWRlZCA9IDA7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNUb0xvYWQgPSAwO1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2dsX1NoYWRlckxvYWRpbmdRdWV1ZSA9IG5ldyBRdWV1ZSgpO1xuXG4gICAgICAgIHRoaXMuZ2xfU2hhZGVyUHJvZ3JhbXMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgdGhpcy5nbF9UZXh0dXJlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5nbF9OZXh0VGV4dHVyZUlEID0gMDtcbiAgICAgICAgdGhpcy5nbF9CdWZmZXJzID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIHRoaXMucmVzb3VyY2VzVG9VbmxvYWQgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy5yZXNvdXJjZXNUb0tlZXAgPSBuZXcgQXJyYXkoKTtcbiAgICB9O1xuXG4gICAgLyogIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBTSU5HTEVUT04gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIG9yIGEgbmV3IGluc3RhbmNlIGlmIG5vbmUgZXhpc3RcbiAgICAgKiBAcmV0dXJucyBUaGUgcmVzb3VyY2UgbWFuYWdlclxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBSZXNvdXJjZU1hbmFnZXIge1xuICAgICAgICBpZighdGhpcy5pbnN0YW5jZSl7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IFJlc291cmNlTWFuYWdlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgLyogIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBQVUJMSUMgRlVOQ1RJT04gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyovXG4gICAgLyoqXG4gICAgICogQWN0aXZhdGVzIG9yIGRlYWN0aXZhdGVzIHRoZSB1c2Ugb2YgV2ViR0xcbiAgICAgKiBAcGFyYW0gZmxhZyBUcnVlIGlmIFdlYkdMIHNob3VsZCBiZSB1c2VkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKiBAcGFyYW0gZ2wgVGhlIGluc3RhbmNlIG9mIHRoZSBncmFwaGljcyBjb250ZXh0LCBpZiBhcHBsaWNhYmxlXG4gICAgICovXG4gICAgcHVibGljIHVzZVdlYkdMKGZsYWc6IGJvb2xlYW4sIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5nbF9XZWJHTEFjdGl2ZSA9IGZsYWc7XG5cbiAgICAgICAgaWYodGhpcy5nbF9XZWJHTEFjdGl2ZSl7XG4gICAgICAgICAgICB0aGlzLmdsID0gZ2w7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhbiBpbWFnZSBmcm9tIGZpbGVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gYXNzb2NpYXRlIHRoZSBsb2FkZWQgaW1hZ2Ugd2l0aFxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBpbWFnZSB0byBsb2FkXG4gICAgICovXG4gICAgcHVibGljIGltYWdlKGtleTogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9pbWFnZUxvYWRpbmdRdWV1ZS5lbnF1ZXVlKHtrZXk6IGtleSwgcGF0aDogcGF0aH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlbGxzIHRoZSByZXNvdXJjZSBtYW5hZ2VyIHRvIGtlZXAgdGhpcyByZXNvdXJjZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgcmVzb3VyY2VcbiAgICAgKi9cbiAgICBwdWJsaWMga2VlcEltYWdlKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMua2VlcFJlc291cmNlKGtleSwgUmVzb3VyY2VUeXBlLklNQUdFKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsb2FkZWQgaW1hZ2VcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGxvYWRlZCBpbWFnZVxuICAgICAqIEByZXR1cm5zIFRoZSBpbWFnZSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGtleVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRJbWFnZShrZXk6IHN0cmluZyk6IEhUTUxJbWFnZUVsZW1lbnQge1xuICAgICAgICBsZXQgaW1hZ2UgPSB0aGlzLmltYWdlcy5nZXQoa2V5KTtcbiAgICAgICAgaWYoaW1hZ2UgPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICB0aHJvdyBgVGhlcmUgaXMgbm8gaW1hZ2UgYXNzb2NpYXRlZCB3aXRoIGtleSBcIiR7a2V5fVwiYFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbWFnZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIHNwcml0ZXNoZWV0IGZyb20gZmlsZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBhc3NvY2lhdGUgdGhlIGxvYWRlZCBzcHJpdGVzaGVldCB3aXRoXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gdGhlIHNwcml0ZXNoZWV0IHRvIGxvYWRcbiAgICAgKi9cbiAgICBwdWJsaWMgc3ByaXRlc2hlZXQoa2V5OiBzdHJpbmcsIHBhdGg6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0TG9hZGluZ1F1ZXVlLmVucXVldWUoe2tleToga2V5LCBwYXRoOiBwYXRofSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVsbHMgdGhlIHJlc291cmNlIG1hbmFnZXIgdG8ga2VlcCB0aGlzIHJlc291cmNlXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSByZXNvdXJjZVxuICAgICAqL1xuICAgIHB1YmxpYyBrZWVwU3ByaXRlc2hlZXQoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5rZWVwUmVzb3VyY2Uoa2V5LCBSZXNvdXJjZVR5cGUuU1BSSVRFU0hFRVQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIGxvYWRlZCBzcHJpdGVzaGVldFxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgc3ByaXRlc2hlZXQgdG8gbG9hZFxuICAgICAqIEByZXR1cm5zIFRoZSBsb2FkZWQgU3ByaXRlc2hlZXRcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0U3ByaXRlc2hlZXQoa2V5OiBzdHJpbmcpOiBTcHJpdGVzaGVldCB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwcml0ZXNoZWV0cy5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhbiBhdWRpbyBmaWxlXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBsb2FkZWQgYXVkaW8gZmlsZVxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBhdWRpbyBmaWxlIHRvIGxvYWRcbiAgICAgKi9cbiAgICBwdWJsaWMgYXVkaW8oa2V5OiBzdHJpbmcsIHBhdGg6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2F1ZGlvTG9hZGluZ1F1ZXVlLmVucXVldWUoe2tleToga2V5LCBwYXRoOiBwYXRofSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVsbHMgdGhlIHJlc291cmNlIG1hbmFnZXIgdG8ga2VlcCB0aGlzIHJlc291cmNlXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSByZXNvdXJjZVxuICAgICAqL1xuICAgICBwdWJsaWMga2VlcEF1ZGlvKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMua2VlcFJlc291cmNlKGtleSwgUmVzb3VyY2VUeXBlLkFVRElPKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsb2FkZWQgYXVkaW8gZmlsZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgYXVkaW8gZmlsZSB0byBsb2FkXG4gICAgICogQHJldHVybnMgVGhlIEF1ZGlvQnVmZmVyIGNyZWF0ZWQgZnJvbSB0aGUgbG9hZGVkIGF1ZGlvIGZsZVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRBdWRpbyhrZXk6IHN0cmluZyk6IEF1ZGlvQnVmZmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXVkaW9CdWZmZXJzLmdldChrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWQgYSB0aWxlbWFwIGZyb20gYSBqc29uIGZpbGUuIEF1dG9tYXRpY2FsbHkgbG9hZHMgcmVsYXRlZCBpbWFnZXNcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gYXNzb2NpYXRlIHdpdGggdGhlIGxvYWRlZCB0aWxlbWFwXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gdGhlIHRpbGVtYXAgdG8gbG9hZFxuICAgICAqL1xuICAgIHB1YmxpYyB0aWxlbWFwKGtleTogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV90aWxlbWFwTG9hZGluZ1F1ZXVlLmVucXVldWUoe2tleToga2V5LCBwYXRoOiBwYXRofSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVsbHMgdGhlIHJlc291cmNlIG1hbmFnZXIgdG8ga2VlcCB0aGlzIHJlc291cmNlXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSByZXNvdXJjZVxuICAgICAqL1xuICAgICBwdWJsaWMga2VlcFRpbGVtYXAoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5rZWVwUmVzb3VyY2Uoa2V5LCBSZXNvdXJjZVR5cGUuVElMRU1BUCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmVpdmVzIGEgbG9hZGVkIHRpbGVtYXBcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGxvYWRlZCB0aWxlbWFwXG4gICAgICogQHJldHVybnMgVGhlIHRpbGVtYXAgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGtleVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRUaWxlbWFwKGtleTogc3RyaW5nKTogVGlsZWRUaWxlbWFwRGF0YSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbGVtYXBzLmdldChrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGFuIG9iamVjdCBmcm9tIGEganNvbiBmaWxlLlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgbG9hZGVkIG9iamVjdFxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBqc29uIGZpbGUgdG8gbG9hZFxuICAgICAqL1xuICAgIHB1YmxpYyBvYmplY3Qoa2V5OiBzdHJpbmcsIHBhdGg6IHN0cmluZyl7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfanNvbkxvYWRpbmdRdWV1ZS5lbnF1ZXVlKHtrZXk6IGtleSwgcGF0aDogcGF0aH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlbGxzIHRoZSByZXNvdXJjZSBtYW5hZ2VyIHRvIGtlZXAgdGhpcyByZXNvdXJjZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgcmVzb3VyY2VcbiAgICAgKi9cbiAgICAgcHVibGljIGtlZXBPYmplY3Qoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5rZWVwUmVzb3VyY2Uoa2V5LCBSZXNvdXJjZVR5cGUuSlNPTik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmVpdmVzIGEgbG9hZGVkIG9iamVjdFxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgbG9hZGVkIG9iamVjdFxuICAgICAqIEByZXR1cm5zIFRoZSBvYmplY3QgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGtleVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRPYmplY3Qoa2V5OiBzdHJpbmcpe1xuICAgICAgICByZXR1cm4gdGhpcy5qc29uT2JqZWN0cy5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICAvKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIExPQUQgRlVOQ1RJT04gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyovXG4gICAgLyoqXG4gICAgICogTG9hZHMgYWxsIHJlc291cmNlcyBjdXJyZW50bHkgaW4gdGhlIHF1ZXVlXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWwgd2hlbiB0aGUgcmVzb3VyY2VzIGFyZSBmaW5pc2hlZCBsb2FkaW5nXG4gICAgICovXG4gICAgbG9hZFJlc291cmNlc0Zyb21RdWV1ZShjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV90eXBlc1RvTG9hZCA9IDU7XG5cbiAgICAgICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcblxuICAgICAgICAvLyBMb2FkIGV2ZXJ5dGhpbmcgaW4gdGhlIHF1ZXVlcy4gVGlsZW1hcHMgaGF2ZSB0byBjb21lIGJlZm9yZSBpbWFnZXMgYmVjYXVzZSB0aGV5IHdpbGwgYWRkIG5ldyBpbWFnZXMgdG8gdGhlIHF1ZXVlXG4gICAgICAgIHRoaXMubG9hZFRpbGVtYXBzRnJvbVF1ZXVlKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTG9hZGVkIFRpbGVtYXBzXCIpO1xuICAgICAgICAgICAgdGhpcy5sb2FkU3ByaXRlc2hlZXRzRnJvbVF1ZXVlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxvYWRlZCBTcHJpdGVzaGVldHNcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkSW1hZ2VzRnJvbVF1ZXVlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2FkZWQgSW1hZ2VzXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRBdWRpb0Zyb21RdWV1ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxvYWRlZCBBdWRpb1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZE9iamVjdHNGcm9tUXVldWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTG9hZGVkIE9iamVjdHNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5nbF9XZWJHTEFjdGl2ZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2xfTG9hZFNoYWRlcnNGcm9tUXVldWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2FkZWQgU2hhZGVyc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoTG9hZGluZyhjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoTG9hZGluZyhjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBmaW5pc2hMb2FkaW5nKGNhbGxiYWNrOiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICAvLyBEb25lIGxvYWRpbmdcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuanVzdExvYWRlZCA9IHRydWU7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgLyogIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBVTkxPQUQgRlVOQ1RJT04gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyovXG4gICAgXG4gICAgcHJpdmF0ZSBrZWVwUmVzb3VyY2Uoa2V5OiBzdHJpbmcsIHR5cGU6IFJlc291cmNlVHlwZSk6IHZvaWQge1xuICAgICAgICBjb25zb2xlLmxvZyhcIktlZXAgcmVzb3VyY2UuLi5cIik7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLnJlc291cmNlc1RvVW5sb2FkLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGxldCByZXNvdXJjZSA9IHRoaXMucmVzb3VyY2VzVG9VbmxvYWRbaV07XG4gICAgICAgICAgICBpZihyZXNvdXJjZS5rZXkgPT09IGtleSAmJiByZXNvdXJjZS5yZXNvdXJjZVR5cGUgPT09IHR5cGUpe1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRm91bmQgcmVzb3VyY2UgXCIgKyBrZXkgKyBcIiBvZiB0eXBlIFwiICsgdHlwZSArIFwiLiBLZWVwaW5nLlwiKTtcbiAgICAgICAgICAgICAgICBsZXQgcmVzb3VyY2VUb01vdmUgPSB0aGlzLnJlc291cmNlc1RvVW5sb2FkLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc291cmNlc1RvS2VlcC5wdXNoKC4uLnJlc291cmNlVG9Nb3ZlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogRGVsZXRlcyByZWZlcmVuY2VzIHRvIGFsbCByZXNvdXJjZXMgaW4gdGhlIHJlc291cmNlIG1hbmFnZXJcbiAgICAgKi9cbiAgICB1bmxvYWRBbGxSZXNvdXJjZXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmp1c3RMb2FkZWQgPSBmYWxzZTtcblxuICAgICAgICBmb3IobGV0IHJlc291cmNlIG9mIHRoaXMucmVzb3VyY2VzVG9VbmxvYWQpe1xuICAgICAgICAgICAgLy8gVW5sb2FkIHRoZSByZXNvdXJjZVxuICAgICAgICAgICAgdGhpcy51bmxvYWRSZXNvdXJjZShyZXNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHVubG9hZFJlc291cmNlKHJlc291cmNlOiBSZXNvdXJjZVJlZmVyZW5jZSk6IHZvaWQge1xuICAgICAgICAvLyBEZWxldGUgdGhlIHJlc291cmNlIGl0c2VsZlxuICAgICAgICBzd2l0Y2gocmVzb3VyY2UucmVzb3VyY2VUeXBlKXtcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VUeXBlLklNQUdFOlxuICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VzLmRlbGV0ZShyZXNvdXJjZS5rZXkpO1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuZ2xfV2ViR0xBY3RpdmUpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdsX1RleHR1cmVzLmRlbGV0ZShyZXNvdXJjZS5rZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VUeXBlLlRJTEVNQVA6XG4gICAgICAgICAgICAgICAgdGhpcy50aWxlbWFwcy5kZWxldGUocmVzb3VyY2Uua2V5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VUeXBlLlNQUklURVNIRUVUOlxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlc2hlZXRzLmRlbGV0ZShyZXNvdXJjZS5rZXkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZVR5cGUuQVVESU86XG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb0J1ZmZlcnMuZGVsZXRlKHJlc291cmNlLmtleSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFJlc291cmNlVHlwZS5KU09OOlxuICAgICAgICAgICAgICAgIHRoaXMuanNvbk9iamVjdHMuZGVsZXRlKHJlc291cmNlLmtleSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvKmNhc2UgUmVzb3VyY2VUeXBlLlNIQURFUjpcbiAgICAgICAgICAgICAgICB0aGlzLmdsX1NoYWRlclByb2dyYW1zLmdldChyZXNvdXJjZS5rZXkpLmRlbGV0ZSh0aGlzLmdsKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdsX1NoYWRlclByb2dyYW1zLmRlbGV0ZShyZXNvdXJjZS5rZXkpO1xuICAgICAgICAgICAgICAgIGJyZWFrOyovXG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWxldGUgYW55IGRlcGVuZGVuY2llc1xuICAgICAgICBmb3IobGV0IGRlcGVuZGVuY3kgb2YgcmVzb3VyY2UuZGVwZW5kZW5jaWVzKXtcbiAgICAgICAgICAgIHRoaXMudW5sb2FkUmVzb3VyY2UoZGVwZW5kZW5jeSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIFdPUksgRlVOQ1RJT05TICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMqL1xuICAgIC8qKlxuICAgICAqIExvYWRzIGFsbCB0aWxlbWFwcyBjdXJyZW50bHkgaW4gdGhlIHRpbGVtYXAgbG9hZGluZyBxdWV1ZVxuICAgICAqIEBwYXJhbSBvbkZpbmlzaExvYWRpbmcgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBsb2FkaW5nIGlzIGNvbXBsZXRlXG4gICAgICovXG4gICAgcHJpdmF0ZSBsb2FkVGlsZW1hcHNGcm9tUXVldWUob25GaW5pc2hMb2FkaW5nOiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRvbmx5X3RpbGVtYXBzVG9Mb2FkID0gdGhpcy5sb2Fkb25seV90aWxlbWFwTG9hZGluZ1F1ZXVlLmdldFNpemUoKTtcbiAgICAgICAgdGhpcy5sb2Fkb25seV90aWxlbWFwc0xvYWRlZCA9IDA7XG5cbiAgICAgICAgLy8gSWYgbm8gaXRlbXMgdG8gbG9hZCwgd2UncmUgZmluaXNoZWRcbiAgICAgICAgaWYodGhpcy5sb2Fkb25seV90aWxlbWFwc1RvTG9hZCA9PT0gMCl7XG4gICAgICAgICAgICBvbkZpbmlzaExvYWRpbmcoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlKHRoaXMubG9hZG9ubHlfdGlsZW1hcExvYWRpbmdRdWV1ZS5oYXNJdGVtcygpKXtcbiAgICAgICAgICAgIGxldCB0aWxlbWFwID0gdGhpcy5sb2Fkb25seV90aWxlbWFwTG9hZGluZ1F1ZXVlLmRlcXVldWUoKTtcbiAgICAgICAgICAgIHRoaXMubG9hZFRpbGVtYXAodGlsZW1hcC5rZXksIHRpbGVtYXAucGF0aCwgb25GaW5pc2hMb2FkaW5nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGEgc2luZ3VsYXIgdGlsZW1hcCBcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHRpbGVtYXBcbiAgICAgKiBAcGFyYW0gcGF0aFRvVGlsZW1hcEpTT04gVGhlIHBhdGggdG8gdGhlIHRpbGVtYXAgSlNPTiBmaWxlXG4gICAgICogQHBhcmFtIGNhbGxiYWNrSWZMYXN0IFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3QgdGlsZW1hcCB0byBsb2FkXG4gICAgICovXG4gICAgcHJpdmF0ZSBsb2FkVGlsZW1hcChrZXk6IHN0cmluZywgcGF0aFRvVGlsZW1hcEpTT046IHN0cmluZywgY2FsbGJhY2tJZkxhc3Q6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZFRleHRGaWxlKHBhdGhUb1RpbGVtYXBKU09OLCAoZmlsZVRleHQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgbGV0IHRpbGVtYXBPYmplY3QgPSA8VGlsZWRUaWxlbWFwRGF0YT5KU09OLnBhcnNlKGZpbGVUZXh0KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gV2UgY2FuIHBhcnNlIHRoZSBvYmplY3QgbGF0ZXIgLSBpdCdzIG11Y2ggZmFzdGVyIHRoYW4gbG9hZGluZ1xuICAgICAgICAgICAgdGhpcy50aWxlbWFwcy5hZGQoa2V5LCB0aWxlbWFwT2JqZWN0KTtcbiAgICAgICAgICAgIGxldCByZXNvdXJjZSA9IG5ldyBSZXNvdXJjZVJlZmVyZW5jZShrZXksIFJlc291cmNlVHlwZS5USUxFTUFQKTtcblxuICAgICAgICAgICAgLy8gR3JhYiB0aGUgdGlsZXNldCBpbWFnZXMgd2UgbmVlZCB0byBsb2FkIGFuZCBhZGQgdGhlbSB0byB0aGUgaW1hZ2Vsb2FkaW5nIHF1ZXVlXG4gICAgICAgICAgICBmb3IobGV0IHRpbGVzZXQgb2YgdGlsZW1hcE9iamVjdC50aWxlc2V0cyl7XG4gICAgICAgICAgICAgICAgaWYodGlsZXNldC5pbWFnZSl7XG4gICAgICAgICAgICAgICAgICAgIGxldCBrZXkgPSB0aWxlc2V0LmltYWdlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGF0aCA9IFN0cmluZ1V0aWxzLmdldFBhdGhGcm9tRmlsZVBhdGgocGF0aFRvVGlsZW1hcEpTT04pICsga2V5O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlLmVucXVldWUoe2tleToga2V5LCBwYXRoOiBwYXRoLCBpc0RlcGVuZGVuY3k6IHRydWV9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhpcyBpbWFnZSBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIHRpbGVtYXBcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UuYWRkRGVwZW5kZW5jeShuZXcgUmVzb3VyY2VSZWZlcmVuY2Uoa2V5LCBSZXNvdXJjZVR5cGUuSU1BR0UpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYodGlsZXNldC50aWxlcyl7XG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgdGlsZSBvZiB0aWxlc2V0LnRpbGVzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBrZXkgPSB0aWxlLmltYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhdGggPSBTdHJpbmdVdGlscy5nZXRQYXRoRnJvbUZpbGVQYXRoKHBhdGhUb1RpbGVtYXBKU09OKSArIGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWUuZW5xdWV1ZSh7a2V5OiBrZXksIHBhdGg6IHBhdGgsIGlzRGVwZW5kZW5jeTogdHJ1ZX0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhpcyBpbWFnZSBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIHRpbGVtYXBcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlLmFkZERlcGVuZGVuY3kobmV3IFJlc291cmNlUmVmZXJlbmNlKGtleSwgUmVzb3VyY2VUeXBlLklNQUdFKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgcmVzb3VyY2UgcmVmZXJlbmNlIHRvIHRoZSBsaXN0IG9mIHJlc291cmNlIHRvIHVubG9hZFxuICAgICAgICAgICAgdGhpcy5yZXNvdXJjZXNUb1VubG9hZC5wdXNoKHJlc291cmNlKTtcblxuICAgICAgICAgICAgLy8gRmluaXNoIGxvYWRpbmdcbiAgICAgICAgICAgIHRoaXMuZmluaXNoTG9hZGluZ1RpbGVtYXAoY2FsbGJhY2tJZkxhc3QpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5pc2ggbG9hZGluZyBhIHRpbGVtYXAuIENhbGxzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpZiB0aGlzIGlzIHRoZSBsYXN0IHRpbGVtYXAgYmVpbmcgbG9hZGVkXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3QgdGlsZW1hcCB0byBsb2FkXG4gICAgICovXG4gICAgcHJpdmF0ZSBmaW5pc2hMb2FkaW5nVGlsZW1hcChjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV90aWxlbWFwc0xvYWRlZCArPSAxO1xuXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfdGlsZW1hcHNMb2FkZWQgPT09IHRoaXMubG9hZG9ubHlfdGlsZW1hcHNUb0xvYWQpe1xuICAgICAgICAgICAgLy8gV2UncmUgZG9uZSBsb2FkaW5nIHRpbGVtYXBzXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgYWxsIHNwcml0ZXNoZWV0cyBjdXJyZW50bHkgaW4gdGhlIHNwcml0ZXNoZWV0IGxvYWRpbmcgcXVldWVcbiAgICAgKiBAcGFyYW0gb25GaW5pc2hMb2FkaW5nIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHNwcml0ZXNoZWV0cyBhcmUgZG9uZSBsb2FkaW5nXG4gICAgICovXG4gICAgcHJpdmF0ZSBsb2FkU3ByaXRlc2hlZXRzRnJvbVF1ZXVlKG9uRmluaXNoTG9hZGluZzogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNUb0xvYWQgPSB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0TG9hZGluZ1F1ZXVlLmdldFNpemUoKTtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNMb2FkZWQgPSAwO1xuXG4gICAgICAgIC8vIElmIG5vIGl0ZW1zIHRvIGxvYWQsIHdlJ3JlIGZpbmlzaGVkXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRzVG9Mb2FkID09PSAwKXtcbiAgICAgICAgICAgIG9uRmluaXNoTG9hZGluZygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUodGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldExvYWRpbmdRdWV1ZS5oYXNJdGVtcygpKXtcbiAgICAgICAgICAgIGxldCBzcHJpdGVzaGVldCA9IHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRMb2FkaW5nUXVldWUuZGVxdWV1ZSgpO1xuICAgICAgICAgICAgdGhpcy5sb2FkU3ByaXRlc2hlZXQoc3ByaXRlc2hlZXQua2V5LCBzcHJpdGVzaGVldC5wYXRoLCBvbkZpbmlzaExvYWRpbmcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgYSBzaW5ndWxhciBzcHJpdGVzaGVldCBcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHNwcml0ZXNoZWV0IHRvIGxvYWRcbiAgICAgKiBAcGFyYW0gcGF0aFRvU3ByaXRlc2hlZXRKU09OIFRoZSBwYXRoIHRvIHRoZSBzcHJpdGVzaGVldCBKU09OIGZpbGVcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tJZkxhc3QgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgaWYgdGhpcyBpcyB0aGUgbGFzdCBzcHJpdGVzaGVldFxuICAgICAqL1xuICAgIHByaXZhdGUgbG9hZFNwcml0ZXNoZWV0KGtleTogc3RyaW5nLCBwYXRoVG9TcHJpdGVzaGVldEpTT046IHN0cmluZywgY2FsbGJhY2tJZkxhc3Q6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZFRleHRGaWxlKHBhdGhUb1Nwcml0ZXNoZWV0SlNPTiwgKGZpbGVUZXh0OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIGxldCBzcHJpdGVzaGVldCA9IDxTcHJpdGVzaGVldD5KU09OLnBhcnNlKGZpbGVUZXh0KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gV2UgY2FuIHBhcnNlIHRoZSBvYmplY3QgbGF0ZXIgLSBpdCdzIG11Y2ggZmFzdGVyIHRoYW4gbG9hZGluZ1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVzaGVldHMuYWRkKGtleSwgc3ByaXRlc2hlZXQpO1xuXG4gICAgICAgICAgICBsZXQgcmVzb3VyY2UgPSBuZXcgUmVzb3VyY2VSZWZlcmVuY2Uoa2V5LCBSZXNvdXJjZVR5cGUuU1BSSVRFU0hFRVQpO1xuXG4gICAgICAgICAgICAvLyBHcmFiIHRoZSBpbWFnZSB3ZSBuZWVkIHRvIGxvYWQgYW5kIGFkZCBpdCB0byB0aGUgaW1hZ2Vsb2FkaW5nIHF1ZXVlXG4gICAgICAgICAgICBsZXQgcGF0aCA9IFN0cmluZ1V0aWxzLmdldFBhdGhGcm9tRmlsZVBhdGgocGF0aFRvU3ByaXRlc2hlZXRKU09OKSArIHNwcml0ZXNoZWV0LnNwcml0ZVNoZWV0SW1hZ2U7XG4gICAgICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlLmVucXVldWUoe2tleTogc3ByaXRlc2hlZXQubmFtZSwgcGF0aDogcGF0aCwgaXNEZXBlbmRlbmN5OiB0cnVlfSk7XG5cbiAgICAgICAgICAgIHJlc291cmNlLmFkZERlcGVuZGVuY3kobmV3IFJlc291cmNlUmVmZXJlbmNlKHNwcml0ZXNoZWV0Lm5hbWUsIFJlc291cmNlVHlwZS5JTUFHRSkpO1xuICAgICAgICAgICAgdGhpcy5yZXNvdXJjZXNUb1VubG9hZC5wdXNoKHJlc291cmNlKTtcblxuICAgICAgICAgICAgLy8gRmluaXNoIGxvYWRpbmdcbiAgICAgICAgICAgIHRoaXMuZmluaXNoTG9hZGluZ1Nwcml0ZXNoZWV0KGNhbGxiYWNrSWZMYXN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluaXNoIGxvYWRpbmcgYSBzcHJpdGVzaGVldC4gQ2FsbHMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlmIHRoaXMgaXMgdGhlIGxhc3Qgc3ByaXRlc2hlZXQgYmVpbmcgbG9hZGVkXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3Qgc3ByaXRlc2hlZXQgdG8gbG9hZFxuICAgICAqL1xuICAgIHByaXZhdGUgZmluaXNoTG9hZGluZ1Nwcml0ZXNoZWV0KGNhbGxiYWNrOiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c0xvYWRlZCArPSAxO1xuXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRzTG9hZGVkID09PSB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c1RvTG9hZCl7XG4gICAgICAgICAgICAvLyBXZSdyZSBkb25lIGxvYWRpbmcgc3ByaXRlc2hlZXRzXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgYWxsIGltYWdlcyBjdXJyZW50bHkgaW4gdGhlIGltYWdlIGxvYWRpbmcgcXVldWVcbiAgICAgKiBAcGFyYW0gb25GaW5pc2hMb2FkaW5nIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgaW1hZ2VzIHRvIGxvYWRcbiAgICAgKi9cbiAgICBwcml2YXRlIGxvYWRJbWFnZXNGcm9tUXVldWUob25GaW5pc2hMb2FkaW5nOiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlc1RvTG9hZCA9IHRoaXMubG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWUuZ2V0U2l6ZSgpO1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlc0xvYWRlZCA9IDA7XG5cbiAgICAgICAgLy8gSWYgbm8gaXRlbXMgdG8gbG9hZCwgd2UncmUgZmluaXNoZWRcbiAgICAgICAgaWYodGhpcy5sb2Fkb25seV9pbWFnZXNUb0xvYWQgPT09IDApe1xuICAgICAgICAgICAgb25GaW5pc2hMb2FkaW5nKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSh0aGlzLmxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlLmhhc0l0ZW1zKCkpe1xuICAgICAgICAgICAgbGV0IGltYWdlID0gdGhpcy5sb2Fkb25seV9pbWFnZUxvYWRpbmdRdWV1ZS5kZXF1ZXVlKCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRJbWFnZShpbWFnZS5rZXksIGltYWdlLnBhdGgsIGltYWdlLmlzRGVwZW5kZW5jeSwgb25GaW5pc2hMb2FkaW5nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGEgc2luZ3VsYXIgaW1hZ2VcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGltYWdlIHRvIGxvYWRcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byB0aGUgaW1hZ2UgdG8gbG9hZFxuICAgICAqIEBwYXJhbSBjYWxsYmFja0lmTGFzdCBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IGltYWdlXG4gICAgICovXG4gICAgcHVibGljIGxvYWRJbWFnZShrZXk6IHN0cmluZywgcGF0aDogc3RyaW5nLCBpc0RlcGVuZGVuY3k6IGJvb2xlYW4sIGNhbGxiYWNrSWZMYXN0OiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcblxuICAgICAgICBpbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAvLyBBZGQgdG8gbG9hZGVkIGltYWdlc1xuICAgICAgICAgICAgdGhpcy5pbWFnZXMuYWRkKGtleSwgaW1hZ2UpO1xuXG4gICAgICAgICAgICAvLyBJZiBub3QgYSBkZXBlbmRlbmN5LCBwdXNoIGl0IHRvIHRoZSB1bmxvYWQgbGlzdC4gT3RoZXJ3aXNlIGl0J3MgbWFuYWdlZCBieSBzb21ldGhpbmcgZWxzZVxuICAgICAgICAgICAgaWYoIWlzRGVwZW5kZW5jeSl7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvdXJjZXNUb1VubG9hZC5wdXNoKG5ldyBSZXNvdXJjZVJlZmVyZW5jZShrZXksIFJlc291cmNlVHlwZS5JTUFHRSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBXZWJHTCBpcyBhY3RpdmUsIGNyZWF0ZSBhIHRleHR1cmVcbiAgICAgICAgICAgIGlmKHRoaXMuZ2xfV2ViR0xBY3RpdmUpe1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlV2ViR0xUZXh0dXJlKGtleSwgaW1hZ2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaW5pc2ggaW1hZ2UgbG9hZFxuICAgICAgICAgICAgdGhpcy5maW5pc2hMb2FkaW5nSW1hZ2UoY2FsbGJhY2tJZkxhc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW1hZ2Uuc3JjID0gcGF0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5pc2ggbG9hZGluZyBhbiBpbWFnZS4gSWYgdGhpcyBpcyB0aGUgbGFzdCBpbWFnZSwgaXQgY2FsbHMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3QgaW1hZ2VcbiAgICAgKi9cbiAgICBwcml2YXRlIGZpbmlzaExvYWRpbmdJbWFnZShjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9pbWFnZXNMb2FkZWQgKz0gMTtcblxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X2ltYWdlc0xvYWRlZCA9PT0gdGhpcy5sb2Fkb25seV9pbWFnZXNUb0xvYWQgKXtcbiAgICAgICAgICAgIC8vIFdlJ3JlIGRvbmUgbG9hZGluZyBpbWFnZXNcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhbGwgYXVkaW8gY3VycmVudGx5IGluIHRoZSB0aWxlbWFwIGxvYWRpbmcgcXVldWVcbiAgICAgKiBAcGFyYW0gb25GaW5pc2hMb2FkaW5nIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGlsZW1hcHMgYXJlIGRvbmUgbG9hZGluZ1xuICAgICAqL1xuICAgIHByaXZhdGUgbG9hZEF1ZGlvRnJvbVF1ZXVlKG9uRmluaXNoTG9hZGluZzogRnVuY3Rpb24pe1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2F1ZGlvVG9Mb2FkID0gdGhpcy5sb2Fkb25seV9hdWRpb0xvYWRpbmdRdWV1ZS5nZXRTaXplKCk7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkZWQgPSAwO1xuXG4gICAgICAgIC8vIElmIG5vIGl0ZW1zIHRvIGxvYWQsIHdlJ3JlIGZpbmlzaGVkXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfYXVkaW9Ub0xvYWQgPT09IDApe1xuICAgICAgICAgICAgb25GaW5pc2hMb2FkaW5nKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSh0aGlzLmxvYWRvbmx5X2F1ZGlvTG9hZGluZ1F1ZXVlLmhhc0l0ZW1zKCkpe1xuICAgICAgICAgICAgbGV0IGF1ZGlvID0gdGhpcy5sb2Fkb25seV9hdWRpb0xvYWRpbmdRdWV1ZS5kZXF1ZXVlKCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRBdWRpbyhhdWRpby5rZXksIGF1ZGlvLnBhdGgsIG9uRmluaXNoTG9hZGluZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIGEgc2luZ3VsYXIgYXVkaW8gZmlsZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byB0aGUgYXVkaW8gZmlsZSB0byBsb2FkXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gdGhlIGF1ZGlvIGZpbGUgdG8gbG9hZFxuICAgICAqIEBwYXJhbSBjYWxsYmFja0lmTGFzdCBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IGF1ZGlvIGZpbGUgdG8gbG9hZFxuICAgICAqL1xuICAgIHByaXZhdGUgbG9hZEF1ZGlvKGtleTogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGNhbGxiYWNrSWZMYXN0OiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICBsZXQgYXVkaW9DdHggPSBBdWRpb01hbmFnZXIuZ2V0SW5zdGFuY2UoKS5nZXRBdWRpb0NvbnRleHQoKTtcblxuICAgICAgICBsZXQgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHBhdGgsIHRydWUpO1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cbiAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBhdWRpb0N0eC5kZWNvZGVBdWRpb0RhdGEocmVxdWVzdC5yZXNwb25zZSwgKGJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEFkZCB0byBsaXN0IG9mIGF1ZGlvIGJ1ZmZlcnNcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvQnVmZmVycy5hZGQoa2V5LCBidWZmZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb3VyY2VzVG9VbmxvYWQucHVzaChuZXcgUmVzb3VyY2VSZWZlcmVuY2Uoa2V5LCBSZXNvdXJjZVR5cGUuQVVESU8pKTtcblxuICAgICAgICAgICAgICAgIC8vIEZpbmlzaCBsb2FkaW5nIHNvdW5kXG4gICAgICAgICAgICAgICAgdGhpcy5maW5pc2hMb2FkaW5nQXVkaW8oY2FsbGJhY2tJZkxhc3QpO1xuICAgICAgICAgICAgfSwgKGVycm9yKSA9PntcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkVycm9yIGxvYWRpbmcgc291bmRcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3Quc2VuZCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmlzaCBsb2FkaW5nIGFuIGF1ZGlvIGZpbGUuIENhbGxzIHRoZSBjYWxsYmFjayBmdW5jdG9uIGlmIHRoaXMgaXMgdGhlIGxhc3QgYXVkaW8gc2FtcGxlIGJlaW5nIGxvYWRlZC5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgaWYgdGhpcyBpcyB0aGUgbGFzdCBhdWRpbyBmaWxlIHRvIGxvYWRcbiAgICAgKi9cbiAgICBwcml2YXRlIGZpbmlzaExvYWRpbmdBdWRpbyhjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9hdWRpb0xvYWRlZCArPSAxO1xuXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkZWQgPT09IHRoaXMubG9hZG9ubHlfYXVkaW9Ub0xvYWQpe1xuICAgICAgICAgICAgLy8gV2UncmUgZG9uZSBsb2FkaW5nIGF1ZGlvXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgYWxsIG9iamVjdHMgY3VycmVudGx5IGluIHRoZSBvYmplY3QgbG9hZGluZyBxdWV1ZVxuICAgICAqIEBwYXJhbSBvbkZpbmlzaExvYWRpbmcgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGVyZSBhcmUgbm8gbW9yZSBvYmplY3RzIHRvIGxvYWRcbiAgICAgKi9cbiAgICBwcml2YXRlIGxvYWRPYmplY3RzRnJvbVF1ZXVlKG9uRmluaXNoTG9hZGluZzogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9qc29uVG9Mb2FkID0gdGhpcy5sb2Fkb25seV9qc29uTG9hZGluZ1F1ZXVlLmdldFNpemUoKTtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9qc29uTG9hZGVkID0gMDtcblxuICAgICAgICAvLyBJZiBubyBpdGVtcyB0byBsb2FkLCB3ZSdyZSBmaW5pc2hlZFxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X2pzb25Ub0xvYWQgPT09IDApe1xuICAgICAgICAgICAgb25GaW5pc2hMb2FkaW5nKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSh0aGlzLmxvYWRvbmx5X2pzb25Mb2FkaW5nUXVldWUuaGFzSXRlbXMoKSl7XG4gICAgICAgICAgICBsZXQgb2JqID0gdGhpcy5sb2Fkb25seV9qc29uTG9hZGluZ1F1ZXVlLmRlcXVldWUoKTtcbiAgICAgICAgICAgIHRoaXMubG9hZE9iamVjdChvYmoua2V5LCBvYmoucGF0aCwgb25GaW5pc2hMb2FkaW5nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGEgc2luZ3VsYXIgb2JqZWN0XG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBvYmplY3QgdG8gbG9hZFxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBvYmplY3QgdG8gbG9hZFxuICAgICAqIEBwYXJhbSBjYWxsYmFja0lmTGFzdCBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IG9iamVjdFxuICAgICAqL1xuICAgIHB1YmxpYyBsb2FkT2JqZWN0KGtleTogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGNhbGxiYWNrSWZMYXN0OiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRUZXh0RmlsZShwYXRoLCAoZmlsZVRleHQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgbGV0IG9iaiA9IEpTT04ucGFyc2UoZmlsZVRleHQpO1xuICAgICAgICAgICAgdGhpcy5qc29uT2JqZWN0cy5hZGQoa2V5LCBvYmopO1xuXG4gICAgICAgICAgICB0aGlzLnJlc291cmNlc1RvVW5sb2FkLnB1c2gobmV3IFJlc291cmNlUmVmZXJlbmNlKGtleSwgUmVzb3VyY2VUeXBlLkpTT04pKTtcblxuICAgICAgICAgICAgdGhpcy5maW5pc2hMb2FkaW5nT2JqZWN0KGNhbGxiYWNrSWZMYXN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluaXNoIGxvYWRpbmcgYW4gb2JqZWN0LiBJZiB0aGlzIGlzIHRoZSBsYXN0IG9iamVjdCwgaXQgY2FsbHMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3Qgb2JqZWN0XG4gICAgICovXG4gICAgcHJpdmF0ZSBmaW5pc2hMb2FkaW5nT2JqZWN0KGNhbGxiYWNrOiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2pzb25Mb2FkZWQgKz0gMTtcblxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X2pzb25Mb2FkZWQgPT09IHRoaXMubG9hZG9ubHlfanNvblRvTG9hZCl7XG4gICAgICAgICAgICAvLyBXZSdyZSBkb25lIGxvYWRpbmcgb2JqZWN0c1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qICMjIyMjIyMjIyMgV0VCR0wgU1BFQ0lGSUMgRlVOQ1RJT05TICMjIyMjIyMjIyMgKi9cblxuICAgIHB1YmxpYyBnZXRUZXh0dXJlKGtleTogc3RyaW5nKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2xfVGV4dHVyZXMuZ2V0KGtleSk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldFNoYWRlclByb2dyYW0oa2V5OiBzdHJpbmcpOiBXZWJHTFByb2dyYW0ge1xuICAgICAgICByZXR1cm4gdGhpcy5nbF9TaGFkZXJQcm9ncmFtcy5nZXQoa2V5KS5wcm9ncmFtO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRCdWZmZXIoa2V5OiBzdHJpbmcpOiBXZWJHTEJ1ZmZlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmdsX0J1ZmZlcnMuZ2V0KGtleSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVXZWJHTFRleHR1cmUoaW1hZ2VLZXk6IHN0cmluZywgaW1hZ2U6IEhUTUxJbWFnZUVsZW1lbnQpOiB2b2lkIHtcbiAgICAgICAgLy8gR2V0IHRoZSB0ZXh0dXJlIElEXG4gICAgICAgIGNvbnN0IHRleHR1cmVJRCA9IHRoaXMuZ2V0VGV4dHVyZUlEKHRoaXMuZ2xfTmV4dFRleHR1cmVJRCk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSB0ZXh0dXJlXG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLmdsLmNyZWF0ZVRleHR1cmUoKTtcblxuICAgICAgICAvLyBTZXQgdXAgdGhlIHRleHR1cmVcbiAgICAgICAgLy8gRW5hYmxlIHRleHR1cmUwXG4gICAgICAgIHRoaXMuZ2wuYWN0aXZlVGV4dHVyZSh0ZXh0dXJlSUQpO1xuXG4gICAgICAgIC8vIEJpbmQgb3VyIHRleHR1cmUgdG8gdGV4dHVyZSAwXG4gICAgICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcblxuICAgICAgICAvLyBTZXQgdGhlIHRleHR1cmUgcGFyYW1ldGVyc1xuICAgICAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGhpcy5nbC5MSU5FQVIpO1xuICAgICAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfV1JBUF9TLCB0aGlzLmdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLmdsLkNMQU1QX1RPX0VER0UpO1xuXG4gICAgICAgIC8vIFNldCB0aGUgdGV4dHVyZSBpbWFnZVxuICAgICAgICB0aGlzLmdsLnRleEltYWdlMkQodGhpcy5nbC5URVhUVVJFXzJELCAwLCB0aGlzLmdsLlJHQkEsIHRoaXMuZ2wuUkdCQSwgdGhpcy5nbC5VTlNJR05FRF9CWVRFLCBpbWFnZSk7XG5cbiAgICAgICAgLy8gQWRkIHRoZSB0ZXh0dXJlIHRvIG91ciBtYXAgd2l0aCB0aGUgc2FtZSBrZXkgYXMgdGhlIGltYWdlXG4gICAgICAgIHRoaXMuZ2xfVGV4dHVyZXMuYWRkKGltYWdlS2V5LCB0aGlzLmdsX05leHRUZXh0dXJlSUQpO1xuXG4gICAgICAgIC8vIEluY3JlbWVudCB0aGUga2V5XG4gICAgICAgIHRoaXMuZ2xfTmV4dFRleHR1cmVJRCArPSAxO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0VGV4dHVyZUlEKGlkOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICAvLyBTdGFydCB3aXRoIDkgY2FzZXMgLSB0aGlzIGNhbiBiZSBleHBhbmRlZCBpZiBuZWVkZWQsIGJ1dCBmb3IgdGhlIGJlc3QgcGVyZm9ybWFuY2UsXG4gICAgICAgIC8vIFRleHR1cmVzIHNob3VsZCBiZSBzdGl0Y2hlZCBpbnRvIGFuIGF0bGFzXG4gICAgICAgIHN3aXRjaChpZCl7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiB0aGlzLmdsLlRFWFRVUkUwO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gdGhpcy5nbC5URVhUVVJFMTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTI7XG4gICAgICAgICAgICBjYXNlIDM6IHJldHVybiB0aGlzLmdsLlRFWFRVUkUzO1xuICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gdGhpcy5nbC5URVhUVVJFNDtcbiAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTU7XG4gICAgICAgICAgICBjYXNlIDY6IHJldHVybiB0aGlzLmdsLlRFWFRVUkU2O1xuICAgICAgICAgICAgY2FzZSA3OiByZXR1cm4gdGhpcy5nbC5URVhUVVJFNztcbiAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTg7XG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gdGhpcy5nbC5URVhUVVJFOTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBjcmVhdGVCdWZmZXIoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgaWYodGhpcy5nbF9XZWJHTEFjdGl2ZSl7XG4gICAgICAgICAgICBsZXQgYnVmZmVyID0gdGhpcy5nbC5jcmVhdGVCdWZmZXIoKTtcblxuICAgICAgICAgICAgdGhpcy5nbF9CdWZmZXJzLmFkZChrZXksIGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnF1ZXVlcyBsb2FkaW5nIG9mIGEgbmV3IHNoYWRlciBwcm9ncmFtXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBzaGFkZXIgcHJvZ3JhbVxuICAgICAqIEBwYXJhbSB2U2hhZGVyRmlsZXBhdGggXG4gICAgICogQHBhcmFtIGZTaGFkZXJGaWxlcGF0aCBcbiAgICAgKi9cbiAgICBwdWJsaWMgc2hhZGVyKGtleTogc3RyaW5nLCB2U2hhZGVyRmlsZXBhdGg6IHN0cmluZywgZlNoYWRlckZpbGVwYXRoOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgbGV0IHNwbGl0UGF0aCA9IHZTaGFkZXJGaWxlcGF0aC5zcGxpdChcIi5cIik7XG4gICAgICAgIGxldCBlbmQgPSBzcGxpdFBhdGhbc3BsaXRQYXRoLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmKGVuZCAhPT0gXCJ2c2hhZGVyXCIpe1xuICAgICAgICAgICAgdGhyb3cgYCR7dlNoYWRlckZpbGVwYXRofSBpcyBub3QgYSB2YWxpZCB2ZXJ0ZXggc2hhZGVyIC0gbXVzdCBlbmQgaW4gXCIudnNoYWRlcmA7XG4gICAgICAgIH1cblxuICAgICAgICBzcGxpdFBhdGggPSBmU2hhZGVyRmlsZXBhdGguc3BsaXQoXCIuXCIpO1xuICAgICAgICBlbmQgPSBzcGxpdFBhdGhbc3BsaXRQYXRoLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmKGVuZCAhPT0gXCJmc2hhZGVyXCIpe1xuICAgICAgICAgICAgdGhyb3cgYCR7ZlNoYWRlckZpbGVwYXRofSBpcyBub3QgYSB2YWxpZCB2ZXJ0ZXggc2hhZGVyIC0gbXVzdCBlbmQgaW4gXCIuZnNoYWRlcmA7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcGF0aHMgPSBuZXcgS2V5UGF0aF9TaGFkZXIoKTtcbiAgICAgICAgcGF0aHMua2V5ID0ga2V5O1xuICAgICAgICBwYXRocy52cGF0aCA9IHZTaGFkZXJGaWxlcGF0aDtcbiAgICAgICAgcGF0aHMuZnBhdGggPSBmU2hhZGVyRmlsZXBhdGg7XG5cbiAgICAgICAgdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJMb2FkaW5nUXVldWUuZW5xdWV1ZShwYXRocyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVsbHMgdGhlIHJlc291cmNlIG1hbmFnZXIgdG8ga2VlcCB0aGlzIHJlc291cmNlXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSByZXNvdXJjZVxuICAgICAqL1xuICAgICBwdWJsaWMga2VlcFNoYWRlcihrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLmtlZXBSZXNvdXJjZShrZXksIFJlc291cmNlVHlwZS5JTUFHRSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnbF9Mb2FkU2hhZGVyc0Zyb21RdWV1ZShvbkZpbmlzaExvYWRpbmc6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNUb0xvYWQgPSB0aGlzLmxvYWRvbmx5X2dsX1NoYWRlckxvYWRpbmdRdWV1ZS5nZXRTaXplKCk7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNMb2FkZWQgPSAwO1xuXG4gICAgICAgIC8vIElmIHdlYkdMIGlzbidhY3RpdmUgb3IgdGhlcmUgYXJlIG5vIGl0ZW1zIHRvIGxvYWQsIHdlJ3JlIGZpbmlzaGVkXG4gICAgICAgIGlmKCF0aGlzLmdsX1dlYkdMQWN0aXZlIHx8IHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNUb0xvYWQgPT09IDApe1xuICAgICAgICAgICAgb25GaW5pc2hMb2FkaW5nKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSh0aGlzLmxvYWRvbmx5X2dsX1NoYWRlckxvYWRpbmdRdWV1ZS5oYXNJdGVtcygpKXtcbiAgICAgICAgICAgIGxldCBzaGFkZXIgPSB0aGlzLmxvYWRvbmx5X2dsX1NoYWRlckxvYWRpbmdRdWV1ZS5kZXF1ZXVlKCk7XG4gICAgICAgICAgICB0aGlzLmdsX0xvYWRTaGFkZXIoc2hhZGVyLmtleSwgc2hhZGVyLnZwYXRoLCBzaGFkZXIuZnBhdGgsIG9uRmluaXNoTG9hZGluZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdsX0xvYWRTaGFkZXIoa2V5OiBzdHJpbmcsIHZwYXRoOiBzdHJpbmcsIGZwYXRoOiBzdHJpbmcsIGNhbGxiYWNrSWZMYXN0OiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRUZXh0RmlsZSh2cGF0aCwgKHZGaWxlVGV4dDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2U2hhZGVyID0gdkZpbGVUZXh0O1xuXG4gICAgICAgICAgICB0aGlzLmxvYWRUZXh0RmlsZShmcGF0aCwgKGZGaWxlVGV4dDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZlNoYWRlciA9IGZGaWxlVGV4dFxuXG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgcHJvZ3JhbSBhbmQgc2hhZGVyc1xuICAgICAgICAgICAgICAgIGNvbnN0IFtzaGFkZXJQcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyXSA9IHRoaXMuY3JlYXRlU2hhZGVyUHJvZ3JhbSh2U2hhZGVyLCBmU2hhZGVyKTtcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHdyYXBwZXIgdHlwZVxuICAgICAgICAgICAgICAgIGNvbnN0IHByb2dyYW1XcmFwcGVyID0gbmV3IFdlYkdMUHJvZ3JhbVR5cGUoKTtcbiAgICAgICAgICAgICAgICBwcm9ncmFtV3JhcHBlci5wcm9ncmFtID0gc2hhZGVyUHJvZ3JhbTtcbiAgICAgICAgICAgICAgICBwcm9ncmFtV3JhcHBlci52ZXJ0ZXhTaGFkZXIgPSB2ZXJ0ZXhTaGFkZXI7XG4gICAgICAgICAgICAgICAgcHJvZ3JhbVdyYXBwZXIuZnJhZ21lbnRTaGFkZXIgPSBmcmFnbWVudFNoYWRlcjtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0byBvdXIgbWFwXG4gICAgICAgICAgICAgICAgdGhpcy5nbF9TaGFkZXJQcm9ncmFtcy5hZGQoa2V5LCBwcm9ncmFtV3JhcHBlcik7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlc291cmNlc1RvVW5sb2FkLnB1c2gobmV3IFJlc291cmNlUmVmZXJlbmNlKGtleSwgUmVzb3VyY2VUeXBlLlNIQURFUikpO1xuXG4gICAgICAgICAgICAgICAgLy8gRmluaXNoIGxvYWRpbmdcbiAgICAgICAgICAgICAgICB0aGlzLmdsX0ZpbmlzaExvYWRpbmdTaGFkZXIoY2FsbGJhY2tJZkxhc3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2xfRmluaXNoTG9hZGluZ1NoYWRlcihjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc0xvYWRlZCArPSAxO1xuXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNMb2FkZWQgPT09IHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNUb0xvYWQpe1xuICAgICAgICAgICAgLy8gV2UncmUgZG9uZSBsb2FkaW5nIHNoYWRlcnNcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGNyZWF0ZVNoYWRlclByb2dyYW0odlNoYWRlclNvdXJjZTogc3RyaW5nLCBmU2hhZGVyU291cmNlOiBzdHJpbmcpe1xuICAgICAgICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSB0aGlzLmxvYWRWZXJ0ZXhTaGFkZXIodlNoYWRlclNvdXJjZSk7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gdGhpcy5sb2FkRnJhZ21lbnRTaGFkZXIoZlNoYWRlclNvdXJjZSk7XG4gICAgXG4gICAgICAgIGlmKHZlcnRleFNoYWRlciA9PT0gbnVsbCB8fCBmcmFnbWVudFNoYWRlciA9PT0gbnVsbCl7XG4gICAgICAgICAgICAvLyBXZSBoYWQgYSBwcm9ibGVtIGludGlhbGl6aW5nIC0gZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIENyZWF0ZSBhIHNoYWRlciBwcm9ncmFtXG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLmdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICAgICAgaWYoIXByb2dyYW0pIHtcbiAgICAgICAgICAgIC8vIEVycm9yIGNyZWF0aW5nXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gY3JlYXRlIHByb2dyYW1cIik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICAvLyBBdHRhY2ggb3VyIHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVyXG4gICAgICAgIHRoaXMuZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gICAgICAgIHRoaXMuZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcbiAgICBcbiAgICAgICAgLy8gTGlua1xuICAgICAgICB0aGlzLmdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBpZighdGhpcy5nbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIHRoaXMuZ2wuTElOS19TVEFUVVMpKXtcbiAgICAgICAgICAgIC8vIEVycm9yIGxpbmtpbmdcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5nbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBsaW5rIHByb2dyYW06IFwiICsgZXJyb3IpO1xuICAgIFxuICAgICAgICAgICAgLy8gQ2xlYW4gdXBcbiAgICAgICAgICAgIHRoaXMuZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgICAgIHRoaXMuZ2wuZGVsZXRlU2hhZGVyKHZlcnRleFNoYWRlcik7XG4gICAgICAgICAgICB0aGlzLmdsLmRlbGV0ZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICAvLyBXZSBzdWNjZXNzZnVsbHkgY3JlYXRlIGEgcHJvZ3JhbVxuICAgICAgICByZXR1cm4gW3Byb2dyYW0sIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXJdO1xuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIGxvYWRWZXJ0ZXhTaGFkZXIoc2hhZGVyU291cmNlOiBzdHJpbmcpOiBXZWJHTFNoYWRlcntcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHZlcnRleCBzaGFkZXJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZFNoYWRlcih0aGlzLmdsLlZFUlRFWF9TSEFERVIsIHNoYWRlclNvdXJjZSk7XG4gICAgfVxuICAgIFxuICAgIHByaXZhdGUgbG9hZEZyYWdtZW50U2hhZGVyKHNoYWRlclNvdXJjZTogc3RyaW5nKTogV2ViR0xTaGFkZXJ7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBzaGFkZXJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZFNoYWRlcih0aGlzLmdsLkZSQUdNRU5UX1NIQURFUiwgc2hhZGVyU291cmNlKTtcdFxuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIGxvYWRTaGFkZXIodHlwZTogbnVtYmVyLCBzaGFkZXJTb3VyY2U6IHN0cmluZyk6IFdlYkdMU2hhZGVye1xuICAgICAgICBjb25zdCBzaGFkZXIgPSB0aGlzLmdsLmNyZWF0ZVNoYWRlcih0eXBlKTtcbiAgICBcbiAgICAgICAgLy8gSWYgd2UgY291bGRuJ3QgY3JlYXRlIHRoZSBzaGFkZXIsIGVycm9yXG4gICAgICAgIGlmKHNoYWRlciA9PT0gbnVsbCl7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbmFibGUgdG8gY3JlYXRlIHNoYWRlclwiKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIEFkZCB0aGUgc291cmNlIHRvIHRoZSBzaGFkZXIgYW5kIGNvbXBpbGVcbiAgICAgICAgdGhpcy5nbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzaGFkZXJTb3VyY2UpO1xuICAgICAgICB0aGlzLmdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgICBcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZXJlIHdlcmUgbm8gZXJyb3JzIGR1cmluZyB0aGlzIHByb2Nlc3NcbiAgICAgICAgaWYoIXRoaXMuZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgdGhpcy5nbC5DT01QSUxFX1NUQVRVUykpe1xuICAgICAgICAgICAgLy8gTm90IGNvbXBpbGVkIC0gZXJyb3JcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5nbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcik7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gY29tcGlsZSBzaGFkZXI6IFwiICsgZXJyb3IpO1xuICAgIFxuICAgICAgICAgICAgLy8gQ2xlYW4gdXBcbiAgICAgICAgICAgIHRoaXMuZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICAvLyBTdWNlc3MsIHNvIHJldHVybiB0aGUgc2hhZGVyXG4gICAgICAgIHJldHVybiBzaGFkZXI7XG4gICAgfVxuXG4gICAgLyogIyMjIyMjIyMjIyBHRU5FUkFMIExPQURJTkcgRlVOQ1RJT05TICMjIyMjIyMjIyMgKi9cblxuICAgIHByaXZhdGUgbG9hZFRleHRGaWxlKHRleHRGaWxlUGF0aDogc3RyaW5nLCBjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgbGV0IHhvYmo6IFhNTEh0dHBSZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhvYmoub3ZlcnJpZGVNaW1lVHlwZShcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgICAgIHhvYmoub3BlbignR0VUJywgdGV4dEZpbGVQYXRoLCB0cnVlKTtcbiAgICAgICAgeG9iai5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoKHhvYmoucmVhZHlTdGF0ZSA9PSA0KSAmJiAoeG9iai5zdGF0dXMgPT0gMjAwKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHhvYmoucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgeG9iai5zZW5kKG51bGwpO1xuICAgIH1cblxuICAgIC8qICMjIyMjIyMjIyMgTE9BRElORyBCQVIgSU5GTyAjIyMjIyMjIyMjICovXG5cbiAgICBwcml2YXRlIGdldExvYWRQZXJjZW50KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiAodGhpcy5sb2Fkb25seV90aWxlbWFwc0xvYWRlZC90aGlzLmxvYWRvbmx5X3RpbGVtYXBzVG9Mb2FkXG4gICAgICAgICAgICArIHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRzTG9hZGVkL3RoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRzVG9Mb2FkXG4gICAgICAgICAgICArIHRoaXMubG9hZG9ubHlfaW1hZ2VzTG9hZGVkL3RoaXMubG9hZG9ubHlfaW1hZ2VzVG9Mb2FkXG4gICAgICAgICAgICArIHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkZWQvdGhpcy5sb2Fkb25seV9hdWRpb1RvTG9hZClcbiAgICAgICAgICAgIC8gdGhpcy5sb2Fkb25seV90eXBlc1RvTG9hZDtcbiAgICB9XG5cbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgaWYodGhpcy5sb2FkaW5nKXtcbiAgICAgICAgICAgIGlmKHRoaXMub25Mb2FkUHJvZ3Jlc3Mpe1xuICAgICAgICAgICAgICAgIHRoaXMub25Mb2FkUHJvZ3Jlc3ModGhpcy5nZXRMb2FkUGVyY2VudCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKHRoaXMuanVzdExvYWRlZCl7XG4gICAgICAgICAgICB0aGlzLmp1c3RMb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmKHRoaXMub25Mb2FkQ29tcGxldGUpe1xuICAgICAgICAgICAgICAgIHRoaXMub25Mb2FkQ29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhIHJlZmVyZW5jZSB0byBhIHJlc291cmNlLlxuICogVGhpcyBpcyB1c2VkIGZvciB0aGUgZXhlbXB0aW9uIGxpc3QgdG8gYXNzdXJlIGFzc2V0cyBhbmQgdGhlaXIgZGVwZW5kZW5jaWVzIGRvbid0IGdldFxuICogZGVzdHJveWVkIGlmIHRoZXkgYXJlIHN0aWxsIG5lZWRlZC5cbiAqL1xuY2xhc3MgUmVzb3VyY2VSZWZlcmVuY2Uge1xuICAgIGtleTogc3RyaW5nO1xuICAgIHJlc291cmNlVHlwZTogUmVzb3VyY2VUeXBlO1xuICAgIGRlcGVuZGVuY2llczogQXJyYXk8UmVzb3VyY2VSZWZlcmVuY2U+O1xuXG4gICAgY29uc3RydWN0b3Ioa2V5OiBzdHJpbmcsIHJlc291cmNlVHlwZTogUmVzb3VyY2VUeXBlKXtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMucmVzb3VyY2VUeXBlID0gcmVzb3VyY2VUeXBlO1xuICAgICAgICB0aGlzLiBkZXBlbmRlbmNpZXMgPSBuZXcgQXJyYXkoKTtcbiAgICB9XG5cbiAgICBhZGREZXBlbmRlbmN5KHJlc291cmNlOiBSZXNvdXJjZVJlZmVyZW5jZSk6IHZvaWQge1xuICAgICAgICB0aGlzLmRlcGVuZGVuY2llcy5wdXNoKHJlc291cmNlKTtcbiAgICB9XG59XG5cblxuZW51bSBSZXNvdXJjZVR5cGUge1xuICAgIElNQUdFID0gXCJJTUFHRVwiLFxuICAgIFRJTEVNQVAgPSBcIlRJTEVNQVBcIixcbiAgICBTUFJJVEVTSEVFVCA9IFwiU1BSSVRFU0hFRVRcIixcbiAgICBBVURJTyA9IFwiQVVESU9cIixcbiAgICBKU09OID0gXCJKU09OXCIsXG4gICAgU0hBREVSID0gXCJTSEFERVJcIlxufVxuXG4vKipcbiAqIEEgcGFpciByZXByZXNlbnRpbmcgYSBrZXkgYW5kIHRoZSBwYXRoIG9mIHRoZSByZXNvdXJjZSB0byBsb2FkXG4gKi9cbmNsYXNzIEtleVBhdGhQYWlyIHtcbiAgICBrZXk6IHN0cmluZztcbiAgICBwYXRoOiBzdHJpbmc7XG4gICAgaXNEZXBlbmRlbmN5PzogYm9vbGVhbiA9IGZhbHNlO1xufVxuXG5jbGFzcyBLZXlQYXRoX1NoYWRlciB7XG4gICAga2V5OiBzdHJpbmc7XG4gICAgdnBhdGg6IHN0cmluZztcbiAgICBmcGF0aDogc3RyaW5nO1xufSIsImltcG9ydCBTY2VuZSBmcm9tIFwiLi4vU2NlbmVcIjtcbmltcG9ydCBVSUVsZW1lbnQgZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudFwiO1xuaW1wb3J0IEdyYXBoaWMgZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNcIjtcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uLy4uL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uLy4uL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcbmltcG9ydCB7IEdyYXBoaWNUeXBlIH0gZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL0dyYXBoaWNUeXBlc1wiO1xuaW1wb3J0IHsgVUlFbGVtZW50VHlwZSB9IGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL1VJRWxlbWVudFR5cGVzXCI7XG5pbXBvcnQgUG9pbnQgZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL1BvaW50XCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBCdXR0b24gZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvQnV0dG9uXCI7XG5pbXBvcnQgTGFiZWwgZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvTGFiZWxcIjtcbmltcG9ydCBTbGlkZXIgZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvU2xpZGVyXCI7XG5pbXBvcnQgVGV4dElucHV0IGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL1RleHRJbnB1dFwiO1xuaW1wb3J0IFJlY3QgZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL1JlY3RcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBMaW5lIGZyb20gXCIuLi8uLi9Ob2Rlcy9HcmFwaGljcy9MaW5lXCI7XG5pbXBvcnQgUGFydGljbGUgZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL1BhcnRpY2xlXCI7XG5pbXBvcnQgU3ByaXRlc2hlZXQgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9TcHJpdGVzaGVldFwiO1xuXG4vLyBAaWdub3JlUGFnZVxuXG4vKipcbiAqIEEgZmFjdG9yeSB0aGF0IGFic3RyYWN0cyBhZGRpbmcgQHJlZmVyZW5jZVtDYW52YXNOb2RlXXMgdG8gdGhlIEByZWZlcmVuY2VbU2NlbmVdLlxuICogQWNjZXNzIG1ldGhvZHMgaW4gdGhpcyBmYWN0b3J5IHRocm91Z2ggU2NlbmUuYWRkLlttZXRob2ROYW1lXSgpLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYW52YXNOb2RlRmFjdG9yeSB7XG5cdHByb3RlY3RlZCBzY2VuZTogU2NlbmU7XG5cdHByb3RlY3RlZCByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcblxuXHRpbml0KHNjZW5lOiBTY2VuZSk6IHZvaWQge1xuXHRcdHRoaXMuc2NlbmUgPSBzY2VuZTtcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYW4gaW5zdGFuY2Ugb2YgYSBVSUVsZW1lbnQgdG8gdGhlIGN1cnJlbnQgc2NlbmUgLSBpLmUuIGFueSBjbGFzcyB0aGF0IGV4dGVuZHMgVUlFbGVtZW50XG5cdCAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIFVJRWxlbWVudCB0byBhZGRcblx0ICogQHBhcmFtIGxheWVyTmFtZSBUaGUgbGF5ZXIgdG8gYWRkIHRoZSBVSUVsZW1lbnQgdG9cblx0ICogQHBhcmFtIG9wdGlvbnMgQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIGZlZWQgdG8gdGhlIGNvbnN0cnVjdG9yXG5cdCAqIEByZXR1cm5zIEEgbmV3IFVJRWxlbWVudFxuXHQgKi9cblx0YWRkVUlFbGVtZW50ID0gKHR5cGU6IHN0cmluZyB8IFVJRWxlbWVudFR5cGUsIGxheWVyTmFtZTogc3RyaW5nLCBvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IFVJRWxlbWVudCA9PiB7XG5cdFx0Ly8gR2V0IHRoZSBsYXllclxuXHRcdGxldCBsYXllciA9IHRoaXMuc2NlbmUuZ2V0TGF5ZXIobGF5ZXJOYW1lKTtcblxuXHRcdGxldCBpbnN0YW5jZTogVUlFbGVtZW50O1xuXG5cdFx0c3dpdGNoKHR5cGUpe1xuXHRcdFx0Y2FzZSBVSUVsZW1lbnRUeXBlLkJVVFRPTjpcblx0XHRcdFx0aW5zdGFuY2UgPSB0aGlzLmJ1aWxkQnV0dG9uKG9wdGlvbnMpO1xuXHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFVJRWxlbWVudFR5cGUuTEFCRUw6XG5cdFx0XHRcdGluc3RhbmNlID0gdGhpcy5idWlsZExhYmVsKG9wdGlvbnMpO1xuXHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFVJRWxlbWVudFR5cGUuU0xJREVSOlxuXHRcdFx0XHRpbnN0YW5jZSA9IHRoaXMuYnVpbGRTbGlkZXIob3B0aW9ucyk7XG5cdFx0XHRicmVhaztcblx0XHRcdGNhc2UgVUlFbGVtZW50VHlwZS5URVhUX0lOUFVUOlxuXHRcdFx0XHRpbnN0YW5jZSA9IHRoaXMuYnVpbGRUZXh0SW5wdXQob3B0aW9ucyk7XG5cdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHRocm93IGBVSUVsZW1lbnRUeXBlICcke3R5cGV9JyBkb2VzIG5vdCBleGlzdCwgb3IgaXMgcmVnaXN0ZXJlZCBpbmNvcnJlY3RseS5gXG5cdFx0fVxuXG5cdFx0aW5zdGFuY2Uuc2V0U2NlbmUodGhpcy5zY2VuZSk7XG5cdFx0aW5zdGFuY2UuaWQgPSB0aGlzLnNjZW5lLmdlbmVyYXRlSWQoKTtcblx0XHR0aGlzLnNjZW5lLmdldFNjZW5lR3JhcGgoKS5hZGROb2RlKGluc3RhbmNlKTtcblxuXHRcdC8vIEFkZCBpbnN0YW5jZSB0byBsYXllclxuXHRcdGxheWVyLmFkZE5vZGUoaW5zdGFuY2UpXG5cblx0XHRyZXR1cm4gaW5zdGFuY2U7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIHNwcml0ZSB0byB0aGUgY3VycmVudCBzY2VuZVxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGltYWdlIHRoZSBzcHJpdGUgd2lsbCByZXByZXNlbnRcblx0ICogQHBhcmFtIGxheWVyTmFtZSBUaGUgbGF5ZXIgb24gd2hpY2ggdG8gYWRkIHRoZSBzcHJpdGVcblx0ICogQHJldHVybnMgQSBuZXcgU3ByaXRlXG5cdCAqL1xuXHRhZGRTcHJpdGUgPSAoa2V5OiBzdHJpbmcsIGxheWVyTmFtZTogc3RyaW5nKTogU3ByaXRlID0+IHtcblx0XHRsZXQgbGF5ZXIgPSB0aGlzLnNjZW5lLmdldExheWVyKGxheWVyTmFtZSk7XG5cblx0XHRsZXQgaW5zdGFuY2UgPSBuZXcgU3ByaXRlKGtleSk7XG5cblx0XHQvLyBBZGQgaW5zdGFuY2UgdG8gc2NlbmVcblx0XHRpbnN0YW5jZS5zZXRTY2VuZSh0aGlzLnNjZW5lKTtcblx0XHRpbnN0YW5jZS5pZCA9IHRoaXMuc2NlbmUuZ2VuZXJhdGVJZCgpO1xuXG5cdFx0aWYoISh0aGlzLnNjZW5lLmlzUGFyYWxsYXhMYXllcihsYXllck5hbWUpIHx8IHRoaXMuc2NlbmUuaXNVSUxheWVyKGxheWVyTmFtZSkpKXtcblx0XHRcdHRoaXMuc2NlbmUuZ2V0U2NlbmVHcmFwaCgpLmFkZE5vZGUoaW5zdGFuY2UpO1xuXHRcdH1cblx0XHRcblx0XHQvLyBBZGQgaW5zdGFuY2UgdG8gbGF5ZXJcblx0XHRsYXllci5hZGROb2RlKGluc3RhbmNlKTtcblxuXHRcdHJldHVybiBpbnN0YW5jZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGFuIEFuaW1hdGVkU3ByaXRlIHRvIHRoZSBjdXJyZW50IHNjZW5lXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaW1hZ2UgdGhlIHNwcml0ZSB3aWxsIHJlcHJlc2VudFxuXHQgKiBAcGFyYW0gbGF5ZXJOYW1lIFRoZSBsYXllciBvbiB3aGljaCB0byBhZGQgdGhlIHNwcml0ZVxuXHQgKiBAcmV0dXJucyBBIG5ldyBBbmltYXRlZFNwcml0ZVxuXHQgKi9cblx0YWRkQW5pbWF0ZWRTcHJpdGUgPSA8VCBleHRlbmRzIEFuaW1hdGVkU3ByaXRlPihjb25zdHI6IG5ldyAoczogU3ByaXRlc2hlZXQpID0+IFQsIGtleTogc3RyaW5nLCBsYXllck5hbWU6IHN0cmluZyk6IFQgPT4ge1xuXHRcdGxldCBsYXllciA9IHRoaXMuc2NlbmUuZ2V0TGF5ZXIobGF5ZXJOYW1lKTtcblx0XHRsZXQgc3ByaXRlc2hlZXQgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRTcHJpdGVzaGVldChrZXkpO1xuXHRcdGxldCBpbnN0YW5jZSA9IG5ldyBjb25zdHIoc3ByaXRlc2hlZXQpO1xuXG5cdFx0Ly8gQWRkIGluc3RhbmNlIGZvIHNjZW5lXG5cdFx0aW5zdGFuY2Uuc2V0U2NlbmUodGhpcy5zY2VuZSk7XG5cdFx0aW5zdGFuY2UuaWQgPSB0aGlzLnNjZW5lLmdlbmVyYXRlSWQoKTtcblx0XHRcblx0XHRpZighKHRoaXMuc2NlbmUuaXNQYXJhbGxheExheWVyKGxheWVyTmFtZSkgfHwgdGhpcy5zY2VuZS5pc1VJTGF5ZXIobGF5ZXJOYW1lKSkpe1xuXHRcdFx0dGhpcy5zY2VuZS5nZXRTY2VuZUdyYXBoKCkuYWRkTm9kZShpbnN0YW5jZSk7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIGluc3RhbmNlIHRvIGxheWVyXG5cdFx0bGF5ZXIuYWRkTm9kZShpbnN0YW5jZSk7XG5cblx0XHRyZXR1cm4gaW5zdGFuY2U7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIG5ldyBncmFwaGljIGVsZW1lbnQgdG8gdGhlIGN1cnJlbnQgU2NlbmVcblx0ICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgZ3JhcGhpYyB0byBhZGRcblx0ICogQHBhcmFtIGxheWVyTmFtZSBUaGUgbGF5ZXIgb24gd2hpY2ggdG8gYWRkIHRoZSBncmFwaGljXG5cdCAqIEBwYXJhbSBvcHRpb25zIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBzZW5kIHRvIHRoZSBncmFwaGljIGNvbnN0cnVjdG9yXG5cdCAqIEByZXR1cm5zIEEgbmV3IEdyYXBoaWNcblx0ICovXG5cdGFkZEdyYXBoaWMgPSAodHlwZTogR3JhcGhpY1R5cGUgfCBzdHJpbmcsIGxheWVyTmFtZTogc3RyaW5nLCBvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IEdyYXBoaWMgPT4ge1xuXHRcdC8vIEdldCB0aGUgbGF5ZXJcblx0XHRsZXQgbGF5ZXIgPSB0aGlzLnNjZW5lLmdldExheWVyKGxheWVyTmFtZSk7XG5cblx0XHRsZXQgaW5zdGFuY2U6IEdyYXBoaWM7XG5cblx0XHRzd2l0Y2godHlwZSl7XG5cdFx0XHRjYXNlIEdyYXBoaWNUeXBlLlBPSU5UOlxuXHRcdFx0XHRpbnN0YW5jZSA9IHRoaXMuYnVpbGRQb2ludChvcHRpb25zKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIEdyYXBoaWNUeXBlLkxJTkU6XG5cdFx0XHRcdGluc3RhbmNlID0gdGhpcy5idWlsZExpbmUob3B0aW9ucyk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBHcmFwaGljVHlwZS5SRUNUOlxuXHRcdFx0XHRpbnN0YW5jZSA9IHRoaXMuYnVpbGRSZWN0KG9wdGlvbnMpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgR3JhcGhpY1R5cGUuUEFSVElDTEU6XG5cdFx0XHRcdGluc3RhbmNlID0gdGhpcy5idWlsZFBhcnRpY2xlKG9wdGlvbnMpO1xuXHRcdFx0XHRicmVhaztcdFx0XHRcdFxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgYEdyYXBoaWNUeXBlICcke3R5cGV9JyBkb2VzIG5vdCBleGlzdCwgb3IgaXMgcmVnaXN0ZXJlZCBpbmNvcnJlY3RseS5gXG5cdFx0fVxuXG5cdFx0Ly8gQWRkIGluc3RhbmNlIHRvIHNjZW5lXG5cdFx0aW5zdGFuY2Uuc2V0U2NlbmUodGhpcy5zY2VuZSk7XG5cdFx0aW5zdGFuY2UuaWQgPSB0aGlzLnNjZW5lLmdlbmVyYXRlSWQoKTtcblxuXHRcdGlmKCEodGhpcy5zY2VuZS5pc1BhcmFsbGF4TGF5ZXIobGF5ZXJOYW1lKSB8fCB0aGlzLnNjZW5lLmlzVUlMYXllcihsYXllck5hbWUpKSl7XG5cdFx0XHR0aGlzLnNjZW5lLmdldFNjZW5lR3JhcGgoKS5hZGROb2RlKGluc3RhbmNlKTtcblx0XHR9XG5cblx0XHQvLyBBZGQgaW5zdGFuY2UgdG8gbGF5ZXJcblx0XHRsYXllci5hZGROb2RlKGluc3RhbmNlKTtcblxuXHRcdHJldHVybiBpbnN0YW5jZTtcblx0fVxuXG5cdC8qIC0tLS0tLS0tLS0gQlVJTERFUlMgLS0tLS0tLS0tLSAqL1xuXG5cdGJ1aWxkQnV0dG9uKG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogQnV0dG9uIHtcblx0XHR0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiQnV0dG9uXCIsIG9wdGlvbnMsIFwicG9zaXRpb25cIiwgVmVjMiwgXCJWZWMyXCIpO1xuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJCdXR0b25cIiwgb3B0aW9ucywgXCJ0ZXh0XCIsIFwic3RyaW5nXCIpO1xuXG5cdFx0cmV0dXJuIG5ldyBCdXR0b24ob3B0aW9ucy5wb3NpdGlvbiwgb3B0aW9ucy50ZXh0KTtcblx0fVxuXG5cdGJ1aWxkTGFiZWwob3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiBMYWJlbCB7XG5cdFx0dGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIkxhYmVsXCIsIG9wdGlvbnMsIFwicG9zaXRpb25cIiwgVmVjMiwgXCJWZWMyXCIpO1xuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJMYWJlbFwiLCBvcHRpb25zLCBcInRleHRcIiwgXCJzdHJpbmdcIik7XG5cblx0XHRyZXR1cm4gbmV3IExhYmVsKG9wdGlvbnMucG9zaXRpb24sIG9wdGlvbnMudGV4dClcblx0fVxuXG5cdGJ1aWxkU2xpZGVyKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBTbGlkZXIge1xuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJTbGlkZXJcIiwgb3B0aW9ucywgXCJwb3NpdGlvblwiLCBWZWMyLCBcIlZlYzJcIik7XG5cblx0XHRsZXQgaW5pdFZhbHVlID0gMDtcblx0XHRpZihvcHRpb25zLnZhbHVlICE9PSB1bmRlZmluZWQpe1xuXHRcdFx0aW5pdFZhbHVlID0gb3B0aW9ucy52YWx1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IFNsaWRlcihvcHRpb25zLnBvc2l0aW9uLCBpbml0VmFsdWUpO1xuXHR9XG5cblx0YnVpbGRUZXh0SW5wdXQob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IFRleHRJbnB1dCB7XG5cdFx0dGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIlRleHRJbnB1dFwiLCBvcHRpb25zLCBcInBvc2l0aW9uXCIsIFZlYzIsIFwiVmVjMlwiKTtcblxuXHRcdHJldHVybiBuZXcgVGV4dElucHV0KG9wdGlvbnMucG9zaXRpb24pO1xuXHR9XG5cblx0YnVpbGRQb2ludChvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IFBvaW50IHtcblx0XHR0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiUG9pbnRcIiwgb3B0aW9ucywgXCJwb3NpdGlvblwiLCBWZWMyLCBcIlZlYzJcIik7XG5cblx0XHRyZXR1cm4gbmV3IFBvaW50KG9wdGlvbnMucG9zaXRpb24pO1xuXHR9XG5cblx0YnVpbGRQYXJ0aWNsZShvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IFBvaW50IHtcblx0XHR0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiUGFydGljbGVcIiwgb3B0aW9ucywgXCJwb3NpdGlvblwiLCBWZWMyLCBcIlZlYzJcIik7XG5cdFx0dGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIlBhcnRpY2xlXCIsIG9wdGlvbnMsIFwic2l6ZVwiLCBWZWMyLCBcIlZlYzJcIik7XG5cdFx0dGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIlBhcnRpY2xlXCIsIG9wdGlvbnMsIFwibWFzc1wiLCBcIm51bWJlclwiLCBcIm51bWJlclwiKTtcblxuXHRcdC8vQ2hhbmdlZCBmb3IgdGVzdGluZ1xuXHRcdHJldHVybiBuZXcgUGFydGljbGUob3B0aW9ucy5wb3NpdGlvbiwgb3B0aW9ucy5zaXplLCBvcHRpb25zLm1hc3MpO1xuXHR9XG5cblx0YnVpbGRMaW5lKG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUG9pbnQge1xuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJMaW5lXCIsIG9wdGlvbnMsIFwic3RhcnRcIiwgVmVjMiwgXCJWZWMyXCIpO1xuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJMaW5lXCIsIG9wdGlvbnMsIFwiZW5kXCIsIFZlYzIsIFwiVmVjMlwiKTtcblxuXHRcdHJldHVybiBuZXcgTGluZShvcHRpb25zLnN0YXJ0LCBvcHRpb25zLmVuZCk7XG5cdH1cblxuXHRidWlsZFJlY3Qob3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiBSZWN0IHtcblx0XHR0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiUmVjdFwiLCBvcHRpb25zLCBcInBvc2l0aW9uXCIsIFZlYzIsIFwiVmVjMlwiKTtcblx0XHR0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiUmVjdFwiLCBvcHRpb25zLCBcInNpemVcIiwgVmVjMiwgXCJWZWMyXCIpO1xuXG5cdFx0cmV0dXJuIG5ldyBSZWN0KG9wdGlvbnMucG9zaXRpb24sIG9wdGlvbnMuc2l6ZSk7XG5cdH1cblxuXHQvKiAtLS0tLS0tLS0tIEVSUk9SIEhBTkRMSU5HIC0tLS0tLS0tLS0gKi9cblxuXHRjaGVja0lmUHJvcEV4aXN0czxUPihvYmplY3ROYW1lOiBzdHJpbmcsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4sIHByb3A6IHN0cmluZywgdHlwZTogKG5ldyAoLi4uYXJnczogYW55KSA9PiBUKSB8IHN0cmluZywgdHlwZU5hbWU/OiBzdHJpbmcpe1xuXHRcdGlmKCFvcHRpb25zIHx8IG9wdGlvbnNbcHJvcF0gPT09IHVuZGVmaW5lZCl7XG5cdFx0XHQvLyBDaGVjayB0aGF0IHRoZSBvcHRpb25zIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5XG5cdFx0XHR0aHJvdyBgJHtvYmplY3ROYW1lfSBvYmplY3QgcmVxdWlyZXMgYXJndW1lbnQgJHtwcm9wfSBvZiB0eXBlICR7dHlwZU5hbWV9LCBidXQgbm9uZSB3YXMgcHJvdmlkZWQuYDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gQ2hlY2sgdGhhdCB0aGUgcHJvcGVydHkgaGFzIHRoZSBjb3JyZWN0IHR5cGVcblx0XHRcdGlmKCh0eXBlb2YgdHlwZSkgPT09IFwic3RyaW5nXCIpe1xuXHRcdFx0XHRpZighKHR5cGVvZiBvcHRpb25zW3Byb3BdID09PSB0eXBlKSl7XG5cdFx0XHRcdFx0dGhyb3cgYCR7b2JqZWN0TmFtZX0gb2JqZWN0IHJlcXVpcmVzIGFyZ3VtZW50ICR7cHJvcH0gb2YgdHlwZSAke3R5cGV9LCBidXQgcHJvdmlkZWQgJHtwcm9wfSB3YXMgbm90IG9mIHR5cGUgJHt0eXBlfS5gO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYodHlwZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKXtcblx0XHRcdFx0Ly8gSWYgdHlwZSBpcyBhIGNvbnN0cnVjdG9yLCBjaGVjayBhZ2FpbnN0IHRoYXRcblx0XHRcdFx0aWYoIShvcHRpb25zW3Byb3BdIGluc3RhbmNlb2YgdHlwZSkpe1xuXHRcdFx0XHRcdHRocm93IGAke29iamVjdE5hbWV9IG9iamVjdCByZXF1aXJlcyBhcmd1bWVudCAke3Byb3B9IG9mIHR5cGUgJHt0eXBlTmFtZX0sIGJ1dCBwcm92aWRlZCAke3Byb3B9IHdhcyBub3Qgb2YgdHlwZSAke3R5cGVOYW1lfS5gO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBgJHtvYmplY3ROYW1lfSBvYmplY3QgcmVxdWlyZXMgYXJndW1lbnQgJHtwcm9wfSBvZiB0eXBlICR7dHlwZU5hbWV9LCBidXQgcHJvdmlkZWQgJHtwcm9wfSB3YXMgbm90IG9mIHR5cGUgJHt0eXBlTmFtZX0uYDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0iLCJpbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lXCI7XG5pbXBvcnQgQ2FudmFzTm9kZUZhY3RvcnkgZnJvbSBcIi4vQ2FudmFzTm9kZUZhY3RvcnlcIjtcbmltcG9ydCBUaWxlbWFwRmFjdG9yeSBmcm9tIFwiLi9UaWxlbWFwRmFjdG9yeVwiO1xuaW1wb3J0IFRpbGVtYXAgZnJvbSBcIi4uLy4uL05vZGVzL1RpbGVtYXBcIjtcbmltcG9ydCB7IFVJRWxlbWVudFR5cGUgfSBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9VSUVsZW1lbnRUeXBlc1wiO1xuaW1wb3J0IFVJRWxlbWVudCBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50XCI7XG5pbXBvcnQgU3ByaXRlIGZyb20gXCIuLi8uLi9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZVwiO1xuaW1wb3J0IHsgR3JhcGhpY1R5cGUgfSBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY3MvR3JhcGhpY1R5cGVzXCI7XG5pbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY1wiO1xuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi8uLi9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBMYXllciBmcm9tIFwiLi4vTGF5ZXJcIjtcbmltcG9ydCBTcHJpdGVzaGVldCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1Nwcml0ZXNoZWV0XCI7XG5cbi8qKlxuICogVGhlIG1hbmFnZXIgb2YgYWxsIGZhY3RvcmllcyB1c2VkIGZvciBhZGRpbmcgQHJlZmVyZW5jZVtHYW1lTm9kZV1zIHRvIHRoZSBAcmVmZXJlbmNlW1NjZW5lXS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmFjdG9yeU1hbmFnZXIge1xuXG4gICAgLy8gQ29uc3RydWN0b3JzIGFyZSBjYWxsZWQgaGVyZSB0byBhbGxvdyBhc3NpZ25tZW50IG9mIHRoZWlyIGZ1bmN0aW9ucyB0byBmdW5jdGlvbnMgaW4gdGhpcyBjbGFzc1xuICAgIHByaXZhdGUgY2FudmFzTm9kZUZhY3Rvcnk6IENhbnZhc05vZGVGYWN0b3J5ID0gbmV3IENhbnZhc05vZGVGYWN0b3J5KCk7XG4gICAgcHJpdmF0ZSB0aWxlbWFwRmFjdG9yeTogVGlsZW1hcEZhY3RvcnkgPSBuZXcgVGlsZW1hcEZhY3RvcnkoKTtcblxuICAgIGNvbnN0cnVjdG9yKHNjZW5lOiBTY2VuZSwgdGlsZW1hcHM6IEFycmF5PFRpbGVtYXA+KXtcbiAgICAgICAgdGhpcy5jYW52YXNOb2RlRmFjdG9yeS5pbml0KHNjZW5lKTtcbiAgICAgICAgdGhpcy50aWxlbWFwRmFjdG9yeS5pbml0KHNjZW5lLCB0aWxlbWFwcyk7XG4gICAgfVxuXG4gICAgLy8gRXhwb3NlIGFsbCBvZiB0aGUgZmFjdG9yaWVzIHRocm91Z2ggdGhlIGZhY3RvcnkgbWFuYWdlclxuICAgIC8qKlxuXHQgKiBBZGRzIGFuIGluc3RhbmNlIG9mIGEgVUlFbGVtZW50IHRvIHRoZSBjdXJyZW50IHNjZW5lIC0gaS5lLiBhbnkgY2xhc3MgdGhhdCBleHRlbmRzIFVJRWxlbWVudFxuXHQgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiBVSUVsZW1lbnQgdG8gYWRkXG5cdCAqIEBwYXJhbSBsYXllck5hbWUgVGhlIGxheWVyIHRvIGFkZCB0aGUgVUlFbGVtZW50IHRvXG5cdCAqIEBwYXJhbSBvcHRpb25zIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBmZWVkIHRvIHRoZSBjb25zdHJ1Y3RvclxuXHQgKiBAcmV0dXJucyBBIG5ldyBVSUVsZW1lbnRcblx0ICovXG4gICAgdWlFbGVtZW50KHR5cGU6IHN0cmluZyB8IFVJRWxlbWVudFR5cGUsIGxheWVyTmFtZTogc3RyaW5nLCBvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IFVJRWxlbWVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhc05vZGVGYWN0b3J5LmFkZFVJRWxlbWVudCh0eXBlLCBsYXllck5hbWUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuXHQgKiBBZGRzIGEgc3ByaXRlIHRvIHRoZSBjdXJyZW50IHNjZW5lXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaW1hZ2UgdGhlIHNwcml0ZSB3aWxsIHJlcHJlc2VudFxuXHQgKiBAcGFyYW0gbGF5ZXJOYW1lIFRoZSBsYXllciBvbiB3aGljaCB0byBhZGQgdGhlIHNwcml0ZVxuXHQgKiBAcmV0dXJucyBBIG5ldyBTcHJpdGVcblx0ICovXG5cdHNwcml0ZShrZXk6IHN0cmluZywgbGF5ZXJOYW1lOiBzdHJpbmcpOiBTcHJpdGUge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXNOb2RlRmFjdG9yeS5hZGRTcHJpdGUoa2V5LCBsYXllck5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuXHQgKiBBZGRzIGFuIEFuaW1hdGVkU3ByaXRlIHRvIHRoZSBjdXJyZW50IHNjZW5lXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaW1hZ2UgdGhlIHNwcml0ZSB3aWxsIHJlcHJlc2VudFxuXHQgKiBAcGFyYW0gbGF5ZXJOYW1lIFRoZSBsYXllciBvbiB3aGljaCB0byBhZGQgdGhlIHNwcml0ZVxuXHQgKiBAcmV0dXJucyBBIG5ldyBBbmltYXRlZFNwcml0ZVxuXHQgKi9cblx0YW5pbWF0ZWRTcHJpdGU8VCBleHRlbmRzIEFuaW1hdGVkU3ByaXRlPihjb25zdHI6IG5ldyAoczogU3ByaXRlc2hlZXQpID0+IFQsIGtleTogc3RyaW5nLCBsYXllck5hbWU6IHN0cmluZyk6IFQge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXNOb2RlRmFjdG9yeS5hZGRBbmltYXRlZFNwcml0ZShjb25zdHIsIGtleSwgbGF5ZXJOYW1lKTtcbiAgICB9XG5cbiAgICAvKipcblx0ICogQWRkcyBhIG5ldyBncmFwaGljIGVsZW1lbnQgdG8gdGhlIGN1cnJlbnQgU2NlbmVcblx0ICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgZ3JhcGhpYyB0byBhZGRcblx0ICogQHBhcmFtIGxheWVyTmFtZSBUaGUgbGF5ZXIgb24gd2hpY2ggdG8gYWRkIHRoZSBncmFwaGljXG5cdCAqIEBwYXJhbSBvcHRpb25zIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBzZW5kIHRvIHRoZSBncmFwaGljIGNvbnN0cnVjdG9yXG5cdCAqIEByZXR1cm5zIEEgbmV3IEdyYXBoaWNcblx0ICovXG5cdGdyYXBoaWModHlwZTogR3JhcGhpY1R5cGUgfCBzdHJpbmcsIGxheWVyTmFtZTogc3RyaW5nLCBvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IEdyYXBoaWMge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXNOb2RlRmFjdG9yeS5hZGRHcmFwaGljKHR5cGUsIGxheWVyTmFtZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHRpbGVtYXAgdG8gdGhlIHNjZW5lXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBsb2FkZWQgdGlsZW1hcCB0byBsb2FkXG4gICAgICogQHBhcmFtIGNvbnN0ciBUaGUgY29uc3RydWN0b3Igb2YgdGhlIGRlc2lyZWQgdGlsZW1hcFxuICAgICAqIEBwYXJhbSBhcmdzIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHNlbmQgdG8gdGhlIHRpbGVtYXAgY29uc3RydWN0b3JcbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBMYXllcnMsIGVhY2ggb2Ygd2hpY2ggY29udGFpbnMgYSBsYXllciBvZiB0aGUgdGlsZW1hcCBhcyBpdHMgb3duIFRpbGVtYXAgaW5zdGFuY2UuXG4gICAgICovXG5cdHRpbGVtYXAoa2V5OiBzdHJpbmcsIHNjYWxlPzogVmVjMik6IEFycmF5PExheWVyPiB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbGVtYXBGYWN0b3J5LmFkZChrZXksIHNjYWxlKTtcbiAgICB9XG59IiwiaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZVwiO1xuaW1wb3J0IFRpbGVtYXAgZnJvbSBcIi4uLy4uL05vZGVzL1RpbGVtYXBcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBPcnRob2dvbmFsVGlsZW1hcCBmcm9tIFwiLi4vLi4vTm9kZXMvVGlsZW1hcHMvT3J0aG9nb25hbFRpbGVtYXBcIjtcbmltcG9ydCBMYXllciBmcm9tIFwiLi4vTGF5ZXJcIjtcbmltcG9ydCBUaWxlc2V0IGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVGlsZXNldHMvVGlsZXNldFwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgeyBUaWxlZENvbGxlY3Rpb25UaWxlIH0gZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlZERhdGFcIjtcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uLy4uL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XG5pbXBvcnQgUG9zaXRpb25HcmFwaCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL0dyYXBocy9Qb3NpdGlvbkdyYXBoXCI7XG5pbXBvcnQgTmF2bWVzaCBmcm9tIFwiLi4vLi4vUGF0aGZpbmRpbmcvTmF2bWVzaFwiO1xuaW1wb3J0IElzb21ldHJpY1RpbGVtYXAgZnJvbSBcIi4uLy4uL05vZGVzL1RpbGVtYXBzL0lzb21ldHJpY1RpbGVtYXBcIjtcbmltcG9ydCBTdGFnZ2VyZWRJc29tZXRyaWNUaWxlbWFwIGZyb20gXCIuLi8uLi9Ob2Rlcy9UaWxlbWFwcy9TdGFnZ2VyZWRJc29tZXRyaWNUaWxlbWFwXCI7XG5cbi8vIEBpZ25vcmVQYWdlXG5leHBvcnQgZW51bSBUaWxlbWFwT3JpZW50YXRpb24ge1xuICAgIE9SVEhPR09OQUwgPSBcIm9ydGhvZ29uYWxcIixcbiAgICBJU09NRVRSSUMgPSBcImlzb21ldHJpY1wiLFxuICAgIFNUQUdHRVJFRF9JU09NRVRSSUMgPSBcInN0YWdnZXJlZFwiXG59XG5cblxuLyoqXG4gKiBBIGZhY3RvcnkgdGhhdCBhYnN0cmFjdHMgYWRkaW5nIEByZWZlcmVuY2VbVGlsZW1hcF1zIHRvIHRoZSBAcmVmZXJlbmNlW1NjZW5lXS5cbiAqIEFjY2VzcyBtZXRob2RzIGluIHRoaXMgZmFjdG9yeSB0aHJvdWdoIFNjZW5lLmFkZC5bbWV0aG9kTmFtZV0oKS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGlsZW1hcEZhY3Rvcnkge1xuICAgIHByaXZhdGUgc2NlbmU6IFNjZW5lO1xuICAgIHByaXZhdGUgdGlsZW1hcHM6IEFycmF5PFRpbGVtYXA+O1xuICAgIHByaXZhdGUgcmVzb3VyY2VNYW5hZ2VyOiBSZXNvdXJjZU1hbmFnZXI7XG4gICAgXG4gICAgaW5pdChzY2VuZTogU2NlbmUsIHRpbGVtYXBzOiBBcnJheTxUaWxlbWFwPik6IHZvaWQge1xuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgICAgIHRoaXMudGlsZW1hcHMgPSB0aWxlbWFwcztcbiAgICAgICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPIC0gVGhpcyBpcyBzcGVjaWZpY2FsbHkgY2F0ZXJlZCB0byBUaWxlZCB0aWxlbWFwcyByaWdodCBub3cuIEluIHRoZSBmdXR1cmUsXG4gICAgLy8gaXQgd291bGQgYmUgZ29vZCB0byBoYXZlIGEgXCJwYXJzZVRpbGVtYXBcIiBmdW5jdGlvbiB0aGF0IHdvdWxkIGNvbnZlcnQgdGhlIHRpbGVtYXBcbiAgICAvLyBkYXRhIGludG8gYSBzdGFuZGFyZCBmb3JtYXQuIFRoaXMgY291bGQgYWxsb3cgZm9yIHN1cHBvcnQgZnJvbSBvdGhlciBwcm9ncmFtc1xuICAgIC8vIG9yIHRoZSBkZXZlbG9wbWVudCBvZiBhbiBpbnRlcm5hbCBsZXZlbCBidWlsZGVyIHRvb2xcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgdGlsZW1hcCB0byB0aGUgc2NlbmVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGxvYWRlZCB0aWxlbWFwIHRvIGxvYWRcbiAgICAgKiBAcGFyYW0gY29uc3RyIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgZGVzaXJlZCB0aWxlbWFwXG4gICAgICogQHBhcmFtIGFyZ3MgQWRkaXRpb25hbCBhcmd1bWVudHMgdG8gc2VuZCB0byB0aGUgdGlsZW1hcCBjb25zdHJ1Y3RvclxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIExheWVycywgZWFjaCBvZiB3aGljaCBjb250YWlucyBhIGxheWVyIG9mIHRoZSB0aWxlbWFwIGFzIGl0cyBvd24gVGlsZW1hcCBpbnN0YW5jZS5cbiAgICAgKi9cblx0YWRkID0gKGtleTogc3RyaW5nLCBzY2FsZTogVmVjMiA9IG5ldyBWZWMyKDEsIDEpKTogQXJyYXk8TGF5ZXI+ID0+IHtcbiAgICAgICAgLy8gR2V0IFRpbGVtYXAgRGF0YVxuICAgICAgICBsZXQgdGlsZW1hcERhdGEgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRUaWxlbWFwKGtleSk7XG5cbiAgICAgICAgLy8gU2V0IHRoZSBjb25zdHJ1Y3RvciBmb3IgdGhpcyB0aWxlbWFwIHRvIGVpdGhlciBiZSBvcnRob2dyYXBoaWMgb3IgaXNvbWV0cmljXG4gICAgICAgIGxldCBjb25zdHI6IG5ldyguLi5hcmdzOiBhbnkpID0+IFRpbGVtYXA7XG5cbiAgICAgICAgc3dpdGNoKHRpbGVtYXBEYXRhLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIFRpbGVtYXBPcmllbnRhdGlvbi5PUlRIT0dPTkFMOiB7XG4gICAgICAgICAgICAgICAgY29uc3RyID0gT3J0aG9nb25hbFRpbGVtYXA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFRpbGVtYXBPcmllbnRhdGlvbi5JU09NRVRSSUM6IHtcbiAgICAgICAgICAgICAgICBjb25zdHIgPSBJc29tZXRyaWNUaWxlbWFwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBUaWxlbWFwT3JpZW50YXRpb24uU1RBR0dFUkVEX0lTT01FVFJJQzoge1xuICAgICAgICAgICAgICAgIGNvbnN0ciA9IFN0YWdnZXJlZElzb21ldHJpY1RpbGVtYXA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIFRpbGVtYXAgT3JpZW50YXRpb24gXCIke3RpbGVtYXBEYXRhLm9yaWVudGF0aW9ufVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSByZXR1cm4gdmFsdWUgYXJyYXlcbiAgICAgICAgbGV0IHNjZW5lTGF5ZXJzID0gbmV3IEFycmF5PExheWVyPigpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhbGwgb2YgdGhlIHRpbGVzZXRzIGZvciB0aGlzIHRpbGVtYXBcbiAgICAgICAgbGV0IHRpbGVzZXRzID0gbmV3IEFycmF5PFRpbGVzZXQ+KCk7XG5cbiAgICAgICAgbGV0IGNvbGxlY3Rpb25UaWxlcyA9IG5ldyBBcnJheTxUaWxlZENvbGxlY3Rpb25UaWxlPigpO1xuXG4gICAgICAgIGZvcihsZXQgdGlsZXNldCBvZiB0aWxlbWFwRGF0YS50aWxlc2V0cyl7XG4gICAgICAgICAgICBpZih0aWxlc2V0LmltYWdlKXtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgc3RhbmRhcmQgdGlsZXNldCBhbmQgbm90IGEgY29sbGVjdGlvbiwgY3JlYXRlIGEgdGlsZXNldCBmb3IgaXQuXG4gICAgICAgICAgICAgICAgLy8gVE9ETyAtIFdlIGFyZSBpZ25vcmluZyBjb2xsZWN0aW9uIHRpbGVzZXRzIGZvciBub3cuIFRoaXMgaXMgbGlrZWx5IG5vdCBhIGdyZWF0IGlkZWEgaW4gcHJhY3RpY2UsXG4gICAgICAgICAgICAgICAgLy8gYXMgdGhlb3JldGljYWxseSBzb21lb25lIGNvdWxkIHdhbnQgdG8gdXNlIG9uZSBmb3IgYSBzdGFuZGFyZCB0aWxlbWFwLiBXZSBhcmUgYXNzdW1pbmcgZm9yIG5vd1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgd2Ugb25seSB3YW50IHRvIHVzZSB0aGVtIGZvciBvYmplY3QgbGF5ZXJzXG4gICAgICAgICAgICAgICAgdGlsZXNldHMucHVzaChuZXcgVGlsZXNldCh0aWxlc2V0KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpbGVzZXQudGlsZXMuZm9yRWFjaCh0aWxlID0+IHRpbGUuaWQgKz0gdGlsZXNldC5maXJzdGdpZCk7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvblRpbGVzLnB1c2goLi4udGlsZXNldC50aWxlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb29wIG92ZXIgdGhlIGxheWVycyBvZiB0aGUgdGlsZW1hcCBhbmQgY3JlYXRlIHRpbGVkbGF5ZXJzIG9yIG9iamVjdCBsYXllcnNcbiAgICAgICAgZm9yKGxldCBsYXllciBvZiB0aWxlbWFwRGF0YS5sYXllcnMpe1xuXG4gICAgICAgICAgICBsZXQgc2NlbmVMYXllcjtcbiAgICAgICAgICAgIGxldCBpc1BhcmFsbGF4TGF5ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBkZXB0aCA9IDA7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKGxheWVyLnByb3BlcnRpZXMpe1xuICAgICAgICAgICAgICAgIGZvcihsZXQgcHJvcCBvZiBsYXllci5wcm9wZXJ0aWVzKXtcbiAgICAgICAgICAgICAgICAgICAgaWYocHJvcC5uYW1lID09PSBcIlBhcmFsbGF4XCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNQYXJhbGxheExheWVyID0gcHJvcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHByb3AubmFtZSA9PT0gXCJEZXB0aFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXB0aCA9IHByb3AudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGlzUGFyYWxsYXhMYXllcil7XG4gICAgICAgICAgICAgICAgc2NlbmVMYXllciA9IHRoaXMuc2NlbmUuYWRkUGFyYWxsYXhMYXllcihsYXllci5uYW1lLCBuZXcgVmVjMigxLCAxKSwgZGVwdGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY2VuZUxheWVyID0gdGhpcy5zY2VuZS5hZGRMYXllcihsYXllci5uYW1lLCBkZXB0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKGxheWVyLnR5cGUgPT09IFwidGlsZWxheWVyXCIpe1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyB0aWxlbWFwIG9iamVjdCBmb3IgdGhlIGxheWVyXG4gICAgICAgICAgICAgICAgbGV0IHRpbGVtYXAgPSBuZXcgY29uc3RyKHRpbGVtYXBEYXRhLCBsYXllciwgdGlsZXNldHMsIHNjYWxlKTtcbiAgICAgICAgICAgICAgICB0aWxlbWFwLmlkID0gdGhpcy5zY2VuZS5nZW5lcmF0ZUlkKCk7XG4gICAgICAgICAgICAgICAgdGlsZW1hcC5zZXRTY2VuZSh0aGlzLnNjZW5lKTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGlsZW1hcCB0byBzY2VuZVxuICAgICAgICAgICAgICAgIHRoaXMudGlsZW1hcHMucHVzaCh0aWxlbWFwKTtcbiAgICBcbiAgICAgICAgICAgICAgICBzY2VuZUxheWVyLmFkZE5vZGUodGlsZW1hcCk7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gUmVnaXN0ZXIgdGlsZW1hcCB3aXRoIHBoeXNpY3MgaWYgaXQncyBjb2xsaWRhYmxlXG4gICAgICAgICAgICAgICAgaWYodGlsZW1hcC5pc0NvbGxpZGFibGUpe1xuICAgICAgICAgICAgICAgICAgICB0aWxlbWFwLmFkZFBoeXNpY3MoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZihsYXllci5wcm9wZXJ0aWVzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaXRlbSBvZiBsYXllci5wcm9wZXJ0aWVzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihpdGVtLm5hbWUgPT09IFwiR3JvdXBcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbGVtYXAuc2V0R3JvdXAoaXRlbS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGxldCBpc05hdm1lc2hQb2ludHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsZXQgbmF2bWVzaE5hbWU7XG4gICAgICAgICAgICAgICAgbGV0IGVkZ2VzO1xuICAgICAgICAgICAgICAgIGlmKGxheWVyLnByb3BlcnRpZXMpe1xuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IHByb3Agb2YgbGF5ZXIucHJvcGVydGllcyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihwcm9wLm5hbWUgPT09IFwiTmF2bWVzaFBvaW50c1wiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc05hdm1lc2hQb2ludHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHByb3AubmFtZSA9PT0gXCJuYW1lXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdm1lc2hOYW1lID0gcHJvcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihwcm9wLm5hbWUgPT09IFwiZWRnZXNcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRnZXMgPSBwcm9wLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYoaXNOYXZtZXNoUG9pbnRzKXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGcgPSBuZXcgUG9zaXRpb25HcmFwaCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgb2JqIG9mIGxheWVyLm9iamVjdHMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZy5hZGRQb3NpdGlvbmVkTm9kZShuZXcgVmVjMihvYmoueCwgb2JqLnkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgZWRnZSBvZiBlZGdlcyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBnLmFkZEVkZ2UoZWRnZS5mcm9tLCBlZGdlLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuZ2V0TmF2aWdhdGlvbk1hbmFnZXIoKS5hZGROYXZpZ2FibGVFbnRpdHkobmF2bWVzaE5hbWUsIG5ldyBOYXZtZXNoKGcpKTtcblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBMYXllciBpcyBhbiBvYmplY3QgbGF5ZXIsIHNvIGFkZCBlYWNoIG9iamVjdCBhcyBhIHNwcml0ZSB0byBhIG5ldyBsYXllclxuICAgICAgICAgICAgICAgIGZvcihsZXQgb2JqIG9mIGxheWVyLm9iamVjdHMpe1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBvYmogaXMgY29sbGlkYWJsZVxuICAgICAgICAgICAgICAgICAgICBsZXQgaGFzUGh5c2ljcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXNDb2xsaWRhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpc1RyaWdnZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9uRW50ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBsZXQgb25FeGl0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRyaWdnZXJHcm91cCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxldCBncm91cCA9IFwiXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYob2JqLnByb3BlcnRpZXMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBwcm9wIG9mIG9iai5wcm9wZXJ0aWVzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihwcm9wLm5hbWUgPT09IFwiSGFzUGh5c2ljc1wiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzUGh5c2ljcyA9IHByb3AudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHByb3AubmFtZSA9PT0gXCJDb2xsaWRhYmxlXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbGxpZGFibGUgPSBwcm9wLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihwcm9wLm5hbWUgPT09IFwiR3JvdXBcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwID0gcHJvcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocHJvcC5uYW1lID09PSBcIklzVHJpZ2dlclwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNUcmlnZ2VyID0gcHJvcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocHJvcC5uYW1lID09PSBcIlRyaWdnZXJHcm91cFwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckdyb3VwID0gcHJvcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocHJvcC5uYW1lID09PSBcIlRyaWdnZXJPbkVudGVyXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVudGVyID0gcHJvcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocHJvcC5uYW1lID09PSBcIlRyaWdnZXJPbkV4aXRcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRXhpdCA9IHByb3AudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwcml0ZTogU3ByaXRlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIG9iaiBpcyBhIHRpbGUgZnJvbSBhIHRpbGVzZXRcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCB0aWxlc2V0IG9mIHRpbGVzZXRzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRpbGVzZXQuaGFzVGlsZShvYmouZ2lkKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG9iamVjdCBpcyBhIHRpbGUgZnJvbSB0aGlzIHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbWFnZUtleSA9IHRpbGVzZXQuZ2V0SW1hZ2VLZXkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gdGlsZXNldC5nZXRJbWFnZU9mZnNldEZvclRpbGUob2JqLmdpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlID0gdGhpcy5zY2VuZS5hZGQuc3ByaXRlKGltYWdlS2V5LCBsYXllci5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IHRpbGVzZXQuZ2V0VGlsZVNpemUoKS5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5wb3NpdGlvbi5zZXQoKG9iai54ICsgc2l6ZS54LzIpKnNjYWxlLngsIChvYmoueSAtIHNpemUueS8yKSpzY2FsZS55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuc2V0SW1hZ2VPZmZzZXQob2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuc2l6ZS5jb3B5KHNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5zY2FsZS5zZXQoc2NhbGUueCwgc2NhbGUueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBOb3QgaW4gYSB0aWxlc2V0LCBtdXN0IGNvcnJlc3BvbmQgdG8gYSBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmKCFzcHJpdGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCB0aWxlIG9mIGNvbGxlY3Rpb25UaWxlcyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYob2JqLmdpZCA9PT0gdGlsZS5pZCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbWFnZUtleSA9IHRpbGUuaW1hZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZSA9IHRoaXMuc2NlbmUuYWRkLnNwcml0ZShpbWFnZUtleSwgbGF5ZXIubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5wb3NpdGlvbi5zZXQoKG9iai54ICsgdGlsZS5pbWFnZXdpZHRoLzIpKnNjYWxlLngsIChvYmoueSAtIHRpbGUuaW1hZ2VoZWlnaHQvMikqc2NhbGUueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5zY2FsZS5zZXQoc2NhbGUueCwgc2NhbGUueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm93IHdlIGhhdmUgc3ByaXRlLiBBc3NvY2lhdGUgaXQgd2l0aCBvdXIgcGh5c2ljcyBvYmplY3QgaWYgdGhlcmUgaXMgb25lXG4gICAgICAgICAgICAgICAgICAgIGlmKGhhc1BoeXNpY3Mpe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSB0aGUgc3ByaXRlIGEgc3RhdGljIHBoeXNpY3Mgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuYWRkUGh5c2ljcyhzcHJpdGUuYm91bmRhcnkuY2xvbmUoKSwgVmVjMi5aRVJPLCBpc0NvbGxpZGFibGUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnNldEdyb3VwKGdyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGlzVHJpZ2dlciAmJiB0cmlnZ2VyR3JvdXAgIT09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5zZXRUcmlnZ2VyKHRyaWdnZXJHcm91cCwgb25FbnRlciwgb25FeGl0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgIHNjZW5lTGF5ZXJzLnB1c2goc2NlbmVMYXllcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2NlbmVMYXllcnM7XG5cdH1cbn0iLCJpbXBvcnQgU2NlbmUgZnJvbSBcIi4vU2NlbmVcIjtcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4uL1V0aWxzL01hdGhVdGlsc1wiO1xuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi9Ob2Rlcy9HYW1lTm9kZVwiO1xuXG5cbi8qKlxuICogQSBsYXllciBpbiB0aGUgc2NlbmUuIExheWVycyBhcmUgdXNlZCBmb3Igc29ydGluZyBAcmVmZXJlbmNlW0dhbWVOb2RlXXMgYnkgZGVwdGguXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExheWVyIHtcbiAgICAvKiogVGhlIHNjZW5lIHRoaXMgbGF5ZXIgYmVsb25ncyB0byAqL1xuICAgIHByb3RlY3RlZCBzY2VuZTogU2NlbmU7XG5cbiAgICAvKiogVGhlIG5hbWUgb2YgdGhpcyBsYXllciAqL1xuICAgIHByb3RlY3RlZCBuYW1lOiBzdHJpbmc7XG5cbiAgICAvKiogV2hldGhlciB0aGlzIGxheWVyIGlzIHBhdXNlZCBvciBub3QgKi9cbiAgICBwcm90ZWN0ZWQgcGF1c2VkOiBib29sZWFuO1xuXG4gICAgLyoqIFdoZXRoZXIgdGhpcyBsYXllciBpcyBoaWRkZW4gZnJvbSBiZWluZyByZW5kZXJlZCBvciBub3QgKi9cbiAgICBwcm90ZWN0ZWQgaGlkZGVuOiBib29sZWFuO1xuXG4gICAgLyoqIFRoZSBnbG9iYWwgYWxwaGEgbGV2ZWwgb2YgdGhpcyBsYXllciAqL1xuICAgIHByb3RlY3RlZCBhbHBoYTogbnVtYmVyO1xuXG4gICAgLyoqIEFuIGFycmF5IG9mIHRoZSBHYW1lTm9kZXMgdGhhdCBiZWxvbmcgdG8gdGhpcyBsYXllciAqL1xuICAgIHByb3RlY3RlZCBpdGVtczogQXJyYXk8R2FtZU5vZGU+O1xuXG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoaXMgbGF5ZXIgc2hvdWxkIGJlIHlzb3J0ZWQgKi9cbiAgICBwcm90ZWN0ZWQgeVNvcnQ6IGJvb2xlYW47XG5cbiAgICAvKiogVGhlIGRlcHRoIG9mIHRoaXMgbGF5ZXIgY29tcGFyZWQgdG8gb3RoZXIgbGF5ZXJzICovXG4gICAgcHJvdGVjdGVkIGRlcHRoOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGxheWVyLiBUbyBkbyB0aGlzIGluIGEgZ2FtZSwgdXNlIHRoZSBhZGRMYXllcigpIG1ldGhvZCBpbiBAcmVmcmVuY2VbU2NlbmVdXG4gICAgICogQHBhcmFtIHNjZW5lIFRoZSBzY2VuZSB0byBhZGQgdGhlIGxheWVyIHRvXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGxheWVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2NlbmU6IFNjZW5lLCBuYW1lOiBzdHJpbmcpe1xuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWxwaGEgPSAxO1xuICAgICAgICB0aGlzLml0ZW1zID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMueVNvcnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXB0aCA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmVpdmVzIHRoZSBuYW1lIG9mIHRoZSBsYXllclxuICAgICAqIEByZXR1cm5zIFRoZSBuYW1lIG9mIHRoZSBsYXllclxuICAgICAqL1xuICAgIGdldE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXVzZXMvVW5wYXVzZXMgdGhlIGxheWVyLiBBZmZlY3RzIGFsbCBlbGVtZW50cyBpbiB0aGlzIGxheWVyXG4gICAgICogQHBhcmFtIHBhdXNlVmFsdWUgVHJ1ZSBpZiB0aGUgbGF5ZXIgc2hvdWxkIGJlIHBhdXNlZCwgZmFsc2UgaWYgbm90XG4gICAgICovXG4gICAgc2V0UGF1c2VkKHBhdXNlVmFsdWU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5wYXVzZWQgPSBwYXVzZVZhbHVlO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBsYXllciBpcyBwYXVzZWRcbiAgICAgKi9cbiAgICBpc1BhdXNlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF1c2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG9wYWNpdHkgb2YgdGhlIGxheWVyXG4gICAgICogQHBhcmFtIGFscGhhIFRoZSBuZXcgb3BhY2l0eSB2YWx1ZSBpbiB0aGUgcmFuZ2UgWzAsIDFdXG4gICAgICovXG4gICAgc2V0QWxwaGEoYWxwaGE6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLmFscGhhID0gTWF0aFV0aWxzLmNsYW1wKGFscGhhLCAwLCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBvcGFjaXR5IG9mIHRoZSBsYXllclxuICAgICAqIEByZXR1cm5zIFRoZSBvcGFjaXR5XG4gICAgICovXG4gICAgZ2V0QWxwaGEoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxwaGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGF5ZXIncyBoaWRkZW4gdmFsdWUuIElmIGhpZGRlbiwgYSBsYXllciB3aWxsIG5vdCBiZSByZW5kZXJlZCwgYnV0IHdpbGwgc3RpbGwgdXBkYXRlXG4gICAgICogQHBhcmFtIGhpZGRlbiBUaGUgaGlkZGVuIHZhbHVlIG9mIHRoZSBsYXllclxuICAgICAqL1xuICAgIHNldEhpZGRlbihoaWRkZW46IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5oaWRkZW4gPSBoaWRkZW47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaGlkZWVuIHZhbHVlIG9mIHRoZSBseWFlclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHNjZW5lIGlzIGhpZGRlbiwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgaXNIaWRkZW4oKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmhpZGRlbjtcbiAgICB9XG5cbiAgICAvKiogUGF1c2VzIHRoaXMgc2NlbmUgYW5kIGhpZGVzIGl0ICovXG4gICAgZGlzYWJsZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmhpZGRlbiA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqIFVucGF1c2VzIHRoaXMgbGF5ZXIgYW5kIG1ha2VzIGl0IHZpc2libGUgKi9cbiAgICBlbmFibGUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgc2NlbmUgd2lsbCB5U29ydCBhdXRvbWF0aWNhbGx5LlxuICAgICAqIHlTb3J0aW5nIG1lYW5zIHRoYXQgQ2FudmFzTm9kZXMgb24gdGhpcyBsYXllciB3aWxsIGhhdmUgdGhlaXIgZGVwdGggc29ydGVkIGRlcGVuZGluZyBvbiB0aGVpciB5LXZhbHVlLlxuICAgICAqIFRoaXMgbWVhbnMgdGhhdCBpZiBhbiBvYmplY3QgaXMgXCJoaWdoZXJcIiBpbiB0aGUgc2NlbmUsIGl0IHdpbGwgc29ydCBiZWhpbmQgb2JqZWN0cyB0aGF0IGFyZSBcImxvd2VyXCIuXG4gICAgICogVGhpcyBpcyB1c2VmdWwgZm9yIDMvNCB2aWV3IGdhbWVzLCBvciBzaW1pbGFyIHNpdHVhdGlvbnMsIHdoZXJlIHlvdSBzb21ldGltZXMgd2FudCB0byBiZSBpbiBmcm9udCBvZiBvYmplY3RzLFxuICAgICAqIGFuZCBvdGhlciB0aW1lcyB3YW50IHRvIGJlIGJlaGluZCB0aGUgc2FtZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB5U29ydCBUcnVlIGlmIHlTb3J0aW5nIHNob3VsZCBiZSBhY3RpdmUsIGZhbHNlIGlmIG5vdFxuICAgICAqL1xuICAgIHNldFlTb3J0KHlTb3J0OiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMueVNvcnQgPSB5U29ydDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB5U29ydCBzdGF0dXMgb2YgdGhlIHNjZW5lXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB5U29ydGluZyBpcyBvY2N1cnJpbmcsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGdldFlTb3J0KCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy55U29ydDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkZXB0aCBvZiB0aGUgbGF5ZXIgY29tcGFyZWQgdG8gb3RoZXIgbGF5ZXJzLiBBIGxhcmdlciBudW1iZXIgbWVhbnMgdGhlIGxheWVyIHdpbGwgYmUgY2xvc2VyIHRvIHRoZSBzY3JlZW4uXG4gICAgICogQHBhcmFtIGRlcHRoIFRoZSBkZXB0aCBvZiB0aGUgbGF5ZXIuXG4gICAgICovXG4gICAgc2V0RGVwdGgoZGVwdGg6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLmRlcHRoID0gZGVwdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBkZXB0aCBvZiB0aGUgbGF5ZXIuXG4gICAgICogQHJldHVybnMgVGhlIGRlcHRoXG4gICAgICovXG4gICAgZ2V0RGVwdGgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5vZGUgdG8gdGhpcyBsYXllclxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIGFkZCB0byB0aGlzIGxheWVyLlxuICAgICAqL1xuICAgIGFkZE5vZGUobm9kZTogR2FtZU5vZGUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5pdGVtcy5wdXNoKG5vZGUpO1xuICAgICAgICBub2RlLnNldExheWVyKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBub2RlIGZyb20gdGhpcyBsYXllclxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIHJlbW92ZVxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIG5vZGUgd2FzIHJlbW92ZWQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIHJlbW92ZU5vZGUobm9kZTogR2FtZU5vZGUpOiB2b2lkIHtcbiAgICAgICAgLy8gRmluZCBhbmQgcmVtb3ZlIHRoZSBub2RlXG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuaXRlbXMuaW5kZXhPZihub2RlKTtcblxuICAgICAgICBpZihpbmRleCAhPT0gLTEpe1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgbm9kZS5zZXRMYXllcih1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmVpdmVzIGFsbCBHYW1lTm9kZXMgZnJvbSB0aGlzIGxheWVyXG4gICAgICogQHJldHVybnMgYW4gQXJyYXkgdGhhdCBjb250YWlucyBhbGwgb2YgdGhlIEdhbWVOb2RlcyBpbiB0aGlzIGxheWVyLlxuICAgICAqL1xuICAgIGdldEl0ZW1zKCk6IEFycmF5PEdhbWVOb2RlPiB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zO1xuICAgIH1cbn0iLCJpbXBvcnQgTGF5ZXIgZnJvbSBcIi4uL0xheWVyXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vU2NlbmVcIjtcblxuLyoqXG4gKiBBbiBleHRlbnNpb24gb2YgYSBMYXllciB0aGF0IGhhcyBhIHBhcmFsbGF4IHZhbHVlLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJhbGxheExheWVyIGV4dGVuZHMgTGF5ZXIge1xuXHQvKiogVGhlIHZhbHVlIG9mIHRoZSBwYXJhbGxheCBvZiB0aGUgTGF5ZXIgKi9cblx0cGFyYWxsYXg6IFZlYzI7XG5cdFxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyBQYXJhbGxheExheWVyLlxuXHQgKiBVc2UgYWRkUGFyYWxsYXhMYXllcigpIGluIEByZWZlcmVuY2VbU2NlbmVdIHRvIGFkZCBhIGxheWVyIG9mIHRoaXMgdHlwZSB0byB5b3VyIGdhbWUuXG5cdCAqIEBwYXJhbSBzY2VuZSBUaGUgU2NlbmUgdG8gYWRkIHRoaXMgUGFyYWxsYXhMYXllciB0b1xuXHQgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgUGFyYWxsYXhMYXllclxuXHQgKiBAcGFyYW0gcGFyYWxsYXggVGhlIHBhcmFsbGF4IGxldmVsXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihzY2VuZTogU2NlbmUsIG5hbWU6IHN0cmluZywgcGFyYWxsYXg6IFZlYzIpe1xuXHRcdHN1cGVyKHNjZW5lLCBuYW1lKTtcblx0XHR0aGlzLnBhcmFsbGF4ID0gcGFyYWxsYXg7XG5cdH1cbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vU2NlbmVcIjtcbmltcG9ydCBQYXJhbGxheExheWVyIGZyb20gXCIuL1BhcmFsbGF4TGF5ZXJcIjtcblxuLyoqXG4gKiBBIExheWVyIHN0cmljdGx5IHRvIGJlIHVzZWQgZm9yIG1hbmFnaW5nIFVJRWxlbWVudHMuXG4gKiBUaGlzIGlzIGludGVuZGVkIHRvIGJlIGEgTGF5ZXIgdGhhdCBhbHdheXMgc3RheXMgaW4gdGhlIHNhbWUgcGxhY2UsXG4gKiBhbmQgdGh1cyByZW5kZXJzIHRoaW5ncyBsaWtlIGEgSFVEIG9yIGFuIGludmVudG9yeSB3aXRob3V0IHRha2luZyBpbnRvIGNvbnNpZGVyYXRpb24gdGhlIFxccmVmZXJlbmNlW1ZpZXdwb3J0XSBzY3JvbGwuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVJTGF5ZXIgZXh0ZW5kcyBQYXJhbGxheExheWVyIHtcblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgVUlMYXllci5cblx0ICogVXNlIGFkZFVJTGF5ZXIoKSBpbiBAcmVmZXJlbmNlW1NjZW5lXSB0byBhZGQgYSBsYXllciBvZiB0aGlzIHR5cGUgdG8geW91ciBnYW1lLlxuXHQgKiBAcGFyYW0gc2NlbmUgVGhlIFNjZW5lIHRvIGFkZCB0aGlzIFVJTGF5ZXIgdG9cblx0ICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIFVJTGF5ZXJcblx0ICovXG5cdGNvbnN0cnVjdG9yKHNjZW5lOiBTY2VuZSwgbmFtZTogc3RyaW5nKXtcblx0XHRzdXBlcihzY2VuZSwgbmFtZSwgVmVjMi5aRVJPKTtcblx0fVxufSIsImltcG9ydCBMYXllciBmcm9tIFwiLi9MYXllclwiO1xuaW1wb3J0IFZpZXdwb3J0IGZyb20gXCIuLi9TY2VuZUdyYXBoL1ZpZXdwb3J0XCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBTY2VuZUdyYXBoIGZyb20gXCIuLi9TY2VuZUdyYXBoL1NjZW5lR3JhcGhcIjtcbmltcG9ydCBQaHlzaWNzTWFuYWdlciBmcm9tIFwiLi4vUGh5c2ljcy9QaHlzaWNzTWFuYWdlclwiO1xuaW1wb3J0IEJhc2ljUGh5c2ljc01hbmFnZXIgZnJvbSBcIi4uL1BoeXNpY3MvQmFzaWNQaHlzaWNzTWFuYWdlclwiO1xuaW1wb3J0IFNjZW5lR3JhcGhBcnJheSBmcm9tIFwiLi4vU2NlbmVHcmFwaC9TY2VuZUdyYXBoQXJyYXlcIjtcbmltcG9ydCBGYWN0b3J5TWFuYWdlciBmcm9tIFwiLi9GYWN0b3JpZXMvRmFjdG9yeU1hbmFnZXJcIjtcbmltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwXCI7XG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5pbXBvcnQgR2FtZSBmcm9tIFwiLi4vTG9vcC9HYW1lXCI7XG5pbXBvcnQgU2NlbmVNYW5hZ2VyIGZyb20gXCIuL1NjZW5lTWFuYWdlclwiO1xuaW1wb3J0IFJlY2VpdmVyIGZyb20gXCIuLi9FdmVudHMvUmVjZWl2ZXJcIjtcbmltcG9ydCBFbWl0dGVyIGZyb20gXCIuLi9FdmVudHMvRW1pdHRlclwiO1xuaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcbmltcG9ydCBOYXZpZ2F0aW9uTWFuYWdlciBmcm9tIFwiLi4vUGF0aGZpbmRpbmcvTmF2aWdhdGlvbk1hbmFnZXJcIjtcbmltcG9ydCBBSU1hbmFnZXIgZnJvbSBcIi4uL0FJL0FJTWFuYWdlclwiO1xuaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL0NvbGxlY3Rpb25zL01hcFwiO1xuaW1wb3J0IFBhcmFsbGF4TGF5ZXIgZnJvbSBcIi4vTGF5ZXJzL1BhcmFsbGF4TGF5ZXJcIjtcbmltcG9ydCBVSUxheWVyIGZyb20gXCIuL0xheWVycy9VSUxheWVyXCI7XG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi9Ob2Rlcy9HYW1lTm9kZVwiO1xuaW1wb3J0IFNjZW5lT3B0aW9ucyBmcm9tIFwiLi9TY2VuZU9wdGlvbnNcIjtcbmltcG9ydCBSZW5kZXJpbmdNYW5hZ2VyIGZyb20gXCIuLi9SZW5kZXJpbmcvUmVuZGVyaW5nTWFuYWdlclwiO1xuaW1wb3J0IERlYnVnIGZyb20gXCIuLi9EZWJ1Zy9EZWJ1Z1wiO1xuaW1wb3J0IFRpbWVyTWFuYWdlciBmcm9tIFwiLi4vVGltaW5nL1RpbWVyTWFuYWdlclwiO1xuaW1wb3J0IFR3ZWVuTWFuYWdlciBmcm9tIFwiLi4vUmVuZGVyaW5nL0FuaW1hdGlvbnMvVHdlZW5NYW5hZ2VyXCI7XG5pbXBvcnQgUGFydGljbGVTeXN0ZW1NYW5hZ2VyIGZyb20gXCIuLi9SZW5kZXJpbmcvQW5pbWF0aW9ucy9QYXJ0aWNsZVN5c3RlbU1hbmFnZXJcIjtcblxuLyoqXG4gKiBTY2VuZXMgYXJlIHRoZSBtYWluIGNvbnRhaW5lciBpbiB0aGUgZ2FtZSBlbmdpbmUuXG4gKiBZb3VyIG1haW4gc2NlbmUgaXMgdGhlIGN1cnJlbnQgbGV2ZWwgb3IgbWVudSBvZiB0aGUgZ2FtZSwgYW5kIHdpbGwgY29udGFpbiBhbGwgb2YgdGhlIEdhbWVOb2RlcyBuZWVkZWQuXG4gKiBTY2VuZXMgcHJvdmlkZSBhbiBlYXN5IHdheSB0byBsb2FkIGFzc2V0cywgYWRkIGFzc2V0cyB0byB0aGUgZ2FtZSB3b3JsZCwgYW5kIHVubG9hZCBhc3NldHMsXG4gKiBhbmQgaGF2ZSBsaWZlY3ljbGUgbWV0aG9kcyBleHBvc2VkIGZvciB0aGVzZSBmdW5jdGlvbnMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjZW5lIGltcGxlbWVudHMgVXBkYXRlYWJsZSB7XG4gICAgLyoqIFRoZSBzaXplIG9mIHRoZSBnYW1lIHdvcmxkLiAqL1xuICAgIHByb3RlY3RlZCB3b3JsZFNpemU6IFZlYzI7XG5cbiAgICAvKiogVGhlIHZpZXdwb3J0LiAqL1xuICAgIHByb3RlY3RlZCB2aWV3cG9ydDogVmlld3BvcnQ7XG5cbiAgICAvKiogQSBmbGFnIHRoYXQgcmVwcmVzZW50cyB3aGV0aGVyIHRoaXMgc2NlbmUgaXMgcnVubmluZyBvciBub3QuICovXG4gICAgcHJvdGVjdGVkIHJ1bm5pbmc6IGJvb2xlYW47XG5cbiAgICAvKiogVGhlIG1hbmFnZXIgb2YgdGhpcyBzY2VuZS4gKi9cbiAgICBwcm90ZWN0ZWQgc2NlbmVNYW5hZ2VyOiBTY2VuZU1hbmFnZXI7XG5cbiAgICAvKiogVGhlIHJlY2VpdmVyIGZvciB0aGlzIHNjZW5lLiAqL1xuICAgIHByb3RlY3RlZCByZWNlaXZlcjogUmVjZWl2ZXI7XG5cbiAgICAvKiogVGhlIGVtaXR0ZXIgZm9yIHRoaXMgc2NlbmUuICovXG4gICAgcHJvdGVjdGVkIGVtaXR0ZXI6IEVtaXR0ZXI7XG5cbiAgICAvKiogVGhpcyBsaXN0IG9mIHRpbGVtYXBzIGluIHRoaXMgc2NlbmUuICovXG4gICAgcHJvdGVjdGVkIHRpbGVtYXBzOiBBcnJheTxUaWxlbWFwPjtcblxuICAgIC8qKiBBIG1hcCBmcm9tIGxheWVyIG5hbWVzIHRvIHRoZSBsYXllcnMgdGhlbXNlbHZlcyAqL1xuICAgIHByb3RlY3RlZCBsYXllcnM6IE1hcDxMYXllcj47XG5cbiAgICAvKiogQSBtYXAgZnJvbSBwYXJhbGxheCBsYXllciBuYW1lcyB0byB0aGUgcGFyYWxsYXggbGF5ZXJzIHRoZW1zZWx2ZXMgKi9cbiAgICBwcm90ZWN0ZWQgcGFyYWxsYXhMYXllcnM6IE1hcDxQYXJhbGxheExheWVyPjtcblxuICAgIC8qKiBBIG1hcCBmcm9tIHVpTGF5ZXIgbmFtZXMgdG8gdGhlIHVpTGF5ZXJzIHRoZW1zZWx2ZXMgKi9cbiAgICBwcm90ZWN0ZWQgdWlMYXllcnM6IE1hcDxVSUxheWVyPjtcblxuICAgIC8qKiBUaGUgc2NlbmUgZ3JhcGggb2YgdGhlIFNjZW5lKi9cbiAgICBwcm90ZWN0ZWQgc2NlbmVHcmFwaDogU2NlbmVHcmFwaDtcblxuICAgIC8qKiBUaGUgcGh5c2ljcyBtYW5hZ2VyIG9mIHRoZSBTY2VuZSAqL1xuICAgIHByb3RlY3RlZCBwaHlzaWNzTWFuYWdlcjogUGh5c2ljc01hbmFnZXI7XG4gICAgXG4gICAgLyoqIFRoZSBuYXZpZ2F0aW9uIG1hbmFnZXIgb2YgdGhlIFNjZW5lICovXG4gICAgcHJvdGVjdGVkIG5hdk1hbmFnZXI6IE5hdmlnYXRpb25NYW5hZ2VyO1xuXG4gICAgLyoqIFRoZSBBSSBtYW5hZ2VyIG9mIHRoZSBTY2VuZSAqL1xuICAgIHByb3RlY3RlZCBhaU1hbmFnZXI6IEFJTWFuYWdlcjtcblxuICAgIC8qKiBUaGUgcmVuZGVyaW5nTWFuYWdlciBvZiB0aGUgc2NlbmUgKi9cbiAgICBwcm90ZWN0ZWQgcmVuZGVyaW5nTWFuYWdlcjogUmVuZGVyaW5nTWFuYWdlcjtcblxuICAgIC8qKiBBbiBpbnRlcmZhY2UgdGhhdCBhbGxvd3MgdGhlIGFkZGluZyBvZiBkaWZmZXJlbnQgbm9kZXMgdG8gdGhlIHNjZW5lICovXG4gICAgcHVibGljIGFkZDogRmFjdG9yeU1hbmFnZXI7XG5cbiAgICAvKiogQW4gaW50ZXJmYWNlIHRoYXQgYWxsb3dzIHRoZSBsb2FkaW5nIG9mIGRpZmZlcmVudCBmaWxlcyBmb3IgdXNlIGluIHRoZSBzY2VuZS4gQW4gYWxpYXMgZm9yIHJlc291cmNlTWFuYWdlciAqL1xuICAgIHB1YmxpYyBsb2FkOiBSZXNvdXJjZU1hbmFnZXI7XG5cbiAgICAvKiogQW4gaW50ZXJmYWNlIHRoYXQgYWxsb3dzIHRoZSBsb2FkaW5nIGFuZCB1bmxvYWRpbmcgb2YgZGlmZmVyZW50IGZpbGVzIGZvciB1c2UgaW4gdGhlIHNjZW5lICovXG4gICAgcHVibGljIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xuXG4gICAgLyoqIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoaXMgc2NlbmUgKi9cbiAgICBwdWJsaWMgc2NlbmVPcHRpb25zOiBTY2VuZU9wdGlvbnM7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNjZW5lLiBUbyBhZGQgYSBuZXcgU2NlbmUgaW4geW91ciBnYW1lLCB1c2UgY2hhbmdlVG9TY2VuZSgpIGluIEByZWZlcmVuY2VbU2NlbmVNYW5hZ2VyXVxuICAgICAqIEBwYXJhbSB2aWV3cG9ydCBUaGUgdmlld3BvcnQgb2YgdGhlIGdhbWVcbiAgICAgKiBAcGFyYW0gc2NlbmVNYW5hZ2VyIFRoZSBTY2VuZU1hbmFnZXIgdGhhdCBvd25zIHRoaXMgU2NlbmVcbiAgICAgKiBAcGFyYW0gcmVuZGVyaW5nTWFuYWdlciBUaGUgUmVuZGVyaW5nTWFuYWdlciB0aGF0IHdpbGwgaGFuZGxlIHRoaXMgU2NlbmUncyByZW5kZXJpbmdcbiAgICAgKiBAcGFyYW0gZ2FtZSBUaGUgaW5zdGFuY2Ugb2YgdGhlIEdhbWVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgU2NlbmUgaW5pdGlhbGl6YXRpb25cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih2aWV3cG9ydDogVmlld3BvcnQsIHNjZW5lTWFuYWdlcjogU2NlbmVNYW5hZ2VyLCByZW5kZXJpbmdNYW5hZ2VyOiBSZW5kZXJpbmdNYW5hZ2VyLCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KXtcbiAgICAgICAgdGhpcy5zY2VuZU9wdGlvbnMgPSBTY2VuZU9wdGlvbnMucGFyc2Uob3B0aW9ucyA9PT0gdW5kZWZpbmVkID8ge30gOiBvcHRpb25zKTtcblxuICAgICAgICB0aGlzLndvcmxkU2l6ZSA9IG5ldyBWZWMyKDUwMCwgNTAwKTtcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICB0aGlzLnZpZXdwb3J0LnNldEJvdW5kcygwLCAwLCAyNTYwLCAxMjgwKTtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyID0gc2NlbmVNYW5hZ2VyO1xuICAgICAgICB0aGlzLnJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKCk7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG5cbiAgICAgICAgdGhpcy50aWxlbWFwcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLnNjZW5lR3JhcGggPSBuZXcgU2NlbmVHcmFwaEFycmF5KHRoaXMudmlld3BvcnQsIHRoaXMpO1xuXG4gICAgICAgIHRoaXMubGF5ZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnVpTGF5ZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnBhcmFsbGF4TGF5ZXJzID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIHRoaXMucGh5c2ljc01hbmFnZXIgPSBuZXcgQmFzaWNQaHlzaWNzTWFuYWdlcih0aGlzLnNjZW5lT3B0aW9ucy5waHlzaWNzKTtcbiAgICAgICAgdGhpcy5uYXZNYW5hZ2VyID0gbmV3IE5hdmlnYXRpb25NYW5hZ2VyKCk7XG4gICAgICAgIHRoaXMuYWlNYW5hZ2VyID0gbmV3IEFJTWFuYWdlcigpO1xuICAgICAgICB0aGlzLnJlbmRlcmluZ01hbmFnZXIgPSByZW5kZXJpbmdNYW5hZ2VyO1xuXG4gICAgICAgIHRoaXMuYWRkID0gbmV3IEZhY3RvcnlNYW5hZ2VyKHRoaXMsIHRoaXMudGlsZW1hcHMpO1xuXG4gICAgICAgIHRoaXMubG9hZCA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpXG4gICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gdGhpcy5sb2FkO1xuXG4gICAgICAgIC8vIEdldCB0aGUgdGltZXIgbWFuYWdlciBhbmQgY2xlYXIgYW55IGV4aXN0aW5nIHRpbWVyc1xuICAgICAgICBUaW1lck1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5jbGVhclRpbWVycygpO1xuICAgIH1cblxuICAgIC8qKiBBIGxpZmVjeWNsZSBtZXRob2QgdGhhdCBnZXRzIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciBhIG5ldyBzY2VuZSBpcyBjcmVhdGVkLCBiZWZvcmUgYW55dGhpbmcgZWxzZS4gKi9cbiAgICBpbml0U2NlbmUoaW5pdDogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge31cblxuICAgIC8qKiBBIGxpZmVjeWNsZSBtZXRob2QgdGhhdCBnZXRzIGNhbGxlZCB3aGVuIGEgbmV3IHNjZW5lIGlzIGNyZWF0ZWQuIExvYWQgYWxsIGZpbGVzIHlvdSB3aXNoIHRvIGFjY2VzcyBpbiB0aGUgc2NlbmUgaGVyZS4gKi9cbiAgICBsb2FkU2NlbmUoKTogdm9pZCB7fVxuXG4gICAgLyoqIEEgbGlmZWN5Y2xlIG1ldGhvZCBjYWxsZWQgc3RyaWN0bHkgYWZ0ZXIgbG9hZFNjZW5lKCkuIENyZWF0ZSBhbnkgZ2FtZSBvYmplY3RzIHlvdSB3aXNoIHRvIHVzZSBpbiB0aGUgc2NlbmUgaGVyZS4gKi9cbiAgICBzdGFydFNjZW5lKCk6IHZvaWQge31cblxuICAgIC8qKlxuICAgICAqIEEgbGlmZWN5Y2xlIG1ldGhvZCBjYWxsZWQgZXZlcnkgZnJhbWUgb2YgdGhlIGdhbWUuIFRoaXMgaXMgd2hlcmUgeW91IGNhbiBkeW5hbWljYWxseSBkbyB0aGluZ3MgbGlrZSBhZGQgaW4gbmV3IGVuZW1pZXNcbiAgICAgKiBAcGFyYW0gZGVsdGEgVGhlIHRpbWUgdGhpcyBmcmFtZSByZXByZXNlbnRzXG4gICAgICovXG4gICAgdXBkYXRlU2NlbmUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHt9XG5cbiAgICAvKiogQSBsaWZlY3ljbGUgbWV0aG9kIHRoYXQgZ2V0cyBjYWxsZWQgb24gc2NlbmUgZGVzdHJ1Y3Rpb24uIFNwZWNpZnkgd2hpY2ggZmlsZXMgeW91IG5vIGxvbmdlciBuZWVkIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24uICovXG4gICAgdW5sb2FkU2NlbmUoKTogdm9pZCB7fVxuXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMudXBkYXRlU2NlbmUoZGVsdGFUKTtcblxuICAgICAgICAvLyBEbyB0aW1lIHVwZGF0ZXNcbiAgICAgICAgVGltZXJNYW5hZ2VyLmdldEluc3RhbmNlKCkudXBkYXRlKGRlbHRhVCk7XG5cbiAgICAgICAgLy8gRG8gYWxsIEFJIHVwZGF0ZXNcbiAgICAgICAgdGhpcy5haU1hbmFnZXIudXBkYXRlKGRlbHRhVCk7XG5cbiAgICAgICAgLy8gVXBkYXRlIGFsbCBwaHlzaWNzIG9iamVjdHNcbiAgICAgICAgdGhpcy5waHlzaWNzTWFuYWdlci51cGRhdGUoZGVsdGFUKTtcblxuICAgICAgICAvLyBVcGRhdGUgYWxsIGNhbnZhcyBvYmplY3RzXG4gICAgICAgIHRoaXMuc2NlbmVHcmFwaC51cGRhdGUoZGVsdGFUKTtcblxuICAgICAgICAvLyBVcGRhdGUgYWxsIHRpbGVtYXBzXG4gICAgICAgIHRoaXMudGlsZW1hcHMuZm9yRWFjaCh0aWxlbWFwID0+IHtcbiAgICAgICAgICAgIGlmKCF0aWxlbWFwLmdldExheWVyKCkuaXNQYXVzZWQoKSl7XG4gICAgICAgICAgICAgICAgdGlsZW1hcC51cGRhdGUoZGVsdGFUKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIGFsbCB0d2VlbnNcbiAgICAgICAgVHdlZW5NYW5hZ2VyLmdldEluc3RhbmNlKCkudXBkYXRlKGRlbHRhVCk7XG5cbiAgICAgICAgLy8gVXBkYXRlIGFsbCBwYXJ0aWNsZSBzeXN0ZW1zXG4gICAgICAgIFBhcnRpY2xlU3lzdGVtTWFuYWdlci5nZXRJbnN0YW5jZSgpLnVwZGF0ZShkZWx0YVQpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB2aWV3cG9ydFxuICAgICAgICB0aGlzLnZpZXdwb3J0LnVwZGF0ZShkZWx0YVQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbGxlY3RzIHJlbmRlcmFibGUgc2V0cyBhbmQgY29vcmRpbmF0ZXMgd2l0aCB0aGUgUmVuZGVyaW5nTWFuYWdlciB0byBkcmF3IHRoZSBTY2VuZVxuICAgICAqL1xuICAgIHJlbmRlcigpOiB2b2lkIHtcbiAgICAgICAgLy8gR2V0IHRoZSB2aXNpYmxlIHNldCBvZiBub2Rlc1xuICAgICAgICBsZXQgdmlzaWJsZVNldCA9IHRoaXMuc2NlbmVHcmFwaC5nZXRWaXNpYmxlU2V0KCk7XG5cbiAgICAgICAgLy8gQWRkIHBhcmFsbGF4IGxheWVyIGl0ZW1zIHRvIHRoZSB2aXNpYmxlIHNldCAod2UncmUgcmVuZGVyaW5nIHRoZW0gYWxsIGZvciBub3cpXG4gICAgICAgIHRoaXMucGFyYWxsYXhMYXllcnMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHBMYXllciA9IHRoaXMucGFyYWxsYXhMYXllcnMuZ2V0KGtleSk7XG4gICAgICAgICAgICBmb3IobGV0IG5vZGUgb2YgcExheWVyLmdldEl0ZW1zKCkpe1xuICAgICAgICAgICAgICAgIGlmKG5vZGUgaW5zdGFuY2VvZiBDYW52YXNOb2RlKXtcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZVNldC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU2VuZCB0aGUgdmlzaWJsZSBzZXQsIHRpbGVtYXBzLCBhbmQgdWlMYXllcnMgdG8gdGhlIHJlbmRlcmVyXG4gICAgICAgIHRoaXMucmVuZGVyaW5nTWFuYWdlci5yZW5kZXIodmlzaWJsZVNldCwgdGhpcy50aWxlbWFwcywgdGhpcy51aUxheWVycyk7XG5cbiAgICAgICAgbGV0IG5vZGVzID0gdGhpcy5zY2VuZUdyYXBoLmdldEFsbE5vZGVzKCk7XG4gICAgICAgIHRoaXMudGlsZW1hcHMuZm9yRWFjaCh0aWxlbWFwID0+IHRpbGVtYXAudmlzaWJsZSA/IG5vZGVzLnB1c2godGlsZW1hcCkgOiAwKTtcbiAgICAgICAgRGVidWcuc2V0Tm9kZXMobm9kZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNjZW5lIGFzIHJ1bm5pbmcgb3Igbm90XG4gICAgICogQHBhcmFtIHJ1bm5pbmcgVHJ1ZSBpZiB0aGUgU2NlbmUgc2hvdWxkIGJlIHJ1bm5pbmcsIGZhbHNlIGlmIG5vdFxuICAgICAqL1xuICAgIHNldFJ1bm5pbmcocnVubmluZzogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBydW5uaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIFNjZW5lIGlzIHJ1bm5pbmdcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBzY2VuZSBpcyBydW5uaW5nLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBpc1J1bm5pbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnJ1bm5pbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIG5vZGUgZnJvbSB0aGlzIFNjZW5lXG4gICAgICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXG4gICAgICovXG4gICAgcmVtb3ZlKG5vZGU6IEdhbWVOb2RlKTogdm9pZCB7XG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIHRoZSBzY2VuZSBncmFwaFxuICAgICAgICBpZihub2RlIGluc3RhbmNlb2YgQ2FudmFzTm9kZSl7XG4gICAgICAgICAgICB0aGlzLnNjZW5lR3JhcGgucmVtb3ZlTm9kZShub2RlKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLyoqIERlc3Ryb3lzIHRoaXMgc2NlbmUgYW5kIGFsbCBub2RlcyBpbiBpdCAqL1xuICAgIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIGZvcihsZXQgbm9kZSBvZiB0aGlzLnNjZW5lR3JhcGguZ2V0QWxsTm9kZXMoKSl7XG4gICAgICAgICAgICBub2RlLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihsZXQgdGlsZW1hcCBvZiB0aGlzLnRpbGVtYXBzKXtcbiAgICAgICAgICAgIHRpbGVtYXAuZGVzdHJveSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZWNlaXZlci5kZXN0cm95KCk7XG5cbiAgICAgICAgZGVsZXRlIHRoaXMuc2NlbmVHcmFwaDtcbiAgICAgICAgZGVsZXRlIHRoaXMucGh5c2ljc01hbmFnZXI7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm5hdk1hbmFnZXI7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmFpTWFuYWdlcjtcbiAgICAgICAgZGVsZXRlIHRoaXMucmVjZWl2ZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBsYXllciB0byB0aGUgc2NlbmUgYW5kIHJldHVybnMgaXRcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgbmV3IGxheWVyXG4gICAgICogQHBhcmFtIGRlcHRoIFRoZSBkZXB0aCBvZiB0aGUgbGF5ZXJcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3bHkgY3JlYXRlZCBMYXllclxuICAgICAqL1xuICAgIGFkZExheWVyKG5hbWU6IHN0cmluZywgZGVwdGg/OiBudW1iZXIpOiBMYXllciB7XG4gICAgICAgIGlmKHRoaXMubGF5ZXJzLmhhcyhuYW1lKSB8fCB0aGlzLnBhcmFsbGF4TGF5ZXJzLmhhcyhuYW1lKSB8fCB0aGlzLnVpTGF5ZXJzLmhhcyhuYW1lKSl7XG4gICAgICAgICAgICB0aHJvdyBgTGF5ZXIgd2l0aCBuYW1lICR7bmFtZX0gYWxyZWFkeSBleGlzdHNgO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxheWVyID0gbmV3IExheWVyKHRoaXMsIG5hbWUpO1xuXG4gICAgICAgIHRoaXMubGF5ZXJzLmFkZChuYW1lLCBsYXllcik7XG5cbiAgICAgICAgaWYoZGVwdGgpe1xuICAgICAgICAgICAgbGF5ZXIuc2V0RGVwdGgoZGVwdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgcGFyYWxsYXggbGF5ZXIgdG8gdGhpcyBzY2VuZSBhbmQgcmV0dXJucyBpdFxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwYXJhbGxheCBsYXllclxuICAgICAqIEBwYXJhbSBwYXJhbGxheCBUaGUgcGFyYWxsYXggbGV2ZWxcbiAgICAgKiBAcGFyYW0gZGVwdGggVGhlIGRlcHRoIG9mIHRoZSBsYXllclxuICAgICAqIEByZXR1cm5zIFRoZSBuZXdseSBjcmVhdGVkIFBhcmFsbGF4TGF5ZXJcbiAgICAgKi9cbiAgICBhZGRQYXJhbGxheExheWVyKG5hbWU6IHN0cmluZywgcGFyYWxsYXg6IFZlYzIsIGRlcHRoPzogbnVtYmVyKTogUGFyYWxsYXhMYXllciB7XG4gICAgICAgIGlmKHRoaXMubGF5ZXJzLmhhcyhuYW1lKSB8fCB0aGlzLnBhcmFsbGF4TGF5ZXJzLmhhcyhuYW1lKSB8fCB0aGlzLnVpTGF5ZXJzLmhhcyhuYW1lKSl7XG4gICAgICAgICAgICB0aHJvdyBgTGF5ZXIgd2l0aCBuYW1lICR7bmFtZX0gYWxyZWFkeSBleGlzdHNgO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxheWVyID0gbmV3IFBhcmFsbGF4TGF5ZXIodGhpcywgbmFtZSwgcGFyYWxsYXgpO1xuXG4gICAgICAgIHRoaXMucGFyYWxsYXhMYXllcnMuYWRkKG5hbWUsIGxheWVyKTtcblxuICAgICAgICBpZihkZXB0aCl7XG4gICAgICAgICAgICBsYXllci5zZXREZXB0aChkZXB0aCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBVSUxheWVyIHRvIHRoZSBzY2VuZVxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBuZXcgVUlsYXllclxuICAgICAqIEByZXR1cm5zIFRoZSBuZXdseSBjcmVhdGVkIFVJTGF5ZXJcbiAgICAgKi9cbiAgICBhZGRVSUxheWVyKG5hbWU6IHN0cmluZyk6IFVJTGF5ZXIge1xuICAgICAgICBpZih0aGlzLmxheWVycy5oYXMobmFtZSkgfHwgdGhpcy5wYXJhbGxheExheWVycy5oYXMobmFtZSkgfHwgdGhpcy51aUxheWVycy5oYXMobmFtZSkpe1xuICAgICAgICAgICAgdGhyb3cgYExheWVyIHdpdGggbmFtZSAke25hbWV9IGFscmVhZHkgZXhpc3RzYDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsYXllciA9IG5ldyBVSUxheWVyKHRoaXMsIG5hbWUpO1xuXG4gICAgICAgIHRoaXMudWlMYXllcnMuYWRkKG5hbWUsIGxheWVyKTtcblxuICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIGxheWVyIGZyb20gdGhlIHNjZW5lIGJ5IG5hbWUgaWYgaXQgZXhpc3RzLlxuICAgICAqIFRoaXMgY2FuIGJlIGEgTGF5ZXIgb3IgYW55IG9mIGl0cyBzdWJjbGFzc2VzXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGxheWVyXG4gICAgICogQHJldHVybnMgVGhlIExheWVyIGZvdW5kIHdpdGggdGhhdCBuYW1lXG4gICAgICovXG4gICAgZ2V0TGF5ZXIobmFtZTogc3RyaW5nKTogTGF5ZXIge1xuICAgICAgICBpZih0aGlzLmxheWVycy5oYXMobmFtZSkpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXJzLmdldChuYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmKHRoaXMucGFyYWxsYXhMYXllcnMuaGFzKG5hbWUpKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmFsbGF4TGF5ZXJzLmdldChuYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmKHRoaXMudWlMYXllcnMuaGFzKG5hbWUpKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVpTGF5ZXJzLmdldChuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGBSZXF1ZXN0ZWQgbGF5ZXIgJHtuYW1lfSBkb2VzIG5vdCBleGlzdC5gO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgbGF5ZXIgaXMgYSBQYXJhbGxheExheWVyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGxheWVyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGlzIGxheWVyIGlzIGEgUGFyYWxsYXhMYXllclxuICAgICAqL1xuICAgIGlzUGFyYWxsYXhMYXllcihuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYWxsYXhMYXllcnMuaGFzKG5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGxheWVyIGlzIGEgVUlMYXllclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBsYXllclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhpcyBsYXllciBpcyBQYXJhbGxheExheWVyXG4gICAgICovXG4gICAgaXNVSUxheWVyKG5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy51aUxheWVycy5oYXMobmFtZSk7XG4gICAgfSAgICBcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRyYW5zbGF0aW9uIG9mIHRoaXMgbm9kZSB3aXRoIHJlc3BlY3QgdG8gY2FtZXJhIHNwYWNlIChkdWUgdG8gdGhlIHZpZXdwb3J0IG1vdmluZykuXG4gICAgICogVGhpcyB2YWx1ZSBpcyBhZmZlY3RlZCBieSB0aGUgcGFyYWxsYXggbGV2ZWwgb2YgdGhlIEByZWZlcmVuY2VbTGF5ZXJdIHRoZSBub2RlIGlzIG9uLlxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIGNoZWNrIHRoZSB2aWV3cG9ydCB3aXRoIHJlc3BlY3QgdG9cbiAgICAgKiBAcmV0dXJucyBBIFZlYzIgY29udGFpbmluZyB0aGUgdHJhbnNsYXRpb24gb2Ygdmlld3BvcnQgd2l0aCByZXNwZWN0IHRvIHRoaXMgbm9kZS5cbiAgICAgKi9cbiAgICBnZXRWaWV3VHJhbnNsYXRpb24obm9kZTogR2FtZU5vZGUpOiBWZWMyIHtcbiAgICAgICAgbGV0IGxheWVyID0gbm9kZS5nZXRMYXllcigpO1xuXG4gICAgICAgIGlmKGxheWVyIGluc3RhbmNlb2YgUGFyYWxsYXhMYXllciB8fCBsYXllciBpbnN0YW5jZW9mIFVJTGF5ZXIpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlld3BvcnQuZ2V0T3JpZ2luKCkubXVsdChsYXllci5wYXJhbGxheCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3cG9ydC5nZXRPcmlnaW4oKTtcbiAgICAgICAgfVxuXHR9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzY2FsZSBsZXZlbCBvZiB0aGUgdmlld1xuICAgICAqIEByZXR1cm5zIFRoZSB6b29tIGxldmVsIG9mIHRoZSB2aWV3cG9ydFxuICAgICovXG5cdGdldFZpZXdTY2FsZSgpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLnZpZXdwb3J0LmdldFpvb21MZXZlbCgpO1xuXHR9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBWaWV3cG9ydCBhc3NvY2lhdGVkIHdpdGggdGhpcyBzY2VuZVxuICAgICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IFZpZXdwb3J0XG4gICAgICovXG4gICAgZ2V0Vmlld3BvcnQoKTogVmlld3BvcnQge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cG9ydDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB3b3JsZCBzaXplIG9mIHRoaXMgU2NlbmVcbiAgICAgKiBAcmV0dXJucyBUaGUgd29ybGQgc2l6ZSBpbiBhIFZlYzJcbiAgICAgKi9cbiAgICBnZXRXb3JsZFNpemUoKTogVmVjMiB7XG4gICAgICAgIHJldHVybiB0aGlzLndvcmxkU2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBTY2VuZUdyYXBoIGFzc29jaWF0ZWQgd2l0aCB0aGlzIFNjZW5lXG4gICAgICogQHJldHVybnMgVGhlIFNjZW5lR3JhcGhcbiAgICAgKi9cbiAgICBnZXRTY2VuZUdyYXBoKCk6IFNjZW5lR3JhcGgge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2VuZUdyYXBoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFBoeXNpY3NNYW5hZ2VyIGFzc29jaWF0ZWQgd2l0aCB0aGlzIFNjZW5lXG4gICAgICogQHJldHVybnMgVGhlIFBoeXNpY3NNYW5hZ2VyXG4gICAgICovXG4gICAgZ2V0UGh5c2ljc01hbmFnZXIoKTogUGh5c2ljc01hbmFnZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5waHlzaWNzTWFuYWdlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBOYXZpZ2F0aW9uTWFuYWdlciBhc3NvY2lhdGVkIHdpdGggdGhpcyBTY2VuZVxuICAgICAqIEByZXR1cm5zIFRoZSBOYXZpZ2F0aW9uTWFuYWdlclxuICAgICAqL1xuICAgIGdldE5hdmlnYXRpb25NYW5hZ2VyKCk6IE5hdmlnYXRpb25NYW5hZ2VyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2TWFuYWdlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBBSU1hbmFnZXIgYXNzb2NpYXRlZCB3aXRoIHRoaXMgU2NlbmVcbiAgICAgKiBAcmV0dXJucyBUaGUgQUlNYW5hZ2VyXG4gICAgICovXG4gICAgZ2V0QUlNYW5hZ2VyKCk6IEFJTWFuYWdlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmFpTWFuYWdlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYW4gSUQgZm9yIGEgR2FtZU5vZGVcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3IElEXG4gICAgICovXG4gICAgZ2VuZXJhdGVJZCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2VuZU1hbmFnZXIuZ2VuZXJhdGVJZCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIFRpbGVtYXAgaW4gdGhpcyBTY2VuZVxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBUaWxlbWFwXG4gICAgICogQHJldHVybnMgVGhlIFRpbGVtYXAsIGlmIG9uZSB0aGlzIG5hbWUgZXhpc3RzLCBvdGhlcndpc2UgbnVsbFxuICAgICAqL1xuICAgIGdldFRpbGVtYXAobmFtZTogc3RyaW5nKTogVGlsZW1hcCB7XG4gICAgICAgIGZvcihsZXQgdGlsZW1hcCBvZiB0aGlzIC50aWxlbWFwcyl7XG4gICAgICAgICAgICBpZih0aWxlbWFwLm5hbWUgPT09IG5hbWUpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0aWxlbWFwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufSIsImltcG9ydCBTY2VuZSBmcm9tIFwiLi9TY2VuZVwiO1xuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xuaW1wb3J0IFZpZXdwb3J0IGZyb20gXCIuLi9TY2VuZUdyYXBoL1ZpZXdwb3J0XCI7XG5pbXBvcnQgUmVuZGVyaW5nTWFuYWdlciBmcm9tIFwiLi4vUmVuZGVyaW5nL1JlbmRlcmluZ01hbmFnZXJcIjtcbmltcG9ydCBNZW1vcnlVdGlscyBmcm9tIFwiLi4vVXRpbHMvTWVtb3J5VXRpbHNcIjtcbmltcG9ydCBSZWNlaXZlciBmcm9tIFwiLi4vRXZlbnRzL1JlY2VpdmVyXCI7XG5pbXBvcnQgeyBHYW1lRXZlbnRUeXBlIH0gZnJvbSBcIi4uL0V2ZW50cy9HYW1lRXZlbnRUeXBlXCI7XG5cbi8qKlxuICogVGhlIFNjZW5lTWFuYWdlciBhY3RzIGFzIGFuIGludGVyZmFjZSB0byBjcmVhdGUgU2NlbmVzLCBhbmQgaGFuZGxlcyB0aGUgbGlmZWN5Y2xlIG1ldGhvZHMgb2YgU2NlbmVzLlxuICogSXQgZ2l2ZXMgU2NlbmVzIGFjY2VzcyB0byBpbmZvcm1hdGlvbiB0aGV5IG5lZWQgZnJvbSB0aGUgQHJlZmVyZW5jZVtHYW1lXSBjbGFzcyB3aGlsZSBrZWVwaW5nIGEgbGF5ZXIgb2Ygc2VwYXJhdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NlbmVNYW5hZ2VyIHtcblx0LyoqIFRoZSBjdXJyZW50IFNjZW5lIG9mIHRoZSBnYW1lICovXG5cdHByb3RlY3RlZCBjdXJyZW50U2NlbmU6IFNjZW5lO1xuXG5cdC8qKiBUaGUgVmlld3BvcnQgb2YgdGhlIGdhbWUgKi9cblx0cHJvdGVjdGVkIHZpZXdwb3J0OiBWaWV3cG9ydDtcblxuXHQvKiogQSByZWZlcmVuY2UgdG8gdGhlIFJlc291cmNlTWFuYWdlciAqL1xuXHRwcm90ZWN0ZWQgcmVzb3VyY2VNYW5hZ2VyOiBSZXNvdXJjZU1hbmFnZXI7XG5cblx0LyoqIEEgY291bnRlciB0byBrZWVwIHRyYWNrIG9mIGdhbWUgaWRzICovXG5cdHByb3RlY3RlZCBpZENvdW50ZXI6IG51bWJlcjtcblxuXHQvKiogVGhlIFJlbmRlcmluZ01hbmFnZXIgb2YgdGhlIGdhbWUgKi9cblx0cHJvdGVjdGVkIHJlbmRlcmluZ01hbmFnZXI6IFJlbmRlcmluZ01hbmFnZXI7XG5cblx0LyoqIEZvciBjb25zaXN0ZW5jeSwgb25seSBjaGFuZ2Ugc2NlbmVzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHVwZGF0ZSBjeWNsZSAqL1xuXHRwcm90ZWN0ZWQgcGVuZGluZ1NjZW5lOiBTY2VuZTtcblx0cHJvdGVjdGVkIHBlbmRpbmdTY2VuZUluaXQ6IFJlY29yZDxzdHJpbmcsIGFueT47XG5cblx0cHJvdGVjdGVkIHJlY2VpdmVyOiBSZWNlaXZlcjtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyBTY2VuZU1hbmFnZXJcblx0ICogQHBhcmFtIHZpZXdwb3J0IFRoZSBWaWV3cG9ydCBvZiB0aGUgZ2FtZVxuXHQgKiBAcGFyYW0gZ2FtZSBUaGUgR2FtZSBpbnN0YW5jZVxuXHQgKiBAcGFyYW0gcmVuZGVyaW5nTWFuYWdlciBUaGUgUmVuZGVyaW5nTWFuYWdlciBvZiB0aGUgZ2FtZVxuXHQgKi9cblx0Y29uc3RydWN0b3Iodmlld3BvcnQ6IFZpZXdwb3J0LCByZW5kZXJpbmdNYW5hZ2VyOiBSZW5kZXJpbmdNYW5hZ2VyKXtcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xuXHRcdHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcblx0XHR0aGlzLnJlbmRlcmluZ01hbmFnZXIgPSByZW5kZXJpbmdNYW5hZ2VyO1xuXHRcdHRoaXMuaWRDb3VudGVyID0gMDtcblx0XHR0aGlzLnBlbmRpbmdTY2VuZSA9IG51bGw7XG5cblx0XHR0aGlzLnJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKCk7XG5cdFx0dGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoR2FtZUV2ZW50VHlwZS5DSEFOR0VfU0NFTkUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZCBhIHNjZW5lIGFzIHRoZSBtYWluIHNjZW5lLlxuXHQgKiBVc2UgdGhpcyBtZXRob2QgaWYgeW91J3ZlIGNyZWF0ZWQgYSBzdWJjbGFzcyBvZiBTY2VuZSwgYW5kIHlvdSB3YW50IHRvIGFkZCBpdCBhcyB0aGUgbWFpbiBTY2VuZS5cblx0ICogQHBhcmFtIGNvbnN0ciBUaGUgY29uc3RydWN0b3Igb2YgdGhlIHNjZW5lIHRvIGFkZFxuXHQgKiBAcGFyYW0gaW5pdCBBbiBvYmplY3QgdG8gcGFzcyB0byB0aGUgaW5pdCBmdW5jdGlvbiBvZiB0aGUgbmV3IHNjZW5lXG5cdCAqL1xuXHRwdWJsaWMgY2hhbmdlVG9TY2VuZTxUIGV4dGVuZHMgU2NlbmU+KGNvbnN0cjogbmV3ICguLi5hcmdzOiBhbnkpID0+IFQsIGluaXQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xuXHRcdGNvbnNvbGUubG9nKFwiQ3JlYXRpbmcgdGhlIG5ldyBzY2VuZSAtIGNoYW5nZSBpcyBwZW5kaW5nIHVudGlsIG5leHQgdXBkYXRlXCIpO1xuXHRcdHRoaXMucGVuZGluZ1NjZW5lID0gbmV3IGNvbnN0cih0aGlzLnZpZXdwb3J0LCB0aGlzLCB0aGlzLnJlbmRlcmluZ01hbmFnZXIsIG9wdGlvbnMpO1xuXHRcdHRoaXMucGVuZGluZ1NjZW5lSW5pdCA9IGluaXQ7XG5cdH1cblxuXHRwcm90ZWN0ZWQgZG9TY2VuZUNoYW5nZSgpe1xuXHRcdGNvbnNvbGUubG9nKFwiUGVyZm9ybWluZyBzY2VuZSBjaGFuZ2VcIik7XG5cdFx0dGhpcy52aWV3cG9ydC5zZXRDZW50ZXIodGhpcy52aWV3cG9ydC5nZXRIYWxmU2l6ZSgpLngsIHRoaXMudmlld3BvcnQuZ2V0SGFsZlNpemUoKS55KTtcblx0XHRcblx0XHRpZih0aGlzLmN1cnJlbnRTY2VuZSl7XG5cdFx0XHRjb25zb2xlLmxvZyhcIlVubG9hZGluZyBvbGQgc2NlbmVcIilcblx0XHRcdHRoaXMuY3VycmVudFNjZW5lLnVubG9hZFNjZW5lKCk7XG5cblx0XHRcdGNvbnNvbGUubG9nKFwiRGVzdHJveWluZyBvbGQgc2NlbmVcIik7XG5cdFx0XHR0aGlzLmN1cnJlbnRTY2VuZS5kZXN0cm95KCk7XG5cdFx0fVxuXG5cdFx0Y29uc29sZS5sb2coXCJVbmxvYWRpbmcgb2xkIHJlc291cmNlcy4uLlwiKTtcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlci51bmxvYWRBbGxSZXNvdXJjZXMoKTtcblxuXHRcdC8vIE1ha2UgdGhlIHBlbmRpbmcgc2NlbmUgdGhlIGN1cnJlbnQgb25lXG5cdFx0dGhpcy5jdXJyZW50U2NlbmUgPSB0aGlzLnBlbmRpbmdTY2VuZTtcblxuXHRcdC8vIE1ha2UgdGhlIHBlbmRpbmcgc2NlbmUgbnVsbFxuXHRcdHRoaXMucGVuZGluZ1NjZW5lID0gbnVsbDtcblxuXHRcdC8vIEluaXQgdGhlIHNjZW5lXG5cdFx0dGhpcy5jdXJyZW50U2NlbmUuaW5pdFNjZW5lKHRoaXMucGVuZGluZ1NjZW5lSW5pdCk7XG5cblx0XHQvLyBFbnF1ZXVlIGFsbCBzY2VuZSBhc3NldCBsb2Fkc1xuXHRcdHRoaXMuY3VycmVudFNjZW5lLmxvYWRTY2VuZSgpO1xuXG5cdFx0Ly8gTG9hZCBhbGwgYXNzZXRzXG5cdFx0Y29uc29sZS5sb2coXCJTdGFydGluZyBTY2VuZSBMb2FkXCIpO1xuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyLmxvYWRSZXNvdXJjZXNGcm9tUXVldWUoKCkgPT4ge1xuXHRcdFx0Y29uc29sZS5sb2coXCJTdGFydGluZyBTY2VuZVwiKTtcblx0XHRcdHRoaXMuY3VycmVudFNjZW5lLnN0YXJ0U2NlbmUoKTtcblx0XHRcdHRoaXMuY3VycmVudFNjZW5lLnNldFJ1bm5pbmcodHJ1ZSk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLnJlbmRlcmluZ01hbmFnZXIuc2V0U2NlbmUodGhpcy5jdXJyZW50U2NlbmUpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogR2VuZXJhdGVzIGEgdW5pcXVlIElEXG5cdCAqIEByZXR1cm5zIEEgbmV3IElEXG5cdCAqL1xuXHRwdWJsaWMgZ2VuZXJhdGVJZCgpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLmlkQ291bnRlcisrO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbmRlcnMgdGhlIGN1cnJlbnQgU2NlbmVcblx0ICovXG5cdHB1YmxpYyByZW5kZXIoKTogdm9pZCB7XG5cdFx0aWYodGhpcy5jdXJyZW50U2NlbmUpe1xuXHRcdFx0dGhpcy5jdXJyZW50U2NlbmUucmVuZGVyKCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIGN1cnJlbnQgU2NlbmVcblx0ICogQHBhcmFtIGRlbHRhVCBUaGUgdGltZXN0ZXAgb2YgdGhlIFNjZW5lXG5cdCAqL1xuXHRwdWJsaWMgdXBkYXRlKGRlbHRhVDogbnVtYmVyKXtcblx0XHR3aGlsZSAodGhpcy5yZWNlaXZlci5oYXNOZXh0RXZlbnQoKSkge1xuXHRcdFx0bGV0IGV2ID0gdGhpcy5yZWNlaXZlci5nZXROZXh0RXZlbnQoKTtcblx0XHRcdGlmIChldi50eXBlID09PSBHYW1lRXZlbnRUeXBlLkNIQU5HRV9TQ0VORSkgdGhpcy5jaGFuZ2VUb1NjZW5lKGV2LmRhdGEuZ2V0KFwic2NlbmVcIiksIGV2LmRhdGEuZ2V0KFwiaW5pdFwiKSk7XG5cdFx0fVxuXG5cdFx0aWYodGhpcy5wZW5kaW5nU2NlbmUgIT09IG51bGwpe1xuXHRcdFx0dGhpcy5kb1NjZW5lQ2hhbmdlKCk7XG5cdFx0fVxuXG5cdFx0aWYodGhpcy5jdXJyZW50U2NlbmUgJiYgdGhpcy5jdXJyZW50U2NlbmUuaXNSdW5uaW5nKCkpe1xuXHRcdFx0dGhpcy5jdXJyZW50U2NlbmUudXBkYXRlKGRlbHRhVCk7XG5cdFx0fVxuXHR9XG59IiwiaW1wb3J0IEFycmF5VXRpbHMgZnJvbSBcIi4uL1V0aWxzL0FycmF5VXRpbHNcIjtcblxuLy8gQGlnbm9yZVBhZ2VcblxuLyoqXG4gKiBUaGUgb3B0aW9ucyB0byBnaXZlIGEgQHJlZmVyZW5jZVtTY2VuZV0gZm9yIGluaXRpYWxpemF0aW9uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjZW5lT3B0aW9ucyB7XG4gICAgcGh5c2ljczoge1xuICAgICAgICBncm91cHM6IEFycmF5PHN0cmluZz4sXG4gICAgICAgIGNvbGxpc2lvbnM6IEFycmF5PEFycmF5PG51bWJlcj4+O1xuICAgIH1cblxuICAgIHN0YXRpYyBwYXJzZShvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogU2NlbmVPcHRpb25ze1xuICAgICAgICBsZXQgc09wdCA9IG5ldyBTY2VuZU9wdGlvbnMoKTtcblxuICAgICAgICBpZihvcHRpb25zLnBoeXNpY3MgPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICBzT3B0LnBoeXNpY3MgPSB7Z3JvdXBzOiB1bmRlZmluZWQsIGNvbGxpc2lvbnM6IHVuZGVmaW5lZH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzT3B0LnBoeXNpY3MgPSBvcHRpb25zLnBoeXNpY3M7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc09wdDtcbiAgICB9XG59IiwiaW1wb3J0IFZpZXdwb3J0IGZyb20gXCIuL1ZpZXdwb3J0XCI7XG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xuaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL0NvbGxlY3Rpb25zL01hcFwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lL1NjZW5lXCI7XG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XG5cbi8qKlxuICogQW4gYWJzdHJhY3QgaW50ZXJmYWNlIG9mIGEgU2NlbmVHcmFwaC5cbiAqIEV4cG9zZXMgbWV0aG9kcyBmb3IgdXNlIGJ5IG90aGVyIGNvZGUsIGJ1dCBsZWF2ZXMgdGhlIGltcGxlbWVudGF0aW9uIHVwIHRvIHRoZSBzdWJjbGFzc2VzLlxuICogVGhlIFNjZW5lR3JhcGggbWFuYWdlcyB0aGUgcG9zaXRpb25zIG9mIGFsbCBHYW1lTm9kZXMsIGFuZCBjYW4gZWFzaWx5IHBydW5lIGEgdmlzaWJsZSBzZXQgZm9yIHJlbmRlcmluZy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgU2NlbmVHcmFwaCB7XG5cdC8qKlx0QSByZWZlcmVuY2UgdG8gdGhlIHZpZXdwb3J0ICovXG5cdHByb3RlY3RlZCB2aWV3cG9ydDogVmlld3BvcnQ7XG5cdC8qKlx0QSBtYXAgb2YgQ2FudmFzTm9kZXMgaW4gdGhpcyBTY2VuZUdyYXBoICovXG5cdHByb3RlY3RlZCBub2RlTWFwOiBBcnJheTxDYW52YXNOb2RlPjtcblx0LyoqIEEgY291bnRlciBvZiBJRHMgZm9yIG5vZGVzIGluIHRoaXMgU2NlbmVHcmFwaCAqL1xuXHRwcm90ZWN0ZWQgaWRDb3VudGVyOiBudW1iZXI7XG5cdC8qKiBBIHJlZmVyZW5jZSB0byB0aGUgU2NlbmUgdGhpcyBTY2VuZUdyYXBoIGJlbG9uZ3MgdG8gKi9cblx0cHJvdGVjdGVkIHNjZW5lOiBTY2VuZTtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyBTY2VuZUdyYXBoXG5cdCAqIEBwYXJhbSB2aWV3cG9ydCBUaGUgdmlld3BvcnRcblx0ICogQHBhcmFtIHNjZW5lIFRoZSBTY2VuZSB0aGlzIFNjZW5lR3JhcGggYmVsb25ncyB0b1xuXHQgKi9cbiAgICBjb25zdHJ1Y3Rvcih2aWV3cG9ydDogVmlld3BvcnQsIHNjZW5lOiBTY2VuZSl7XG5cdFx0dGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuXHRcdHRoaXMuc2NlbmUgPSBzY2VuZTtcblx0XHR0aGlzLm5vZGVNYXAgPSBuZXcgQXJyYXkoKTtcblx0XHR0aGlzLmlkQ291bnRlciA9IDA7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBBZGQgYSBub2RlIHRvIHRoZSBTY2VuZUdyYXBoXG5cdCAqIEBwYXJhbSBub2RlIFRoZSBDYW52YXNOb2RlIHRvIGFkZCB0byB0aGUgU2NlbmVHcmFwaFxuXHQgKiBAcmV0dXJucyBUaGUgU2NlbmVHcmFwaCBJRCBvZiB0aGlzIG5ld2x5IGFkZGVkIENhbnZhc05vZGVcblx0ICovXG4gICAgYWRkTm9kZShub2RlOiBDYW52YXNOb2RlKTogbnVtYmVyIHtcblx0XHR0aGlzLm5vZGVNYXBbbm9kZS5pZF0gPSBub2RlO1xuXHRcdHRoaXMuYWRkTm9kZVNwZWNpZmljKG5vZGUsIHRoaXMuaWRDb3VudGVyKTtcblx0XHR0aGlzLmlkQ291bnRlciArPSAxO1xuXHRcdHJldHVybiB0aGlzLmlkQ291bnRlciAtIDE7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFuIG92ZXJyaWRhYmxlIG1ldGhvZCB0byBhZGQgYSBDYW52YXNOb2RlIHRvIHRoZSBzcGVjaWZpYyBkYXRhIHN0cnVjdHVyZSBvZiB0aGUgU2NlbmVHcmFwaFxuXHQgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB0byBhZGQgdG8gdGhlIGRhdGEgc3RydWN0dXJlXG5cdCAqIEBwYXJhbSBpZCBUaGUgaWQgb2YgdGhlIENhbnZhc05vZGVcblx0ICovXG5cdHByb3RlY3RlZCBhYnN0cmFjdCBhZGROb2RlU3BlY2lmaWMobm9kZTogQ2FudmFzTm9kZSwgaWQ6IG51bWJlcik6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYSBub2RlIGZyb20gdGhlIFNjZW5lR3JhcGhcblx0ICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXG5cdCAqL1xuICAgIHJlbW92ZU5vZGUobm9kZTogQ2FudmFzTm9kZSk6IHZvaWQge1xuXHRcdC8vIEZpbmQgYW5kIHJlbW92ZSBub2RlIGluIE8obilcblx0XHR0aGlzLm5vZGVNYXBbbm9kZS5pZF0gPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5yZW1vdmVOb2RlU3BlY2lmaWMobm9kZSwgbm9kZS5pZCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBvZiByZW1vdmluZyBhIG5vZGVcblx0ICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXG5cdCAqIEBwYXJhbSBpZCBUaGUgaWQgb2YgdGhlIG5vZGUgdG8gcmVtb3ZlXG5cdCAqL1xuXHRwcm90ZWN0ZWQgYWJzdHJhY3QgcmVtb3ZlTm9kZVNwZWNpZmljKG5vZGU6IENhbnZhc05vZGUsIGlkOiBudW1iZXIpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBHZXQgYSBzcGVjaWZpYyBub2RlIHVzaW5nIGl0cyBpZFxuXHQgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBDYW52YXNOb2RlIHRvIHJldHJpZXZlXG5cdCAqIEByZXR1cm5zIFRoZSBub2RlIHdpdGggdGhpcyBJRFxuXHQgKi9cblx0Z2V0Tm9kZShpZDogbnVtYmVyKTogQ2FudmFzTm9kZSB7XG5cdFx0cmV0dXJuIHRoaXMubm9kZU1hcFtpZF07XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbm9kZXMgYXQgc3BlY2lmaWMgY29vcmRpbmF0ZXNcblx0ICogQHBhcmFtIHZlY09yWCBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBwb3NpdGlvbiwgb3IgdGhlIGNvb3JkaW5hdGVzIGluIGEgVmVjMlxuXHQgKiBAcGFyYW0geSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBwb3NpdGlvblxuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBub2RlcyBmb3VuZCBhdCB0aGUgcG9zaXRpb24gcHJvdmlkZWRcblx0ICovXG4gICAgZ2V0Tm9kZXNBdCh2ZWNPclg6IFZlYzIgfCBudW1iZXIsIHk6IG51bWJlciA9IG51bGwpOiBBcnJheTxDYW52YXNOb2RlPiB7XG5cdFx0aWYodmVjT3JYIGluc3RhbmNlb2YgVmVjMil7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXROb2Rlc0F0Q29vcmRzKHZlY09yWC54LCB2ZWNPclgueSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLmdldE5vZGVzQXRDb29yZHModmVjT3JYLCB5KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbm9kZXMgdGhhdCBvdmVybGFwIGEgc3BlY2lmaWMgYm91bmRhcnlcblx0ICogQHBhcmFtIGJvdW5kYXJ5IFRoZSByZWdpb24gdG8gY2hlY2tcblx0ICogQHJldHVybnMgQW4gYXJyYXkgb2Ygbm9kZXMgZm91bmQgb3ZlcmxhcHBpbmcgdGhlIHByb3ZpZGVkIGJvdW5kYXJ5XG5cdCAqL1xuXHRhYnN0cmFjdCBnZXROb2Rlc0luUmVnaW9uKGJvdW5kYXJ5OiBBQUJCKTogQXJyYXk8Q2FudmFzTm9kZT47XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhbGwgbm9kZXMgaW4gdGhlIFNjZW5lR3JhcGhcblx0ICogQHJldHVybnMgQW4gQXJyYXkgY29udGFpbmluZyBhbGwgbm9kZXMgaW4gdGhlIFNjZW5lR3JhcGhcblx0ICovXG5cdGdldEFsbE5vZGVzKCk6IEFycmF5PENhbnZhc05vZGU+IHtcblx0XHRsZXQgYXJyID0gbmV3IEFycmF5PENhbnZhc05vZGU+KCk7XG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IHRoaXMubm9kZU1hcC5sZW5ndGg7IGkrKyl7XG5cdFx0XHRpZih0aGlzLm5vZGVNYXBbaV0gIT09IHVuZGVmaW5lZCl7XG5cdFx0XHRcdGFyci5wdXNoKHRoaXMubm9kZU1hcFtpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBhcnI7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIG9mIGdldHRpbmcgYSBub2RlIGF0IGNlcnRhaW4gY29vcmRpbmF0ZXNcblx0ICogQHBhcmFtIHggVGhlIHgtY29vcmRpbmF0ZXMgb2YgdGhlIG5vZGVcblx0ICogQHBhcmFtIHkgVGhlIHktY29vcmRpbmF0ZXMgb2YgdGhlIG5vZGVcblx0ICovXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IGdldE5vZGVzQXRDb29yZHMoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBBcnJheTxDYW52YXNOb2RlPjtcblxuXHRhYnN0cmFjdCB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkO1xuXHRcblx0YWJzdHJhY3QgcmVuZGVyKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogdm9pZDtcblxuXHQvKipcblx0ICogR2V0cyB0aGUgdmlzaWJsZSBzZXQgb2YgQ2FudmFzTm9kZXMgYmFzZWQgb24gdGhlIEByZWZlcmVuY2VbVmlld3BvcnRdXG5cdCAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIHZpc2libGUgbm9kZXMgaW4gdGhlIFNjZW5lR3JhcGhcblx0ICovXG4gICAgYWJzdHJhY3QgZ2V0VmlzaWJsZVNldCgpOiBBcnJheTxDYW52YXNOb2RlPjtcbn0iLCJpbXBvcnQgU2NlbmVHcmFwaCBmcm9tIFwiLi9TY2VuZUdyYXBoXCI7XG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xuaW1wb3J0IFZpZXdwb3J0IGZyb20gXCIuL1ZpZXdwb3J0XCI7XG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lL1NjZW5lXCI7XG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XG5pbXBvcnQgU3RhdHMgZnJvbSBcIi4uL0RlYnVnL1N0YXRzXCI7XG5cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgYSBTY2VuZUdyYXBoIHRoYXQgc2ltcGx5IHN0b3JlZCBDYW52YXNOb2RlcyBpbiBhbiBhcnJheS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NlbmVHcmFwaEFycmF5IGV4dGVuZHMgU2NlbmVHcmFwaCB7XG4gICAgLyoqIFRoZSBsaXN0IG9mIENhbnZhc05vZGVzIGluIHRoaXMgU2NlbmVHcmFwaCAqL1xuICAgIHByaXZhdGUgbm9kZUxpc3Q6IEFycmF5PENhbnZhc05vZGU+O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTY2VuZUdyYXBoQXJyYXlcbiAgICAgKiBAcGFyYW0gdmlld3BvcnQgVGhlIFZpZXdwb3J0XG4gICAgICogQHBhcmFtIHNjZW5lIFRoZSBTY2VuZSB0aGlzIFNjZW5lR3JhcGggYmVsb25ncyB0b1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZpZXdwb3J0OiBWaWV3cG9ydCwgc2NlbmU6IFNjZW5lKXtcbiAgICAgICAgc3VwZXIodmlld3BvcnQsIHNjZW5lKTtcblxuICAgICAgICB0aGlzLm5vZGVMaXN0ID0gbmV3IEFycmF5PENhbnZhc05vZGU+KCk7XG4gICAgfVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgcHJvdGVjdGVkIGFkZE5vZGVTcGVjaWZpYyhub2RlOiBDYW52YXNOb2RlLCBpZDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMubm9kZUxpc3QucHVzaChub2RlKTtcbiAgICB9XG5cbiAgICAvLyBAb3ZlcnJpZGVcbiAgICBwcm90ZWN0ZWQgcmVtb3ZlTm9kZVNwZWNpZmljKG5vZGU6IENhbnZhc05vZGUsIGlkOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5ub2RlTGlzdC5pbmRleE9mKG5vZGUpO1xuICAgICAgICBpZihpbmRleCA+IC0xKXtcbiAgICAgICAgICAgIHRoaXMubm9kZUxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEBvdmVycmlkZVxuICAgIGdldE5vZGVzQXRDb29yZHMoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBBcnJheTxDYW52YXNOb2RlPiB7XG4gICAgICAgIGxldCByZXN1bHRzID0gW107XG5cbiAgICAgICAgZm9yKGxldCBub2RlIG9mIHRoaXMubm9kZUxpc3Qpe1xuICAgICAgICAgICAgaWYobm9kZS5jb250YWlucyh4LCB5KSl7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgZ2V0Tm9kZXNJblJlZ2lvbihib3VuZGFyeTogQUFCQik6IEFycmF5PENhbnZhc05vZGU+IHtcbiAgICAgICAgbGV0IHQwID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGxldCByZXN1bHRzID0gW107XG5cbiAgICAgICAgZm9yKGxldCBub2RlIG9mIHRoaXMubm9kZUxpc3Qpe1xuICAgICAgICAgICAgaWYoYm91bmRhcnkub3ZlcmxhcHMobm9kZS5ib3VuZGFyeSkpe1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdDEgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgU3RhdHMubG9nKFwic2dxdWVyeVwiLCAodDEtdDApKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgbGV0IHQwID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGZvcihsZXQgbm9kZSBvZiB0aGlzLm5vZGVMaXN0KXtcbiAgICAgICAgICAgIGlmKCFub2RlLmdldExheWVyKCkuaXNQYXVzZWQoKSl7XG4gICAgICAgICAgICAgICAgbm9kZS51cGRhdGUoZGVsdGFUKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdDEgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgU3RhdHMubG9nKFwic2d1cGRhdGVcIiwgKHQxLXQwKSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogdm9pZCB7fVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgZ2V0VmlzaWJsZVNldCgpOiBBcnJheTxDYW52YXNOb2RlPiB7XG4gICAgICAgIGxldCB2aXNpYmxlU2V0ID0gbmV3IEFycmF5PENhbnZhc05vZGU+KCk7XG5cbiAgICAgICAgZm9yKGxldCBub2RlIG9mIHRoaXMubm9kZUxpc3Qpe1xuICAgICAgICAgICAgaWYoIW5vZGUuZ2V0TGF5ZXIoKS5pc0hpZGRlbigpICYmIG5vZGUudmlzaWJsZSAmJiB0aGlzLnZpZXdwb3J0LmluY2x1ZGVzKG5vZGUpKXtcbiAgICAgICAgICAgICAgICB2aXNpYmxlU2V0LnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmlzaWJsZVNldDtcbiAgICB9XG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uL05vZGVzL0dhbWVOb2RlXCI7XG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xuaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vVXRpbHMvTWF0aFV0aWxzXCI7XG5pbXBvcnQgUXVldWUgZnJvbSBcIi4uL0RhdGFUeXBlcy9Db2xsZWN0aW9ucy9RdWV1ZVwiO1xuaW1wb3J0IEFBQkIgZnJvbSBcIi4uL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xuaW1wb3J0IElucHV0IGZyb20gXCIuLi9JbnB1dC9JbnB1dFwiO1xuaW1wb3J0IFBhcmFsbGF4TGF5ZXIgZnJvbSBcIi4uL1NjZW5lL0xheWVycy9QYXJhbGxheExheWVyXCI7XG5pbXBvcnQgVUlMYXllciBmcm9tIFwiLi4vU2NlbmUvTGF5ZXJzL1VJTGF5ZXJcIjtcblxuLyoqXG4gKiBUaGUgdmlld3BvcnQgb2YgdGhlIGdhbWUuIENvcnJlc3BvbmRzIHRvIHRoZSB2aXNpYmxlIHdpbmRvdyBkaXNwbGF5ZWQgaW4gdGhlIGJyb3dzZXIuXG4gKiBUaGUgdmlld3BvcnQga2VlcHMgdHJhY2sgb2YgaXRzIHBvc2l0aW9uIGluIHRoZSBnYW1lIHdvcmxkLCBhbmQgY2FuIGFjdCBhcyBhIGNhbWVyYSB0byBmb2xsb3cgb2JqZWN0cy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlld3BvcnQge1xuICAgIC8qKiBUaGUgQUFCQiB0aGF0IGNvbnRhaW5zIHRoZSBwb3NpdGlvbiBhbmQgc2l6ZSBvZiB0aGUgdmlld3BvcnQgdmlldyAqL1xuICAgIHByaXZhdGUgdmlldzogQUFCQjtcbiAgICAvKiogVGhlIGJvdW5kYXJ5IGZvciB0aGUgdmlld3BvcnQuIFRoaXMgcmVwcmVzZW50cyB0aGUgbGltaXRzIHRvIHdoZXJlIHRoZSB2aWV3cG9ydCBjYW4gZ28gKi9cbiAgICBwcml2YXRlIGJvdW5kYXJ5OiBBQUJCO1xuICAgIC8qKiBUaGUgR2FtZU5vZGUgdGhlIFZpZXdwb3J0IGlzIGZvbGxvd2luZyAqL1xuICAgIHByaXZhdGUgZm9sbG93aW5nOiBHYW1lTm9kZTtcbiAgICAvKiogVGhlIHBvc2l0aW9uIHRoZSBHYW1lTm9kZSBpcyBmb2N1c2luZyBvbi4gVGhpcyBpcyBvdmVycmlkZGVuIGlmIFwiZm9sbG93aW5nXCIgaXMgc2V0LiAqL1xuICAgIHByaXZhdGUgZm9jdXM6IFZlYzI7XG5cbiAgICAvKiogQSBxdWV1ZSBvZiBwcmV2aW91cyBwb3NpdGlvbnMgb2Ygd2hhdCB0aGlzIHZpZXdwb3J0IGlzIGZvbGxvd2luZy4gVXNlZCBmb3Igc21vb3RoaW5nIHZpZXdwb3J0IG1vdmVtZW50ICovXG4gICAgcHJpdmF0ZSBsYXN0UG9zaXRpb25zOiBRdWV1ZTxWZWMyPjtcblxuICAgIC8qKiBUaGUgbnVtYmVyIG9mIHByZXZpb3VzIHBvc2l0aW9ucyB0aGlzIHZpZXdwb3J0IHRyYWNrcyAqL1xuICAgIHByaXZhdGUgc21vb3RoaW5nRmFjdG9yOiBudW1iZXI7XG5cbiAgICAvKiogQSBib29sZWFuIHRoYSByZXByZXNlbnRzIHdoZXRoZXIgdGhlIHBsYXllciBjYW4gem9vbSBieSBzY3JvbGxpbmcgd2l0aCB0aGUgbW91c2Ugd2hlZWwgKi9cbiAgICBwcml2YXRlIHNjcm9sbFpvb21FbmFibGVkOiBib29sZWFuO1xuXG4gICAgLyoqIFRoZSBhbW91bnQgdGhhdCBpcyB6b29tZWQgaW4gb3Igb3V0LiAqL1xuICAgIHByaXZhdGUgWk9PTV9GQUNUT1I6IG51bWJlciA9IDEuMjtcblxuICAgIC8qKiBUaGUgc2l6ZSBvZiB0aGUgY2FudmFzICovXG4gICAgcHJpdmF0ZSBjYW52YXNTaXplOiBWZWMyO1xuXG4gICAgY29uc3RydWN0b3IoY2FudmFzU2l6ZTogVmVjMiwgem9vbUxldmVsOiBudW1iZXIpe1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgQUFCQihWZWMyLlpFUk8sIFZlYzIuWkVSTyk7XG4gICAgICAgIHRoaXMuYm91bmRhcnkgPSBuZXcgQUFCQihWZWMyLlpFUk8sIFZlYzIuWkVSTyk7XG4gICAgICAgIHRoaXMubGFzdFBvc2l0aW9ucyA9IG5ldyBRdWV1ZSgpO1xuICAgICAgICB0aGlzLnNtb290aGluZ0ZhY3RvciA9IDEwO1xuICAgICAgICB0aGlzLnNjcm9sbFpvb21FbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FudmFzU2l6ZSA9IFZlYzIuWkVSTztcbiAgICAgICAgdGhpcy5mb2N1cyA9IFZlYzIuWkVSTztcblxuICAgICAgICAvLyBTZXQgdGhlIHNpemUgb2YgdGhlIGNhbnZhc1xuICAgICAgICB0aGlzLnNldENhbnZhc1NpemUoY2FudmFzU2l6ZSk7XG5cbiAgICAgICAgLy8gU2V0IHRoZSBzaXplIG9mIHRoZSB2aWV3cG9ydFxuICAgICAgICB0aGlzLnNldFNpemUoY2FudmFzU2l6ZSk7XG4gICAgICAgIHRoaXMuc2V0Wm9vbUxldmVsKHpvb21MZXZlbCk7XG5cbiAgICAgICAgLy8gU2V0IHRoZSBjZW50ZXIgKGFuZCBtYWtlIHRoZSB2aWV3cG9ydCBzdGF5IHRoZXJlKVxuICAgICAgICB0aGlzLnNldENlbnRlcih0aGlzLnZpZXcuaGFsZlNpemUuY2xvbmUoKSk7XG4gICAgICAgIHRoaXMuc2V0Rm9jdXModGhpcy52aWV3LmhhbGZTaXplLmNsb25lKCkpO1xuICAgIH1cblxuICAgIC8qKiBFbmFibGVzIHRoZSB2aWV3cG9ydCB0byB6b29tIGluIGFuZCBvdXQgKi9cbiAgICBlbmFibGVab29tKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnNjcm9sbFpvb21FbmFibGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgdmlld3BvcnRcbiAgICAgKiBAcmV0dXJucyBUaGUgY2VudGVyIG9mIHRoZSB2aWV3cG9ydCBhcyBhIFZlYzJcbiAgICAgKi9cbiAgICBnZXRDZW50ZXIoKTogVmVjMiB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuY2VudGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgVmVjMiB3aXRoIHRoZSBvcmlnaW4gb2YgdGhlIHZpZXdwb3J0XG4gICAgICogQHJldHVybnMgVGhlIHRvcCBsZWZ0IGNvcm5kZXIgb2YgdGhlIFZpZXBvcnQgYXMgYSBWZWMyXG4gICAgICovXG4gICAgZ2V0T3JpZ2luKCk6IFZlYzIge1xuICAgICAgICByZXR1cm4gbmV3IFZlYzIodGhpcy52aWV3LmxlZnQsIHRoaXMudmlldy50b3ApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJlZ2lvbiB2aXNpYmxlIHRvIHRoaXMgdmlld3BvcnRcbiAgICAgKiBAcmV0dXJucyBUaGUgQUFCQiBjb250YWluaW5nIHRoZSByZWdpb24gdmlzaWJsZSB0byB0aGUgdmlld3BvcnRcbiAgICAgKi9cbiAgICBnZXRWaWV3KCk6IEFBQkIge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcG9zaXRpb24gb2YgdGhlIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHZlY09yWCBUaGUgbmV3IHBvc2l0aW9uIG9yIHRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIG5ldyBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB5IFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIG5ldyBwb3NpdGlvblxuICAgICAqL1xuICAgIHNldENlbnRlcih2ZWNPclg6IFZlYzIgfCBudW1iZXIsIHk6IG51bWJlciA9IG51bGwpOiB2b2lkIHtcbiAgICAgICAgbGV0IHBvczogVmVjMjtcblx0XHRpZih2ZWNPclggaW5zdGFuY2VvZiBWZWMyKXtcbiAgICAgICAgICAgIHBvcyA9IHZlY09yWDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvcyA9IG5ldyBWZWMyKHZlY09yWCwgeSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZpZXcuY2VudGVyID0gcG9zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNpemUgb2YgdGhlIHZpZXdwb3J0IGFzIGEgVmVjMlxuICAgICAqIEByZXR1cm5zIFRoZSBoYWxmLXNpemUgb2YgdGhlIHZpZXdwb3J0IGFzIGEgVmVjMlxuICAgICAqL1xuICAgIGdldEhhbGZTaXplKCk6IFZlYzIge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmdldEhhbGZTaXplKCk7XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNpemUgb2YgdGhlIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHZlY09yWCBUaGUgbmV3IHdpZHRoIG9mIHRoZSB2aWV3cG9ydCBvciB0aGUgbmV3IHNpemUgYXMgYSBWZWMyXG4gICAgICogQHBhcmFtIHkgVGhlIG5ldyBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0XG4gICAgICovXG4gICAgc2V0U2l6ZSh2ZWNPclg6IFZlYzIgfCBudW1iZXIsIHk6IG51bWJlciA9IG51bGwpOiB2b2lkIHtcblx0XHRpZih2ZWNPclggaW5zdGFuY2VvZiBWZWMyKXtcblx0XHRcdHRoaXMudmlldy5zZXRIYWxmU2l6ZSh2ZWNPclguc2NhbGVkKDEvMikpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnZpZXcuc2V0SGFsZlNpemUobmV3IFZlYzIodmVjT3JYLzIsIHkvMikpO1xuXHRcdH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBoYWxmLXNpemUgb2YgdGhlIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHZlY09yWCBUaGUgbmV3IGhhbGYtd2lkdGggb2YgdGhlIHZpZXdwb3J0IG9yIHRoZSBuZXcgaGFsZi1zaXplIGFzIGEgVmVjMlxuICAgICAqIEBwYXJhbSB5IFRoZSBuZXcgaGVpZ2h0IG9mIHRoZSB2aWV3cG9ydFxuICAgICAqL1xuICAgIHNldEhhbGZTaXplKHZlY09yWDogVmVjMiB8IG51bWJlciwgeTogbnVtYmVyID0gbnVsbCk6IHZvaWQge1xuXHRcdGlmKHZlY09yWCBpbnN0YW5jZW9mIFZlYzIpe1xuXHRcdFx0dGhpcy52aWV3LnNldEhhbGZTaXplKHZlY09yWC5jbG9uZSgpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy52aWV3LnNldEhhbGZTaXplKG5ldyBWZWMyKHZlY09yWCwgeSkpO1xuXHRcdH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB2aWV3cG9ydCB3aXRoIHRoZSBzaXplIG9mIHRoZSBjdXJyZW50IENhbnZhc1xuICAgICAqIEBwYXJhbSB2ZWNPclggVGhlIHdpZHRoIG9mIHRoZSBjYW52YXMsIG9yIHRoZSBjYW52YXMgc2l6ZSBhcyBhIFZlYzJcbiAgICAgKiBAcGFyYW0geSBUaGUgaGVpZ2h0IG9mIHRoZSBjYW52YXNcbiAgICAgKi9cbiAgICBzZXRDYW52YXNTaXplKHZlY09yWDogVmVjMiB8IG51bWJlciwgeTogbnVtYmVyID0gbnVsbCk6IHZvaWQge1xuXHRcdGlmKHZlY09yWCBpbnN0YW5jZW9mIFZlYzIpe1xuXHRcdFx0dGhpcy5jYW52YXNTaXplID0gdmVjT3JYLmNsb25lKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuY2FudmFzU2l6ZSA9IG5ldyBWZWMyKHZlY09yWCwgeSk7XG5cdFx0fVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHpvb20gbGV2ZWwgb2YgdGhlIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHpvb20gVGhlIHpvb20gbGV2ZWxcbiAgICAgKi9cbiAgICBzZXRab29tTGV2ZWwoem9vbTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMudmlldy5oYWxmU2l6ZS5jb3B5KHRoaXMuY2FudmFzU2l6ZS5zY2FsZWQoMS96b29tLzIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB6b29tIGxldmVsIG9mIHRoZSB2aWV3cG9ydFxuICAgICAqIEByZXR1cm5zIFRoZSB6b29tIGxldmVsXG4gICAgICovXG4gICAgZ2V0Wm9vbUxldmVsKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhc1NpemUueC90aGlzLnZpZXcuaHcvMlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNtb290aGluZyBmYWN0b3IgZm9yIHRoZSB2aWV3cG9ydCBtb3ZlbWVudC5cbiAgICAgKiBAcGFyYW0gc21vb3RoaW5nRmFjdG9yIFRoZSBzbW9vdGhpbmcgZmFjdG9yIGZvciB0aGUgdmlld3BvcnRcbiAgICAgKi9cbiAgICBzZXRTbW9vdGhpbmdGYWN0b3Ioc21vb3RoaW5nRmFjdG9yOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgaWYoc21vb3RoaW5nRmFjdG9yIDwgMSkgc21vb3RoaW5nRmFjdG9yID0gMTtcbiAgICAgICAgdGhpcy5zbW9vdGhpbmdGYWN0b3IgPSBzbW9vdGhpbmdGYWN0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVsbHMgdGhlIHZpZXdwb3J0IHRvIGZvY3VzIG9uIGEgcG9pbnQuIE92ZXJpZGRlbiBieSBcImZvbGxvd2luZ1wiLlxuICAgICAqIEBwYXJhbSBmb2N1cyBUaGUgcG9pbnQgdGhlICB2aWV3cG9ydCBzaG91bGQgZm9jdXMgb25cbiAgICAgKi9cbiAgICBzZXRGb2N1cyhmb2N1czogVmVjMik6IHZvaWQge1xuICAgICAgICB0aGlzLmZvY3VzLmNvcHkoZm9jdXMpO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIENhbnZhc05vZGUgaXMgaW5zaWRlIG9mIHRoZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIGNoZWNrXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgbm9kZSBpcyBjdXJyZW50bHkgdmlzaWJsZSBpbiB0aGUgdmlld3BvcnQsIGZhbHNlIGlmIG5vdFxuICAgICAqL1xuICAgIGluY2x1ZGVzKG5vZGU6IENhbnZhc05vZGUpOiBib29sZWFuIHtcbiAgICAgICAgbGV0IHBhcmFsbGF4ID0gbm9kZS5nZXRMYXllcigpIGluc3RhbmNlb2YgUGFyYWxsYXhMYXllciB8fCBub2RlLmdldExheWVyKCkgaW5zdGFuY2VvZiBVSUxheWVyID8gKDxQYXJhbGxheExheWVyPm5vZGUuZ2V0TGF5ZXIoKSkucGFyYWxsYXggOiBuZXcgVmVjMigxLCAxKTtcbiAgICAgICAgbGV0IGNlbnRlciA9IHRoaXMudmlldy5jZW50ZXIuY2xvbmUoKTtcbiAgICAgICAgdGhpcy52aWV3LmNlbnRlci5tdWx0KHBhcmFsbGF4KTtcbiAgICAgICAgbGV0IG92ZXJsYXBzID0gdGhpcy52aWV3Lm92ZXJsYXBzKG5vZGUuYm91bmRhcnkpO1xuICAgICAgICB0aGlzLnZpZXcuY2VudGVyID0gY2VudGVyXG4gICAgICAgIHJldHVybiBvdmVybGFwcztcbiAgICB9XG5cblx0Ly8gVE9ETzogUHV0IHNvbWUgZXJyb3IgaGFuZGxpbmcgb24gdGhpcyBmb3IgdHJ5aW5nIHRvIG1ha2UgdGhlIGJvdW5kcyB0b28gc21hbGwgZm9yIHRoZSB2aWV3cG9ydFxuICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIHByb2JhYmx5IGJlIGRvbmUgYXV0b21hdGljYWxseSwgb3Igc2hvdWxkIGNvbnNpZGVyIHRoZSBhc3BlY3QgcmF0aW8gb3Igc29tZXRoaW5nXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYm91bmRzIG9mIHRoZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSBsb3dlclggVGhlIGxlZnQgZWRnZSBvZiB0aGUgdmlld3BvcnRcbiAgICAgKiBAcGFyYW0gbG93ZXJZIFRoZSB0b3AgZWRnZSBvZiB0aGUgdmlld3BvcnRcbiAgICAgKiBAcGFyYW0gdXBwZXJYIFRoZSByaWdodCBlZGdlIG9mIHRoZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSB1cHBlclkgVGhlIGJvdHRvbSBlZGdlIG9mIHRoZSB2aWV3cG9ydFxuICAgICAqL1xuICAgIHNldEJvdW5kcyhsb3dlclg6IG51bWJlciwgbG93ZXJZOiBudW1iZXIsIHVwcGVyWDogbnVtYmVyLCB1cHBlclk6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBsZXQgaHdpZHRoID0gKHVwcGVyWCAtIGxvd2VyWCkvMjtcbiAgICAgICAgbGV0IGhoZWlnaHQgPSAodXBwZXJZIC0gbG93ZXJZKS8yO1xuICAgICAgICBsZXQgeCA9IGxvd2VyWCArIGh3aWR0aDtcbiAgICAgICAgbGV0IHkgPSBsb3dlclkgKyBoaGVpZ2h0O1xuICAgICAgICB0aGlzLmJvdW5kYXJ5LmNlbnRlci5zZXQoeCwgeSk7XG4gICAgICAgIHRoaXMuYm91bmRhcnkuaGFsZlNpemUuc2V0KGh3aWR0aCwgaGhlaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFrZSB0aGUgdmlld3BvcnQgZm9sbG93IHRoZSBzcGVjaWZpZWQgR2FtZU5vZGVcbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgR2FtZU5vZGUgdG8gZm9sbG93XG4gICAgICovXG4gICAgZm9sbG93KG5vZGU6IEdhbWVOb2RlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZm9sbG93aW5nID0gbm9kZTtcbiAgICB9XG5cbiAgICB1cGRhdGVWaWV3KCk6IHZvaWQge1xuICAgICAgICBpZih0aGlzLmxhc3RQb3NpdGlvbnMuZ2V0U2l6ZSgpID4gdGhpcy5zbW9vdGhpbmdGYWN0b3Ipe1xuICAgICAgICAgICAgdGhpcy5sYXN0UG9zaXRpb25zLmRlcXVldWUoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gR2V0IHRoZSBhdmVyYWdlIG9mIHRoZSBsYXN0IDEwIHBvc2l0aW9uc1xuICAgICAgICBsZXQgcG9zID0gVmVjMi5aRVJPO1xuICAgICAgICB0aGlzLmxhc3RQb3NpdGlvbnMuZm9yRWFjaChwb3NpdGlvbiA9PiBwb3MuYWRkKHBvc2l0aW9uKSk7XG4gICAgICAgIHBvcy5zY2FsZSgxL3RoaXMubGFzdFBvc2l0aW9ucy5nZXRTaXplKCkpO1xuXG4gICAgICAgIC8vIFNldCB0aGlzIHBvc2l0aW9uIGVpdGhlciB0byB0aGUgb2JqZWN0IG9yIHRvIGl0cyBib3VuZHNcbiAgICAgICAgcG9zLnggPSBNYXRoVXRpbHMuY2xhbXAocG9zLngsIHRoaXMuYm91bmRhcnkubGVmdCArIHRoaXMudmlldy5odywgdGhpcy5ib3VuZGFyeS5yaWdodCAtIHRoaXMudmlldy5odyk7XG4gICAgICAgIHBvcy55ID0gTWF0aFV0aWxzLmNsYW1wKHBvcy55LCB0aGlzLmJvdW5kYXJ5LnRvcCArIHRoaXMudmlldy5oaCwgdGhpcy5ib3VuZGFyeS5ib3R0b20gLSB0aGlzLnZpZXcuaGgpO1xuXG4gICAgICAgIC8vIEFzc3VyZSB0aGVyZSBhcmUgbm8gbGluZXMgaW4gdGhlIHRpbGVtYXBcbiAgICAgICAgcG9zLnggPSBNYXRoLmZsb29yKHBvcy54KTtcbiAgICAgICAgcG9zLnkgPSBNYXRoLmZsb29yKHBvcy55KTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMudmlldy5jZW50ZXIuY29weShwb3MpO1xuICAgIH1cblxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICAvLyBJZiB6b29tIGlzIGVuYWJsZWRcbiAgICAgICAgaWYodGhpcy5zY3JvbGxab29tRW5hYmxlZCl7XG4gICAgICAgICAgICBpZihJbnB1dC5kaWRKdXN0U2Nyb2xsKCkpe1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50U2l6ZSA9IHRoaXMudmlldy5nZXRIYWxmU2l6ZSgpLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgaWYoSW5wdXQuZ2V0U2Nyb2xsRGlyZWN0aW9uKCkgPCAwKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gWm9vbSBpblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2l6ZS5zY2FsZSgxL3RoaXMuWk9PTV9GQUNUT1IpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFpvb20gb3V0XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTaXplLnNjYWxlKHRoaXMuWk9PTV9GQUNUT1IpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRTaXplLnggPiB0aGlzLmJvdW5kYXJ5Lmh3KXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZhY3RvciA9IHRoaXMuYm91bmRhcnkuaHcvY3VycmVudFNpemUueDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNpemUueCA9IHRoaXMuYm91bmRhcnkuaHc7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTaXplLnkgKj0gZmFjdG9yO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRTaXplLnkgPiB0aGlzLmJvdW5kYXJ5LmhoKXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZhY3RvciA9IHRoaXMuYm91bmRhcnkuaGgvY3VycmVudFNpemUueTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNpemUueSA9IHRoaXMuYm91bmRhcnkuaGg7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTaXplLnggKj0gZmFjdG9yO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5zZXRIYWxmU2l6ZShjdXJyZW50U2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB2aWV3cG9ydCBpcyBmb2xsb3dpbmcgYW4gb2JqZWN0XG4gICAgICAgIGlmKHRoaXMuZm9sbG93aW5nKXtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBvdXIgbGlzdCBvZiBwcmV2aW91cyBwb3NpdGlvbnNcbiAgICAgICAgICAgIHRoaXMubGFzdFBvc2l0aW9ucy5lbnF1ZXVlKHRoaXMuZm9sbG93aW5nLnBvc2l0aW9uLmNsb25lKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sYXN0UG9zaXRpb25zLmVucXVldWUodGhpcy5mb2N1cyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZVZpZXcoKTtcbiAgICB9XG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL0NvbGxlY3Rpb25zL01hcFwiO1xuaW1wb3J0IFJlY2VpdmVyIGZyb20gXCIuLi9FdmVudHMvUmVjZWl2ZXJcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCB7IEdhbWVFdmVudFR5cGUgfSBmcm9tIFwiLi4vRXZlbnRzL0dhbWVFdmVudFR5cGVcIjtcblxuLyoqXG4gKiBNYW5hZ2VzIGFueSBzb3VuZHMgb3IgbXVzaWMgbmVlZGVkIGZvciB0aGUgZ2FtZS5cbiAqIFRocm91Z2ggdGhlIEV2ZW50UXVldWUsIGV4cG9zZXMgaW50ZXJmYWNlIHRvIHBsYXkgc291bmRzIHNvIEdhbWVOb2RlcyBjYW4gYWN0aXZhdGUgc291bmRzIHdpdGhvdXRcbiAqIG5lZWRpbmcgZGlyZWN0IHJlZmVyZW5jZXMgdG8gdGhlIGF1ZGlvIHN5c3RlbVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdWRpb01hbmFnZXIge1xuICAgIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBBdWRpb01hbmFnZXI7XG5cbiAgICAvKiogVGhlIGV2ZW50IHJlY2VpdmVyIG9mIHRoaXMgQXVkaW9NYW5hZ2VyICovXG4gICAgcHJpdmF0ZSByZWNlaXZlcjogUmVjZWl2ZXI7XG5cbiAgICAvKiogQSBNYXAgb2YgdGhlIG5hbWVzIG9mIGN1cnJlbnRseSBwbGF5aW5nIChvciBwYXVzZWQpIHNvdW5kcyB0byB0aGVpciBBdWRpb0J1ZmZlcnMgKi9cbiAgICBwcml2YXRlIGN1cnJlbnRTb3VuZHM6IE1hcDxBdWRpb0J1ZmZlclNvdXJjZU5vZGU+O1xuXG4gICAgcHJpdmF0ZSBhdWRpb0N0eDogQXVkaW9Db250ZXh0O1xuXG4gICAgcHJpdmF0ZSBnYWluTm9kZXM6IEFycmF5PEdhaW5Ob2RlPjtcblxuICAgIHByaXZhdGUgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5pbml0QXVkaW8oKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IG5ldyBSZWNlaXZlcigpO1xuICAgICAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZShbXG4gICAgICAgICAgICBHYW1lRXZlbnRUeXBlLlBMQVlfU09VTkQsXG4gICAgICAgICAgICBHYW1lRXZlbnRUeXBlLlNUT1BfU09VTkQsXG4gICAgICAgICAgICBHYW1lRXZlbnRUeXBlLlBMQVlfTVVTSUMsXG4gICAgICAgICAgICBHYW1lRXZlbnRUeXBlLlBMQVlfU0ZYLFxuICAgICAgICAgICAgR2FtZUV2ZW50VHlwZS5NVVRFX0NIQU5ORUwsXG4gICAgICAgICAgICBHYW1lRXZlbnRUeXBlLlVOTVVURV9DSEFOTkVMXG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLmN1cnJlbnRTb3VuZHMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgdGhpcy5nYWluTm9kZXMgPSBuZXcgQXJyYXk8R2Fpbk5vZGU+KE1BWF9BVURJT19DSEFOTkVMUyk7XG4gICAgICAgIHRoaXMuaW5pdEdhaW5Ob2RlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaW5zdGFuY2Ugb2YgdGhlIEF1ZGlvTWFuYWdlciBjbGFzcyBvciBjcmVhdGUgYSBuZXcgb25lIGlmIG5vbmUgZXhpc3RzXG4gICAgICogQHJldHVybnMgVGhlIEF1ZGlvTWFuYWdlclxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogQXVkaW9NYW5hZ2VyIHtcbiAgICAgICAgaWYoIXRoaXMuaW5zdGFuY2Upe1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBBdWRpb01hbmFnZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgd2ViQXVkaW8gY29udGV4dFxuICAgICAqL1xuICAgIHByaXZhdGUgaW5pdEF1ZGlvKCk6IHZvaWQge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2luZG93LkF1ZGlvQ29udGV4dCA9IHdpbmRvdy5BdWRpb0NvbnRleHQ7Ly8gfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dDsgXG4gICAgICAgICAgICB0aGlzLmF1ZGlvQ3R4ID0gbmV3IEF1ZGlvQ29udGV4dCgpOyBcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXZWIgQXVkaW8gQVBJIHN1Y2Nlc3NmdWxseSBsb2FkZWQnKTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dlYiBBdWRpbyBBUEkgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKTsgXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGluaXRHYWluTm9kZXMoKTogdm9pZCB7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBNQVhfQVVESU9fQ0hBTk5FTFM7IGkrKyl7XG4gICAgICAgICAgICB0aGlzLmdhaW5Ob2Rlc1tpXSA9IHRoaXMuYXVkaW9DdHguY3JlYXRlR2FpbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBhdWRpbyBjb250ZXh0XG4gICAgICogQHJldHVybnMgVGhlIEF1ZGlvQ29udGV4dFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRBdWRpb0NvbnRleHQoKTogQXVkaW9Db250ZXh0IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXVkaW9DdHg7XG4gICAgfVxuXG4gICAgLypcbiAgICAgICAgQWNjb3JkaW5nIHRvIHRoZSBNRE4sIGNyZWF0ZSBhIG5ldyBzb3VuZCBmb3IgZXZlcnkgY2FsbDpcblxuICAgICAgICBBbiBBdWRpb0J1ZmZlclNvdXJjZU5vZGUgY2FuIG9ubHkgYmUgcGxheWVkIG9uY2U7IGFmdGVyIGVhY2ggY2FsbCB0byBzdGFydCgpLCB5b3UgaGF2ZSB0byBjcmVhdGUgYSBuZXcgbm9kZVxuICAgICAgICBpZiB5b3Ugd2FudCB0byBwbGF5IHRoZSBzYW1lIHNvdW5kIGFnYWluLiBGb3J0dW5hdGVseSwgdGhlc2Ugbm9kZXMgYXJlIHZlcnkgaW5leHBlbnNpdmUgdG8gY3JlYXRlLCBhbmQgdGhlXG4gICAgICAgIGFjdHVhbCBBdWRpb0J1ZmZlcnMgY2FuIGJlIHJldXNlZCBmb3IgbXVsdGlwbGUgcGxheXMgb2YgdGhlIHNvdW5kLiBJbmRlZWQsIHlvdSBjYW4gdXNlIHRoZXNlIG5vZGVzIGluIGFcbiAgICAgICAgXCJmaXJlIGFuZCBmb3JnZXRcIiBtYW5uZXI6IGNyZWF0ZSB0aGUgbm9kZSwgY2FsbCBzdGFydCgpIHRvIGJlZ2luIHBsYXlpbmcgdGhlIHNvdW5kLCBhbmQgZG9uJ3QgZXZlbiBib3RoZXIgdG9cbiAgICAgICAgaG9sZCBhIHJlZmVyZW5jZSB0byBpdC4gSXQgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGdhcmJhZ2UtY29sbGVjdGVkIGF0IGFuIGFwcHJvcHJpYXRlIHRpbWUsIHdoaWNoIHdvbid0IGJlXG4gICAgICAgIHVudGlsIHNvbWV0aW1lIGFmdGVyIHRoZSBzb3VuZCBoYXMgZmluaXNoZWQgcGxheWluZy5cbiAgICAqL1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgc291bmQgZnJvbSB0aGUga2V5IG9mIGEgbG9hZGVkIGF1ZGlvIGZpbGVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGxvYWRlZCBhdWRpbyBmaWxlIHRvIGNyZWF0ZSBhIG5ldyBzb3VuZCBmb3JcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3bHkgY3JlYXRlZCBBdWRpb0J1ZmZlclxuICAgICAqL1xuICAgIHByb3RlY3RlZCBjcmVhdGVTb3VuZChrZXk6IHN0cmluZywgaG9sZFJlZmVyZW5jZTogYm9vbGVhbiwgY2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZSwgb3B0aW9uczogTWFwPGFueT4pOiBBdWRpb0J1ZmZlclNvdXJjZU5vZGUge1xuICAgICAgICAvLyBHZXQgYXVkaW8gYnVmZmVyXG4gICAgICAgIGxldCBidWZmZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5nZXRBdWRpbyhrZXkpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIHNvdW5kIHNvdXJjZVxuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5hdWRpb0N0eC5jcmVhdGVCdWZmZXJTb3VyY2UoKTsgXG4gICAgICBcbiAgICAgICAgLy8gVGVsbCB0aGUgc291cmNlIHdoaWNoIHNvdW5kIHRvIHBsYXlcbiAgICAgICAgc291cmNlLmJ1ZmZlciA9IGJ1ZmZlcjsgICAgICAgICAgICAgICBcbiAgICAgIFxuICAgICAgICAvLyBBZGQgYW55IGFkZGl0aW9uYWwgbm9kZXNcbiAgICAgICAgY29uc3Qgbm9kZXM6IEFycmF5PEF1ZGlvTm9kZT4gPSBbc291cmNlXTtcblxuICAgICAgICAvLyBEbyBhbnkgYWRkaXRpb25hbCBub2RlcyBoZXJlP1xuICAgICAgICAvLyBPZiBjb3Vyc2UsIHRoZXJlIGFyZW4ndCBhbnkgc3VwcG9ydGVkIHlldC4uLlxuXG4gICAgICAgIC8vIEFkZCB0aGUgZ2FpbiBub2RlIGZvciB0aGlzIGNoYW5uZWxcbiAgICAgICAgbm9kZXMucHVzaCh0aGlzLmdhaW5Ob2Rlc1tjaGFubmVsXSk7XG5cbiAgICAgICAgLy8gQ29ubmVjdCBhbnkgbm9kZXMgYWxvbmcgdGhlIHBhdGhcbiAgICAgICAgZm9yKGxldCBpID0gMTsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIG5vZGVzW2ktMV0uY29ubmVjdChub2Rlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb25uZWN0IHRoZSBzb3VyY2UgdG8gdGhlIGNvbnRleHQncyBkZXN0aW5hdGlvblxuICAgICAgICBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXS5jb25uZWN0KHRoaXMuYXVkaW9DdHguZGVzdGluYXRpb24pO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQbGF5IHRoZSBzb3VuZCBzcGVjaWZpZWQgYnkgdGhlIGtleVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgc291bmQgdG8gcGxheVxuICAgICAqIEBwYXJhbSBsb29wIEEgYm9vbGVhbiBmb3Igd2hldGhlciBvciBub3QgdG8gbG9vcCB0aGUgc291bmRcbiAgICAgKiBAcGFyYW0gaG9sZFJlZmVyZW5jZSBBIGJvb2xlYW4gZm9yIHdoZXRoZXIgb3Igbm90IHdlIHdhbnQgdG8gaG9sZCBvbiB0byBhIHJlZmVyZW5jZSBvZiB0aGUgYXVkaW8gbm9kZS4gVGhpcyBpcyBnb29kIGZvciBwbGF5aW5nIG11c2ljIG9uIGEgbG9vcCB0aGF0IHdpbGwgZXZlbnR1YWxseSBuZWVkIHRvIGJlIHN0b3BwZWQuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHBsYXlTb3VuZChrZXk6IHN0cmluZywgbG9vcDogYm9vbGVhbiwgaG9sZFJlZmVyZW5jZTogYm9vbGVhbiwgY2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZSwgb3B0aW9uczogTWFwPGFueT4pOiB2b2lkIHtcbiAgICAgICAgbGV0IHNvdW5kID0gdGhpcy5jcmVhdGVTb3VuZChrZXksIGhvbGRSZWZlcmVuY2UsIGNoYW5uZWwsIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmKGxvb3Ape1xuICAgICAgICAgICAgc291bmQubG9vcCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgYSByZWZlcmVuY2Ugb2YgdGhlIG5ldyBzb3VuZCB0byBhIG1hcC4gVGhpcyB3aWxsIGFsbG93IHVzIHRvIHN0b3AgYSBsb29waW5nIG9yIGxvbmcgc291bmQgYXQgYSBsYXRlciB0aW1lXG4gICAgICAgIGlmKGhvbGRSZWZlcmVuY2Upe1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U291bmRzLmFkZChrZXksIHNvdW5kKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgc291bmQuc3RhcnQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9wIHRoZSBzb3VuZCBzcGVjaWZpZWQgYnkgdGhlIGtleVxuICAgICAqL1xuICAgIHByb3RlY3RlZCBzdG9wU291bmQoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgbGV0IHNvdW5kID0gdGhpcy5jdXJyZW50U291bmRzLmdldChrZXkpO1xuICAgICAgICBpZihzb3VuZCl7XG4gICAgICAgICAgICBzb3VuZC5zdG9wKCk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTb3VuZHMuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgbXV0ZUNoYW5uZWwoY2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZSl7XG4gICAgICAgIHRoaXMuZ2Fpbk5vZGVzW2NoYW5uZWxdLmdhaW4uc2V0VmFsdWVBdFRpbWUoMCwgdGhpcy5hdWRpb0N0eC5jdXJyZW50VGltZSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHVubXV0ZUNoYW5uZWwoY2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZSl7XG4gICAgICAgIHRoaXMuZ2Fpbk5vZGVzW2NoYW5uZWxdLmdhaW4uc2V0VmFsdWVBdFRpbWUoMSwgdGhpcy5hdWRpb0N0eC5jdXJyZW50VGltZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdm9sdW1lIG9mIGEgY2hhbm5lbCB1c2luZyB0aGUgR2Fpbk5vZGUgZm9yIHRoYXQgY2hhbm5lbC4gRm9yIG1vcmVcbiAgICAgKiBpbmZvcm1hdGlvbiBvbiBHYWluTm9kZXMsIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvR2Fpbk5vZGVcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgYXVkaW8gY2hhbm5lbCB0byBzZXQgdGhlIHZvbHVtZSBmb3JcbiAgICAgKiBAcGFyYW0gdm9sdW1lIFRoZSB2b2x1bWUgb2YgdGhlIGNoYW5uZWwuIDAgaXMgbXV0ZWQuIFZhbHVlcyBiZWxvdyB6ZXJvIHdpbGwgYmUgc2V0IHRvIHplcm8uXG4gICAgICovXG4gICAgc3RhdGljIHNldFZvbHVtZShjaGFubmVsOiBBdWRpb0NoYW5uZWxUeXBlLCB2b2x1bWU6IG51bWJlcil7XG4gICAgICAgIGlmKHZvbHVtZSA8IDApe1xuICAgICAgICAgICAgdm9sdW1lID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFtID0gQXVkaW9NYW5hZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgICAgIGFtLmdhaW5Ob2Rlc1tjaGFubmVsXS5nYWluLnNldFZhbHVlQXRUaW1lKHZvbHVtZSwgYW0uYXVkaW9DdHguY3VycmVudFRpbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIEdhaW5Ob2RlIGZvciB0aGlzIGNoYW5uZWwuXG4gICAgICogTGVhcm4gbW9yZSBhYm91dCBHYWluTm9kZXMgaGVyZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvR2Fpbk5vZGVcbiAgICAgKiBET04nVCBVU0UgVEhJUyBVTkxFU1MgWU9VIEtOT1cgV0hBVCBZT1UnUkUgRE9JTkdcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgY2hhbm5lbFxuICAgICAqIEByZXR1cm5zIFRoZSBHYWluTm9kZSBmb3IgdGhlIHNwZWNpZmllZCBjaGFubmVsXG4gICAgICovXG4gICAgZ2V0Q2hhbm5lbEdhaW5Ob2RlKGNoYW5uZWw6IEF1ZGlvQ2hhbm5lbFR5cGUpe1xuICAgICAgICByZXR1cm4gdGhpcy5nYWluTm9kZXNbY2hhbm5lbF07XG4gICAgfVxuICAgIFxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICAvLyBQbGF5IGVhY2ggYXVkaW8gY2xpcCByZXF1ZXN0ZWRcbiAgICAgICAgLy8gVE9ETyAtIEFkZCBsb2dpYyB0byBtZXJnZSBzb3VuZHMgaWYgdGhlcmUgYXJlIG11bHRpcGxlIG9mIHRoZSBzYW1lIGtleVxuICAgICAgICB3aGlsZSh0aGlzLnJlY2VpdmVyLmhhc05leHRFdmVudCgpKXtcbiAgICAgICAgICAgIGxldCBldmVudCA9IHRoaXMucmVjZWl2ZXIuZ2V0TmV4dEV2ZW50KCk7XG4gICAgICAgICAgICBpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLlBMQVlfU09VTkQgfHwgZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5QTEFZX01VU0lDIHx8IGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuUExBWV9TRlgpe1xuICAgICAgICAgICAgICAgIGxldCBzb3VuZEtleSA9IGV2ZW50LmRhdGEuZ2V0KFwia2V5XCIpO1xuICAgICAgICAgICAgICAgIGxldCBsb29wID0gZXZlbnQuZGF0YS5nZXQoXCJsb29wXCIpO1xuICAgICAgICAgICAgICAgIGxldCBob2xkUmVmZXJlbmNlID0gZXZlbnQuZGF0YS5nZXQoXCJob2xkUmVmZXJlbmNlXCIpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGNoYW5uZWwgPSBBdWRpb0NoYW5uZWxUeXBlLkRFRkFVTFQ7XG5cbiAgICAgICAgICAgICAgICBpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLlBMQVlfTVVTSUMpe1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsID0gQXVkaW9DaGFubmVsVHlwZS5NVVNJQztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoR2FtZUV2ZW50VHlwZS5QTEFZX1NGWCl7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwgPSBBdWRpb0NoYW5uZWxUeXBlLlNGWDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoZXZlbnQuZGF0YS5oYXMoXCJjaGFubmVsXCIpKXtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbCA9IGV2ZW50LmRhdGEuZ2V0KFwiY2hhbm5lbFwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnBsYXlTb3VuZChzb3VuZEtleSwgbG9vcCwgaG9sZFJlZmVyZW5jZSwgY2hhbm5lbCwgZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuU1RPUF9TT1VORCl7XG4gICAgICAgICAgICAgICAgbGV0IHNvdW5kS2V5ID0gZXZlbnQuZGF0YS5nZXQoXCJrZXlcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wU291bmQoc291bmRLZXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLk1VVEVfQ0hBTk5FTCl7XG4gICAgICAgICAgICAgICAgdGhpcy5tdXRlQ2hhbm5lbChldmVudC5kYXRhLmdldChcImNoYW5uZWxcIikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLlVOTVVURV9DSEFOTkVMKXtcbiAgICAgICAgICAgICAgICB0aGlzLnVubXV0ZUNoYW5uZWwoZXZlbnQuZGF0YS5nZXQoXCJjaGFubmVsXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGVudW0gQXVkaW9DaGFubmVsVHlwZSB7XG4gICAgREVGQVVMVCA9IDAsXG4gICAgU0ZYID0gMSxcbiAgICBNVVNJQyA9IDIsXG4gICAgQ1VTVE9NXzEgPSAzLFxuICAgIENVU1RPTV8yID0gNCxcbiAgICBDVVNUT01fMyA9IDUsXG4gICAgQ1VTVE9NXzQgPSA2LFxuICAgIENVU1RPTV81ID0gNyxcbiAgICBDVVNUT01fNiA9IDgsXG4gICAgQ1VTVE9NXzcgPSA5LFxuICAgIENVU1RPTV84ID0gMTAsXG4gICAgQ1VTVE9NXzkgPSAxMSxcbn1cblxuZXhwb3J0IGNvbnN0IE1BWF9BVURJT19DSEFOTkVMUyA9IDEyOyIsImltcG9ydCBVcGRhdGVhYmxlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VcGRhdGVhYmxlXCI7XG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuLi9VdGlscy9NYXRoVXRpbHNcIjtcbmltcG9ydCBUaW1lck1hbmFnZXIgZnJvbSBcIi4vVGltZXJNYW5hZ2VyXCI7XG5cbi8qKiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGltZXIgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcblxuICAgIC8qKiBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGlzIHRpbWVyICovXG4gICAgcHJvdGVjdGVkIHN0YXRlOiBUaW1lclN0YXRlO1xuICAgIFxuICAgIC8qKiBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoaXMgdGltZXIgZW5kcyAqL1xuICAgIHByb3RlY3RlZCBvbkVuZDogRnVuY3Rpb247XG5cbiAgICAvKiogV2hldGhlciBvciBub3QgdGhpcyB0aW1lciBzaG91bGQgbG9vcCAqL1xuICAgIHByb3RlY3RlZCBsb29wOiBib29sZWFuO1xuXG4gICAgLyoqIFRoZSB0b3RhbCBhbW91bnQgb2YgdGltZSB0aGlzIHRpbWVyIHJ1bnMgZm9yICovXG4gICAgcHJvdGVjdGVkIHRvdGFsVGltZTogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSBhbW91bnQgb2YgdGltZSBsZWZ0IG9uIHRoZSBjdXJyZW50IHJ1biAqL1xuICAgIHByb3RlY3RlZCB0aW1lTGVmdDogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSBudW1iZXIgb2YgdGltZXMgdGhpcyB0aW1lciBoYXMgYmVlbiBydW4gKi9cbiAgICBwcm90ZWN0ZWQgbnVtUnVuczogbnVtYmVyO1xuXG4gICAgY29uc3RydWN0b3IodGltZTogbnVtYmVyLCBvbkVuZD86IEZ1bmN0aW9uLCBsb29wOiBib29sZWFuID0gZmFsc2Upe1xuICAgICAgICAvLyBSZWdpc3RlciB0aGlzIHRpbWVyXG4gICAgICAgIFRpbWVyTWFuYWdlci5nZXRJbnN0YW5jZSgpLmFkZFRpbWVyKHRoaXMpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy50b3RhbFRpbWUgPSB0aW1lO1xuICAgICAgICB0aGlzLnRpbWVMZWZ0ID0gMDtcbiAgICAgICAgdGhpcy5vbkVuZCA9IG9uRW5kO1xuICAgICAgICB0aGlzLmxvb3AgPSBsb29wO1xuICAgICAgICB0aGlzLnN0YXRlID0gVGltZXJTdGF0ZS5TVE9QUEVEO1xuICAgICAgICB0aGlzLm51bVJ1bnMgPSAwO1xuICAgIH1cblxuICAgIGlzU3RvcHBlZCgpe1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gVGltZXJTdGF0ZS5TVE9QUEVEO1xuICAgIH1cblxuICAgIGlzUGF1c2VkKCl7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBUaW1lclN0YXRlLlBBVVNFRDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoaXMgdGltZXIgaGFzIGJlZW4gcnVuIGJlZm9yZVxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgaXQgaGFzIGJlZW4gcnVuIGF0IGxlYXN0IG9uY2UgKGFmdGVyIHRoZSBsYXRlc3QgcmVzZXQpLCBhbmQgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgaGFzUnVuKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5udW1SdW5zID4gMDtcbiAgICB9XG5cbiAgICBzdGFydCh0aW1lPzogbnVtYmVyKXtcbiAgICAgICAgaWYodGltZSAhPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIHRoaXMudG90YWxUaW1lID0gdGltZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gVGltZXJTdGF0ZS5BQ1RJVkU7XG4gICAgICAgIHRoaXMudGltZUxlZnQgPSB0aGlzLnRvdGFsVGltZTtcbiAgICB9XG5cbiAgICAvKiogUmVzZXRzIHRoaXMgdGltZXIuIFNldHMgdGhlIHByb2dyZXNzIGJhY2sgdG8gemVybywgYW5kIHNldHMgdGhlIG51bWJlciBvZiBydW5zIGJhY2sgdG8gemVybyAqL1xuICAgIHJlc2V0KCl7XG4gICAgICAgIHRoaXMudGltZUxlZnQgPSB0aGlzLnRvdGFsVGltZTtcbiAgICAgICAgdGhpcy5udW1SdW5zID0gMDtcbiAgICB9XG5cbiAgICBwYXVzZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFRpbWVyU3RhdGUuUEFVU0VEO1xuICAgIH1cblxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcil7XG4gICAgICAgIGlmKHRoaXMuc3RhdGUgPT09IFRpbWVyU3RhdGUuQUNUSVZFKXtcbiAgICAgICAgICAgIHRoaXMudGltZUxlZnQgLT0gZGVsdGFUKjEwMDA7XG5cbiAgICAgICAgICAgIGlmKHRoaXMudGltZUxlZnQgPD0gMCl7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lTGVmdCA9IE1hdGhVdGlscy5jbGFtcExvdzAodGhpcy50aW1lTGVmdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBlbmQoKXtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBzdGF0ZVxuICAgICAgICB0aGlzLnN0YXRlID0gVGltZXJTdGF0ZS5TVE9QUEVEO1xuICAgICAgICB0aGlzLm51bVJ1bnMgKz0gMTtcblxuICAgICAgICAvLyBDYWxsIHRoZSBlbmQgZnVuY3Rpb24gaWYgdGhlcmUgaXMgb25lXG4gICAgICAgIGlmKHRoaXMub25FbmQpe1xuICAgICAgICAgICAgdGhpcy5vbkVuZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9vcCBpZiB3ZSB3YW50IHRvXG4gICAgICAgIGlmKHRoaXMubG9vcCl7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gVGltZXJTdGF0ZS5BQ1RJVkU7XG4gICAgICAgICAgICB0aGlzLnRpbWVMZWZ0ID0gdGhpcy50b3RhbFRpbWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b1N0cmluZygpOiBzdHJpbmd7XG4gICAgICAgIHJldHVybiBcIlRpbWVyOiBcIiArIHRoaXMuc3RhdGUgKyBcIiAtIFRpbWUgTGVmdDogXCIgKyB0aGlzLnRpbWVMZWZ0ICsgXCJtcyBvZiBcIiArIHRoaXMudG90YWxUaW1lICsgXCJtc1wiO1xuICAgIH1cbn1cblxuZXhwb3J0IGVudW0gVGltZXJTdGF0ZSB7XG4gICAgQUNUSVZFID0gXCJBQ1RJVkVcIixcbiAgICBQQVVTRUQgPSBcIlBBVVNFRFwiLFxuICAgIFNUT1BQRUQgPSBcIlNUT1BQRURcIlxufSIsImltcG9ydCBVcGRhdGVhYmxlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VcGRhdGVhYmxlXCI7XG5pbXBvcnQgVGltZXIgZnJvbSBcIi4vVGltZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGltZXJNYW5hZ2VyIGltcGxlbWVudHMgVXBkYXRlYWJsZSB7XG5cbiAgICBwcm90ZWN0ZWQgdGltZXJzOiBBcnJheTxUaW1lcj47XG5cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLnRpbWVycyA9IG5ldyBBcnJheSgpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBzdGF0aWMgaW5zdGFuY2U6IFRpbWVyTWFuYWdlcjtcblxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBUaW1lck1hbmFnZXIge1xuICAgICAgICBpZighdGhpcy5pbnN0YW5jZSl7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IFRpbWVyTWFuYWdlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgYWRkVGltZXIodGltZXI6IFRpbWVyKXtcbiAgICAgICAgdGhpcy50aW1lcnMucHVzaCh0aW1lcik7XG4gICAgfVxuXG4gICAgY2xlYXJUaW1lcnMoKXtcbiAgICAgICAgdGhpcy50aW1lcnMgPSBuZXcgQXJyYXkoKTtcbiAgICB9XG5cbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy50aW1lcnMuZm9yRWFjaCh0aW1lciA9PiB0aW1lci51cGRhdGUoZGVsdGFUKSk7XG4gICAgfVxufSIsImltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4vTWF0aFV0aWxzXCI7XG5cbi8vIFRPRE86IFRoaXMgc2hvdWxkIGJlIG1vdmVkIHRvIHRoZSBkYXRhdHlwZXMgZm9sZGVyXG4vKipcbiAqIEEgQ29sb3IgdXRpbCBjbGFzcyB0aGF0IGtlZXBzIHRyYWNrIG9mIGNvbG9ycyBsaWtlIGEgdmVjdG9yLCBidXQgY2FuIGJlIGNvbnZlcnRlZCBpbnRvIGEgc3RyaW5nIGZvcm1hdFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2xvciB7XG5cdC8qKiBUaGUgcmVkIHZhbHVlICovXG5cdHB1YmxpYyByOiBudW1iZXI7XG5cdC8qKiBUaGUgZ3JlZW4gdmFsdWUgKi9cblx0cHVibGljIGc6IG51bWJlcjtcblx0LyoqIFRoZSBibHVlIHZhbHVlICovXG5cdHB1YmxpYyBiOiBudW1iZXI7XG5cdC8qKiBUaGUgYWxwaGEgdmFsdWUgKi9cblx0cHVibGljIGE6IG51bWJlcjtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyBjb2xvclxuXHQgKiBAcGFyYW0gciBSZWRcblx0ICogQHBhcmFtIGcgR3JlZW5cblx0ICogQHBhcmFtIGIgQmx1ZVxuXHQgKiBAcGFyYW0gYSBBbHBoYVxuXHQgKi9cblx0Y29uc3RydWN0b3IocjogbnVtYmVyID0gMCwgZzogbnVtYmVyID0gMCwgYjogbnVtYmVyID0gMCwgYTogbnVtYmVyID0gMSl7XG4gICAgICAgIHRoaXMuciA9IHI7XG4gICAgICAgIHRoaXMuZyA9IGc7XG4gICAgICAgIHRoaXMuYiA9IGI7XG4gICAgICAgIHRoaXMuYSA9IGE7XG5cdH1cblxuXHQvKipcdFxuXHQgKiBUcmFuc3BhcmVudCBjb2xvclxuXHQgKiBAcmV0dXJucyByZ2JhKDAsIDAsIDAsIDApXG5cdCAqL1xuXHRzdGF0aWMgZ2V0IFRSQU5TUEFSRU5UKCk6IENvbG9yIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yKDAsIDAsIDAsIDApO1xuXHR9XG5cdFxuXHQvKipcdFxuXHQgKiBSZWQgY29sb3Jcblx0ICogQHJldHVybnMgcmdiKDI1NSwgMCwgMClcblx0ICovXG5cdHN0YXRpYyBnZXQgUkVEKCk6IENvbG9yIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yKDI1NSwgMCwgMCwgMSk7XG5cdH1cblxuXHQvKipcdFxuXHQgKiBHcmVlbiBjb2xvclxuXHQgKiBAcmV0dXJucyByZ2IoMCwgMjU1LCAwKVxuXHQgKi9cblx0c3RhdGljIGdldCBHUkVFTigpOiBDb2xvciB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcigwLCAyNTUsIDAsIDEpO1xuXHR9XG5cblx0LyoqXHRcblx0ICogQmx1ZSBjb2xvclxuXHQgKiBAcmV0dXJucyByZ2IoMCwgMCwgMjU1KVxuXHQgKi9cblx0c3RhdGljIGdldCBCTFVFKCk6IENvbG9yIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yKDAsIDAsIDI1NSwgMSk7XG5cdH1cblxuXHQvKipcdFxuXHQgKiBZZWxsb3cgY29sb3Jcblx0ICogQHJldHVybnMgcmdiKDI1NSwgMjU1LCAwKVxuXHQgKi9cblx0c3RhdGljIGdldCBZRUxMT1coKTogQ29sb3Ige1xuXHRcdHJldHVybiBuZXcgQ29sb3IoMjU1LCAyNTUsIDAsIDEpO1xuXHR9XG5cblx0LyoqXHRcblx0ICogTWFnZW50YSBjb2xvclxuXHQgKiBAcmV0dXJucyByZ2IoMjU1LCAwLCAyNTUpXG5cdCAqL1xuXHRzdGF0aWMgZ2V0IE1BR0VOVEEoKTogQ29sb3Ige1xuXHRcdHJldHVybiBuZXcgQ29sb3IoMjU1LCAwLCAyNTUsIDEpO1xuXHR9XG5cblx0LyoqXHRcblx0ICogQ3lhbiBjb2xvclxuXHQgKiBAcmV0dXJucyByZ2IoMCwgMjU1LCAyNTUpXG5cdCAqL1xuXHRzdGF0aWMgZ2V0IENZQU4oKTogQ29sb3Ige1xuXHRcdHJldHVybiBuZXcgQ29sb3IoMCwgMjU1LCAyNTUsIDEpO1xuXHR9XG5cblx0LyoqXHRcblx0ICogV2hpdGUgY29sb3Jcblx0ICogQHJldHVybnMgcmdiKDI1NSwgMjU1LCAyNTUpXG5cdCAqL1xuXHRzdGF0aWMgZ2V0IFdISVRFKCk6IENvbG9yIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yKDI1NSwgMjU1LCAyNTUsIDEpO1xuXHR9IFxuXG5cdC8qKlx0XG5cdCAqIEJsYWNrIGNvbG9yXG5cdCAqIEByZXR1cm5zIHJnYigwLCAwLCAwKVxuXHQgKi9cblx0c3RhdGljIGdldCBCTEFDSygpOiBDb2xvciB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcigwLCAwLCAwLCAxKTtcblx0fVxuXG5cdC8qKlx0XG5cdCAqIE9yYW5nZSBjb2xvclxuXHQgKiBAcmV0dXJucyByZ2IoMjU1LCAxMDAsIDApXG5cdCAqL1xuXHRzdGF0aWMgZ2V0IE9SQU5HRSgpOiBDb2xvciB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcigyNTUsIDEwMCwgMCwgMSk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgY29sb3IgdG8gdGhlIHZhbHVlcyBwcm92aWRlZFxuXHQgKiBAcGFyYW0gciBSZWRcblx0ICogQHBhcmFtIGcgR3JlZW5cblx0ICogQHBhcmFtIGIgQmx1ZVxuXHQgKiBAcGFyYW0gYSBBbHBoYVxuXHQgKi9cblx0c2V0KHI6IG51bWJlciwgZzogbnVtYmVyLCBiOiBudW1iZXIsIGE6IG51bWJlciA9IDEpOiB2b2lkIHtcblx0XHR0aGlzLnIgPSByO1xuXHRcdHRoaXMuZyA9IGc7XG5cdFx0dGhpcy5iID0gYjtcblx0XHR0aGlzLmEgPSBhO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBuZXcgY29sb3Igc2xpZ2h0bHkgbGlnaHRlciB0aGFuIHRoZSBjdXJyZW50IGNvbG9yXG5cdCAqIEByZXR1cm5zIEEgbmV3IGxpZ2h0ZXIgQ29sb3Jcblx0ICovXG5cdGxpZ2h0ZW4oKTogQ29sb3Ige1xuXHRcdHJldHVybiBuZXcgQ29sb3IoTWF0aFV0aWxzLmNsYW1wKHRoaXMuciArIDQwLCAwLCAyNTUpLCBNYXRoVXRpbHMuY2xhbXAodGhpcy5nICsgNDAsIDAsIDI1NSksIE1hdGhVdGlscy5jbGFtcCh0aGlzLmIgKyA0MCwgMCwgMjU1KSwgTWF0aFV0aWxzLmNsYW1wKHRoaXMuYSArIDEwLCAwLCAyNTUpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbmV3IGNvbG9yIHNsaWdodGx5IGRhcmtlciB0aGFuIHRoZSBjdXJyZW50IGNvbG9yXG5cdCAqIEByZXR1cm5zIEEgbmV3IGRhcmtlciBDb2xvclxuXHQgKi9cblx0ZGFya2VuKCk6IENvbG9yIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yKE1hdGhVdGlscy5jbGFtcCh0aGlzLnIgLSA0MCwgMCwgMjU1KSwgTWF0aFV0aWxzLmNsYW1wKHRoaXMuZyAtIDQwLCAwLCAyNTUpLCBNYXRoVXRpbHMuY2xhbXAodGhpcy5iIC0gNDAsIDAsIDI1NSksIE1hdGhVdGlscy5jbGFtcCh0aGlzLmEgKyAxMCwgMCwgMjU1KSk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoaXMgY29sb3IgYXMgYW4gYXJyYXlcblx0ICogQHJldHVybnMgW3IsIGcsIGIsIGFdXG5cdCAqL1xuXHR0b0FycmF5KCk6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdIHtcblx0XHRyZXR1cm4gW3RoaXMuciwgdGhpcy5nLCB0aGlzLmIsIHRoaXMuYV07XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjb2xvciBhcyBhIHN0cmluZyBvZiB0aGUgZm9ybSAjUlJHR0JCXG5cdCAqIEByZXR1cm5zICNSUkdHQkJcblx0ICovXG5cdHRvU3RyaW5nKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuIFwiI1wiICsgTWF0aFV0aWxzLnRvSGV4KHRoaXMuciwgMikgKyBNYXRoVXRpbHMudG9IZXgodGhpcy5nLCAyKSArIE1hdGhVdGlscy50b0hleCh0aGlzLmIsIDIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGNvbG9yIGFzIGEgc3RyaW5nIG9mIHRoZSBmb3JtIHJnYihyLCBnLCBiKVxuXHQgKiBAcmV0dXJucyByZ2IociwgZywgYilcblx0ICovXG5cdHRvU3RyaW5nUkdCKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuIFwicmdiKFwiICsgdGhpcy5yLnRvU3RyaW5nKCkgKyBcIiwgXCIgKyB0aGlzLmcudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMuYi50b1N0cmluZygpICsgXCIpXCI7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgY29sb3IgYXMgYSBzdHJpbmcgb2YgdGhlIGZvcm0gcmdiYShyLCBnLCBiLCBhKVxuXHQgKiBAcmV0dXJucyByZ2JhKHIsIGcsIGIsIGEpXG5cdCAqL1xuXHR0b1N0cmluZ1JHQkEoKTogc3RyaW5nIHtcblx0XHRpZih0aGlzLmEgPT09IDApe1xuXHRcdFx0cmV0dXJuIHRoaXMudG9TdHJpbmdSR0IoKTtcblx0XHR9XG5cdFx0cmV0dXJuIFwicmdiYShcIiArIHRoaXMuci50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5nLnRvU3RyaW5nKCkgKyBcIiwgXCIgKyB0aGlzLmIudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMuYS50b1N0cmluZygpICtcIilcIlxuXHR9XG5cblx0LyoqXG5cdCAqIFR1cm5zIHRoaXMgY29sb3IgaW50byBhIGZsb2F0MzJBcnJheSBhbmQgY2hhbmdlcyBjb2xvciByYW5nZSB0byBbMC4wLCAxLjBdXG5cdCAqIEByZXR1cm5zIGEgRmxvYXQzMkFycmF5IGNvbnRhaW5pbmcgdGhlIGNvbG9yXG5cdCAqL1xuXHR0b1dlYkdMKCk6IEZsb2F0MzJBcnJheSB7XG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xuXHRcdFx0dGhpcy5yLzI1NSxcblx0XHRcdHRoaXMuZy8yNTUsXG5cdFx0XHR0aGlzLmIvMjU1LFxuXHRcdFx0dGhpcy5hXG5cdFx0XSk7XG5cdH1cblxuXHRzdGF0aWMgZnJvbVN0cmluZ0hleChzdHI6IHN0cmluZyk6IENvbG9yIHtcblx0XHRsZXQgaSA9IDA7XG5cdFx0aWYoc3RyLmNoYXJBdCgwKSA9PSBcIiNcIikgaSs9IDE7XG5cdFx0bGV0IHIgPSBNYXRoVXRpbHMuZnJvbUhleChzdHIuc3Vic3RyaW5nKGksIGkrMikpO1xuXHRcdGxldCBnID0gTWF0aFV0aWxzLmZyb21IZXgoc3RyLnN1YnN0cmluZyhpKzIsIGkrNCkpO1xuXHRcdGxldCBiID0gTWF0aFV0aWxzLmZyb21IZXgoc3RyLnN1YnN0cmluZyhpKzQsIGkrNikpO1xuXHRcdHJldHVybiBuZXcgQ29sb3IociwgZywgYik7XG5cdH1cbn0iLCIvLyBAaWdub3JlUGFnZVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFYXNlRnVuY3Rpb25zIHtcblxuICAgIHN0YXRpYyBlYXNlSW5PdXRTaW5lKHg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiAtKE1hdGguY29zKE1hdGguUEkgKiB4KSAtIDEpIC8gMjtcbiAgICB9XG5cbiAgICBzdGF0aWMgZWFzZU91dEluU2luZSh4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4geCA8IDAuNSA/IC1NYXRoLmNvcyhNYXRoLlBJKih4ICsgMC41KSkvMiA6IC1NYXRoLmNvcyhNYXRoLlBJKih4IC0gMC41KSkvMiArIDE7XG4gICAgfVxuXG4gICAgc3RhdGljIGVhc2VPdXRTaW5lKHg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBNYXRoLnNpbigoeCAqIE1hdGguUEkpIC8gMik7XG4gICAgfVxuXG4gICAgc3RhdGljIGVhc2VJblNpbmUoeDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIDEgLSBNYXRoLmNvcygoeCAqIE1hdGguUEkpIC8gMik7IFxuICAgIH1cblxuICAgIHN0YXRpYyBlYXNlSW5PdXRRdWludCh4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4geCA8IDAuNSA/IDE2ICogeCAqIHggKiB4ICogeCAqIHggOiAxIC0gTWF0aC5wb3coLTIgKiB4ICsgMiwgNSkgLyAyOyAgICBcbiAgICB9XG5cbiAgICBzdGF0aWMgZWFzZUluT3V0UXVhZCh4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4geCA8IDAuNSA/IDIgKiB4ICogeCA6IDEgLSBNYXRoLnBvdygtMiAqIHggKyAyLCAyKSAvIDI7XG4gICAgfVxuXG4gICAgc3RhdGljIGVhc2VPdXRJblF1YWQoeDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHggPCAwLjUgPyB0aGlzLmVhc2VPdXRJbl9PdXRQb3coeCwgMikgOiB0aGlzLmVhc2VPdXRJbl9JblBvdyh4LCAyKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBlYXNlT3V0SW5fT3V0UG93KHg6IG51bWJlciwgcG93OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gMC41IC0gTWF0aC5wb3coLTIgKiB4ICsgMSwgcG93KSAvIDI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZWFzZU91dEluX0luUG93KHg6IG51bWJlciwgcG93OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gMC41ICsgTWF0aC5wb3coMiAqIHggLSAxLCBwb3cpIC8gMjtcbiAgICB9XG59XG5cbmV4cG9ydCBlbnVtIEVhc2VGdW5jdGlvblR5cGUge1xuICAgIC8vIFNJTkVcbiAgICBJTl9PVVRfU0lORSA9IFwiZWFzZUluT3V0U2luZVwiLFxuICAgIE9VVF9JTl9TSU5FID0gXCJlYXNlT3V0SW5TaW5lXCIsXG4gICAgSU5fU0lORSA9IFwiZWFzZUluU2luZVwiLFxuICAgIE9VVF9TSU5FID0gXCJlYXNlT3V0U2luZVwiLFxuXG4gICAgLy8gUVVBRFxuICAgIElOX09VVF9RVUFEID0gXCJlYXNlSW5PdXRRdWFkXCIsXG4gICAgT1VUX0lOX1FVQUQgPSBcImVhc2VPdXRJblF1YWRcIixcblxuICAgIC8vIFFVSU5UXG4gICAgSU5fT1VUX1FVSU5UID0gXCJlYXNlSW5PdXRRdWludFwiXG59IiwiaW1wb3J0IEdyYXBoIGZyb20gXCIuLi9EYXRhVHlwZXMvR3JhcGhzL0dyYXBoXCI7XG5pbXBvcnQgRWRnZU5vZGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9HcmFwaHMvRWRnZU5vZGVcIjtcblxuLyoqIEEgY2xhc3MgdG8gcHJvdmlkZXMgc29tZSB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgZ3JhcGhzICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcmFwaFV0aWxzIHtcblxuXHQvKipcblx0ICogQW4gaW1wbGVtZW50YXRpb24gb2YgRGppa3N0cmEncyBzaG9ydGVzdCBwYXRoIGFsZ29yaXRobSBiYXNlZCBvbiB0aGUgb25lIGRlc2NyaWJlZCBpbiBUaGUgQWxnb3JpdGhtIERlc2lnbiBNYW51YWwuXG5cdCAqIEBwYXJhbSBnIFRoZSBncmFwaFxuXHQgKiBAcGFyYW0gc3RhcnQgVGhlIG51bWJlciB0byBzdGFydCB0aGUgc2hvcnRlc3QgcGF0aCBmcm9tXG5cdCAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHBhcmVudCBvZiBlYWNoIG5vZGUgb2YgdGhlIEdyYXBoIGluIHRoZSBzaG9ydGVzdCBwYXRoLlxuXHQgKi9cblx0c3RhdGljIGRqaWtzdHJhKGc6IEdyYXBoLCBzdGFydDogbnVtYmVyKTogQXJyYXk8bnVtYmVyPiB7XG5cdFx0bGV0IGk6IG51bWJlcjtcdFx0Ly8gQ291bnRlclxuXHRcdGxldCBwOiBFZGdlTm9kZTtcdC8vIFBvaW50ZXIgdG8gZWRnZW5vZGVcblx0XHRsZXQgaW5UcmVlOiBBcnJheTxib29sZWFuPiA9IG5ldyBBcnJheShnLm51bVZlcnRpY2VzKTtcblx0XHRsZXQgZGlzdGFuY2U6IEFycmF5PG51bWJlcj4gPSBuZXcgQXJyYXkoZy5udW1WZXJ0aWNlcyk7XG5cdFx0bGV0IHBhcmVudDogQXJyYXk8bnVtYmVyPiA9IG5ldyBBcnJheShnLm51bVZlcnRpY2VzKTtcblx0XHRsZXQgdjogbnVtYmVyO1x0XHQvLyBDdXJyZW50IHZlcnRleCB0byBwcm9jZXNzXG5cdFx0bGV0IHc6IG51bWJlcjsgXHRcdC8vIENhbmRpZGF0ZSBmb3IgbmV4dCB2ZXJ0ZXhcblx0XHRsZXQgd2VpZ2h0OiBudW1iZXI7XHQvLyBFZGdlIHdlaWdodFxuXHRcdGxldCBkaXN0O1x0XHRcdC8vIEJlc3QgY3VycmVudCBkaXN0YW5jZSBmcm9tIHN0YXJ0XG5cblx0XHRmb3IoaSA9IDA7IGkgPCBnLm51bVZlcnRpY2VzOyBpKyspe1xuXHRcdFx0aW5UcmVlW2ldID0gZmFsc2U7XG5cdFx0XHRkaXN0YW5jZVtpXSA9IEluZmluaXR5O1xuXHRcdFx0cGFyZW50W2ldID0gLTE7XG5cdFx0fVxuXG5cdFx0ZGlzdGFuY2Vbc3RhcnRdID0gMDtcblx0XHR2ID0gc3RhcnQ7XG5cblx0XHR3aGlsZSghaW5UcmVlW3ZdKXtcblx0XHRcdGluVHJlZVt2XSA9IHRydWU7XG5cdFx0XHRwID0gZy5lZGdlc1t2XTtcblxuXHRcdFx0d2hpbGUocCAhPT0gbnVsbCl7XG5cdFx0XHRcdHcgPSBwLnk7XG5cdFx0XHRcdHdlaWdodCA9IHAud2VpZ2h0O1xuXG5cdFx0XHRcdGlmKGRpc3RhbmNlW3ddID4gZGlzdGFuY2Vbdl0gKyB3ZWlnaHQpe1xuXHRcdFx0XHRcdGRpc3RhbmNlW3ddID0gZGlzdGFuY2Vbdl0gKyB3ZWlnaHQ7XG5cdFx0XHRcdFx0cGFyZW50W3ddID0gdjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHAgPSBwLm5leHQ7XG5cdFx0XHR9XG5cblx0XHRcdHYgPSAwO1xuXG5cdFx0XHRkaXN0ID0gSW5maW5pdHk7XG5cblx0XHRcdGZvcihpID0gMDsgaSA8PSBnLm51bVZlcnRpY2VzOyBpKyspe1xuXHRcdFx0XHRpZighaW5UcmVlW2ldICYmIGRpc3QgPiBkaXN0YW5jZVtpXSl7XG5cdFx0XHRcdFx0ZGlzdCA9IGRpc3RhbmNlO1xuXHRcdFx0XHRcdHYgPSBpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBhcmVudDtcblxuXHR9XG5cbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcblxuLyoqIEEgY2xhc3MgY29udGFpbmluZyBzb21lIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBtYXRoIG9wZXJhdGlvbnMgKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hdGhVdGlscyB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2lnbiBvZiB0aGUgdmFsdWUgcHJvdmlkZWRcbiAgICAgKiBAcGFyYW0geCBUaGUgdmFsdWUgdG8gZXh0cmFjdCB0aGUgc2lnbiBmcm9tXG4gICAgICogQHJldHVybnMgLTEgaWYgdGhlIG51bWJlciBpcyBsZXNzIHRoYW4gMCwgMSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgc2lnbih4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4geCA8IDAgPyAtMSA6IDE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB4IGlzIGJldHdlZW4gYSBhbmQgYlxuICAgICAqIEBwYXJhbSBhIFRoZSBtaW4gYm91bmRcbiAgICAgKiBAcGFyYW0gYiBUaGUgbWF4IGJvdW5kXG4gICAgICogQHBhcmFtIHggVGhlIHZhbHVlIHRvIGNoZWNrXG4gICAgICogQHBhcmFtIGV4Y2x1c2l2ZSBXaGV0aGVyIG9yIG5vdCBhIGFuZCBiIGFyZSBleGNsdXNpdmUgYm91bmRzXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB4IGlzIGJldHdlZW4gYSBhbmQgYiwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgc3RhdGljIGJldHdlZW4oYTogbnVtYmVyLCBiOiBudW1iZXIsIHg6IG51bWJlciwgZXhjbHVzaXZlPzogYm9vbGVhbik6IGJvb2xlYW4ge1xuICAgICAgICBpZihleGNsdXNpdmUpe1xuICAgICAgICAgICAgcmV0dXJuIChhIDwgeCkgJiYgKHggPCBiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoYSA8PSB4KSAmJiAoeCA8PSBiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsYW1wcyB0aGUgdmFsdWUgeCB0byB0aGUgcmFuZ2UgW21pbiwgbWF4XSwgcm91bmRpbmcgdXAgb3IgZG93biBpZiBuZWVkZWRcbiAgICAgKiBAcGFyYW0geCBUaGUgdmFsdWUgdG8gYmUgY2xhbXBlZFxuICAgICAqIEBwYXJhbSBtaW4gVGhlIG1pbiBvZiB0aGUgcmFuZ2VcbiAgICAgKiBAcGFyYW0gbWF4IFRoZSBtYXggb2YgdGhlIHJhbmdlXG4gICAgICogQHJldHVybnMgeCwgaWYgaXQgaXMgYmV0d2VlbiBtaW4gYW5kIG1heCwgb3IgbWluL21heCBpZiBpdCBleGNlZWRzIHRoZWlyIGJvdW5kc1xuICAgICAqL1xuICAgIHN0YXRpYyBjbGFtcCh4OiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIGlmKHggPCBtaW4pIHJldHVybiBtaW47XG4gICAgICAgIGlmKHggPiBtYXgpIHJldHVybiBtYXg7XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsYW1wcyB0aGUgdmFsdWUgeCB0byB0aGUgcmFuZ2UgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHggVGhlIHZhbHVlIHRvIGJlIGNsYW1wZWRcbiAgICAgKiBAcmV0dXJucyB4LCBpZiBpdCBpcyBiZXR3ZWVuIDAgYW5kIDEsIG9yIDAvMSBpZiBpdCBleGNlZWRzIHRoZWlyIGJvdW5kc1xuICAgICAqL1xuICAgIHN0YXRpYyBjbGFtcDAxKHg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBNYXRoVXRpbHMuY2xhbXAoeCwgMCwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xhbXBzIHRoZSBsb3dlciBlbmQgb2YgdGhlIHZhbHVlIG9mIHggdG8gdGhlIHJhbmdlIHRvIG1pblxuICAgICAqIEBwYXJhbSB4IFRoZSB2YWx1ZSB0byBiZSBjbGFtcGVkXG4gICAgICogQHBhcmFtIG1pbiBUaGUgbWluaW11bSBhbGxvd2VkIHZhbHVlIG9mIHhcbiAgICAgKiBAcmV0dXJucyB4LCBpZiBpdCBpcyBncmVhdGVyIHRoYW4gbWluLCBvdGhlcndpc2UgbWluXG4gICAgICovXG4gICAgc3RhdGljIGNsYW1wTG93KHg6IG51bWJlciwgbWluOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4geCA8IG1pbiA/IG1pbiA6IHg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xhbXBzIHRoZSBsb3dlciBlbmQgb2YgdGhlIHZhbHVlIG9mIHggdG8gemVyb1xuICAgICAqIEBwYXJhbSB4IFRoZSB2YWx1ZSB0byBiZSBjbGFtcGVkXG4gICAgICogQHJldHVybnMgeCwgaWYgaXQgaXMgZ3JlYXRlciB0aGFuIDAsIG90aGVyd2lzZSAwXG4gICAgICovXG4gICAgc3RhdGljIGNsYW1wTG93MCh4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gTWF0aFV0aWxzLmNsYW1wTG93KHgsIDApO1xuICAgIH1cblxuICAgIHN0YXRpYyBjbGFtcE1hZ25pdHVkZSh2OiBWZWMyLCBtOiBudW1iZXIpOiBWZWMyIHtcbiAgICAgICAgaWYodi5tYWdTcSgpID4gbSptKXtcbiAgICAgICAgICAgIHJldHVybiB2LnNjYWxlVG8obSk7XG4gICAgICAgIH0gZWxzZXtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGNoYW5nZVJhbmdlKHg6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyLCBuZXdNaW46IG51bWJlciwgbmV3TWF4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5sZXJwKG5ld01pbiwgbmV3TWF4LCB0aGlzLmludkxlcnAobWluLCBtYXgsIHgpKTtcbiAgICB9XG5cbiAgICAvKipcblx0ICogTGluZWFyIEludGVycG9sYXRpb25cblx0ICogQHBhcmFtIGEgVGhlIGZpcnN0IHZhbHVlIGZvciB0aGUgaW50ZXJwb2xhdGlvbiBib3VuZFxuXHQgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZhbHVlIGZvciB0aGUgaW50ZXJwb2xhdGlvbiBib3VuZFxuXHQgKiBAcGFyYW0gdCBUaGUgdGltZSB3ZSBhcmUgaW50ZXJwb2xhdGluZyB0b1xuICAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBiZXR3ZWVuIGEgYW5kIGIgYXQgdGltZSB0XG5cdCAqL1xuXHRzdGF0aWMgbGVycChhOiBudW1iZXIsIGI6IG51bWJlciwgdDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIGEgKyB0ICogKGIgLSBhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZlcnNlIExpbmVhciBJbnRlcnBvbGF0aW9uLiBGaW5kcyB0aGUgdGltZSBhdCB3aGljaCBhIHZhbHVlIGJldHdlZW4gYSBhbmQgYiB3b3VsZCBvY2N1clxuICAgICAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2YWx1ZSBmb3IgdGhlIGludGVycG9sYXRpb24gYm91bmRcbiAgICAgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZhbHVlIGZvciB0aGUgaW50ZXJwb2xhdGlvbiBib3VuZFxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgY3VycmVudCB2YWx1ZVxuICAgICAqIEByZXR1cm5zIFRoZSB0aW1lIGF0IHdoaWNoIHRoZSBjdXJyZW50IHZhbHVlIG9jY3VycyBiZXR3ZWVuIGEgYW5kIGJcbiAgICAgKi9cbiAgICBzdGF0aWMgaW52TGVycChhOiBudW1iZXIsIGI6IG51bWJlciwgdmFsdWU6IG51bWJlcil7XG4gICAgICAgIHJldHVybiAodmFsdWUgLSBhKS8oYiAtIGEpO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBDdXRzIG9mZiBkZWNpbWFsIHBvaW50cyBvZiBhIG51bWJlciBhZnRlciBhIHNwZWNpZmllZCBwbGFjZVxuICAgICAqIEBwYXJhbSBudW0gVGhlIG51bWJlciB0byBmbG9vclxuICAgICAqIEBwYXJhbSBwbGFjZSBUaGUgbGFzdCBkZWNpbWFsIHBsYWNlIG9mIHRoZSBuZXcgbnVtYmVyXG4gICAgICogQHJldHVybnMgVGhlIGZsb29yZWQgbnVtYmVyXG4gICAgICovXG4gICAgc3RhdGljIGZsb29yVG9QbGFjZShudW06IG51bWJlciwgcGxhY2U6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIGlmKHBsYWNlID09PSAwKXtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZmFjdG9yID0gMTA7XG4gICAgICAgIHdoaWxlKHBsYWNlID4gMSl7XG4gICAgICAgICAgICBmYWN0b3IgIT0gMTA7XG4gICAgICAgICAgICBwbGFjZS0tO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtKmZhY3RvcikvZmFjdG9yO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG51bWJlciBmcm9tIGEgaGV4IHN0cmluZ1xuICAgICAqIEBwYXJhbSBzdHIgdGhlIHN0cmluZyBjb250YWluaW5nIHRoZSBoZXggbnVtYmVyXG4gICAgICogQHJldHVybnMgdGhlIG51bWJlciBpbiBkZWNpbWFsIHJlcHJlc2VudGVkIGJ5IHRoZSBoZXggc3RyaW5nXG4gICAgICovXG4gICAgc3RhdGljIGZyb21IZXgoc3RyOiBzdHJpbmcpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoc3RyLCAxNik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIGFzIGEgaGV4YWRlY2ltYWxcbiAgICAgKiBAcGFyYW0gbnVtIFRoZSBudW1iZXIgdG8gY29udmVydCB0byBoZXhcbiAgICAgKiBAcGFyYW0gbWluTGVuZ3RoIFRoZSBsZW5ndGggb2YgdGhlIHJldHVybmVkIGhleCBzdHJpbmcgKGFkZHMgemVybyBwYWRkaW5nIGlmIG5lZWRlZClcbiAgICAgKiBAcmV0dXJucyBUaGUgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBudW1iZXIgYXMgYSBzdHJpbmdcbiAgICAgKi9cbiAgICBzdGF0aWMgdG9IZXgobnVtOiBudW1iZXIsIG1pbkxlbmd0aDogbnVtYmVyID0gbnVsbCk6IHN0cmluZyB7XG4gICAgICAgIGxldCBmYWN0b3IgPSAxO1xuICAgICAgICB3aGlsZShmYWN0b3IqMTYgPCBudW0pe1xuICAgICAgICAgICAgZmFjdG9yICo9IDE2O1xuICAgICAgICB9XG4gICAgICAgIGxldCBoZXhTdHIgPSBcIlwiO1xuICAgICAgICB3aGlsZShmYWN0b3IgPj0gMSl7XG4gICAgICAgICAgICBsZXQgZGlnaXQgPSBNYXRoLmZsb29yKG51bS9mYWN0b3IpO1xuICAgICAgICAgICAgaGV4U3RyICs9IE1hdGhVdGlscy50b0hleERpZ2l0KGRpZ2l0KTtcbiAgICAgICAgICAgIG51bSAtPSBkaWdpdCAqIGZhY3RvcjtcbiAgICAgICAgICAgIGZhY3RvciAvPSAxNjtcblx0XHR9XG5cdFx0XG5cdFx0aWYobWluTGVuZ3RoICE9PSBudWxsKXtcblx0XHRcdHdoaWxlKGhleFN0ci5sZW5ndGggPCBtaW5MZW5ndGgpe1xuXHRcdFx0XHRoZXhTdHIgPSBcIjBcIiArIGhleFN0cjtcblx0XHRcdH1cblx0XHR9XG5cbiAgICAgICAgcmV0dXJuIGhleFN0cjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGRpZ2l0IHRvIGhleGFkZWNpbWFsLiBJbiB0aGlzIGNhc2UsIGEgZGlnaXQgaXMgYmV0d2VlbiAwIGFuZCAxNSBpbmNsdXNpdmVcbiAgICAgKiBAcGFyYW0gbnVtIFRoZSBkaWdpdCB0byBjb252ZXJ0IHRvIGhleGFkZWNpbWFsXG4gICAgICogQHJldHVybnMgVGhlIGhleCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGlnaXQgYXMgYSBzdHJpbmdcbiAgICAgKi9cbiAgICBzdGF0aWMgdG9IZXhEaWdpdChudW06IG51bWJlcik6IHN0cmluZyB7XG4gICAgICAgIGlmKG51bSA8IDEwKXtcbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgbnVtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoNjUgKyBudW0gLSAxMCk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vTWF0aFV0aWxzXCI7XG5cbmNvbnN0IHBlcm11dGF0aW9uID0gWyAxNTEsMTYwLDEzNyw5MSw5MCwxNSxcblx0MTMxLDEzLDIwMSw5NSw5Niw1MywxOTQsMjMzLDcsMjI1LDE0MCwzNiwxMDMsMzAsNjksMTQyLDgsOTksMzcsMjQwLDIxLDEwLDIzLFxuXHQxOTAsIDYsMTQ4LDI0NywxMjAsMjM0LDc1LDAsMjYsMTk3LDYyLDk0LDI1MiwyMTksMjAzLDExNywzNSwxMSwzMiw1NywxNzcsMzMsXG5cdDg4LDIzNywxNDksNTYsODcsMTc0LDIwLDEyNSwxMzYsMTcxLDE2OCwgNjgsMTc1LDc0LDE2NSw3MSwxMzQsMTM5LDQ4LDI3LDE2Nixcblx0NzcsMTQ2LDE1OCwyMzEsODMsMTExLDIyOSwxMjIsNjAsMjExLDEzMywyMzAsMjIwLDEwNSw5Miw0MSw1NSw0NiwyNDUsNDAsMjQ0LFxuXHQxMDIsMTQzLDU0LCA2NSwyNSw2MywxNjEsIDEsMjE2LDgwLDczLDIwOSw3NiwxMzIsMTg3LDIwOCwgODksMTgsMTY5LDIwMCwxOTYsXG5cdDEzNSwxMzAsMTE2LDE4OCwxNTksODYsMTY0LDEwMCwxMDksMTk4LDE3MywxODYsIDMsNjQsNTIsMjE3LDIyNiwyNTAsMTI0LDEyMyxcblx0NSwyMDIsMzgsMTQ3LDExOCwxMjYsMjU1LDgyLDg1LDIxMiwyMDcsMjA2LDU5LDIyNyw0NywxNiw1OCwxNywxODIsMTg5LDI4LDQyLFxuXHQyMjMsMTgzLDE3MCwyMTMsMTE5LDI0OCwxNTIsIDIsNDQsMTU0LDE2MywgNzAsMjIxLDE1MywxMDEsMTU1LDE2NywgNDMsMTcyLDksXG5cdDEyOSwyMiwzOSwyNTMsIDE5LDk4LDEwOCwxMTAsNzksMTEzLDIyNCwyMzIsMTc4LDE4NSwgMTEyLDEwNCwyMTgsMjQ2LDk3LDIyOCxcblx0MjUxLDM0LDI0MiwxOTMsMjM4LDIxMCwxNDQsMTIsMTkxLDE3OSwxNjIsMjQxLCA4MSw1MSwxNDUsMjM1LDI0OSwxNCwyMzksMTA3LFxuXHQ0OSwxOTIsMjE0LCAzMSwxODEsMTk5LDEwNiwxNTcsMTg0LCA4NCwyMDQsMTc2LDExNSwxMjEsNTAsNDUsMTI3LCA0LDE1MCwyNTQsXG5cdDEzOCwyMzYsMjA1LDkzLDIyMiwxMTQsNjcsMjksMjQsNzIsMjQzLDE0MSwxMjgsMTk1LDc4LDY2LDIxNSw2MSwxNTYsMTgwXG5dO1xuXG4vKipcbiAqIEEgbm9pc2UgZ2VuZXJhdG9yXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBlcmxpbiB7XG5cbiAgICBwcml2YXRlIHA6IEludDE2QXJyYXk7XG4gICAgcHJpdmF0ZSByZXBlYXQ6IG51bWJlcjtcblxuXHRjb25zdHJ1Y3Rvcigpe1xuXHRcdHRoaXMucCA9IG5ldyBJbnQxNkFycmF5KDUxMik7XG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IDUxMjsgaSsrKXtcblx0XHRcdHRoaXMucFtpXSA9IHBlcm11dGF0aW9uW2klMjU2XTtcblx0XHR9XG5cdFx0dGhpcy5yZXBlYXQgPSAtMTtcblx0fVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJhbmRvbSBwZXJsaW4gbm9pc2UgdmFsdWVcbiAgICAgKiBAcGFyYW0geCBBbiBpbnB1dCB2YWx1ZVxuICAgICAqIEBwYXJhbSB5IEFuIGlucHV0IHZhbHVlXG4gICAgICogQHBhcmFtIHogQW4gaW5wdXQgdmFsdWVcblx0ICogQHJldHVybnMgQSBub2lzZSB2YWx1ZVxuICAgICAqL1xuXHRwZXJsaW4oeDogbnVtYmVyLCB5OiBudW1iZXIsIHo6IG51bWJlciA9IDApOiBudW1iZXIge1xuXHRcdGlmKHRoaXMucmVwZWF0ID4gMCkge1xuXHRcdFx0eCA9IHgldGhpcy5yZXBlYXQ7XG5cdFx0XHR5ID0geSV0aGlzLnJlcGVhdDtcblx0XHRcdHogPSB6JXRoaXMucmVwZWF0O1xuXHRcdH1cblxuXHRcdC8vIEdldCB0aGUgcG9zaXRpb24gb2YgdGhlIHVuaXQgY3ViZSBvZiAoeCwgeSwgeilcblx0XHRsZXQgeGkgPSBNYXRoLmZsb29yKHgpICYgMjU1O1xuXHRcdGxldCB5aSA9IE1hdGguZmxvb3IoeSkgJiAyNTU7XG5cdFx0bGV0IHppID0gTWF0aC5mbG9vcih6KSAmIDI1NTtcblx0XHQvLyBHZXQgdGhlIHBvc2l0aW9uIG9mICh4LCB5LCB6KSBpbiB0aGF0IHVuaXQgY3ViZVxuXHRcdGxldCB4ZiA9IHggLSBNYXRoLmZsb29yKHgpO1xuXHRcdGxldCB5ZiA9IHkgLSBNYXRoLmZsb29yKHkpO1xuXHRcdGxldCB6ZiA9IHogLSBNYXRoLmZsb29yKHopO1xuXG5cdFx0Ly8gVXNlIHRoZSBmYWRlIGZ1bmN0aW9uIHRvIHJlbGF4IHRoZSBjb29yZGluYXRlcyB0b3dhcmRzIGEgd2hvbGUgdmFsdWVcblx0XHRsZXQgdSA9IHRoaXMuZmFkZSh4Zik7XG5cdFx0bGV0IHYgPSB0aGlzLmZhZGUoeWYpO1xuXHRcdGxldCB3ID0gdGhpcy5mYWRlKHpmKTtcblxuXHRcdC8vIFBlcmxpbiBub2lzZSBoYXNoIGZ1bmN0aW9uXG5cdFx0bGV0IGFhYSA9IHRoaXMucFt0aGlzLnBbdGhpcy5wWyAgICB4aSBdKyAgICB5aSBdKyAgICB6aSBdO1xuXHRcdGxldCBhYmEgPSB0aGlzLnBbdGhpcy5wW3RoaXMucFsgICAgeGkgXSt0aGlzLmluYyh5aSldKyAgICB6aSBdO1xuXHRcdGxldCBhYWIgPSB0aGlzLnBbdGhpcy5wW3RoaXMucFsgICAgeGkgXSsgICAgeWkgXSt0aGlzLmluYyh6aSldO1xuXHRcdGxldCBhYmIgPSB0aGlzLnBbdGhpcy5wW3RoaXMucFsgICAgeGkgXSt0aGlzLmluYyh5aSldK3RoaXMuaW5jKHppKV07XG5cdFx0bGV0IGJhYSA9IHRoaXMucFt0aGlzLnBbdGhpcy5wW3RoaXMuaW5jKHhpKV0rICAgIHlpIF0rICAgIHppIF07XG5cdFx0bGV0IGJiYSA9IHRoaXMucFt0aGlzLnBbdGhpcy5wW3RoaXMuaW5jKHhpKV0rdGhpcy5pbmMoeWkpXSsgICAgemkgXTtcblx0XHRsZXQgYmFiID0gdGhpcy5wW3RoaXMucFt0aGlzLnBbdGhpcy5pbmMoeGkpXSsgICAgeWkgXSt0aGlzLmluYyh6aSldO1xuXHRcdGxldCBiYmIgPSB0aGlzLnBbdGhpcy5wW3RoaXMucFt0aGlzLmluYyh4aSldK3RoaXMuaW5jKHlpKV0rdGhpcy5pbmMoemkpXTtcblxuXHRcdC8vIENhbGN1bGF0ZSB0aGUgdmFsdWUgb2YgdGhlIHBlcmxpbiBub2llc1xuICAgIFx0bGV0IHgxID0gTWF0aFV0aWxzLmxlcnAodGhpcy5ncmFkIChhYWEsIHhmICAsIHlmICAsIHpmKSwgdGhpcy5ncmFkIChiYWEsIHhmLTEsIHlmICAsIHpmKSwgdSk7XG4gICAgXHRsZXQgeDIgPSBNYXRoVXRpbHMubGVycCh0aGlzLmdyYWQgKGFiYSwgeGYgICwgeWYtMSwgemYpLCB0aGlzLmdyYWQgKGJiYSwgeGYtMSwgeWYtMSwgemYpLCB1KTtcbiAgICBcdGxldCB5MSA9IE1hdGhVdGlscy5sZXJwKHgxLCB4Miwgdik7XG5cbiAgICBcdHgxID0gTWF0aFV0aWxzLmxlcnAodGhpcy5ncmFkIChhYWIsIHhmICAsIHlmICAsIHpmLTEpLCB0aGlzLmdyYWQgKGJhYiwgeGYtMSwgeWYgICwgemYtMSksIHUpO1xuICAgIFx0eDIgPSBNYXRoVXRpbHMubGVycCh0aGlzLmdyYWQgKGFiYiwgeGYgICwgeWYtMSwgemYtMSksIHRoaXMuZ3JhZCAoYmJiLCB4Zi0xLCB5Zi0xLCB6Zi0xKSwgdSk7XG5cdFx0bGV0IHkyID0gTWF0aFV0aWxzLmxlcnAgKHgxLCB4Miwgdik7XG5cdFx0XG5cdFx0cmV0dXJuIChNYXRoVXRpbHMubGVycCh5MSwgeTIsIHcpICsgMSkvMjtcblx0fVxuXG5cdGdyYWQoaGFzaDogbnVtYmVyLCB4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyKXtcblx0XHRzd2l0Y2goaGFzaCAmIDB4Rilcblx0XHR7XG5cdFx0XHRjYXNlIDB4MDogcmV0dXJuICB4ICsgeTtcblx0XHRcdGNhc2UgMHgxOiByZXR1cm4gLXggKyB5O1xuXHRcdFx0Y2FzZSAweDI6IHJldHVybiAgeCAtIHk7XG5cdFx0XHRjYXNlIDB4MzogcmV0dXJuIC14IC0geTtcblx0XHRcdGNhc2UgMHg0OiByZXR1cm4gIHggKyB6O1xuXHRcdFx0Y2FzZSAweDU6IHJldHVybiAteCArIHo7XG5cdFx0XHRjYXNlIDB4NjogcmV0dXJuICB4IC0gejtcblx0XHRcdGNhc2UgMHg3OiByZXR1cm4gLXggLSB6O1xuXHRcdFx0Y2FzZSAweDg6IHJldHVybiAgeSArIHo7XG5cdFx0XHRjYXNlIDB4OTogcmV0dXJuIC15ICsgejtcblx0XHRcdGNhc2UgMHhBOiByZXR1cm4gIHkgLSB6O1xuXHRcdFx0Y2FzZSAweEI6IHJldHVybiAteSAtIHo7XG5cdFx0XHRjYXNlIDB4QzogcmV0dXJuICB5ICsgeDtcblx0XHRcdGNhc2UgMHhEOiByZXR1cm4gLXkgKyB6O1xuXHRcdFx0Y2FzZSAweEU6IHJldHVybiAgeSAtIHg7XG5cdFx0XHRjYXNlIDB4RjogcmV0dXJuIC15IC0gejtcblx0XHRcdGRlZmF1bHQ6IHJldHVybiAwOyAvLyBuZXZlciBoYXBwZW5zXG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFNhZmUgaW5jcmVtZW50IHRoYXQgZG9lc24ndCBnbyBiZXlvbmQgdGhlIHJlcGVhdCB2YWx1ZVxuXHQgKiBAcGFyYW0gbnVtIFRoZSBudW1iZXIgdG8gaW5jcmVtZW50XG5cdCAqL1xuXHRpbmMobnVtOiBudW1iZXIpe1xuXHRcdG51bSsrO1xuXHRcdGlmKHRoaXMucmVwZWF0ID4gMCl7XG5cdFx0XHRudW0gJT0gdGhpcy5yZXBlYXQ7XG5cdFx0fVxuXHRcdHJldHVybiBudW07XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGZhZGUgZnVuY3Rpb24gNnReNSAtIDE1dF40ICsgMTB0XjNcblx0ICogQHBhcmFtIHQgVGhlIHZhbHVlIHdlIGFyZSBhcHBseWluZyB0aGUgZmFkZSB0b1xuXHQgKi9cblx0ZmFkZSh0OiBudW1iZXIpe1xuXHRcdHJldHVybiB0KnQqdCoodCoodCo2IC0gMTUpICsgMTApO1xuXHR9XG59IiwiaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi9NYXRoVXRpbHNcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi9Db2xvclwiO1xuaW1wb3J0IFBlcmxpbiBmcm9tIFwiLi9SYW5kL1BlcmxpblwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgUkFORE9NIGZyb20gJ3NlZWQtcmFuZG9tJztcblxuY2xhc3MgTm9pc2Uge1xuICAgIHA6IFBlcmxpbiA9IG5ldyBQZXJsaW4oKTtcblxuICAgIHBlcmxpbih4OiBudW1iZXIsIHk6IG51bWJlciwgej86IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnAucGVybGluKHgsIHksIHopO1xuICAgIH1cbn1cblxuLyoqIEEgY2xhc3MgdGhhdCBoYXMgc29tZSByYW5kb20gZ2VuZXJhdG9yIHV0aWxzICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSYW5kVXRpbHMge1xuXG4gICAgcHJpdmF0ZSBzdGF0aWMgX3NlZWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBwcml2YXRlIHN0YXRpYyBfcmFuZDogKCkgPT4gbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJhbmRvbSBmdW5jdGlvbiBmb3IgV29sZmllMkQuIFRoZSByYW5kb20oKSBtZXRob2QgZ2VuZXJhdGVzIGEgcmFuZG9tIG51bWJlciB1c2luZyBcbiAgICAgKiB0aGUgZnVuY3Rpb24gZXhwb3J0ZWQgc2VlZC1yYW5kb20uIFRoaXMgZnVuY3Rpb24gZG9lcyB0aGUgZXhhY3Qgc2FtZSB0aGluZyB0aGF0IFxuICAgICAqIE1hdGgucmFuZG9tKCkgZG9lcywgZXhjZXB0IGl0IGFsbG93cyB1cyB0byB1c2UgYSBzZWVkLlxuICAgICAqIFxuICAgICAqIEByZXR1cm5zIGEgcmFuZG9tIG51bWJlciBmcm9tIHRoZSBmdW5jdGlvbiBfcmFuZCgpIHRoYXQgZ2VuZXJhdGVzIHJhbmRvbSBudW1iZXJzIGJhc2VkXG4gICAgICogb24gdGhlIHNlZWQsIF9zZWVkLlxuICAgICAqL1xuICAgIHN0YXRpYyByYW5kb20oKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKFJhbmRVdGlscy5fcmFuZCA9PT0gdW5kZWZpbmVkIHx8IFJhbmRVdGlscy5fcmFuZCA9PT0gbnVsbCkgeyBcbiAgICAgICAgICAgIFJhbmRVdGlscy5fcmFuZCA9IFJBTkRPTShSYW5kVXRpbHMuc2VlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJhbmRVdGlscy5fcmFuZCgpO1xuICAgIH1cblxuICAgIHN0YXRpYyByYW5kb21TZWVkKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgLyoqIFxuICAgICAqIEdldHMgdGhlIHNlZWQgdXNlZCBieSB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuIElmIHRoZSBzZWVkIGlzIG51bGwgb3IgdW5kZWZpbmVkLFxuICAgICAqIGEgc2VlZCBpcyBnZW5lcmF0ZWQgdXNpbmcgUmFuZFV0aWxzLnJhbmRvbVNlZWQoKS5cbiAgICAgKiBAcmV0dXJucyB0aGUgc2VlZFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgc2VlZCgpOiBzdHJpbmcgeyBcbiAgICAgICAgaWYgKFJhbmRVdGlscy5fc2VlZCA9PT0gdW5kZWZpbmVkIHx8IFJhbmRVdGlscy5fc2VlZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgUmFuZFV0aWxzLl9zZWVkID0gUmFuZFV0aWxzLnJhbmRvbVNlZWQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmFuZFV0aWxzLl9zZWVkOyBcbiAgICB9XG5cbiAgICAvKiogXG4gICAgICogU2V0cyB0aGUgc2VlZCB1c2VkIGJ5IHRoZSByYW5kb20gbnVtYmVyIGdlbmVyYXRvci4gU2V0cyB0aGUgX3JhbmQgZnVuY3Rpb24gdXNlZFxuICAgICAqIGJ5IHJhbmRvbSgpIHRvIGEgbmV3IGZ1bmN0aW9uLCBzZWVkZWQgd2l0aCB0aGUgZ2l2ZW4gc2VlZC5cbiAgICAgKiBAcGFyYW0gc2VlZCB0aGUgc2VlZCB1c2VkIGJ5IHRoZSByYW5kb20gbnVtYmVyIGdlbmVyYXRvclxuICAgICAqL1xuICAgIHN0YXRpYyBzZXQgc2VlZChzZWVkOiBzdHJpbmcpIHsgXG4gICAgICAgIFJhbmRVdGlscy5fc2VlZCA9IHNlZWQ7XG4gICAgICAgIFJhbmRVdGlscy5fcmFuZCA9IFJBTkRPTShzZWVkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSByYW5kb20gaW50ZWdlciBpbiB0aGUgc3BlY2lmaWVkIHJhbmdlXG4gICAgICogQHBhcmFtIG1pbiBUaGUgbWluIG9mIHRoZSByYW5nZSAoaW5jbHVzaXZlKVxuICAgICAqIEBwYXJhbSBtYXggVGhlIG1heCBvZiB0aGUgcmFuZ2UgKGV4Y2x1c2l2ZSlcbiAgICAgKiBAcmV0dXJucyBBIHJhbmRvbSBpbnQgaW4gdGhlIHJhbmdlIFttaW4sIG1heClcbiAgICAgKi9cblx0c3RhdGljIHJhbmRJbnQobWluOiBudW1iZXIsIG1heDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoUmFuZFV0aWxzLnJhbmRvbSgpKihtYXggLSBtaW4pICsgbWluKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSByYW5kb20gZmxvYXQgaW4gdGhlIHNwZWNpZmllZCByYW5nZVxuICAgICAqIEBwYXJhbSBtaW4gVGhlIG1pbiBvZiB0aGUgcmFuZ2UgKGluY2x1c2l2ZSlcbiAgICAgKiBAcGFyYW0gbWF4IFRoZSBtYXggb2YgdGhlIHJhbmdlIChleGNsdXNpdmUpXG4gICAgICogQHJldHVybnMgQSByYW5kb20gZmxvYXQgaW4gdGhlIHJhbmdlIFttaW4sIG1heClcbiAgICAgKi9cblx0c3RhdGljIHJhbmRGbG9hdChtaW46IG51bWJlciwgbWF4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gUmFuZFV0aWxzLnJhbmRvbSgpKihtYXggLSBtaW4pICsgbWluO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSByYW5kb20gaGV4YWRlY2ltYWwgbnVtYmVyIGluIHRoZSBzcGVjaWZpZWQgcmFuZ2VcbiAgICAgKiBAcGFyYW0gbWluIFRoZSBtaW4gb2YgdGhlIHJhbmdlIChpbmNsdXNpdmUpXG4gICAgICogQHBhcmFtIG1heCBUaGUgbWF4IG9mIHRoZSByYW5nZSAoZXhjbHVzaXZlKVxuICAgICAqIEByZXR1cm5zIGEgcmFuZG9tIGhleCBudW1iZXIgaW4gdGhlIHJhbmdlIFttaW4sIG1heCkgYXMgYSBzdHJpbmdcbiAgICAgKi9cbiAgICBzdGF0aWMgcmFuZEhleChtaW46IG51bWJlciwgbWF4OiBudW1iZXIpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gTWF0aFV0aWxzLnRvSGV4KFJhbmRVdGlscy5yYW5kSW50KG1pbiwgbWF4KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgcmFuZG9tIGNvbG9yXG4gICAgICogQHJldHVybnMgQSByYW5kb20gQ29sb3JcbiAgICAgKi9cblx0c3RhdGljIHJhbmRDb2xvcigpOiBDb2xvciB7XG4gICAgICAgIGxldCByID0gUmFuZFV0aWxzLnJhbmRJbnQoMCwgMjU2KTtcbiAgICAgICAgbGV0IGcgPSBSYW5kVXRpbHMucmFuZEludCgwLCAyNTYpO1xuICAgICAgICBsZXQgYiA9IFJhbmRVdGlscy5yYW5kSW50KDAsIDI1Nik7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IociwgZywgYik7XG4gICAgfVxuXG4gICAgc3RhdGljIHJhbmRWZWMobWluWDogbnVtYmVyLCBtYXhYOiBudW1iZXIsIG1pblk6IG51bWJlciwgbWF4WTogbnVtYmVyKTogVmVjMiB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjMih0aGlzLnJhbmRGbG9hdChtaW5YLCBtYXhYKSwgdGhpcy5yYW5kRmxvYXQobWluWSwgbWF4WSkpO1xuICAgIH1cblxuICAgIC8qKiBBIG5vaXNlIGdlbmVyYXRvciAqL1xuICAgIHN0YXRpYyBub2lzZTogTm9pc2UgPSBuZXcgTm9pc2UoKTtcblxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuL0NvbG9yXCI7XG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuL01hdGhVdGlsc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJpbmdVdGlscyB7XG5cdHN0YXRpYyB0b1dlYkdMQ29vcmRzKHBvaW50OiBWZWMyLCBvcmlnaW46IFZlYzIsIHdvcmxkU2l6ZTogVmVjMik6IEZsb2F0MzJBcnJheSB7XG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xuXHRcdFx0TWF0aFV0aWxzLmNoYW5nZVJhbmdlKHBvaW50LngsIG9yaWdpbi54LCBvcmlnaW4ueCArIHdvcmxkU2l6ZS54LCAtMSwgMSksXG5cdFx0XHRNYXRoVXRpbHMuY2hhbmdlUmFuZ2UocG9pbnQueSwgb3JpZ2luLnksIG9yaWdpbi55ICsgd29ybGRTaXplLnksIDEsIC0xKVxuXHRcdF0pO1xuXHR9XG5cblx0c3RhdGljIHRvV2ViR0xTY2FsZShzaXplOiBWZWMyLCB3b3JsZFNpemU6IFZlYzIpOiBGbG9hdDMyQXJyYXkge1xuXHRcdHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFtcblx0XHRcdDIqc2l6ZS54L3dvcmxkU2l6ZS54LFxuXHRcdFx0MipzaXplLnkvd29ybGRTaXplLnksXG5cdFx0XSk7XG5cdH1cblxuXHRzdGF0aWMgdG9XZWJHTENvbG9yKGNvbG9yOiBDb2xvcik6IEZsb2F0MzJBcnJheSB7XG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xuXHRcdFx0TWF0aFV0aWxzLmNoYW5nZVJhbmdlKGNvbG9yLnIsIDAsIDI1NSwgMCwgMSksXG5cdFx0XHRNYXRoVXRpbHMuY2hhbmdlUmFuZ2UoY29sb3IuZywgMCwgMjU1LCAwLCAxKSxcblx0XHRcdE1hdGhVdGlscy5jaGFuZ2VSYW5nZShjb2xvci5iLCAwLCAyNTUsIDAsIDEpLFxuXHRcdFx0Y29sb3IuYVxuXHRcdF0pO1xuXHR9XG59IiwiLyoqIFNvbWUgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBzdHJpbmdzICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdHJpbmdVdGlscyB7XG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIHBhdGggZnJvbSBhIGZpbGVwYXRoIHRoYXQgaW5jbHVkZXMgdGhlIGZpbGVcbiAgICAgKiBAcGFyYW0gZmlsZVBhdGggdGhlIGZpbGVwYXRoIHRvIGV4dHJhY3QgdGhlIHBhdGggZnJvbVxuICAgICAqIEByZXR1cm5zIFRoZSBwYXRoIHBvcnRpb24gb2YgdGhlIGZpbGVwYXRoIHByb3ZpZGVkXG4gICAgICovXG4gICAgc3RhdGljIGdldFBhdGhGcm9tRmlsZVBhdGgoZmlsZVBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGxldCBzcGxpdFBhdGggPSBmaWxlUGF0aC5zcGxpdChcIi9cIik7XG4gICAgICAgIHNwbGl0UGF0aC5wb3AoKTtcbiAgICAgICAgc3BsaXRQYXRoLnB1c2goXCJcIik7XG4gICAgICAgIHJldHVybiBzcGxpdFBhdGguam9pbihcIi9cIik7XG4gICAgfVxufSIsImltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnRcIjtcbmltcG9ydCB7IFRhcmdldGFibGVFbnRpdHkgfSBmcm9tIFwiLi4vLi4vLi4vR2FtZVN5c3RlbXMvVGFyZ2V0aW5nL1RhcmdldGFibGVFbnRpdHlcIjtcbmltcG9ydCBOUENBY3Rpb24gZnJvbSBcIi4vTlBDQWN0aW9uXCI7XG5cbi8qKlxuICogQW4gSWRsZSBhY3Rpb24gZm9yIHRoZSBOUENHb2FwQUkuIEJhc2ljYWxseSBhIGRlZmF1bHQgYWN0aW9uIGZvciBhbGwgb2YgdGhlIE5QQ3NcbiAqIHRvIGRvIG5vdGhpbmcuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElkbGVBY3Rpb24gZXh0ZW5kcyBOUENBY3Rpb24ge1xuXG4gICAgcHVibGljIHBlcmZvcm1BY3Rpb24odGFyZ2V0OiBUYXJnZXRhYmxlRW50aXR5KTogdm9pZCB7XG4gICAgICAgIHRoaXMuZmluaXNoZWQoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgaGFuZGxlSW5wdXQoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQge1xuICAgICAgICBzd2l0Y2goZXZlbnQudHlwZSkge1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIHN1cGVyLmhhbmRsZUlucHV0KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBcbn0iLCJpbXBvcnQgR29hcEFjdGlvbiBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvQUkvR29hcC9Hb2FwQWN0aW9uXCI7XG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9FdmVudHMvR2FtZUV2ZW50XCI7XG5pbXBvcnQgSGVhbHRocGFjayBmcm9tIFwiLi4vLi4vLi4vR2FtZVN5c3RlbXMvSXRlbVN5c3RlbS9JdGVtcy9IZWFsdGhwYWNrXCI7XG5pbXBvcnQgTlBDQWN0b3IgZnJvbSBcIi4uLy4uLy4uL0FjdG9ycy9OUENBY3RvclwiO1xuaW1wb3J0IE5QQ0JlaGF2aW9yIGZyb20gXCIuLi9OUENCZWhhdmlvclwiO1xuaW1wb3J0IEZpbmRlciBmcm9tIFwiLi4vLi4vLi4vR2FtZVN5c3RlbXMvU2VhcmNoaW5nL0ZpbmRlclwiO1xuaW1wb3J0IHsgVGFyZ2V0YWJsZUVudGl0eSB9IGZyb20gXCIuLi8uLi8uLi9HYW1lU3lzdGVtcy9UYXJnZXRpbmcvVGFyZ2V0YWJsZUVudGl0eVwiO1xuaW1wb3J0IEJhc2ljRmluZGVyIGZyb20gXCIuLi8uLi8uLi9HYW1lU3lzdGVtcy9TZWFyY2hpbmcvQmFzaWNGaW5kZXJcIjtcbmltcG9ydCBOYXZpZ2F0aW9uUGF0aCBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvUGF0aGZpbmRpbmcvTmF2aWdhdGlvblBhdGhcIjtcblxuLyoqXG4gKiBBbiBhYnN0cmFjdCBHb2FwQWN0aW9uIGZvciBhbiBOUEMuIEFsbCBOUEMgYWN0aW9ucyBjb25zaXN0IG9mIGRvaW5nIHRocmVlIHRoaW5nczpcbiAqIFxuICogIDEuIFNlbGVjdGluZyBzb21lIHRhcmdldC9sb2NhdGlvblxuICogIDIuIEdvaW5nIHRvIG9yIG1vdmluZyB3aXRoaW4gcmFuZ2Ugb2YgdGhlIHNlbGVjdGVkIHRhcmdldFxuICogIDMuIERvaW5nIHNvbWV0aGluZyBhdCB0aGUgdGFyZ2V0IGxvY2F0aW9uXG4gKiBcbiAqIFRoZSBhYnN0cmFjdCBOUEMgYWN0aW9uIHRha2VzIGNhcmUgb2YgdGhlIGZpcnN0IHR3byBwYXJ0cyAoc2VsZWN0aW5nIHRoZSB0YXJnZXQgYW5kIG1vdmluZyB0byB0aGUgdGFyZ2V0IGxvY2F0aW9uKS4gQWxsXG4gKiBjb25jcmV0ZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIE5QQ0FjdGlvbiB3aWxsIGhhdmUgdG8gaW1wbGVtZW50IHRoZSBhYnN0cmFjdCBtZXRob2QgcGVyZm9ybUFjdGlvbigpIHdoaWNoXG4gKiBnZXRzIGNhbGxlZCB3aGVuIHRoZSBOUEMgcmVhY2hlcyB0aGUgdGFyZ2V0IGxvY2F0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBOUENBY3Rpb24gZXh0ZW5kcyBHb2FwQWN0aW9uIHtcblxuICAgIHByb3RlY3RlZCBwYXJlbnQ6IE5QQ0JlaGF2aW9yO1xuICAgIHByb3RlY3RlZCBhY3RvcjogTlBDQWN0b3I7XG5cbiAgICAvLyBUaGUgdGFyZ2V0aW5nIHN0cmF0ZWd5IHVzZWQgZm9yIHRoaXMgR290b0FjdGlvbiAtIGRldGVybWluZXMgaG93IHRoZSB0YXJnZXQgaXMgc2VsZWN0ZWQgYmFzaWNhbGx5XG4gICAgcHJvdGVjdGVkIF90YXJnZXRGaW5kZXI6IEZpbmRlcjxUYXJnZXRhYmxlRW50aXR5PjtcbiAgICAvLyBUaGUgdGFyZ2V0cyBvciBUYXJnZXRhYmxlIGVudGl0aWVzIFxuICAgIHByb3RlY3RlZCBfdGFyZ2V0czogVGFyZ2V0YWJsZUVudGl0eVtdO1xuICAgIC8vIFRoZSB0YXJnZXQgd2UgYXJlIGdvaW5nIHRvIHNldCB0aGUgYWN0b3IgdG8gdGFyZ2V0XG4gICAgcHJvdGVjdGVkIF90YXJnZXQ6IFRhcmdldGFibGVFbnRpdHkgfCBudWxsO1xuICAgIC8vIFRoZSBwYXRoIGZyb20gdGhlIE5QQyB0byB0aGUgdGFyZ2V0XG4gICAgcHJvdGVjdGVkIF9wYXRoOiBOYXZpZ2F0aW9uUGF0aCB8IG51bGw7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IocGFyZW50OiBOUENCZWhhdmlvciwgYWN0b3I6IE5QQ0FjdG9yKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgYWN0b3IpO1xuICAgICAgICB0aGlzLnRhcmdldEZpbmRlciA9IG5ldyBCYXNpY0ZpbmRlcigpO1xuICAgICAgICB0aGlzLnRhcmdldHMgPSBbXTtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLnBhdGggPSBudWxsO1xuICAgIH1cblxuICAgIHB1YmxpYyBvbkVudGVyKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcbiAgICAgICAgLy8gU2VsZWN0IHRoZSB0YXJnZXQgbG9jYXRpb24gd2hlcmUgdGhlIE5QQyBzaG91bGQgcGVyZm9ybSB0aGUgYWN0aW9uXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGhpcy50YXJnZXRGaW5kZXIuZmluZCh0aGlzLnRhcmdldHMpO1xuXG4gICAgICAgIC8vIElmIHdlIGZvdW5kIGEgdGFyZ2V0LCBzZXQgdGhlIE5QQ3MgdGFyZ2V0IHRvIHRoZSB0YXJnZXQgYW5kIGZpbmQgYSBwYXRoIHRvIHRoZSB0YXJnZXRcbiAgICAgICAgaWYgKHRoaXMudGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBTZXQgdGhlIGFjdG9ycyBjdXJyZW50IHRhcmdldCB0byBiZSB0aGUgdGFyZ2V0IGZvciB0aGlzIGFjdGlvblxuICAgICAgICAgICAgdGhpcy5hY3Rvci5zZXRUYXJnZXQodGhpcy50YXJnZXQpO1xuICAgICAgICAgICAgLy8gQ29uc3RydWN0IGEgcGF0aCBmcm9tIHRoZSBhY3RvciB0byB0aGUgdGFyZ2V0XG4gICAgICAgICAgICB0aGlzLnBhdGggPSB0aGlzLmFjdG9yLmdldFBhdGgodGhpcy5hY3Rvci5wb3NpdGlvbiwgdGhpcy50YXJnZXQucG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICAvLyBUT0RPIGdldCB0aGUgTlBDcyB0byBtb3ZlIG9uIHRoZWlyIHBhdGhzXG4gICAgICAgIGlmKHRoaXMucGF0aCAhPSBudWxsKSAgdGhpcy5hY3Rvci5tb3ZlT25QYXRoKDEsIHRoaXMucGF0aCk7XG4gICAgfVxuXG4gICAgcHVibGljIGFic3RyYWN0IHBlcmZvcm1BY3Rpb24odGFyZ2V0OiBUYXJnZXRhYmxlRW50aXR5KTogdm9pZDtcblxuICAgIHB1YmxpYyBvbkV4aXQoKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gICAgICAgIC8vIENsZWFyIHRoZSBhY3RvcidzIGN1cnJlbnQgdGFyZ2V0XG4gICAgICAgIHRoaXMuYWN0b3IuY2xlYXJUYXJnZXQoKTtcbiAgICAgICAgLy8gQ2xlYXIgdGhlIHJlZmVyZW5jZSB0byB0aGUgdGFyZ2V0IGFuZCB0aGUgcGF0aCBpbiB0aGUgYWN0aW9uXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYXRoID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIHB1YmxpYyBoYW5kbGVJbnB1dChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5oYW5kbGVkIGV2ZW50IGNhdWdodCBpbiBOUENBY3Rpb24hIEV2ZW50IHR5cGU6ICR7ZXZlbnQudHlwZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgdGFyZ2V0RmluZGVyKCk6IEZpbmRlcjxUYXJnZXRhYmxlRW50aXR5PiB7IHJldHVybiB0aGlzLl90YXJnZXRGaW5kZXI7IH1cbiAgICBwdWJsaWMgc2V0IHRhcmdldEZpbmRlcihmaW5kZXI6IEZpbmRlcjxUYXJnZXRhYmxlRW50aXR5PikgeyB0aGlzLl90YXJnZXRGaW5kZXIgPSBmaW5kZXI7IH1cblxuICAgIHB1YmxpYyBnZXQgdGFyZ2V0cygpOiBBcnJheTxUYXJnZXRhYmxlRW50aXR5PiB7IHJldHVybiB0aGlzLl90YXJnZXRzOyB9XG4gICAgcHVibGljIHNldCB0YXJnZXRzKHRhcmdldHM6IEFycmF5PFRhcmdldGFibGVFbnRpdHk+KSB7IHRoaXMuX3RhcmdldHMgPSB0YXJnZXRzOyB9XG5cbiAgICBwdWJsaWMgZ2V0IHRhcmdldCgpOiBUYXJnZXRhYmxlRW50aXR5IHwgbnVsbCB7IHJldHVybiB0aGlzLl90YXJnZXQ7IH1cbiAgICBwcm90ZWN0ZWQgc2V0IHRhcmdldCh0YXJnZXQ6IFRhcmdldGFibGVFbnRpdHkgfCBudWxsKSB7IHRoaXMuX3RhcmdldCA9IHRhcmdldDsgfVxuXG4gICAgcHJvdGVjdGVkIHNldCBwYXRoKHBhdGg6IE5hdmlnYXRpb25QYXRoIHwgbnVsbCkgeyB0aGlzLl9wYXRoID0gcGF0aDsgfVxuICAgIHByb3RlY3RlZCBnZXQgcGF0aCgpOiBOYXZpZ2F0aW9uUGF0aCB8IG51bGwgeyByZXR1cm4gdGhpcy5fcGF0aDsgfVxufVxuIiwiaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFwiO1xuaW1wb3J0IE5QQ0FjdG9yIGZyb20gXCIuLi8uLi8uLi9BY3RvcnMvTlBDQWN0b3JcIjtcbmltcG9ydCBOUENCZWhhdmlvciBmcm9tIFwiLi4vTlBDQmVoYXZpb3JcIjtcbmltcG9ydCBOUENBY3Rpb24gZnJvbSBcIi4vTlBDQWN0aW9uXCI7XG5pbXBvcnQgSXRlbSBmcm9tIFwiLi4vLi4vLi4vR2FtZVN5c3RlbXMvSXRlbVN5c3RlbS9JdGVtXCI7XG5pbXBvcnQgRmluZGVyIGZyb20gXCIuLi8uLi8uLi9HYW1lU3lzdGVtcy9TZWFyY2hpbmcvRmluZGVyXCI7XG5pbXBvcnQgeyBUYXJnZXRhYmxlRW50aXR5IH0gZnJvbSBcIi4uLy4uLy4uL0dhbWVTeXN0ZW1zL1RhcmdldGluZy9UYXJnZXRhYmxlRW50aXR5XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBpY2t1cFRhcmdldGVkSXRlbSBleHRlbmRzIE5QQ0FjdGlvbiB7XG5cbiAgICAvLyBUaGUgdGFyZ2V0aW5nIHN0cmF0ZWd5IHVzZWQgZm9yIHRoaXMgR290b0FjdGlvbiAtIGRldGVybWluZXMgaG93IHRoZSB0YXJnZXQgaXMgc2VsZWN0ZWQgYmFzaWNhbGx5XG4gICAgcHJvdGVjdGVkIG92ZXJyaWRlIF90YXJnZXRGaW5kZXI6IEZpbmRlcjxJdGVtPjtcbiAgICAvLyBUaGUgdGFyZ2V0cyBvciBUYXJnZXRhYmxlIGVudGl0aWVzIFxuICAgIHByb3RlY3RlZCBvdmVycmlkZSBfdGFyZ2V0czogSXRlbVtdO1xuICAgIC8vIFRoZSB0YXJnZXQgd2UgYXJlIGdvaW5nIHRvIHNldCB0aGUgYWN0b3IgdG8gdGFyZ2V0XG4gICAgcHJvdGVjdGVkIF90YXJnZXQ6IEl0ZW0gfCBudWxsO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHBhcmVudDogTlBDQmVoYXZpb3IsIGFjdG9yOiBOUENBY3Rvcikge1xuICAgICAgICBzdXBlcihwYXJlbnQsIGFjdG9yKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcGVyZm9ybUFjdGlvbih0YXJnZXQ6IEl0ZW0pOiB2b2lkIHtcbiAgICAgICAgaWYgKHRhcmdldC5pbnZlbnRvcnkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0b3IuaW52ZW50b3J5LmFkZCh0YXJnZXQpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maW5pc2hlZCgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBoYW5kbGVJbnB1dChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIHN3aXRjaChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgc3VwZXIuaGFuZGxlSW5wdXQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGdldCB0YXJnZXRGaW5kZXIoKTogRmluZGVyPEl0ZW0+IHsgcmV0dXJuIHRoaXMuX3RhcmdldEZpbmRlcjsgfVxuICAgIHB1YmxpYyBzZXQgdGFyZ2V0RmluZGVyKGZpbmRlcjogRmluZGVyPEl0ZW0+KSB7IHRoaXMuX3RhcmdldEZpbmRlciA9IGZpbmRlcjsgfVxuXG4gICAgcHVibGljIGdldCB0YXJnZXRzKCk6IEFycmF5PEl0ZW0+IHsgcmV0dXJuIHRoaXMuX3RhcmdldHM7IH1cbiAgICBwdWJsaWMgc2V0IHRhcmdldHModGFyZ2V0czogQXJyYXk8SXRlbT4pIHsgdGhpcy5fdGFyZ2V0cyA9IHRhcmdldHM7IH1cblxuICAgIHB1YmxpYyBnZXQgdGFyZ2V0KCk6IEl0ZW0gfCBudWxsIHsgcmV0dXJuIHRoaXMuX3RhcmdldDsgfVxuICAgIHByb3RlY3RlZCBzZXQgdGFyZ2V0KHRhcmdldDogSXRlbSB8IG51bGwpIHsgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0OyB9XG5cbn0iLCJpbXBvcnQgeyBHb2FwQWN0aW9uU3RhdHVzIH0gZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9Hb2FwL0dvYXBBY3Rpb25cIjtcbmltcG9ydCBBQUJCIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvU2hhcGVzL0FBQkJcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFwiO1xuaW1wb3J0IE9ydGhvZ29uYWxUaWxlbWFwIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9UaWxlbWFwcy9PcnRob2dvbmFsVGlsZW1hcFwiO1xuaW1wb3J0IExhc2VyR3VuIGZyb20gXCIuLi8uLi8uLi9HYW1lU3lzdGVtcy9JdGVtU3lzdGVtL0l0ZW1zL0xhc2VyR3VuXCI7XG5pbXBvcnQgeyBUYXJnZXRhYmxlRW50aXR5IH0gZnJvbSBcIi4uLy4uLy4uL0dhbWVTeXN0ZW1zL1RhcmdldGluZy9UYXJnZXRhYmxlRW50aXR5XCI7XG5pbXBvcnQgTlBDQWN0b3IgZnJvbSBcIi4uLy4uLy4uL0FjdG9ycy9OUENBY3RvclwiO1xuaW1wb3J0IE5QQ0JlaGF2aW9yIGZyb20gXCIuLi9OUENCZWhhdmlvclwiO1xuaW1wb3J0IE5QQ0FjdGlvbiBmcm9tIFwiLi9OUENBY3Rpb25cIjtcbmltcG9ydCB7IEl0ZW1FdmVudCB9IGZyb20gXCIuLi8uLi8uLi9FdmVudHNcIjtcbmltcG9ydCBUaW1lciBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvVGltaW5nL1RpbWVyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNob290TGFzZXJHdW4gZXh0ZW5kcyBOUENBY3Rpb24ge1xuXG4gICAgcHJvdGVjdGVkIGxhc2VyZ3VuOiBMYXNlckd1biB8IG51bGw7XG4gICAgcHJvdGVjdGVkIHRpbWVyOiBUaW1lcjtcbiAgICBcbiAgICBwdWJsaWMgY29uc3RydWN0b3IocGFyZW50OiBOUENCZWhhdmlvciwgYWN0b3I6IE5QQ0FjdG9yKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgYWN0b3IpO1xuICAgICAgICB0aGlzLmxhc2VyZ3VuID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy50aW1lciA9IG5ldyBUaW1lcigyMDAwKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcGVyZm9ybUFjdGlvbih0YXJnZXQ6IFRhcmdldGFibGVFbnRpdHkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy50aW1lci5pc1N0b3BwZWQoKSA/IGNvbnNvbGUubG9nKFwiV2VhcG9uIGNvb2xpbmcgZG93biFcIikgOiBjb25zb2xlLmxvZyhcIldlYXBvbiByZWFkeSFcIik7XG4gICAgICAgIC8vIElmIHRoZSBsYXNlcmd1biBpcyBub3QgbnVsbCBhbmQgdGhlIGxhc2VyZ3VuIGlzIHN0aWxsIGluIHRoZSBhY3RvcnMgaW52ZW50b3J5OyBzaG9vdCB0aGUgbGFzZXJndW5cbiAgICAgICAgaWYgKHRoaXMudGltZXIuaXNTdG9wcGVkKCkgJiYgdGhpcy5sYXNlcmd1biAhPT0gbnVsbCAmJiB0aGlzLmxhc2VyZ3VuLmludmVudG9yeSAhPT0gbnVsbCAmJiB0aGlzLmxhc2VyZ3VuLmludmVudG9yeS5pZCA9PT0gdGhpcy5hY3Rvci5pbnZlbnRvcnkuaWQpIHtcbiAgICAgICAgICAgIC8vIFNldCB0aGUgc3RhcnQsIGRpcmVjdGlvbiwgYW5kIGVuZCBwb3NpdGlvbiB0byBzaG9vdCB0aGUgbGFzZXIgZ3VuXG4gICAgICAgICAgICB0aGlzLmxhc2VyZ3VuLmxhc2VyU3RhcnQuY29weSh0aGlzLmFjdG9yLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIHRoaXMubGFzZXJndW4uZGlyZWN0aW9uLmNvcHkodGhpcy5hY3Rvci5wb3NpdGlvbi5kaXJUbyh0YXJnZXQucG9zaXRpb24pKTtcbiAgICAgICAgICAgIHRoaXMubGFzZXJndW4ubGFzZXJFbmQuY29weSh0aGlzLmdldExhc2VyRW5kKHRoaXMuYWN0b3IuZ2V0U2NlbmUoKS5nZXRXYWxscygpLCB0aGlzLmxhc2VyZ3VuLmxhc2VyU3RhcnQsIHRoaXMubGFzZXJndW4uZGlyZWN0aW9uKSk7XG5cbiAgICAgICAgICAgIC8vIFBsYXkgdGhlIHNob290aW5nIGFuaW1hdGlvbiBmb3IgdGhlIGxhc2VyIGd1blxuICAgICAgICAgICAgdGhpcy5sYXNlcmd1bi5wbGF5U2hvb3RBbmltYXRpb24oKTtcblxuICAgICAgICAgICAgLy8gU2VuZCBhIGxhc2VyIGZpcmVkIGV2ZW50XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KEl0ZW1FdmVudC5MQVNFUkdVTl9GSVJFRCwge1xuICAgICAgICAgICAgICAgIGFjdG9ySWQ6IHRoaXMuYWN0b3IuaWQsXG4gICAgICAgICAgICAgICAgdG86IHRoaXMubGFzZXJndW4ubGFzZXJTdGFydC5jbG9uZSgpLCBcbiAgICAgICAgICAgICAgICBmcm9tOiB0aGlzLmxhc2VyZ3VuLmxhc2VyRW5kLmNsb25lKCkuc3ViKHRoaXMubGFzZXJndW4ubGFzZXJTdGFydClcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLnRpbWVyLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluaXNoIHRoZSBhY3Rpb25cbiAgICAgICAgdGhpcy5maW5pc2hlZCgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBvbkVudGVyKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcbiAgICAgICAgc3VwZXIub25FbnRlcihvcHRpb25zKTtcbiAgICAgICAgLy8gRmluZCBhIGxhc2VyZ3VuIGluIHRoZSBhY3RvcnMgaW52ZW50b3J5XG4gICAgICAgIGxldCBsYXNlcmd1biA9IHRoaXMuYWN0b3IuaW52ZW50b3J5LmZpbmQoaXRlbSA9PiBpdGVtLmNvbnN0cnVjdG9yID09PSBMYXNlckd1bik7XG4gICAgICAgIGlmIChsYXNlcmd1biAhPT0gbnVsbCAmJiBsYXNlcmd1bi5jb25zdHJ1Y3RvciA9PT0gTGFzZXJHdW4pIHtcbiAgICAgICAgICAgIHRoaXMubGFzZXJndW4gPSBsYXNlcmd1bjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBoYW5kbGVJbnB1dChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIHN3aXRjaChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgc3VwZXIuaGFuZGxlSW5wdXQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBzdXBlci51cGRhdGUoZGVsdGFUKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb25FeGl0KCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICAgICAgICAvLyBDbGVhciB0aGUgcmVmZXJlbmNlIHRvIHRoZSBsYXNlcmd1blxuICAgICAgICB0aGlzLmxhc2VyZ3VuID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHN1cGVyLm9uRXhpdCgpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXRMYXNlckVuZCh3YWxsczogT3J0aG9nb25hbFRpbGVtYXAsIHN0YXJ0OiBWZWMyLCBkaXI6IFZlYzIpOiBWZWMyIHtcbiAgICAgICAgbGV0IGVuZCA9IHN0YXJ0LmNsb25lKCkuYWRkKGRpci5zY2FsZWQoOTAwKSk7XG4gICAgICAgIGxldCBkZWx0YSA9IGVuZC5jbG9uZSgpLnN1YihzdGFydCk7XG5cbiAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSB0aWxlbWFwIHJlZ2lvbiB1bnRpbCB3ZSBmaW5kIGEgY29sbGlzaW9uXG4gICAgICAgIGxldCBtaW5YID0gTWF0aC5taW4oc3RhcnQueCwgZW5kLngpO1xuICAgICAgICBsZXQgbWF4WCA9IE1hdGgubWF4KHN0YXJ0LngsIGVuZC54KTtcbiAgICAgICAgbGV0IG1pblkgPSBNYXRoLm1pbihzdGFydC55LCBlbmQueSk7XG4gICAgICAgIGxldCBtYXhZID0gTWF0aC5tYXgoc3RhcnQueSwgZW5kLnkpO1xuXG4gICAgICAgIGxldCBtaW5JbmRleCA9IHdhbGxzLmdldFRpbGVtYXBQb3NpdGlvbihtaW5YLCBtaW5ZKTtcblx0XHRsZXQgbWF4SW5kZXggPSB3YWxscy5nZXRUaWxlbWFwUG9zaXRpb24obWF4WCwgbWF4WSk7XG5cbiAgICAgICAgbGV0IHRpbGVTaXplID0gd2FsbHMuZ2V0U2NhbGVkVGlsZVNpemUoKTtcblxuICAgICAgICBmb3IobGV0IGNvbCA9IG1pbkluZGV4Lng7IGNvbCA8PSBtYXhJbmRleC54OyBjb2wrKyl7XG4gICAgICAgICAgICBmb3IobGV0IHJvdyA9IG1pbkluZGV4Lnk7IHJvdyA8PSBtYXhJbmRleC55OyByb3crKyl7XG4gICAgICAgICAgICAgICAgaWYod2FsbHMuaXNUaWxlQ29sbGlkYWJsZShjb2wsIHJvdykpe1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHBvc2l0aW9uIG9mIHRoaXMgdGlsZVxuICAgICAgICAgICAgICAgICAgICBsZXQgdGlsZVBvcyA9IG5ldyBWZWMyKGNvbCAqIHRpbGVTaXplLnggKyB0aWxlU2l6ZS54LzIsIHJvdyAqIHRpbGVTaXplLnkgKyB0aWxlU2l6ZS55LzIpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIGNvbGxpZGVyIGZvciB0aGlzIHRpbGVcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbGxpZGVyID0gbmV3IEFBQkIodGlsZVBvcywgdGlsZVNpemUuc2NhbGVkKDEvMikpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBoaXQgPSBjb2xsaWRlci5pbnRlcnNlY3RTZWdtZW50KHN0YXJ0LCBkZWx0YSwgVmVjMi5aRVJPKTtcblxuICAgICAgICAgICAgICAgICAgICBpZihoaXQgIT09IG51bGwgJiYgc3RhcnQuZGlzdGFuY2VTcVRvKGhpdC5wb3MpIDwgc3RhcnQuZGlzdGFuY2VTcVRvKGVuZCkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gaGl0LnBvcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5kO1xuICAgIH1cblxufSIsImltcG9ydCBTdGF0ZU1hY2hpbmVHb2FwQUkgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL0FJL0dvYXAvU3RhdGVNYWNoaW5lR29hcEFJXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnRcIjtcbmltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvTm9kZXMvR2FtZU5vZGVcIjtcbmltcG9ydCBMaW5lIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljcy9MaW5lXCI7XG5pbXBvcnQgVGltZXIgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL1RpbWluZy9UaW1lclwiO1xuaW1wb3J0IE5QQ0FjdG9yIGZyb20gXCIuLi8uLi9BY3RvcnMvTlBDQWN0b3JcIjtcbmltcG9ydCB7IEl0ZW1FdmVudCB9IGZyb20gXCIuLi8uLi9FdmVudHNcIjtcbmltcG9ydCBOUENBY3Rpb24gZnJvbSBcIi4vTlBDQWN0aW9ucy9OUENBY3Rpb25cIjtcblxuXG4vKipcbiAqIEFuIGFic3RyYWN0IGltcGxlbWVudGF0aW9uIG9mIGJlaGF2aW9yIGZvciBhbiBOUEMuIEVhY2ggY29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gKiBOUENCZWhhdmlvciBjbGFzcyBzaG91bGQgZGVmaW5lIHNvbWUgbmV3IGJlaGF2aW9yIGZvciBhbiBOUENBY3Rvci4gXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIE5QQ0JlaGF2aW9yIGV4dGVuZHMgU3RhdGVNYWNoaW5lR29hcEFJPE5QQ0FjdGlvbj4gIHtcblxuICAgIHByb3RlY3RlZCBvdmVycmlkZSBvd25lcjogTlBDQWN0b3I7XG5cbiAgICBwdWJsaWMgaW5pdGlhbGl6ZUFJKG93bmVyOiBOUENBY3Rvciwgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xuICAgICAgICB0aGlzLm93bmVyID0gb3duZXI7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKEl0ZW1FdmVudC5MQVNFUkdVTl9GSVJFRCk7XG4gICAgfVxuXG4gICAgcHVibGljIGFjdGl2YXRlKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHt9XG5cbiAgICBwdWJsaWMgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHN1cGVyLnVwZGF0ZShkZWx0YVQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgZ2FtZSBldmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBoYW5kbGVFdmVudChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIHN3aXRjaChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIEl0ZW1FdmVudC5MQVNFUkdVTl9GSVJFRDoge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ2F0Y2hpbmcgYW5kIGhhbmRsaW5nIGxhc2VyZ3VuIGZpcmVkIGV2ZW50ISEhXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlTGFzZXJndW5GaXJlZChldmVudC5kYXRhLmdldChcImFjdG9ySWRcIiksIGV2ZW50LmRhdGEuZ2V0KFwidG9cIiksIGV2ZW50LmRhdGEuZ2V0KFwiZnJvbVwiKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgc3VwZXIuaGFuZGxlRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGhhbmRsZUxhc2VyZ3VuRmlyZWQoYWN0b3JJZDogbnVtYmVyLCB0bzogVmVjMiwgZnJvbTogVmVjMik6IHZvaWQge1xuICAgICAgICBpZiAoYWN0b3JJZCAhPT0gdGhpcy5vd25lci5pZCkge1xuICAgICAgICAgICAgdGhpcy5vd25lci5oZWFsdGggLT0gdGhpcy5vd25lci5jb2xsaXNpb25TaGFwZS5nZXRCb3VuZGluZ1JlY3QoKS5pbnRlcnNlY3RTZWdtZW50KHRvLCBmcm9tKSA/IDEgOiAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxufSIsImltcG9ydCBOUENBY3RvciBmcm9tIFwiLi4vLi4vLi4vQWN0b3JzL05QQ0FjdG9yXCI7XG5pbXBvcnQgTlBDQmVoYXZpb3IgZnJvbSBcIi4uL05QQ0JlaGF2aW9yXCI7XG5pbXBvcnQgSWRsZSBmcm9tIFwiLi4vTlBDQWN0aW9ucy9Hb3RvQWN0aW9uXCI7XG5pbXBvcnQgU2hvb3RMYXNlckd1biBmcm9tIFwiLi4vTlBDQWN0aW9ucy9TaG9vdExhc2VyR3VuXCI7XG5pbXBvcnQgQmFzaWNGaW5kZXIgZnJvbSBcIi4uLy4uLy4uL0dhbWVTeXN0ZW1zL1NlYXJjaGluZy9CYXNpY0ZpbmRlclwiO1xuaW1wb3J0IHsgQmF0dGxlckFjdGl2ZUZpbHRlciwgRW5lbXlGaWx0ZXIsIEl0ZW1GaWx0ZXIsIFJhbmdlRmlsdGVyLCBWaXNpYmxlSXRlbUZpbHRlciB9IGZyb20gXCIuLi8uLi8uLi9HYW1lU3lzdGVtcy9TZWFyY2hpbmcvSFc0RmlsdGVyc1wiO1xuaW1wb3J0IEl0ZW0gZnJvbSBcIi4uLy4uLy4uL0dhbWVTeXN0ZW1zL0l0ZW1TeXN0ZW0vSXRlbVwiO1xuaW1wb3J0IFBpY2t1cEl0ZW0gZnJvbSBcIi4uL05QQ0FjdGlvbnMvUGlja3VwSXRlbVwiO1xuaW1wb3J0IHsgQ2xvc2VzdFBvc2l0aW9uZWQgfSBmcm9tIFwiLi4vLi4vLi4vR2FtZVN5c3RlbXMvU2VhcmNoaW5nL0hXNFJlZHVjZXJzXCI7XG5pbXBvcnQgeyBUYXJnZXRhYmxlRW50aXR5IH0gZnJvbSBcIi4uLy4uLy4uL0dhbWVTeXN0ZW1zL1RhcmdldGluZy9UYXJnZXRhYmxlRW50aXR5XCI7XG5pbXBvcnQgTGFzZXJHdW4gZnJvbSBcIi4uLy4uLy4uL0dhbWVTeXN0ZW1zL0l0ZW1TeXN0ZW0vSXRlbXMvTGFzZXJHdW5cIjtcbmltcG9ydCB7IFRhcmdldEV4aXN0cyB9IGZyb20gXCIuLi9OUENTdGF0dXNlcy9UYXJnZXRFeGlzdHNcIjtcbmltcG9ydCB7IEhhc0l0ZW0gfSBmcm9tIFwiLi4vTlBDU3RhdHVzZXMvSGFzSXRlbVwiO1xuaW1wb3J0IEZhbHNlU3RhdHVzIGZyb20gXCIuLi9OUENTdGF0dXNlcy9GYWxzZVN0YXR1c1wiO1xuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFwiO1xuaW1wb3J0IEdvYXBBY3Rpb24gZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL0FJL0dvYXAvR29hcEFjdGlvblwiO1xuaW1wb3J0IEdvYXBTdGF0ZSBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvQUkvR29hcC9Hb2FwU3RhdGVcIjtcbmltcG9ydCBCYXR0bGVyIGZyb20gXCIuLi8uLi8uLi9HYW1lU3lzdGVtcy9CYXR0bGVTeXN0ZW0vQmF0dGxlclwiO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEd1YXJkQmVoYXZpb3IgZXh0ZW5kcyBOUENCZWhhdmlvciB7XG5cbiAgICAvKiogVGhlIHRhcmdldCB0aGUgZ3VhcmQgc2hvdWxkIGd1YXJkICovXG4gICAgcHJvdGVjdGVkIHRhcmdldDogVGFyZ2V0YWJsZUVudGl0eTtcbiAgICAvKiogVGhlIHJhbmdlIHRoZSBndWFyZCBzaG91bGQgYmUgZnJvbSB0aGUgdGFyZ2V0IHRoZXkncmUgZ3VhcmRpbmcgdG8gYmUgY29uc2lkZXJlZCBndWFyZGluZyB0aGUgdGFyZ2V0ICovXG4gICAgcHJvdGVjdGVkIHJhbmdlOiBudW1iZXI7XG5cbiAgICAvKiogSW5pdGlhbGl6ZSB0aGUgTlBDIEFJICovXG4gICAgcHVibGljIGluaXRpYWxpemVBSShvd25lcjogTlBDQWN0b3IsIG9wdGlvbnM6IEd1YXJkT3B0aW9ucyk6IHZvaWQge1xuICAgICAgICBzdXBlci5pbml0aWFsaXplQUkob3duZXIsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHRhcmdldGFibGUgZW50aXR5IHRoZSBndWFyZCBzaG91bGQgdHJ5IHRvIHByb3RlY3QgYW5kIHRoZSByYW5nZSB0byB0aGUgdGFyZ2V0XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gb3B0aW9ucy50YXJnZXRcbiAgICAgICAgdGhpcy5yYW5nZSA9IG9wdGlvbnMucmFuZ2U7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBndWFyZCBzdGF0dXNlc1xuICAgICAgICB0aGlzLmluaXRpYWxpemVTdGF0dXNlcygpO1xuICAgICAgICAvLyBJbml0aWFsaXplIGd1YXJkIGFjdGlvbnNcbiAgICAgICAgdGhpcy5pbml0aWFsaXplQWN0aW9ucygpO1xuICAgICAgICAvLyBTZXQgdGhlIGd1YXJkcyBnb2FsXG4gICAgICAgIHRoaXMuZ29hbCA9IEd1YXJkU3RhdHVzZXMuR09BTDtcblxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBndWFyZCBiZWhhdmlvclxuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgaGFuZGxlRXZlbnQoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQge1xuICAgICAgICBzd2l0Y2goZXZlbnQudHlwZSkge1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIHN1cGVyLmhhbmRsZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgc3VwZXIudXBkYXRlKGRlbHRhVCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGluaXRpYWxpemVTdGF0dXNlcygpOiB2b2lkIHtcblxuICAgICAgICBsZXQgc2NlbmUgPSB0aGlzLm93bmVyLmdldFNjZW5lKCk7XG5cbiAgICAgICAgLy8gQSBzdGF0dXMgY2hlY2tpbmcgaWYgdGhlcmUgYXJlIGFueSBlbmVtaWVzIGF0IHRhcmdldCB0aGUgZ3VhcmQgaXMgZ3VhcmRpbmdcbiAgICAgICAgbGV0IGVuZW15QmF0dGxlckZpbmRlciA9IG5ldyBCYXNpY0ZpbmRlcjxCYXR0bGVyPihudWxsLCBCYXR0bGVyQWN0aXZlRmlsdGVyKCksIEVuZW15RmlsdGVyKHRoaXMub3duZXIpLCBSYW5nZUZpbHRlcih0aGlzLnRhcmdldCwgMCwgdGhpcy5yYW5nZSp0aGlzLnJhbmdlKSlcbiAgICAgICAgbGV0IGVuZW15QXRHdWFyZFBvc2l0aW9uID0gbmV3IFRhcmdldEV4aXN0cyhzY2VuZS5nZXRCYXR0bGVycygpLCBlbmVteUJhdHRsZXJGaW5kZXIpXG4gICAgICAgIHRoaXMuYWRkU3RhdHVzKEd1YXJkU3RhdHVzZXMuRU5FTVlfSU5fR1VBUkRfUE9TSVRJT04sIGVuZW15QXRHdWFyZFBvc2l0aW9uKTtcblxuICAgICAgICAvLyBBZGQgYSBzdGF0dXMgdG8gY2hlY2sgaWYgYSBsYXNlcmd1biBleGlzdHMgaW4gdGhlIHNjZW5lIGFuZCBpdCdzIHZpc2libGVcbiAgICAgICAgdGhpcy5hZGRTdGF0dXMoR3VhcmRTdGF0dXNlcy5MQVNFUkdVTl9FWElTVFMsIG5ldyBUYXJnZXRFeGlzdHMoc2NlbmUuZ2V0TGFzZXJHdW5zKCksIG5ldyBCYXNpY0ZpbmRlcjxJdGVtPihudWxsLCBJdGVtRmlsdGVyKExhc2VyR3VuKSwgVmlzaWJsZUl0ZW1GaWx0ZXIoKSkpKTtcbiAgICAgICAgLy8gQWRkIGEgc3RhdHVzIHRvIGNoZWNrIGlmIHRoZSBndWFyZCBoYXMgYSBsYXNlcmd1blxuICAgICAgICB0aGlzLmFkZFN0YXR1cyhHdWFyZFN0YXR1c2VzLkhBU19XRUFQT04sIG5ldyBIYXNJdGVtKHRoaXMub3duZXIsIG5ldyBCYXNpY0ZpbmRlcihudWxsLCBJdGVtRmlsdGVyKExhc2VyR3VuKSkpKTtcblxuICAgICAgICAvLyBBZGQgdGhlIGdvYWwgc3RhdHVzIFxuICAgICAgICB0aGlzLmFkZFN0YXR1cyhHdWFyZFN0YXR1c2VzLkdPQUwsIG5ldyBGYWxzZVN0YXR1cygpKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgaW5pdGlhbGl6ZUFjdGlvbnMoKTogdm9pZCB7XG5cbiAgICAgICAgbGV0IHNjZW5lID0gdGhpcy5vd25lci5nZXRTY2VuZSgpO1xuXG4gICAgICAgIC8vIEFuIGFjdGlvbiBmb3Igc2hvb3RpbmcgYW4gZW5lbXkgaW4gdGhlIGd1YXJkcyBndWFyZCBhcmVhXG4gICAgICAgIGxldCBzaG9vdEVuZW15ID0gbmV3IFNob290TGFzZXJHdW4odGhpcywgdGhpcy5vd25lcik7XG4gICAgICAgIHNob290RW5lbXkudGFyZ2V0cyA9IHNjZW5lLmdldEJhdHRsZXJzKCk7XG4gICAgICAgIHNob290RW5lbXkudGFyZ2V0RmluZGVyID0gbmV3IEJhc2ljRmluZGVyPEJhdHRsZXI+KENsb3Nlc3RQb3NpdGlvbmVkKHRoaXMub3duZXIpLCBCYXR0bGVyQWN0aXZlRmlsdGVyKCksIEVuZW15RmlsdGVyKHRoaXMub3duZXIpLCBSYW5nZUZpbHRlcih0aGlzLnRhcmdldCwgMCwgdGhpcy5yYW5nZSp0aGlzLnJhbmdlKSk7XG4gICAgICAgIHNob290RW5lbXkuYWRkUHJlY29uZGl0aW9uKEd1YXJkU3RhdHVzZXMuSEFTX1dFQVBPTik7XG4gICAgICAgIHNob290RW5lbXkuYWRkUHJlY29uZGl0aW9uKEd1YXJkU3RhdHVzZXMuRU5FTVlfSU5fR1VBUkRfUE9TSVRJT04pO1xuICAgICAgICBzaG9vdEVuZW15LmFkZEVmZmVjdChHdWFyZFN0YXR1c2VzLkdPQUwpO1xuICAgICAgICBzaG9vdEVuZW15LmNvc3QgPSAxO1xuICAgICAgICB0aGlzLmFkZFN0YXRlKEd1YXJkQWN0aW9ucy5TSE9PVF9FTkVNWSwgc2hvb3RFbmVteSk7XG5cbiAgICAgICAgLy8gQW4gYWN0aW9uIGZvciBwaWNraW5nIHVwIGEgbGFzZXJndW5cbiAgICAgICAgbGV0IHBpY2t1cExhc2VyR3VuID0gbmV3IFBpY2t1cEl0ZW0odGhpcywgdGhpcy5vd25lcik7XG4gICAgICAgIHBpY2t1cExhc2VyR3VuLnRhcmdldHMgPSBzY2VuZS5nZXRMYXNlckd1bnMoKTtcbiAgICAgICAgcGlja3VwTGFzZXJHdW4udGFyZ2V0RmluZGVyID0gbmV3IEJhc2ljRmluZGVyPEl0ZW0+KENsb3Nlc3RQb3NpdGlvbmVkKHRoaXMub3duZXIpLCBWaXNpYmxlSXRlbUZpbHRlcigpLCBJdGVtRmlsdGVyKExhc2VyR3VuKSk7XG4gICAgICAgIHBpY2t1cExhc2VyR3VuLmFkZFByZWNvbmRpdGlvbihHdWFyZFN0YXR1c2VzLkxBU0VSR1VOX0VYSVNUUyk7XG4gICAgICAgIHBpY2t1cExhc2VyR3VuLmFkZEVmZmVjdChHdWFyZFN0YXR1c2VzLkhBU19XRUFQT04pO1xuICAgICAgICBwaWNrdXBMYXNlckd1bi5jb3N0ID0gNTtcbiAgICAgICAgdGhpcy5hZGRTdGF0ZShHdWFyZEFjdGlvbnMuUElDS1VQX0xBU0VSX0dVTiwgcGlja3VwTGFzZXJHdW4pO1xuXG4gICAgICAgIC8vIEFuIGFjdGlvbiBmb3IgZ3VhcmRpbmcgdGhlIGd1YXJkJ3MgZ3VhcmQgbG9jYXRpb25cbiAgICAgICAgbGV0IGd1YXJkID0gbmV3IElkbGUodGhpcywgdGhpcy5vd25lcik7XG4gICAgICAgIGd1YXJkLnRhcmdldHMgPSBbdGhpcy50YXJnZXRdO1xuICAgICAgICBndWFyZC50YXJnZXRGaW5kZXIgPSBuZXcgQmFzaWNGaW5kZXIoKTtcbiAgICAgICAgZ3VhcmQuYWRkUHJlY29uZGl0aW9uKEd1YXJkU3RhdHVzZXMuSEFTX1dFQVBPTik7XG4gICAgICAgIGd1YXJkLmFkZEVmZmVjdChHdWFyZFN0YXR1c2VzLkdPQUwpO1xuICAgICAgICBndWFyZC5jb3N0ID0gMTAwMDtcbiAgICAgICAgdGhpcy5hZGRTdGF0ZShHdWFyZEFjdGlvbnMuR1VBUkQsIGd1YXJkKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgYWRkU3RhdGUoc3RhdGVOYW1lOiBHdWFyZEFjdGlvbiwgc3RhdGU6IEdvYXBBY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgc3VwZXIuYWRkU3RhdGUoc3RhdGVOYW1lLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIGFkZFN0YXR1cyhzdGF0dXNOYW1lOiBHdWFyZFN0YXR1cywgc3RhdHVzOiBHb2FwU3RhdGUpOiB2b2lkIHtcbiAgICAgICAgc3VwZXIuYWRkU3RhdHVzKHN0YXR1c05hbWUsIHN0YXR1cyk7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEd1YXJkT3B0aW9ucyB7XG4gICAgdGFyZ2V0OiBUYXJnZXRhYmxlRW50aXR5XG4gICAgcmFuZ2U6IG51bWJlcjtcbn1cblxuZXhwb3J0IHR5cGUgR3VhcmRTdGF0dXMgPSB0eXBlb2YgR3VhcmRTdGF0dXNlc1trZXlvZiB0eXBlb2YgR3VhcmRTdGF0dXNlc107XG5leHBvcnQgY29uc3QgR3VhcmRTdGF0dXNlcyA9IHtcblxuICAgIEVORU1ZX0lOX0dVQVJEX1BPU0lUSU9OOiBcImVuZW15LWF0LWd1YXJkLXBvc2l0aW9uXCIsXG5cbiAgICBIQVNfV0VBUE9OOiBcImhhcy13ZWFwb25cIixcblxuICAgIExBU0VSR1VOX0VYSVNUUzogXCJsYXNlci1ndW4tZXhpc3RzXCIsXG5cbiAgICBHT0FMOiBcImdvYWxcIlxuXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgdHlwZSBHdWFyZEFjdGlvbiA9IHR5cGVvZiBHdWFyZEFjdGlvbnNba2V5b2YgdHlwZW9mIEd1YXJkQWN0aW9uc107XG5leHBvcnQgY29uc3QgR3VhcmRBY3Rpb25zID0ge1xuXG4gICAgUElDS1VQX0xBU0VSX0dVTjogXCJwaWNrdXAtbGFzZXJndW5cIixcblxuICAgIFNIT09UX0VORU1ZOiBcInNob290LWVuZW15XCIsXG5cbiAgICBHVUFSRDogXCJndWFyZFwiLFxuXG59IGFzIGNvbnN0O1xuXG4iLCJpbXBvcnQgTlBDQWN0b3IgZnJvbSBcIi4uLy4uLy4uL0FjdG9ycy9OUENBY3RvclwiO1xuaW1wb3J0IE5QQ0JlaGF2aW9yIGZyb20gXCIuLi9OUENCZWhhdmlvclwiO1xuaW1wb3J0IEdvYWxSZWFjaGVkIGZyb20gXCIuLi9OUENTdGF0dXNlcy9GYWxzZVN0YXR1c1wiO1xuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFwiO1xuaW1wb3J0IElkbGUgZnJvbSBcIi4uL05QQ0FjdGlvbnMvR290b0FjdGlvblwiO1xuaW1wb3J0IHsgVGFyZ2V0RXhpc3RzIH0gZnJvbSBcIi4uL05QQ1N0YXR1c2VzL1RhcmdldEV4aXN0c1wiO1xuaW1wb3J0IEJhc2ljRmluZGVyIGZyb20gXCIuLi8uLi8uLi9HYW1lU3lzdGVtcy9TZWFyY2hpbmcvQmFzaWNGaW5kZXJcIjtcbmltcG9ydCB7IENsb3Nlc3RQb3NpdGlvbmVkIH0gZnJvbSBcIi4uLy4uLy4uL0dhbWVTeXN0ZW1zL1NlYXJjaGluZy9IVzRSZWR1Y2Vyc1wiO1xuaW1wb3J0IHsgQmF0dGxlckFjdGl2ZUZpbHRlciwgQmF0dGxlckdyb3VwRmlsdGVyLCBCYXR0bGVySGVhbHRoRmlsdGVyLCBJdGVtRmlsdGVyLCBSYW5nZUZpbHRlciwgVmlzaWJsZUl0ZW1GaWx0ZXIgfSBmcm9tIFwiLi4vLi4vLi4vR2FtZVN5c3RlbXMvU2VhcmNoaW5nL0hXNEZpbHRlcnNcIjtcbmltcG9ydCBQaWNrdXBJdGVtIGZyb20gXCIuLi9OUENBY3Rpb25zL1BpY2t1cEl0ZW1cIjtcbmltcG9ydCBVc2VIZWFsdGhwYWNrIGZyb20gXCIuLi9OUENBY3Rpb25zL1VzZUhlYWx0aHBhY2tcIjtcbmltcG9ydCBIZWFsdGhwYWNrIGZyb20gXCIuLi8uLi8uLi9HYW1lU3lzdGVtcy9JdGVtU3lzdGVtL0l0ZW1zL0hlYWx0aHBhY2tcIjtcbmltcG9ydCBJdGVtIGZyb20gXCIuLi8uLi8uLi9HYW1lU3lzdGVtcy9JdGVtU3lzdGVtL0l0ZW1cIjtcbmltcG9ydCB7IEhhc0l0ZW0gfSBmcm9tIFwiLi4vTlBDU3RhdHVzZXMvSGFzSXRlbVwiO1xuaW1wb3J0IEZhbHNlU3RhdHVzIGZyb20gXCIuLi9OUENTdGF0dXNlcy9GYWxzZVN0YXR1c1wiO1xuaW1wb3J0IEJhdHRsZXIgZnJvbSBcIi4uLy4uLy4uL0dhbWVTeXN0ZW1zL0JhdHRsZVN5c3RlbS9CYXR0bGVyXCI7XG5cblxuLyoqXG4gKiBXaGVuIGFuIE5QQyBpcyBhY3RpbmcgYXMgYSBoZWFsZXIsIHRoZWlyIGdvYWwgaXMgdG8gdHJ5IGFuZCBoZWFsIGl0J3MgdGVhbW1hdGVzIGJ5IHJ1bm5pbmcgYXJvdW5kLCBwaWNraW5nIHVwIGhlYWx0aHBhY2tzLCBcbiAqIGJyaW5naW5nIHRvIHRoZSBoZWFsdGhwYWNrcyB0byB0aGVpciBhbGxpZXMgYW5kIGhlYWxpbmcgdGhlbS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGVhbGVyQmVoYXZpb3IgZXh0ZW5kcyBOUENCZWhhdmlvciAge1xuXG4gICAgLyoqIFRoZSBHYW1lTm9kZSB0aGF0IG93bnMgdGhpcyBOUENHb2FwQUkgKi9cbiAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgb3duZXI6IE5QQ0FjdG9yO1xuICAgIFxuICAgIC8qKiBJbml0aWFsaXplIHRoZSBOUEMgQUkgKi9cbiAgICBwdWJsaWMgaW5pdGlhbGl6ZUFJKG93bmVyOiBOUENBY3Rvciwgb3B0czogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xuICAgICAgICBzdXBlci5pbml0aWFsaXplQUkob3duZXIsIG9wdHMpO1xuXG4gICAgICAgIGxldCBzY2VuZSA9IG93bmVyLmdldFNjZW5lKCk7XG5cbiAgICAgICAgLyogIyMjIyMjIyMjIEFkZCBhbGwgaGVhbGVyIHN0YXR1c2VzICMjIyMjIyMjICovXG5cbiAgICAgICAgdGhpcy5hZGRTdGF0dXMoSGVhbGVyU3RhdHVzZXMuR09BTCwgbmV3IEZhbHNlU3RhdHVzKCkpO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIGEgaGVhbHRocGFjayBleGlzdHMgaW4gdGhlIHNjZW5lIGFuZCBpdCdzIHZpc2libGVcbiAgICAgICAgdGhpcy5hZGRTdGF0dXMoSGVhbGVyU3RhdHVzZXMuSFBBQ0tfRVhJU1RTLCBuZXcgVGFyZ2V0RXhpc3RzKHNjZW5lLmdldEhlYWx0aHBhY2tzKCksIG5ldyBCYXNpY0ZpbmRlcjxJdGVtPihudWxsLCBJdGVtRmlsdGVyKEhlYWx0aHBhY2spLCBWaXNpYmxlSXRlbUZpbHRlcigpKSkpO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIGEgaGVhbHRocGFjayBleGlzdHMgaW4gdGhlIGFjdG9ycyBpbnZlbnRvcnlcbiAgICAgICAgdGhpcy5hZGRTdGF0dXMoSGVhbGVyU3RhdHVzZXMuSEFTX0hQQUNLLCBuZXcgSGFzSXRlbShvd25lciwgbmV3IEJhc2ljRmluZGVyPEl0ZW0+KG51bGwsIEl0ZW1GaWx0ZXIoSGVhbHRocGFjaykpKSk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgYSBsb3doZWFsdGggYWxseSBleGlzdHMgaW4gdGhlIHNjZW5lXG4gICAgICAgIGxldCBsb3doZWFsdGhBbGx5ID0gbmV3IEJhc2ljRmluZGVyPEJhdHRsZXI+KG51bGwsIEJhdHRsZXJBY3RpdmVGaWx0ZXIoKSwgQmF0dGxlckdyb3VwRmlsdGVyKFtvd25lci5iYXR0bGVHcm91cF0pKTtcbiAgICAgICAgdGhpcy5hZGRTdGF0dXMoSGVhbGVyU3RhdHVzZXMuQUxMWV9FWElTVFMsIG5ldyBUYXJnZXRFeGlzdHMoc2NlbmUuZ2V0QmF0dGxlcnMoKSwgbG93aGVhbHRoQWxseSkpO1xuICAgICAgICBcbiAgICAgICAgLyogIyMjIyMjIyMjIEFkZCBhbGwgaGVhbGVyIGFjdGlvbnMgIyMjIyMjIyMgKi9cblxuICAgICAgICAvLyBUT0RPIGNvbmZpZ3VyZSB0aGUgcmVzdCBvZiB0aGUgaGVhbGVyIGFjdGlvbnNcblxuICAgICAgICAvLyBJZGxlIGFjdGlvblxuICAgICAgICBsZXQgaWRsZSA9IG5ldyBJZGxlKHRoaXMsIHRoaXMub3duZXIpO1xuICAgICAgICBpZGxlLmFkZEVmZmVjdChIZWFsZXJTdGF0dXNlcy5HT0FMKTtcbiAgICAgICAgaWRsZS5jb3N0ID0gMTAwO1xuICAgICAgICB0aGlzLmFkZFN0YXRlKEhlYWxlckFjdGlvbnMuSURMRSwgaWRsZSk7XG5cbiAgICAgICAgLyogIyMjIyMjIyMjIFNldCB0aGUgaGVhbGVycyBnb2FsICMjIyMjIyMjICovXG5cbiAgICAgICAgdGhpcy5nb2FsID0gSGVhbGVyU3RhdHVzZXMuR09BTDtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIGhhbmRsZUV2ZW50KGV2ZW50OiBHYW1lRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgc3dpdGNoKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBzdXBlci5oYW5kbGVFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHN1cGVyLnVwZGF0ZShkZWx0YVQpO1xuICAgIH1cblxufVxuXG4vLyBXb3JsZCBzdGF0ZXMgZm9yIHRoZSBoZWFsZXJcbmNvbnN0IEhlYWxlclN0YXR1c2VzID0ge1xuXG4gICAgLy8gV2hldGhlciBvciBub3QgYSBoZWFsdGhwYWNrIGV4aXN0cyBpbiB0aGUgd29ybGRcbiAgICBIUEFDS19FWElTVFM6IFwiaHBhY2stZXhpc3RzXCIsXG5cbiAgICAvLyBXaGV0aGVyIHRoZSBoZWFsZXIgaGFzIGEgaGVhbHRocGFjayBpbiB0aGVpciBpbnZlbnRvcnkgb3Igbm90XG4gICAgQUxMWV9FWElTVFM6IFwiYWxseS1leGlzdHNcIixcblxuICAgIC8vIFdoZXRoZXIgdGhlIGhlYWxlciBoYXMgYW55IGFsbGllcyBpbiB0aGUgZ2FtZSB3b3JsZCBvciBub3RcbiAgICBIQVNfSFBBQ0s6IFwiaGFzLWhwYWNrXCIsXG5cbiAgICAvLyBXaGV0aGVyIHRoZSBoZWFsZXIgaGFzIHJlYWNoZWQgaXQncyBnb2FsIG9yIG5vdFxuICAgIEdPQUw6IFwiZ29hbFwiXG5cbn0gYXMgY29uc3RcblxuLy8gSGVhbGVyIGFjdGlvbnNcbmNvbnN0IEhlYWxlckFjdGlvbnMgPSB7XG5cbiAgICBQSUNLVVBfSFBBQ0s6IFwicGlja3VwLWhwYWNrXCIsXG5cbiAgICBVU0VfSFBBQ0s6IFwidXNlLWhwYWNrXCIsXG5cbiAgICBJRExFOiBcImlkbGVcIixcblxufSBhcyBjb25zdDtcblxuIiwiaW1wb3J0IEdvYXBTdGF0ZSBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvQUkvR29hcC9Hb2FwU3RhdGVcIjtcbmltcG9ydCBBY3RvciBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL0ludGVyZmFjZXMvQWN0b3JcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmFsc2VTdGF0dXMgZXh0ZW5kcyBHb2FwU3RhdGUge1xuICAgIHB1YmxpYyBpc1NhdGlzZmllZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gXG4gICAgXG59IiwiaW1wb3J0IEdvYXBTdGF0ZSBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvQUkvR29hcC9Hb2FwU3RhdGVcIjtcbmltcG9ydCBJdGVtIGZyb20gXCIuLi8uLi8uLi9HYW1lU3lzdGVtcy9JdGVtU3lzdGVtL0l0ZW1cIjtcbmltcG9ydCBGaW5kZXIgZnJvbSBcIi4uLy4uLy4uL0dhbWVTeXN0ZW1zL1NlYXJjaGluZy9GaW5kZXJcIjtcblxuaW1wb3J0IE5QQ0FjdG9yIGZyb20gXCIuLi8uLi8uLi9BY3RvcnMvTlBDQWN0b3JcIjtcblxuZXhwb3J0IGNsYXNzIEhhc0l0ZW0gZXh0ZW5kcyBHb2FwU3RhdGUge1xuICAgIHByb3RlY3RlZCBhY3RvcjogTlBDQWN0b3I7XG4gICAgcHJvdGVjdGVkIGZpbmRlcjogRmluZGVyPEl0ZW0+O1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKGFjdG9yOiBOUENBY3RvciwgZmluZGVyOiBGaW5kZXI8SXRlbT4pIHtcbiAgICAgICAgc3VwZXIoKVxuICAgICAgICB0aGlzLmFjdG9yID0gYWN0b3I7XG4gICAgICAgIHRoaXMuZmluZGVyID0gZmluZGVyO1xuICAgIH1cblxuICAgIHB1YmxpYyBpc1NhdGlzZmllZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZGVyLmZpbmQoQXJyYXkuZnJvbSh0aGlzLmFjdG9yLmludmVudG9yeS5pdGVtcygpKSkgIT09IG51bGxcbiAgICB9XG4gICAgXG59IiwiaW1wb3J0IEdvYXBTdGF0ZSBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvQUkvR29hcC9Hb2FwU3RhdGVcIjtcbmltcG9ydCBGaW5kZXIgZnJvbSBcIi4uLy4uLy4uL0dhbWVTeXN0ZW1zL1NlYXJjaGluZy9GaW5kZXJcIjtcblxuZXhwb3J0IGNsYXNzIFRhcmdldEV4aXN0czxUPiBleHRlbmRzIEdvYXBTdGF0ZSB7XG5cbiAgICBwcm90ZWN0ZWQgdGFyZ2V0czogUmVhZG9ubHk8VFtdPjtcbiAgICBwcm90ZWN0ZWQgZmluZGVyOiBGaW5kZXI8VD47XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IodGFyZ2V0czogUmVhZG9ubHk8VFtdPiwgZmluZGVyOiBGaW5kZXI8VD4pIHtcbiAgICAgICAgc3VwZXIoKVxuICAgICAgICB0aGlzLmZpbmRlciA9IGZpbmRlcjtcbiAgICAgICAgdGhpcy50YXJnZXRzID0gdGFyZ2V0cztcbiAgICB9XG5cbiAgICBwdWJsaWMgaXNTYXRpc2ZpZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRlci5maW5kKHRoaXMudGFyZ2V0cykgIT09IG51bGw7XG4gICAgfVxuXG59IiwiaW1wb3J0IFN0YXRlTWFjaGluZUFJIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9BSS9TdGF0ZU1hY2hpbmVBSVwiO1xuaW1wb3J0IEFJIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvSW50ZXJmYWNlcy9BSVwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9FdmVudHMvR2FtZUV2ZW50XCI7XG5pbXBvcnQgUGxheWVyQWN0b3IgZnJvbSBcIi4uLy4uL0FjdG9ycy9QbGF5ZXJBY3RvclwiO1xuaW1wb3J0IHsgSXRlbUV2ZW50IH0gZnJvbSBcIi4uLy4uL0V2ZW50c1wiO1xuaW1wb3J0IEludmVudG9yeSBmcm9tIFwiLi4vLi4vR2FtZVN5c3RlbXMvSXRlbVN5c3RlbS9JbnZlbnRvcnlcIjtcbmltcG9ydCBJdGVtIGZyb20gXCIuLi8uLi9HYW1lU3lzdGVtcy9JdGVtU3lzdGVtL0l0ZW1cIjtcbmltcG9ydCBQbGF5ZXJDb250cm9sbGVyIGZyb20gXCIuL1BsYXllckNvbnRyb2xsZXJcIjtcbmltcG9ydCB7IElkbGUsIEludmluY2libGUsIE1vdmluZywgRGVhZCwgUGxheWVyU3RhdGVUeXBlIH0gZnJvbSBcIi4vUGxheWVyU3RhdGVzL1BsYXllclN0YXRlXCI7XG5cbi8qKlxuICogVGhlIEFJIHRoYXQgY29udHJvbHMgdGhlIHBsYXllci4gVGhlIHBsYXllcnMgQUkgaGFzIGJlZW4gY29uZmlndXJlZCBhcyBhIEZpbml0ZSBTdGF0ZSBNYWNoaW5lIChGU00pXG4gKiB3aXRoIDQgc3RhdGVzOyBJZGxlLCBNb3ZpbmcsIEludmluY2libGUsIGFuZCBEZWFkLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQbGF5ZXJBSSBleHRlbmRzIFN0YXRlTWFjaGluZUFJIGltcGxlbWVudHMgQUkge1xuXG4gICAgLyoqIFRoZSBHYW1lTm9kZSB0aGF0IG93bnMgdGhpcyBBSSAqL1xuICAgIHB1YmxpYyBvd25lcjogUGxheWVyQWN0b3I7XG4gICAgLyoqIEEgc2V0IG9mIGNvbnRyb2xzIGZvciB0aGUgcGxheWVyICovXG4gICAgcHVibGljIGNvbnRyb2xsZXI6IFBsYXllckNvbnRyb2xsZXI7XG4gICAgLyoqIFRoZSBpbnZlbnRvcnkgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGUgcGxheWVyICovXG4gICAgcHVibGljIGludmVudG9yeTogSW52ZW50b3J5O1xuICAgIC8qKiBUaGUgcGxheWVycyBoZWxkIGl0ZW0gKi9cbiAgICBwdWJsaWMgaXRlbTogSXRlbSB8IG51bGw7XG4gICAgXG4gICAgcHVibGljIGluaXRpYWxpemVBSShvd25lcjogUGxheWVyQWN0b3IsIG9wdHM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vd25lciA9IG93bmVyO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXcgUGxheWVyQ29udHJvbGxlcihvd25lcik7XG5cbiAgICAgICAgLy8gQWRkIHRoZSBwbGF5ZXJzIHN0YXRlcyB0byBpdCdzIFN0YXRlTWFjaGluZVxuICAgICAgICB0aGlzLmFkZFN0YXRlKFBsYXllclN0YXRlVHlwZS5JRExFLCBuZXcgSWRsZSh0aGlzLCB0aGlzLm93bmVyKSk7XG4gICAgICAgIHRoaXMuYWRkU3RhdGUoUGxheWVyU3RhdGVUeXBlLklOVklOQ0lCTEUsIG5ldyBJbnZpbmNpYmxlKHRoaXMsIHRoaXMub3duZXIpKTtcbiAgICAgICAgdGhpcy5hZGRTdGF0ZShQbGF5ZXJTdGF0ZVR5cGUuTU9WSU5HLCBuZXcgTW92aW5nKHRoaXMsIHRoaXMub3duZXIpKTtcbiAgICAgICAgdGhpcy5hZGRTdGF0ZShQbGF5ZXJTdGF0ZVR5cGUuREVBRCwgbmV3IERlYWQodGhpcywgdGhpcy5vd25lcikpO1xuICAgICAgICBcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgcGxheWVycyBzdGF0ZSB0byBJZGxlXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZShQbGF5ZXJTdGF0ZVR5cGUuSURMRSk7XG4gICAgfVxuXG4gICAgcHVibGljIGFjdGl2YXRlKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHsgfVxuXG4gICAgcHVibGljIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBzdXBlci51cGRhdGUoZGVsdGFUKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZGVzdHJveSgpOiB2b2lkIHt9XG5cbiAgICBwdWJsaWMgaGFuZGxlRXZlbnQoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQge1xuICAgICAgICBzd2l0Y2goZXZlbnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBJdGVtRXZlbnQuTEFTRVJHVU5fRklSRUQ6IHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUxhc2VyRmlyZWRFdmVudChldmVudC5kYXRhLmdldChcImFjdG9ySWRcIiksIGV2ZW50LmRhdGEuZ2V0KFwidG9cIiksIGV2ZW50LmRhdGEuZ2V0KFwiZnJvbVwiKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgc3VwZXIuaGFuZGxlRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGhhbmRsZUxhc2VyRmlyZWRFdmVudChhY3RvcklkOiBudW1iZXIsIHRvOiBWZWMyLCBmcm9tOiBWZWMyKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLm93bmVyLmlkICE9PSBhY3RvcklkICYmIHRoaXMub3duZXIuY29sbGlzaW9uU2hhcGUgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm93bmVyLmNvbGxpc2lvblNoYXBlLmdldEJvdW5kaW5nUmVjdCgpLmludGVyc2VjdFNlZ21lbnQodG8sIGZyb20uY2xvbmUoKS5zdWIodG8pKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3duZXIuaGVhbHRoIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IElucHV0IGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9JbnB1dC9JbnB1dFwiO1xuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XG5cbi8qKlxuICogU3RyaW5ncyB1c2VkIGluIHRoZSBrZXkgYmluZGluZyBmb3IgdGhlIHBsYXllclxuICovXG5leHBvcnQgZW51bSBQbGF5ZXJJbnB1dCB7XG4gICAgTU9WRV9VUCA9IFwiTU9WRV9VUFwiLFxuICAgIE1PVkVfRE9XTiA9IFwiTU9WRV9ET1dOXCIsXG4gICAgTU9WRV9MRUZUID0gXCJNT1ZFX0xFRlRcIixcbiAgICBNT1ZFX1JJR0hUID0gXCJNT1ZFX1JJR0hUXCIsXG4gICAgQVRUQUNLSU5HID0gXCJBVFRBQ0tJTkdcIixcbiAgICBQSUNLVVBfSVRFTSA9IFwiUElDS1VQX0lURU1cIixcbiAgICBEUk9QX0lURU0gPSBcIkRST1BfSVRFTVwiXG59XG5cbi8qKlxuICogVGhlIFBsYXllckNvbnRyb2xsZXIgY2xhc3MgaGFuZGxlcyBwcm9jZXNzaW5nIHRoZSBpbnB1dCByZWNpZXZlZCBmcm9tIHRoZSB1c2VyIGFuZCBleHBvc2VzICBcbiAqIGEgc2V0IG9mIG1ldGhvZHMgdG8gbWFrZSBkZWFsaW5nIHdpdGggdGhlIHVzZXIgaW5wdXQgYSBiaXQgc2ltcGxlci5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGxheWVyQ29udHJvbGxlciB7XG5cbiAgICAvKiogVGhlIEdhbWVOb2RlIHRoYXQgb3ducyB0aGUgQUkgKi9cbiAgICBwcm90ZWN0ZWQgb3duZXI6IEFuaW1hdGVkU3ByaXRlO1xuXG4gICAgY29uc3RydWN0b3Iob3duZXI6IEFuaW1hdGVkU3ByaXRlKSB7XG4gICAgICAgIHRoaXMub3duZXIgPSBvd25lcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkaXJlY3Rpb24gdGhlIHBsYXllciBzaG91bGQgbW92ZSBiYXNlZCBvbiBpbnB1dCBmcm9tIHRoZSBrZXlib2FyZC4gXG4gICAgICogQHJldHVybnMgYSBWZWMyIGluZGljYXRpbmcgdGhlIGRpcmVjdGlvbiB0aGUgcGxheWVyIHNob3VsZCBtb3ZlLiBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG1vdmVEaXIoKTogVmVjMiB7IFxuICAgICAgICBsZXQgZGlyOiBWZWMyID0gVmVjMi5aRVJPO1xuICAgICAgICBkaXIueSA9IChJbnB1dC5pc1ByZXNzZWQoUGxheWVySW5wdXQuTU9WRV9VUCkgPyAtMSA6IDApICsgKElucHV0LmlzUHJlc3NlZChQbGF5ZXJJbnB1dC5NT1ZFX0RPV04pID8gMSA6IDApO1xuXHRcdGRpci54ID0gKElucHV0LmlzUHJlc3NlZChQbGF5ZXJJbnB1dC5NT1ZFX0xFRlQpID8gLTEgOiAwKSArIChJbnB1dC5pc1ByZXNzZWQoUGxheWVySW5wdXQuTU9WRV9SSUdIVCkgPyAxIDogMCk7XG4gICAgICAgIHJldHVybiBkaXIubm9ybWFsaXplKCk7XG4gICAgfVxuXG4gICAgLyoqIFxuICAgICAqIEdldHMgdGhlIGRpcmVjdGlvbiB0aGUgcGxheWVyIHNob3VsZCBiZSBmYWNpbmcgYmFzZWQgb24gdGhlIHBvc2l0aW9uIG9mIHRoZVxuICAgICAqIG1vdXNlIGFyb3VuZCB0aGUgcGxheWVyXG4gICAgICogQHJldHVybiBhIFZlYzIgcmVwcmVzZW50aW5nIHRoZSBkaXJlY3Rpb24gdGhlIHBsYXllciBzaG91bGQgZmFjZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGZhY2VEaXIoKTogVmVjMiB7IHJldHVybiB0aGlzLm93bmVyLnBvc2l0aW9uLmRpclRvKElucHV0LmdldEdsb2JhbE1vdXNlUG9zaXRpb24oKSk7IH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJvdGF0aW9uIG9mIHRoZSBwbGF5ZXJzIHNwcml0ZSBiYXNlZCBvbiB0aGUgZGlyZWN0aW9uIHRoZSBwbGF5ZXJcbiAgICAgKiBzaG91bGQgYmUgZmFjaW5nLlxuICAgICAqIEByZXR1cm4gYSBudW1iZXIgcmVwcmVzZW50aW5nIGhvdyBtdWNoIHRoZSBwbGF5ZXIgc2hvdWxkIGJlIHJvdGF0ZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHJvdGF0aW9uKCk6IG51bWJlciB7IHJldHVybiBWZWMyLlVQLmFuZ2xlVG9DQ1codGhpcy5mYWNlRGlyKTsgfVxuXG4gICAgLyoqIFxuICAgICAqIENoZWNrcyBpZiB0aGUgcGxheWVyIGlzIGF0dGVtcHRpbmcgdG8gdXNlIGEgaGVsZCBpdGVtIG9yIG5vdC5cbiAgICAgKiBAcmV0dXJuIHRydWUgaWYgdGhlIHBsYXllciBpcyBhdHRlbXB0aW5nIHRvIHVzZSBhIGhlbGQgaXRlbTsgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgcHVibGljIGdldCB1c2VJdGVtKCk6IGJvb2xlYW4geyByZXR1cm4gSW5wdXQuaXNNb3VzZUp1c3RQcmVzc2VkKCk7IH1cblxuICAgIC8qKiBcbiAgICAgKiBDaGVja3MgaWYgdGhlIHBsYXllciBpcyBhdHRlbXB0aW5nIHRvIHBpY2sgdXAgYW4gaXRlbSBvciBub3QuXG4gICAgICogQHJldHVybiB0cnVlIGlmIHRoZSBwbGF5ZXIgaXMgYXR0ZW1wdGluZyB0byBwaWNrIHVwIGFuIGl0ZW07IGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHBpY2tpbmdVcCgpOiBib29sZWFuIHsgcmV0dXJuIElucHV0LmlzSnVzdFByZXNzZWQoUGxheWVySW5wdXQuUElDS1VQX0lURU0pOyB9XG5cbiAgICAvKiogXG4gICAgICogQ2hlY2tzIGlmIHRoZSBwbGF5ZXIgaXMgYXR0ZW1wdGluZyB0byBkcm9wIHRoZWlyIGhlbGQgaXRlbSBvciBub3QuXG4gICAgICogQHJldHVybiB0cnVlIGlmIHRoZSBwbGF5ZXIgaXMgYXR0ZW1wdGluZyB0byBkcm9wIHRoZWlyIGhlbGQgaXRlbTsgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgZHJvcHBpbmcoKTogYm9vbGVhbiB7IHJldHVybiBJbnB1dC5pc0p1c3RQcmVzc2VkKFBsYXllcklucHV0LkRST1BfSVRFTSk7IH1cblxufSIsImltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnRcIjtcbmltcG9ydCB7IFBsYXllckV2ZW50IH0gZnJvbSBcIi4uLy4uLy4uL0V2ZW50c1wiO1xuaW1wb3J0IFBsYXllclN0YXRlIGZyb20gXCIuL1BsYXllclN0YXRlXCI7XG5cbi8qKlxuICogVGhlIERlYWQgc3RhdGUgZm9yIHRoZSBQbGF5ZXJBSS4gV2hpbGUgdGhlIHBsYXllciBpcyBpbiB0aGUgXCJEZWFkXCIgc3RhdGUsIHRoZSBwbGF5ZXIgZG9lcyBub3RcbiAqIGdldCB1cGRhdGVkIGFuZCBhbGwgaW5jb21pbmcgZXZlbnRzIHRvIHRoZSBQbGF5ZXJBSSBhcmUgaWdub3JlZC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVhZCBleHRlbmRzIFBsYXllclN0YXRlIHtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIFBsYXllckFJIGVudGVycyB0aGUgZGVhZCBzdGF0ZSwgYW4gZXZlbnQgaXMgZmlyZWQgdG8gYWxlcnQgdGhlIHN5c3RlbVxuICAgICAqIHRoYXQgdGhlIHBsYXllciBpcyBvZmZpY2lhbGx5IGRlYWQuXG4gICAgICovXG4gICAgb25FbnRlcihvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XG4gICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQoUGxheWVyRXZlbnQuUExBWUVSX0tJTExFRCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGlucHV0IGhhbmRsZXIgZm9yIHRoZSBkZWFkIHN0YXRlIGlnbm9yZXMgYWxsIGluY29taW5nIGV2ZW50cyB0byB0aGUgcGxheWVyLiBcbiAgICAgKiBAcGFyYW0gZXZlbnQgXG4gICAgICovXG4gICAgaGFuZGxlSW5wdXQoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQgeyB9XG5cbiAgICAvKipcbiAgICAgKiBTaW1pbGFyIHRvIHRoZSBoYW5kbGVJbnB1dCBtZXRob2QsIHdoaWxlIGluIHRoZSBkZWFkIHN0YXRlLCB0aGUgUGxheWVyQUkgZG9lc24ndFxuICAgICAqIGdldCB1cGRhdGVkLlxuICAgICAqIEBwYXJhbSBkZWx0YVQgXG4gICAgICovXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7IH1cblxuICAgIG9uRXhpdCgpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHsgcmV0dXJuIHt9IH1cblxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFwiO1xuaW1wb3J0IHsgUGxheWVyQW5pbWF0aW9uVHlwZSwgUGxheWVyU3RhdGVUeXBlIH0gZnJvbSBcIi4vUGxheWVyU3RhdGVcIjtcbmltcG9ydCBQbGF5ZXJTdGF0ZSBmcm9tIFwiLi9QbGF5ZXJTdGF0ZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJZGxlIGV4dGVuZHMgUGxheWVyU3RhdGUge1xuXG4gICAgcHVibGljIG92ZXJyaWRlIG9uRW50ZXIob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xuICAgICAgICB0aGlzLnBhcmVudC5vd25lci5hbmltYXRpb24ucGxheUlmTm90QWxyZWFkeShQbGF5ZXJBbmltYXRpb25UeXBlLklETEUsIHRydWUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBvdmVycmlkZSBoYW5kbGVJbnB1dChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIHN3aXRjaChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgc3VwZXIuaGFuZGxlSW5wdXQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBzdXBlci51cGRhdGUoZGVsdGFUKTtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudC5jb250cm9sbGVyLm1vdmVEaXIuZXF1YWxzKFZlYzIuWkVSTykpIHtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoZWQoUGxheWVyU3RhdGVUeXBlLk1PVklORyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgb25FeGl0KCk6IFJlY29yZDxzdHJpbmcsIGFueT4geyBcbiAgICAgICAgcmV0dXJuIHt9OyBcbiAgICB9XG4gICAgXG59IiwiaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFwiO1xuaW1wb3J0IFRpbWVyIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9UaW1pbmcvVGltZXJcIjtcbmltcG9ydCBQbGF5ZXJBY3RvciBmcm9tIFwiLi4vLi4vLi4vQWN0b3JzL1BsYXllckFjdG9yXCI7XG5pbXBvcnQgUGxheWVyQUkgZnJvbSBcIi4uL1BsYXllckFJXCI7XG5pbXBvcnQgUGxheWVyU3RhdGUsIHsgUGxheWVyU3RhdGVUeXBlIH0gZnJvbSBcIi4vUGxheWVyU3RhdGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW52aW5jaWJsZSBleHRlbmRzIFBsYXllclN0YXRlIHtcblxuICAgIHByb3RlY3RlZCB0aW1lcjogVGltZXI7XG5cbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IFBsYXllckFJLCBvd25lcjogUGxheWVyQWN0b3IpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBvd25lcik7XG4gICAgICAgIHRoaXMudGltZXIgPSBuZXcgVGltZXIoMTAwLCAoKSA9PiB0aGlzLmZpbmlzaGVkKFBsYXllclN0YXRlVHlwZS5JRExFKSk7XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge31cblxuICAgIHB1YmxpYyBvdmVycmlkZSBoYW5kbGVJbnB1dChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIHN3aXRjaChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgc3VwZXIuaGFuZGxlSW5wdXQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIG9uRW50ZXIob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xuICAgICAgICB0aGlzLnRpbWVyLnN0YXJ0KCk7XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIG9uRXhpdCgpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHsgXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9FdmVudHMvR2FtZUV2ZW50XCI7XG5pbXBvcnQgeyBQbGF5ZXJTdGF0ZVR5cGUgfSBmcm9tIFwiLi9QbGF5ZXJTdGF0ZVwiO1xuaW1wb3J0IFBsYXllclN0YXRlIGZyb20gXCIuL1BsYXllclN0YXRlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vdmluZyBleHRlbmRzIFBsYXllclN0YXRlIHtcbiAgICBcbiAgICBwdWJsaWMgb3ZlcnJpZGUgb25FbnRlcihvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XG4gICAgXG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIGhhbmRsZUlucHV0KGV2ZW50OiBHYW1lRXZlbnQpOiB2b2lkIHsgXG4gICAgICAgIHN3aXRjaChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgc3VwZXIuaGFuZGxlSW5wdXQoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBzdXBlci51cGRhdGUoZGVsdGFUKTtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmNvbnRyb2xsZXIubW92ZURpci5lcXVhbHMoVmVjMi5aRVJPKSkge1xuICAgICAgICAgICAgdGhpcy5maW5pc2hlZChQbGF5ZXJTdGF0ZVR5cGUuSURMRSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgb25FeGl0KCk6IFJlY29yZDxzdHJpbmcsIGFueT4geyByZXR1cm4ge307IH1cbn0iLCJpbXBvcnQgU3RhdGUgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9TdGF0ZS9TdGF0ZVwiO1xuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFwiO1xuaW1wb3J0IHsgQmF0dGxlckV2ZW50LCBIdWRFdmVudCwgSXRlbUV2ZW50IH0gZnJvbSBcIi4uLy4uLy4uL0V2ZW50c1wiXG5pbXBvcnQgSXRlbSBmcm9tIFwiLi4vLi4vLi4vR2FtZVN5c3RlbXMvSXRlbVN5c3RlbS9JdGVtXCI7XG5pbXBvcnQgUGxheWVyQUkgZnJvbSBcIi4uL1BsYXllckFJXCI7XG5cblxuZXhwb3J0IGVudW0gUGxheWVyQW5pbWF0aW9uVHlwZSB7XG4gICAgSURMRSA9IFwiSURMRVwiXG59XG5cblxuZXhwb3J0IGVudW0gUGxheWVyU3RhdGVUeXBlIHtcbiAgICBJRExFID0gXCJJRExFXCIsXG4gICAgSU5WSU5DSUJMRSA9IFwiSU5WSU5DSUJMRVwiLFxuICAgIEFUVEFDS0lORyA9IFwiQVRUQUNLSU5HXCIsXG4gICAgTU9WSU5HID0gXCJNT1ZJTkdcIixcbiAgICBERUFEID0gXCJERUFEXCJcbn1cblxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgUGxheWVyU3RhdGUgZXh0ZW5kcyBTdGF0ZSB7XG5cbiAgICBwcm90ZWN0ZWQgcGFyZW50OiBQbGF5ZXJBSTtcbiAgICBwcm90ZWN0ZWQgb3duZXI6IFBsYXllckFjdG9yO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHBhcmVudDogUGxheWVyQUksIG93bmVyOiBQbGF5ZXJBY3Rvcikge1xuICAgICAgICBzdXBlcihwYXJlbnQpO1xuICAgICAgICB0aGlzLm93bmVyID0gb3duZXI7XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIG9uRW50ZXIob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge31cbiAgICBwdWJsaWMgb3ZlcnJpZGUgb25FeGl0KCk6IFJlY29yZDxzdHJpbmcsIGFueT4geyByZXR1cm4ge307IH1cbiAgICBwdWJsaWMgb3ZlcnJpZGUgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG5cbiAgICAgICAgLy8gQWRqdXN0IHRoZSBhbmdsZSB0aGUgcGxheWVyIGlzIGZhY2luZyBcbiAgICAgICAgdGhpcy5wYXJlbnQub3duZXIucm90YXRpb24gPSB0aGlzLnBhcmVudC5jb250cm9sbGVyLnJvdGF0aW9uO1xuICAgICAgICAvLyBNb3ZlIHRoZSBwbGF5ZXJcbiAgICAgICAgdGhpcy5wYXJlbnQub3duZXIubW92ZSh0aGlzLnBhcmVudC5jb250cm9sbGVyLm1vdmVEaXIpO1xuXG4gICAgICAgIC8vIEhhbmRsZSB0aGUgcGxheWVyIHRyeWluZyB0byBwaWNrIHVwIGFuIGl0ZW1cbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmNvbnRyb2xsZXIucGlja2luZ1VwKSB7XG4gICAgICAgICAgICAvLyBSZXF1ZXN0IGFuIGl0ZW0gZnJvbSB0aGUgc2NlbmVcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQoSXRlbUV2ZW50LklURU1fUkVRVUVTVCwge25vZGU6IHRoaXMub3duZXIsIGludmVudG9yeTogdGhpcy5vd25lci5pbnZlbnRvcnl9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSB0aGUgcGxheWVyIHRyeWluZyB0byBkcm9wIGFuIGl0ZW1cbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmNvbnRyb2xsZXIuZHJvcHBpbmcpIHtcbiAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmNvbnRyb2xsZXIudXNlSXRlbSkge1xuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgaGFuZGxlSW5wdXQoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQge1xuICAgICAgICBzd2l0Y2goZXZlbnQudHlwZSkge1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5oYW5kbGVkIGV2ZW50IG9mIHR5cGUgJHtldmVudC50eXBlfSBjYXVnaHQgaW4gUGxheWVyU3RhdGUhYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuaW1wb3J0IElkbGUgZnJvbSBcIi4vSWRsZVwiO1xuaW1wb3J0IEludmluY2libGUgZnJvbSBcIi4vSW52aW5jaWJsZVwiO1xuaW1wb3J0IE1vdmluZyBmcm9tIFwiLi9Nb3ZpbmdcIjtcbmltcG9ydCBEZWFkIGZyb20gXCIuL0RlYWRcIjtcbmltcG9ydCBQbGF5ZXJBY3RvciBmcm9tIFwiLi4vLi4vLi4vQWN0b3JzL1BsYXllckFjdG9yXCI7XG5leHBvcnQgeyBJZGxlLCBJbnZpbmNpYmxlLCBNb3ZpbmcsIERlYWR9ICIsImltcG9ydCBTcHJpdGVzaGVldCBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1Nwcml0ZXNoZWV0XCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBBbmltYXRlZFNwcml0ZSBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZVwiXG5pbXBvcnQgTmF2aWdhdGlvblBhdGggZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1BhdGhmaW5kaW5nL05hdmlnYXRpb25QYXRoXCI7XG5pbXBvcnQgeyBCYXR0bGVyRXZlbnQsIEh1ZEV2ZW50IH0gZnJvbSBcIi4uL0V2ZW50c1wiO1xuaW1wb3J0IEludmVudG9yeSBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvSXRlbVN5c3RlbS9JbnZlbnRvcnlcIjtcbmltcG9ydCBIVzRTY2VuZSBmcm9tIFwiLi4vU2NlbmVzL0hXNFNjZW5lXCI7XG5pbXBvcnQgQmFzaWNUYXJnZXRhYmxlIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9UYXJnZXRpbmcvQmFzaWNUYXJnZXRhYmxlXCI7XG5pbXBvcnQgQmFzaWNUYXJnZXRpbmcgZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL1RhcmdldGluZy9CYXNpY1RhcmdldGluZ1wiO1xuXG5pbXBvcnQgQmF0dGxlciBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvQmF0dGxlU3lzdGVtL0JhdHRsZXJcIjtcbmltcG9ydCB7IFRhcmdldGFibGVFbnRpdHkgfSBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvVGFyZ2V0aW5nL1RhcmdldGFibGVFbnRpdHlcIjtcbmltcG9ydCB7IFRhcmdldGluZ0VudGl0eSB9IGZyb20gXCIuLi9HYW1lU3lzdGVtcy9UYXJnZXRpbmcvVGFyZ2V0aW5nRW50aXR5XCI7XG5pbXBvcnQgQmFzaWNCYXR0bGVyIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9CYXR0bGVTeXN0ZW0vQmFzaWNCYXR0bGVyXCI7XG5pbXBvcnQgVGltZXIgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1RpbWluZy9UaW1lclwiO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5QQ0FjdG9yIGV4dGVuZHMgQW5pbWF0ZWRTcHJpdGUgaW1wbGVtZW50cyBCYXR0bGVyLCBUYXJnZXRpbmdFbnRpdHkge1xuXG4gICAgLyoqIE92ZXJyaWRlIHRoZSB0eXBlIG9mIHRoZSBzY2VuZSB0byBiZSB0aGUgSFc0IHNjZW5lICovXG4gICAgcHJvdGVjdGVkIHNjZW5lOiBIVzRTY2VuZVxuXG4gICAgLy8gQW4gaW52aW5jaWJsZSB0aW1lciBmb3Igb3VyIE5QQ3NcbiAgICBwcm90ZWN0ZWQgaW52aW5jaWJsZVRpbWVyOiBUaW1lcjtcblxuICAgIC8vIFRoZSBrZXkgb2YgdGhlIE5hdm1lc2ggdG8gdXNlIHRvIGJ1aWxkIHBhdGhzIGZvciB0aGlzIE5QQ0FjdG9yXG4gICAgcHJvdGVjdGVkIF9uYXZrZXk6IHN0cmluZztcblxuICAgIC8vIFRoZSBOUENzIGJhdHRsZXIgb2JqZWN0XG4gICAgcHJvdGVjdGVkIF9iYXR0bGVyOiBCYXR0bGVyO1xuXG4gICAgcHJvdGVjdGVkIF90YXJnZXRpbmc6IFRhcmdldGluZ0VudGl0eVxuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHNoZWV0OiBTcHJpdGVzaGVldCkge1xuICAgICAgICBzdXBlcihzaGVldCk7XG4gICAgICAgIHRoaXMuX25hdmtleSA9IFwibmF2a2V5XCI7XG4gICAgICAgIHRoaXMuX2JhdHRsZXIgPSBuZXcgQmFzaWNCYXR0bGVyKHRoaXMpO1xuICAgICAgICB0aGlzLl90YXJnZXRpbmcgPSBuZXcgQmFzaWNUYXJnZXRpbmcodGhpcyk7XG4gICAgICAgIHRoaXMuaW52aW5jaWJsZVRpbWVyID0gbmV3IFRpbWVyKDEwMDApO1xuXG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKFwidXNlLWhwYWNrXCIpO1xuICAgIH1cblxuICAgIC8qKiBUaGUgVGFyZ2V0aW5nRW50aXR5IGludGVyZmFjZSAqL1xuXG4gICAgcHVibGljIGNsZWFyVGFyZ2V0KCk6IHZvaWQgeyB0aGlzLl90YXJnZXRpbmcuY2xlYXJUYXJnZXQoKTsgfVxuICAgIHB1YmxpYyBzZXRUYXJnZXQodGFyZ2V0YWJsZTogVGFyZ2V0YWJsZUVudGl0eSk6IHZvaWQgeyB0aGlzLl90YXJnZXRpbmcuc2V0VGFyZ2V0KHRhcmdldGFibGUpOyB9XG4gICAgcHVibGljIGhhc1RhcmdldCgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX3RhcmdldGluZy5oYXNUYXJnZXQoKTsgfVxuICAgIHB1YmxpYyBnZXRUYXJnZXQoKTogVGFyZ2V0YWJsZUVudGl0eSB7IHJldHVybiB0aGlzLl90YXJnZXRpbmcuZ2V0VGFyZ2V0KCk7IH1cbiAgICBcbiAgICAvKiogVGhlIFRhcmdldGFibGVFbnRpdHkgaW50ZXJmYWNlICovXG5cbiAgICBwdWJsaWMgZ2V0VGFyZ2V0aW5nKCk6IFRhcmdldGluZ0VudGl0eVtdIHsgcmV0dXJuIHRoaXMuX2JhdHRsZXIuZ2V0VGFyZ2V0aW5nKCk7IH1cbiAgICBwdWJsaWMgYWRkVGFyZ2V0aW5nKHRhcmdldGluZzogVGFyZ2V0aW5nRW50aXR5KTogdm9pZCB7IHRoaXMuX2JhdHRsZXIuYWRkVGFyZ2V0aW5nKHRhcmdldGluZyk7IH1cbiAgICBwdWJsaWMgcmVtb3ZlVGFyZ2V0aW5nKHRhcmdldGluZzogVGFyZ2V0aW5nRW50aXR5KTogdm9pZCB7IHRoaXMuX2JhdHRsZXIucmVtb3ZlVGFyZ2V0aW5nKHRhcmdldGluZyk7IH1cblxuICAgIGF0VGFyZ2V0KCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0aW5nLmdldFRhcmdldCgpLnBvc2l0aW9uLmRpc3RhbmNlU3FUbyh0aGlzLnBvc2l0aW9uKSA8IDYyNTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGJhdHRsZXJBY3RpdmUoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLmJhdHRsZXIuYmF0dGxlckFjdGl2ZTsgfVxuICAgIHB1YmxpYyBzZXQgYmF0dGxlckFjdGl2ZSh2YWx1ZTogYm9vbGVhbikgeyBcbiAgICAgICAgdGhpcy5iYXR0bGVyLmJhdHRsZXJBY3RpdmUgPSB2YWx1ZTsgXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmFpQWN0aXZlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBiYXR0bGVHcm91cCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5iYXR0bGVyLmJhdHRsZUdyb3VwOyB9XG4gICAgcHVibGljIHNldCBiYXR0bGVHcm91cChiYXR0bGVHcm91cDogbnVtYmVyKSB7IHRoaXMuYmF0dGxlci5iYXR0bGVHcm91cCA9IGJhdHRsZUdyb3VwOyB9XG5cbiAgICBwdWJsaWMgZ2V0IG1heEhlYWx0aCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5iYXR0bGVyLm1heEhlYWx0aCB9XG4gICAgcHVibGljIHNldCBtYXhIZWFsdGgobWF4SGVhbHRoOiBudW1iZXIpIHsgXG4gICAgICAgIHRoaXMuYmF0dGxlci5tYXhIZWFsdGggPSBtYXhIZWFsdGg7IFxuICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KEh1ZEV2ZW50LkhFQUxUSF9DSEFOR0UsIHtpZDogdGhpcy5pZCwgY3VyaHA6IHRoaXMuaGVhbHRoLCBtYXhocDogdGhpcy5tYXhIZWFsdGh9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGhlYWx0aCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5iYXR0bGVyLmhlYWx0aDsgfVxuICAgIHB1YmxpYyBzZXQgaGVhbHRoKGhlYWx0aDogbnVtYmVyKSB7IFxuICAgICAgICB0aGlzLmJhdHRsZXIuaGVhbHRoID0gaGVhbHRoOyBcbiAgICAgICAgaWYgKHRoaXMuaGVhbHRoIDw9IDAgJiYgdGhpcy5iYXR0bGVyQWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KEJhdHRsZXJFdmVudC5CQVRUTEVSX0tJTExFRCwge2lkOiB0aGlzLmlkfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHNwZWVkKCk6IG51bWJlciB7IHJldHVybiB0aGlzLmJhdHRsZXIuc3BlZWQ7IH1cbiAgICBwdWJsaWMgc2V0IHNwZWVkKHNwZWVkOiBudW1iZXIpIHsgdGhpcy5iYXR0bGVyLnNwZWVkID0gc3BlZWQ7IH1cblxuICAgIHB1YmxpYyBvdmVycmlkZSBzZXRTY2VuZShzY2VuZTogSFc0U2NlbmUpOiB2b2lkIHsgdGhpcy5zY2VuZSA9IHNjZW5lOyB9XG4gICAgcHVibGljIG92ZXJyaWRlIGdldFNjZW5lKCk6IEhXNFNjZW5lIHsgcmV0dXJuIHRoaXMuc2NlbmU7IH1cblxuICAgIHB1YmxpYyBnZXQgbmF2a2V5KCk6IHN0cmluZyB7IHJldHVybiB0aGlzLl9uYXZrZXk7IH1cbiAgICBwdWJsaWMgc2V0IG5hdmtleShuYXZrZXk6IHN0cmluZykgeyB0aGlzLl9uYXZrZXkgPSBuYXZrZXk7IH1cblxuICAgIGdldFBhdGgodG86IFZlYzIsIGZyb206IFZlYzIpOiBOYXZpZ2F0aW9uUGF0aCB7IFxuICAgICAgICByZXR1cm4gdGhpcy5zY2VuZS5nZXROYXZpZ2F0aW9uTWFuYWdlcigpLmdldFBhdGgodGhpcy5uYXZrZXksIHRvLCBmcm9tKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGludmVudG9yeSgpOiBJbnZlbnRvcnkgeyByZXR1cm4gdGhpcy5iYXR0bGVyLmludmVudG9yeTsgfVxuXG4gICAgLyoqIFByb3RlY3RlZCBnZXR0ZXJzIGZvciB0aGUgZGlmZmVyZW50IGNvbXBvbmVudHMgKi9cblxuICAgIHByb3RlY3RlZCBnZXQgYmF0dGxlcigpOiBCYXR0bGVyIHsgcmV0dXJuIHRoaXMuX2JhdHRsZXI7IH1cbiAgICBwcm90ZWN0ZWQgZ2V0IHRhcmdldGluZygpOiBUYXJnZXRpbmdFbnRpdHkgeyByZXR1cm4gdGhpcy5fdGFyZ2V0aW5nOyB9XG59IiwiaW1wb3J0IFNwcml0ZXNoZWV0IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvU3ByaXRlc2hlZXRcIjtcbmltcG9ydCBBbmltYXRlZFNwcml0ZSBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZVwiO1xuaW1wb3J0IHsgQmF0dGxlckV2ZW50LCBJdGVtRXZlbnQgfSBmcm9tIFwiLi4vRXZlbnRzXCI7XG5pbXBvcnQgQmFzaWNCYXR0bGVyIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9CYXR0bGVTeXN0ZW0vQmFzaWNCYXR0bGVyXCI7XG5pbXBvcnQgQmF0dGxlciBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvQmF0dGxlU3lzdGVtL0JhdHRsZXJcIjtcbmltcG9ydCBJbnZlbnRvcnkgZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL0l0ZW1TeXN0ZW0vSW52ZW50b3J5XCI7XG5pbXBvcnQgSFc0SXRlbSBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvSXRlbVN5c3RlbS9JdGVtXCI7XG5pbXBvcnQgQmFzaWNUYXJnZXRhYmxlIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9UYXJnZXRpbmcvQmFzaWNUYXJnZXRhYmxlXCI7XG5pbXBvcnQgeyBUYXJnZXRhYmxlRW50aXR5IH0gZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL1RhcmdldGluZy9UYXJnZXRhYmxlRW50aXR5XCI7XG5pbXBvcnQgeyBUYXJnZXRpbmdFbnRpdHkgfSBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvVGFyZ2V0aW5nL1RhcmdldGluZ0VudGl0eVwiO1xuaW1wb3J0IEhXNFNjZW5lIGZyb20gXCIuLi9TY2VuZXMvSFc0U2NlbmVcIjtcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQbGF5ZXJBY3RvciBleHRlbmRzIEFuaW1hdGVkU3ByaXRlIGltcGxlbWVudHMgQmF0dGxlciB7XG5cbiAgICAvKiogT3ZlcnJpZGUgdGhlIHR5cGUgb2YgdGhlIHNjZW5lIHRvIGJlIHRoZSBIVzQgc2NlbmUgKi9cbiAgICBwcm90ZWN0ZWQgc2NlbmU6IEhXNFNjZW5lXG5cbiAgICAvKiogR2l2ZSB0aGUgcGxheWVyIGEgYmF0dGxlciBjb21wb29uZW50ICovXG4gICAgcHJvdGVjdGVkIGJhdHRsZXI6IEJhdHRsZXI7XG4gICAgcHJvdGVjdGVkIHRhcmdldGFibGU6IFRhcmdldGFibGVFbnRpdHk7XG5cbiAgICBwcm90ZWN0ZWQgaGVsZEl0ZW06IEhXNEl0ZW07XG5cbiAgICBjb25zdHJ1Y3RvcihzaGVldDogU3ByaXRlc2hlZXQpIHtcbiAgICAgICAgc3VwZXIoc2hlZXQpO1xuICAgICAgICB0aGlzLmJhdHRsZXIgPSBuZXcgQmFzaWNCYXR0bGVyKHRoaXMpO1xuICAgICAgICB0aGlzLnRhcmdldGFibGUgPSBuZXcgQmFzaWNUYXJnZXRhYmxlKHRoaXMpO1xuXG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKEl0ZW1FdmVudC5MQVNFUkdVTl9GSVJFRClcbiAgICB9XG5cbiAgICBnZXQgYmF0dGxlckFjdGl2ZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmF0dGxlci5iYXR0bGVyQWN0aXZlO1xuICAgIH1cbiAgICBzZXQgYmF0dGxlckFjdGl2ZSh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLmJhdHRsZXIuYmF0dGxlckFjdGl2ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnZpc2libGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgXG4gICAgcHVibGljIGdldFRhcmdldGluZygpOiBUYXJnZXRpbmdFbnRpdHlbXSB7IHJldHVybiB0aGlzLnRhcmdldGFibGUuZ2V0VGFyZ2V0aW5nKCk7IH1cbiAgICBwdWJsaWMgYWRkVGFyZ2V0aW5nKHRhcmdldGluZzogVGFyZ2V0aW5nRW50aXR5KTogdm9pZCB7IHRoaXMudGFyZ2V0YWJsZS5hZGRUYXJnZXRpbmcodGFyZ2V0aW5nKTsgfVxuICAgIHB1YmxpYyByZW1vdmVUYXJnZXRpbmcodGFyZ2V0aW5nOiBUYXJnZXRpbmdFbnRpdHkpOiB2b2lkIHsgdGhpcy50YXJnZXRhYmxlLnJlbW92ZVRhcmdldGluZyh0YXJnZXRpbmcpOyB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgc2V0U2NlbmUoc2NlbmU6IEhXNFNjZW5lKTogdm9pZCB7IHRoaXMuc2NlbmUgPSBzY2VuZTsgfVxuICAgIHB1YmxpYyBvdmVycmlkZSBnZXRTY2VuZSgpOiBIVzRTY2VuZSB7IHJldHVybiB0aGlzLnNjZW5lOyB9XG5cbiAgICBnZXQgYmF0dGxlR3JvdXAoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmF0dGxlci5iYXR0bGVHcm91cDtcbiAgICB9XG4gICAgc2V0IGJhdHRsZUdyb3VwKHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5iYXR0bGVyLmJhdHRsZUdyb3VwID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBtYXhIZWFsdGgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmF0dGxlci5tYXhIZWFsdGg7XG4gICAgfVxuICAgIHNldCBtYXhIZWFsdGgodmFsdWU6IG51bWJlcikge1xuICAgICAgICB0aGlzLmJhdHRsZXIubWF4SGVhbHRoID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBoZWFsdGgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmF0dGxlci5oZWFsdGg7XG4gICAgfVxuICAgIHNldCBoZWFsdGgodmFsdWU6IG51bWJlcikge1xuICAgICAgICB0aGlzLmJhdHRsZXIuaGVhbHRoID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLmhlYWx0aCA8PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KEJhdHRsZXJFdmVudC5CQVRUTEVSX0tJTExFRCwge2lkOiB0aGlzLmlkfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHNwZWVkKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhdHRsZXIuc3BlZWQ7XG4gICAgfVxuICAgIHNldCBzcGVlZCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuYmF0dGxlci5zcGVlZCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgaW52ZW50b3J5KCk6IEludmVudG9yeSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhdHRsZXIuaW52ZW50b3J5O1xuICAgIH1cbn0iLCJleHBvcnQgZW51bSBCYXR0bGVyRXZlbnQge1xuICAgIEJBVFRMRVJfS0lMTEVEID0gXCJCQVRUTEVSX0tJTExFRFwiLFxuICAgIEJBVFRMRVJfUkVTUEFXTiA9IFwiQkFUVExFUl9SRVNQQVdOXCIsXG4gICAgXG4gICAgQkFUVExFUl9DSEFOR0UgPSBcIkJBVFRMRVJfQ0hBTkdFXCIsXG4gICAgQ09OU1VNRSA9IFwiQ09OU1VNRVwiLFxuICAgIEhJVCA9IFwiSElUXCIsXG59XG5cbmV4cG9ydCBlbnVtIEl0ZW1FdmVudCB7XG4gICAgSVRFTV9SRVFVRVNUID0gXCJJVEVNX1JFUVVFU1RcIixcblxuICAgIExBU0VSR1VOX0ZJUkVEID0gXCJMQVNFUkdVTl9GSVJFRFwiLFxuXG4gICAgV0VBUE9OX1VTRUQgPSBcIldFQVBPTl9VU0VEXCIsXG4gICAgQ09OU1VNQUJMRV9VU0VEID0gXCJDT05TVU1BQkxFX1VTRURcIixcbiAgICBJTlZFTlRPUllfQ0hBTkdFRCA9IFwiSU5WRU5UT1JZX0NIQU5HRURcIixcbn1cblxuZXhwb3J0IGVudW0gSHVkRXZlbnQge1xuICAgIEhFQUxUSF9DSEFOR0UgPSBcIkhFQUxUSF9DSEFOR0VcIlxufVxuXG5leHBvcnQgZW51bSBQbGF5ZXJFdmVudCB7XG4gICAgUExBWUVSX0tJTExFRCA9IFwiUExBWUVSX0tJTExFRFwiXG59IiwiaW1wb3J0IFBvc2l0aW9uZWQgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1Bvc2l0aW9uZWRcIjtcbmltcG9ydCBVbmlxdWUgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VuaXF1ZVwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgSW52ZW50b3J5IGZyb20gXCIuLi9JdGVtU3lzdGVtL0ludmVudG9yeVwiO1xuaW1wb3J0IEJhc2ljVGFyZ2V0YWJsZSBmcm9tIFwiLi4vVGFyZ2V0aW5nL0Jhc2ljVGFyZ2V0YWJsZVwiO1xuaW1wb3J0IHsgVGFyZ2V0YWJsZUVudGl0eSB9IGZyb20gXCIuLi9UYXJnZXRpbmcvVGFyZ2V0YWJsZUVudGl0eVwiO1xuaW1wb3J0IHsgVGFyZ2V0aW5nRW50aXR5IH0gZnJvbSBcIi4uL1RhcmdldGluZy9UYXJnZXRpbmdFbnRpdHlcIjtcbmltcG9ydCBCYXR0bGVyIGZyb20gXCIuL0JhdHRsZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzaWNCYXR0bGVyIGltcGxlbWVudHMgQmF0dGxlciB7XG5cbiAgICBwcm90ZWN0ZWQgX293bmVyOiBVbmlxdWUgJiBQb3NpdGlvbmVkO1xuICAgIHByb3RlY3RlZCBfdGFyZ2V0YWJsZTogVGFyZ2V0YWJsZUVudGl0eTtcbiAgICBwcm90ZWN0ZWQgX2ludmVudG9yeTogSW52ZW50b3J5O1xuXG4gICAgcHJvdGVjdGVkIF9tYXhIZWFsdGg6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgX2hlYWx0aDogbnVtYmVyO1xuICAgIHByb3RlY3RlZCBfYmF0dGxlR3JvdXA6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgX3NwZWVkOiBudW1iZXI7XG4gICAgcHJvdGVjdGVkIF9hY3RpdmU6IGJvb2xlYW47XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3Iob3duZXI6IFVuaXF1ZSAmIFBvc2l0aW9uZWQpIHtcbiAgICAgICAgdGhpcy5fb3duZXIgPSBvd25lcjtcbiAgICAgICAgdGhpcy5fdGFyZ2V0YWJsZSA9IG5ldyBCYXNpY1RhcmdldGFibGUob3duZXIpO1xuICAgICAgICB0aGlzLmludmVudG9yeSA9IG5ldyBJbnZlbnRvcnkoKTtcblxuICAgICAgICB0aGlzLm1heEhlYWx0aCA9IDA7XG4gICAgICAgIHRoaXMuaGVhbHRoID0gMDtcbiAgICAgICAgdGhpcy5iYXR0bGVHcm91cCA9IDA7XG4gICAgICAgIHRoaXMuc3BlZWQgPSAwO1xuICAgICAgICB0aGlzLmJhdHRsZXJBY3RpdmUgPSB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBwdWJsaWMgZ2V0IGlkKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9vd25lci5pZDsgfVxuXG4gICAgcHVibGljIGdldCBwb3NpdGlvbigpOiBWZWMyIHsgcmV0dXJuIHRoaXMuX3RhcmdldGFibGUucG9zaXRpb247IH1cbiAgICBwdWJsaWMgc2V0IHBvc2l0aW9uKHBvc2l0aW9uOiBWZWMyKSB7IHRoaXMuX3RhcmdldGFibGUucG9zaXRpb24gPSBwb3NpdGlvbjsgfVxuXG4gICAgcHVibGljIGdldCByZWxhdGl2ZVBvc2l0aW9uKCk6IFZlYzIge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0YWJsZS5yZWxhdGl2ZVBvc2l0aW9uO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgYmF0dGxlR3JvdXAoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX2JhdHRsZUdyb3VwOyB9XG4gICAgcHVibGljIHNldCBiYXR0bGVHcm91cChiYXR0bGVHcm91cDogbnVtYmVyKSB7IHRoaXMuX2JhdHRsZUdyb3VwID0gYmF0dGxlR3JvdXA7IH1cblxuICAgIHB1YmxpYyBnZXQgbWF4SGVhbHRoKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9tYXhIZWFsdGggfVxuICAgIHB1YmxpYyBzZXQgbWF4SGVhbHRoKG1heEhlYWx0aDogbnVtYmVyKSB7IHRoaXMuX21heEhlYWx0aCA9IG1heEhlYWx0aDsgfVxuXG4gICAgcHVibGljIGdldCBoZWFsdGgoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX2hlYWx0aDsgfVxuICAgIHB1YmxpYyBzZXQgaGVhbHRoKGhlYWx0aDogbnVtYmVyKSB7IHRoaXMuX2hlYWx0aCA9IGhlYWx0aDsgfVxuXG4gICAgcHVibGljIGdldCBzcGVlZCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fc3BlZWQ7IH1cbiAgICBwdWJsaWMgc2V0IHNwZWVkKHNwZWVkOiBudW1iZXIpIHsgdGhpcy5fc3BlZWQgPSBzcGVlZDsgfVxuXG4gICAgcHVibGljIGdldCBpbnZlbnRvcnkoKTogSW52ZW50b3J5IHsgcmV0dXJuIHRoaXMuX2ludmVudG9yeTsgfVxuICAgIHByb3RlY3RlZCBzZXQgaW52ZW50b3J5KGludmVudG9yeTogSW52ZW50b3J5KSB7IHRoaXMuX2ludmVudG9yeSA9IGludmVudG9yeTsgfVxuXG4gICAgcHVibGljIGdldCBiYXR0bGVyQWN0aXZlKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fYWN0aXZlOyB9XG4gICAgcHVibGljIHNldCBiYXR0bGVyQWN0aXZlKHZhbHVlOiBib29sZWFuKSB7IHRoaXMuX2FjdGl2ZSA9IHZhbHVlOyB9XG4gICAgXG4gICAgcHVibGljIGdldFRhcmdldGluZygpOiBUYXJnZXRpbmdFbnRpdHlbXSB7IHJldHVybiB0aGlzLl90YXJnZXRhYmxlLmdldFRhcmdldGluZygpOyB9XG4gICAgcHVibGljIGFkZFRhcmdldGluZyh0YXJnZXRpbmc6IFRhcmdldGluZ0VudGl0eSk6IHZvaWQgeyB0aGlzLl90YXJnZXRhYmxlLmFkZFRhcmdldGluZyh0YXJnZXRpbmcpOyB9XG4gICAgcHVibGljIHJlbW92ZVRhcmdldGluZyh0YXJnZXRpbmc6IFRhcmdldGluZ0VudGl0eSk6IHZvaWQgeyB0aGlzLl90YXJnZXRhYmxlLnJlbW92ZVRhcmdldGluZyh0YXJnZXRpbmcpOyB9XG59IiwiaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvU2NlbmUvU2NlbmVcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvVXRpbHMvQ29sb3JcIjtcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9MYWJlbFwiO1xuaW1wb3J0IHsgVUlFbGVtZW50VHlwZSB9IGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL1VJRWxlbWVudFR5cGVzXCI7XG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL05vZGVzL0dhbWVOb2RlXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBQb3NpdGlvbmVkIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvSW50ZXJmYWNlcy9Qb3NpdGlvbmVkXCI7XG5pbXBvcnQgVW5pcXVlIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VbmlxdWVcIjtcblxuaW50ZXJmYWNlIEhlYWx0aCB7XG4gICAgZ2V0IGhlYWx0aCgpOiBudW1iZXI7XG4gICAgZ2V0IG1heEhlYWx0aCgpOiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBIZWFsdGhCYXJPcHRpb25zIHtcbiAgICBzaXplOiBWZWMyO1xuICAgIG9mZnNldDogVmVjMjtcbn1cblxuLyoqXG4gKiBBIFVJIGNvbXBvbmVudCB0aGF0J3Mgc3VwcG9zc2VkIHRvIHJlcHJlc2VudCBhIGhlYWx0aGJhclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIZWFsdGhiYXJIVUQgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcblxuICAgIC8qKiBUaGUgc2NlbmUgYW5kIGxheWVyIGluIHRoZSBzY2VuZSB0aGUgaGVhbHRoYmFyIGlzIGluICovXG4gICAgcHJvdGVjdGVkIHNjZW5lOiBTY2VuZTtcbiAgICBwcm90ZWN0ZWQgbGF5ZXI6IHN0cmluZztcblxuICAgIC8qKiBUaGUgR2FtZU5vZGUgdGhhdCBvd25zIHRoaXMgaGVhbHRoYmFyICovXG4gICAgcHJvdGVjdGVkIG93bmVyOiBIZWFsdGggJiBQb3NpdGlvbmVkICYgVW5pcXVlO1xuXG4gICAgLyoqIFRoZSBzaXplIGFuZCBvZmZzZXQgb2YgdGhlIGhlYWx0aGJhciBmcm9tIGl0J3Mgb3duZXIncyBwb3NpdGlvbiAqL1xuICAgIHByb3RlY3RlZCBzaXplOiBWZWMyO1xuICAgIHByb3RlY3RlZCBvZmZzZXQ6IFZlYzI7XG5cbiAgICAvKiogVGhlIGFjdHVhbCBoZWFsdGhiYXIgKHRoZSBwYXJ0IHdpdGggY29sb3IpICovXG4gICAgcHJvdGVjdGVkIGhlYWx0aEJhcjogTGFiZWw7XG4gICAgLyoqIFRoZSBoZWFsdGhiYXJzIGJhY2tncm91bmQgKHRoZSBwYXJ0IHdpdGggdGhlIGJvcmRlcikgKi9cbiAgICBwcm90ZWN0ZWQgaGVhbHRoQmFyQmc6IExhYmVsO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHNjZW5lOiBTY2VuZSwgb3duZXI6IEhlYWx0aCAmIFBvc2l0aW9uZWQgJiBVbmlxdWUsIGxheWVyOiBzdHJpbmcsIG9wdGlvbnM6IEhlYWx0aEJhck9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgICAgICB0aGlzLmxheWVyID0gbGF5ZXI7XG4gICAgICAgIHRoaXMub3duZXIgPSBvd25lcjtcblxuICAgICAgICB0aGlzLnNpemUgPSBvcHRpb25zLnNpemU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQ7XG5cbiAgICAgICAgdGhpcy5oZWFsdGhCYXIgPSA8TGFiZWw+dGhpcy5zY2VuZS5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuTEFCRUwsIGxheWVyLCB7cG9zaXRpb246IHRoaXMub3duZXIucG9zaXRpb24uY2xvbmUoKS5hZGQodGhpcy5vZmZzZXQpLCB0ZXh0OiBcIlwifSk7XG4gICAgICAgIHRoaXMuaGVhbHRoQmFyLnNpemUuY29weSh0aGlzLnNpemUpO1xuICAgICAgICB0aGlzLmhlYWx0aEJhci5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5SRUQ7XG5cbiAgICAgICAgdGhpcy5oZWFsdGhCYXJCZyA9IDxMYWJlbD50aGlzLnNjZW5lLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgbGF5ZXIsIHtwb3NpdGlvbjogdGhpcy5vd25lci5wb3NpdGlvbi5jbG9uZSgpLmFkZCh0aGlzLm9mZnNldCksIHRleHQ6IFwiXCJ9KTtcbiAgICAgICAgdGhpcy5oZWFsdGhCYXJCZy5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcbiAgICAgICAgdGhpcy5oZWFsdGhCYXJCZy5ib3JkZXJDb2xvciA9IENvbG9yLkJMQUNLO1xuICAgICAgICB0aGlzLmhlYWx0aEJhckJnLmJvcmRlcldpZHRoID0gMTtcbiAgICAgICAgdGhpcy5oZWFsdGhCYXJCZy5zaXplLmNvcHkodGhpcy5zaXplKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBoZWFsdGhiYXJzIHBvc2l0aW9uIGFjY29yZGluZyB0byB0aGUgcG9zaXRpb24gb2YgaXQncyBvd25lclxuICAgICAqIEBwYXJhbSBkZWx0YVQgXG4gICAgICovXG4gICAgcHVibGljIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBcbiAgICAgICAgdGhpcy5oZWFsdGhCYXIucG9zaXRpb24uY29weSh0aGlzLm93bmVyLnBvc2l0aW9uKS5hZGQodGhpcy5vZmZzZXQpO1xuICAgICAgICB0aGlzLmhlYWx0aEJhckJnLnBvc2l0aW9uLmNvcHkodGhpcy5vd25lci5wb3NpdGlvbikuYWRkKHRoaXMub2Zmc2V0KTtcblxuICAgICAgICBsZXQgc2NhbGUgPSB0aGlzLnNjZW5lLmdldFZpZXdTY2FsZSgpO1xuICAgICAgICB0aGlzLmhlYWx0aEJhci5zY2FsZS5zY2FsZShzY2FsZSk7XG4gICAgICAgIHRoaXMuaGVhbHRoQmFyQmcuc2NhbGUuc2NhbGUoc2NhbGUpO1xuXG4gICAgICAgIGxldCB1bml0ID0gdGhpcy5oZWFsdGhCYXJCZy5zaXplLnggLyB0aGlzLm93bmVyLm1heEhlYWx0aDtcblx0XHR0aGlzLmhlYWx0aEJhci5zaXplLnNldCh0aGlzLmhlYWx0aEJhckJnLnNpemUueCAtIHVuaXQgKiAodGhpcy5vd25lci5tYXhIZWFsdGggLSB0aGlzLm93bmVyLmhlYWx0aCksIHRoaXMuaGVhbHRoQmFyQmcuc2l6ZS55KTtcblx0XHR0aGlzLmhlYWx0aEJhci5wb3NpdGlvbi5zZXQodGhpcy5oZWFsdGhCYXJCZy5wb3NpdGlvbi54IC0gKHVuaXQgLyBzY2FsZSAvIDIpICogKHRoaXMub3duZXIubWF4SGVhbHRoIC0gdGhpcy5vd25lci5oZWFsdGgpLCB0aGlzLmhlYWx0aEJhckJnLnBvc2l0aW9uLnkpO1xuXG5cdFx0dGhpcy5oZWFsdGhCYXIuYmFja2dyb3VuZENvbG9yID0gdGhpcy5vd25lci5oZWFsdGggPCB0aGlzLm93bmVyLm1heEhlYWx0aCAqIDEvNCA/IENvbG9yLlJFRCA6IHRoaXMub3duZXIuaGVhbHRoIDwgdGhpcy5vd25lci5tYXhIZWFsdGggKiAzLzQgPyBDb2xvci5ZRUxMT1cgOiBDb2xvci5HUkVFTjtcbiAgICB9XG5cbiAgICBnZXQgb3duZXJJZCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5vd25lci5pZDsgfVxuXG4gICAgc2V0IHZpc2libGUodmlzaWJsZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLmhlYWx0aEJhci52aXNpYmxlID0gdmlzaWJsZTtcbiAgICAgICAgdGhpcy5oZWFsdGhCYXJCZy52aXNpYmxlID0gdmlzaWJsZTtcbiAgICB9XG4gICAgXG5cbn0iLCJpbXBvcnQgU3ByaXRlIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZVwiO1xuaW1wb3J0IExhYmVsIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsXCI7XG5pbXBvcnQgeyBVSUVsZW1lbnRUeXBlIH0gZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvVUlFbGVtZW50VHlwZXNcIjtcblxuaW1wb3J0IFJlY2VpdmVyIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9FdmVudHMvUmVjZWl2ZXJcIjtcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnRcIjtcblxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL1V0aWxzL0NvbG9yXCI7XG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL1NjZW5lL1NjZW5lXCI7XG5pbXBvcnQgVXBkYXRlYWJsZSBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL0ludGVyZmFjZXMvVXBkYXRlYWJsZVwiO1xuaW1wb3J0IEl0ZW0gZnJvbSBcIi4uL0l0ZW1TeXN0ZW0vSXRlbVwiO1xuaW1wb3J0IEludmVudG9yeSBmcm9tIFwiLi4vSXRlbVN5c3RlbS9JbnZlbnRvcnlcIjtcblxuaW50ZXJmYWNlIEhVRE9wdGlvbnMge1xuICAgIHN0YXJ0OiBWZWMyO1xuICAgIHBhZGRpbmc6IG51bWJlcjtcbiAgICBzbG90TGF5ZXI6IHN0cmluZyxcbiAgICBpdGVtTGF5ZXI6IHN0cmluZ1xufVxuXG4vKipcbiAqIE1hbmFnZXMgdGhlIHBsYXllciBpbnZlbnRvcnkgdGhhdCBpcyBkaXNwbGF5ZWQgaW4gdGhlIFVJLiBGdW4gZmFjdCwgSSBhY3R1YWxseSBtYW5hZ2VkIHRvIHBvcnQgdGhpc1xuICogY2xhc3MgZnJvbSBteSBvbGQgQ1NFLTM4MCBwcm9qZWN0IGZyb20gbGFzdCBzZW1lc3Rlci5cbiAqIEBhdXRob3IgUGV0ZXlMdW1wa2luc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnZlbnRvcnlIVUQgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcblxuICAgIC8qIFRoZSBzY2VuZSAqL1xuICAgIHByaXZhdGUgc2NlbmU6IFNjZW5lO1xuXG4gICAgLyogVGhlIGludmVudG9yeSAqL1xuICAgIHByaXZhdGUgaW52ZW50b3J5OiBJbnZlbnRvcnlcblxuICAgIC8qIEV2ZW50IGhhbmRsaW5nIHN0dWZmICovXG4gICAgcHJpdmF0ZSByZWNlaXZlcjogUmVjZWl2ZXI7XG5cbiAgICAvKiBPcHRpb25zIGZvciBzZXR0aWduIHRoZSBzaXplLCBwYWRkaW5nLCBhbmQgc3RhcnRpbmcgcG9zaXRpb24gb2YgdGhlIFVJIHNsb3RzICovXG4gICAgcHJpdmF0ZSBzaXplOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBzdGFydDogVmVjMjtcbiAgICBwcml2YXRlIHBhZGRpbmc6IG51bWJlcjtcblxuICAgIC8qIEludmVudG9yeSBVSSBMYXllcnMgKi9cbiAgICBwcml2YXRlIHNsb3RTcHJpdGU6IHN0cmluZztcbiAgICBwcml2YXRlIGl0ZW1MYXllcjogc3RyaW5nO1xuICAgIHByaXZhdGUgc2xvdExheWVyOiBzdHJpbmc7XG5cbiAgICAvKiBVSSBDb21wb25lbnRzIGZvciB0aGUgaW52ZW50b3J5ICovXG4gICAgcHJpdmF0ZSBpdGVtU2xvdHM6IEFycmF5PFNwcml0ZT47XG4gICAgcHJpdmF0ZSBpdGVtU2xvdE51bXM6IEFycmF5PExhYmVsPjtcblxuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHNjZW5lOiBTY2VuZSwgaW52ZW50b3J5OiBJbnZlbnRvcnksIHNsb3RTcHJpdGU6IHN0cmluZywgb3B0aW9uczogSFVET3B0aW9ucykge1xuXG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICAgICAgdGhpcy5pbnZlbnRvcnkgPSBpbnZlbnRvcnk7XG4gICAgICAgIHRoaXMuc2xvdFNwcml0ZSA9IHNsb3RTcHJpdGU7XG5cbiAgICAgICAgLy8gU2V0IHRoZSBzaXplIGFuZCBwYWRkaW5nIGZvciB0aGUgaXRlbSBzbG90c1xuICAgICAgICB0aGlzLnNpemUgPSB0aGlzLmludmVudG9yeS5jYXBhY2l0eTtcbiAgICAgICAgdGhpcy5wYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gb3B0aW9ucy5zdGFydDtcbiAgICAgICAgLy8gSW5pdCB0aGUgbGF5ZXJzIGZvciB0aGUgaXRlbXNcbiAgICAgICAgdGhpcy5zbG90TGF5ZXIgPSBvcHRpb25zLnNsb3RMYXllcjtcbiAgICAgICAgdGhpcy5pdGVtTGF5ZXIgPSBvcHRpb25zLml0ZW1MYXllcjtcblxuICAgICAgICAvLyBTZXQgdXAgdGhlIHNjYWxlcyBmb3Igc2NhbGluZyB0byB0aGUgdmlld3BvcnRcbiAgICAgICAgbGV0IHNjYWxlID0gc2NlbmUuZ2V0Vmlld1NjYWxlKCk7XG4gICAgICAgIGxldCBzY2FsYXIgPSBuZXcgVmVjMihzY2FsZSwgc2NhbGUpO1xuXG4gICAgICAgIC8vIExvYWQgdGhlIGl0ZW0gc2xvdCBzcHJpdGVzXG4gICAgICAgIHRoaXMuaXRlbVNsb3RzID0gbmV3IEFycmF5PFNwcml0ZT4oKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNpemU7IGkgKz0gMSkge1xuICAgICAgICAgICAgdGhpcy5pdGVtU2xvdHNbaV0gPSB0aGlzLnNjZW5lLmFkZC5zcHJpdGUodGhpcy5zbG90U3ByaXRlLCB0aGlzLnNsb3RMYXllcik7XG4gICAgICAgICAgICB0aGlzLml0ZW1TbG90c1tpXS5zY2FsZS5kaXYoc2NhbGFyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgdGhlIHBvc2l0aW9ucyBvZiB0aGUgaXRlbSBzbG90IHNwcml0ZXNcbiAgICAgICAgbGV0IHdpZHRoID0gdGhpcy5pdGVtU2xvdHNbMF0uc2l6ZS54O1xuICAgICAgICBsZXQgaGVpZ2h0ID0gdGhpcy5pdGVtU2xvdHNbMF0uc2l6ZS55O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2l6ZTsgaSArPSAxKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1TbG90c1tpXS5wb3NpdGlvbi5zZXQodGhpcy5zdGFydC54ICsgaSood2lkdGggKyB0aGlzLnBhZGRpbmcpLCB0aGlzLnN0YXJ0LnkpLmRpdihzY2FsYXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCB0aGUgc2xvdCBudW1iZXJzIGluIHRoZSB1c2VyIGludGVyZmFjZVxuICAgICAgICB0aGlzLml0ZW1TbG90TnVtcyA9IG5ldyBBcnJheTxMYWJlbD4oKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNpemU7IGkgKz0gMSkge1xuICAgICAgICAgICAgdGhpcy5pdGVtU2xvdE51bXNbaV0gPSA8TGFiZWw+dGhpcy5zY2VuZS5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuTEFCRUwsIHRoaXMuc2xvdExheWVyLCB7cG9zaXRpb246IG5ldyBWZWMyKHRoaXMuc3RhcnQueCArIGkqKHdpZHRoICsgdGhpcy5wYWRkaW5nKSwgdGhpcy5zdGFydC55ICsgaGVpZ2h0LzIgKyA4KS5kaXYoc2NhbGFyKSwgdGV4dDogYCR7aSArIDF9YH0pO1xuICAgICAgICAgICAgdGhpcy5pdGVtU2xvdE51bXNbaV0uZm9udFNpemUgPSAxMjtcbiAgICAgICAgICAgIHRoaXMuaXRlbVNsb3ROdW1zW2ldLmZvbnQgPSBcIkNvdXJpZXJcIjtcbiAgICAgICAgICAgIHRoaXMuaXRlbVNsb3ROdW1zW2ldLnRleHRDb2xvciA9IENvbG9yLldISVRFO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaXRlbSBvZiB0aGlzLmludmVudG9yeS5pdGVtcygpKSB7XG4gICAgICAgICAgICBpdGVtLnBvc2l0aW9uLmNvcHkodGhpcy5pdGVtU2xvdHNbaW5kZXhdLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIGl0ZW0udmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICB9XG4gICAgfVxuXG59IiwiaW1wb3J0IFVuaXF1ZSBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL0ludGVyZmFjZXMvVW5pcXVlXCI7XG5pbXBvcnQgRW1pdHRlciBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvRXZlbnRzL0VtaXR0ZXJcIjtcbmltcG9ydCBJdGVtIGZyb20gXCIuL0l0ZW1cIjtcbmltcG9ydCBIZWFsdGhwYWNrIGZyb20gXCIuL0l0ZW1zL0hlYWx0aHBhY2tcIjtcblxuLyoqXG4gKiBBbiBpbnZlbnRvcnkgaXMgYSBjb2xsZWN0aW9uIG9mIGl0ZW1zLiBBbGwgaXRlbXMgaW4gdGhlIGludmVudG9yeSBtdXN0IGJlIHJlZ2lzdGVyZWQgd2l0aFxuICogdGhlIEludmVudG9yeXMgSXRlbU1hbmFnZXIgY2xhc3MuIFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnZlbnRvcnkgaW1wbGVtZW50cyBVbmlxdWUge1xuXG4gICAgLyoqIFRoZSBpZCBudW1iZXIgb2YgdGhlIG5leHQgaW52ZW50b3J5ICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgTkVYVF9JRDogbnVtYmVyID0gMDtcblxuICAgIC8qKiBUaGUgaWQgb2YgdGhpcyBpbnZlbnRvcnkgKi9cbiAgICBwcm90ZWN0ZWQgX19pZDogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSBjb2xsZWN0aW9uIG9mIGl0ZW1zIGluIHRoZSBpbnZlbnRvcnkgKi9cbiAgICBwcm90ZWN0ZWQgX2ludmVudG9yeTogTWFwPG51bWJlciwgSXRlbT47XG5cbiAgICAvKiogQSBmbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgKi9cbiAgICBwcm90ZWN0ZWQgX2RpcnR5OiBib29sZWFuO1xuXG4gICAgLyoqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBpdGVtcyB0aGlzIGludmVudG9yeSBjYW4gaG9sZCAqL1xuICAgIHByb3RlY3RlZCBfY2FwYWNpdHk6IG51bWJlcjtcblxuICAgIC8qKiBUaGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoaXMgaW52ZW50b3J5ICovXG4gICAgcHJvdGVjdGVkIF9zaXplOiBudW1iZXI7XG5cbiAgICAvKiogVGhlIGV2ZW50IHRvIGZpcmUgd2hlbiB0aGlzIGludmVudG9yeSBjaGFuZ2VzICovXG4gICAgcHJvdGVjdGVkIF9vbkNoYW5nZTogc3RyaW5nIHwgbnVsbDtcblxuICAgIC8qKiBBbiBlbWl0dGVyIHVzZWQgdG8gZW1pdCBldmVudHMgd2hlbiB0aGlzIGludmVudG9yeSBjaGFuZ2VzICovXG4gICAgcHJvdGVjdGVkIF9lbWl0dGVyOiBFbWl0dGVyO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKGNhcGFjaXR5OiBudW1iZXIgPSAxMCkge1xuICAgICAgICB0aGlzLl9faWQgPSBJbnZlbnRvcnkuTkVYVF9JRCBcbiAgICAgICAgSW52ZW50b3J5Lk5FWFRfSUQgKz0gMTtcblxuICAgICAgICB0aGlzLmludmVudG9yeSA9IG5ldyBNYXA8bnVtYmVyLCBJdGVtPigpO1xuICAgICAgICB0aGlzLl9lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcblxuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICB0aGlzLmNhcGFjaXR5ID0gY2FwYWNpdHk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IG51bGw7XG4gICAgICAgIFxuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgaWQoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX19pZDsgfVxuXG4gICAgcHVibGljIGdldCBkaXJ0eSgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX2RpcnR5OyB9XG4gICAgcHJvdGVjdGVkIHNldCBkaXJ0eShkaXJ0eTogYm9vbGVhbikgeyB0aGlzLl9kaXJ0eSA9IGRpcnR5OyB9XG5cbiAgICBwdWJsaWMgZ2V0IHNpemUoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX3NpemU7IH1cbiAgICBwcm90ZWN0ZWQgc2V0IHNpemUoc2l6ZTogbnVtYmVyKSB7IHRoaXMuX3NpemUgPSBzaXplOyB9XG5cbiAgICBwdWJsaWMgZ2V0IGNhcGFjaXR5KCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9jYXBhY2l0eTsgfVxuICAgIHByb3RlY3RlZCBzZXQgY2FwYWNpdHkoY2FwYWNpdHk6IG51bWJlcikgeyB0aGlzLl9jYXBhY2l0eSA9IGNhcGFjaXR5OyB9XG5cbiAgICBwdWJsaWMgZ2V0IG9uQ2hhbmdlKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLl9vbkNoYW5nZTsgfVxuICAgIHB1YmxpYyBzZXQgb25DaGFuZ2Uob25DaGFuZ2U6IHN0cmluZykgeyB0aGlzLl9vbkNoYW5nZSA9IG9uQ2hhbmdlOyB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0IGludmVudG9yeSgpOiBNYXA8bnVtYmVyLCBJdGVtPiB7IHJldHVybiB0aGlzLl9pbnZlbnRvcnk7IH1cbiAgICBwcm90ZWN0ZWQgc2V0IGludmVudG9yeShpbnZlbnRvcnk6IE1hcDxudW1iZXIsIEl0ZW0+KSB7IHRoaXMuX2ludmVudG9yeSA9IGludmVudG9yeTsgfVxuXG4gICAgcHJvdGVjdGVkIGdldCBlbWl0dGVyKCk6IEVtaXR0ZXIgeyByZXR1cm4gdGhpcy5fZW1pdHRlcjsgfVxuICAgIHByb3RlY3RlZCBzZXQgZW1pdHRlcihlbWl0dGVyOiBFbWl0dGVyKSB7IHRoaXMuX2VtaXR0ZXIgPSBlbWl0dGVyOyB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFuIGl0ZW0gZnJvbSB0aGlzIGludmVudG9yeSBieSBpZC5cbiAgICAgKiBAcGFyYW0gaWQgdGhlIGlkIG9mIHRoZSBpdGVtIHRvIGdldFxuICAgICAqIEByZXR1cm5zIHRoZSBpdGVtIGlmIGl0IGV4aXN0czsgbnVsbCBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0KGlkOiBudW1iZXIpOiBJdGVtIHwgbnVsbCB7XG4gICAgICAgIGlmICghdGhpcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbnZlbnRvcnkuZ2V0KGlkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGl0ZW0gdG8gdGhpcyBpbnZlbnRvcnlcbiAgICAgKiBAcGFyYW0gaXRlbSBhZGRzIGFuIGl0ZW0gdG8gdGhlIGludmVudG9yeSB3aXRoIHRoZSBrZXkgb2YgdGhlIGl0ZW1zIG93bmVyXG4gICAgICogQHJldHVybnMgaWYgdGhlIEl0ZW0gd2FzIHN1Y2Nlc3NmdWxseSBhZGRlZCB0byB0aGUgaW52ZW50b3J5OyBudWxsIG90aGVyd2lzZVxuICAgICAqL1xuICAgIHB1YmxpYyBhZGQoaXRlbTogSXRlbSk6IEl0ZW0gfCBudWxsIHsgXG4gICAgICAgIGlmICh0aGlzLmhhcyhpdGVtLmlkKSB8fCB0aGlzLnNpemUgPj0gdGhpcy5jYXBhY2l0eSB8fCBpdGVtLmludmVudG9yeSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnZlbnRvcnkuc2V0KGl0ZW0uaWQsIGl0ZW0pO1xuICAgICAgICB0aGlzLnNpemUgKz0gMTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgICAgICAgaXRlbS5pbnZlbnRvcnkgPSB0aGlzO1xuICAgICAgICBpdGVtLnZpc2libGUgPSBmYWxzZTtcblxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYW4gaXRlbSB3aXRoIHRoZSBnaXZlbiBpZCBudW1iZXIgZXhpc3RzIGluIHRoaXMgaW52ZW50b3J5LlxuICAgICAqIEBwYXJhbSBpZCB0aGUgaWQgb2YgdGhlIGl0ZW0gaW4gdGhlIGludmVudG9yeVxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGl0ZW0gd2l0aCB0aGUgaWQgZXhpc3RzOyBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBwdWJsaWMgaGFzKGlkOiBudW1iZXIpOiBib29sZWFuIHsgXG4gICAgICAgIHJldHVybiB0aGlzLmludmVudG9yeS5oYXMoaWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGl0ZW0gd2l0aCB0aGUgZ2l2ZW4gaWQgbnVtYmVyIGZyb20gdGhpcyBpbnZlbnRvcnlcbiAgICAgKiBAcGFyYW0gaWQgdGhlIGlkIG9mIHRoZSBpdGVtXG4gICAgICogQHJldHVybnMgdGhlIGl0ZW0gdGhhdCB3YXMgcmVtb3ZlZCBvciBudWxsIFxuICAgICAqL1xuICAgIHB1YmxpYyByZW1vdmUoaWQ6IG51bWJlcik6IEl0ZW0gfCBudWxsIHsgXG4gICAgICAgIGlmICghdGhpcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaXRlbTogSXRlbSA9IHRoaXMuZ2V0KGlkKTtcbiAgICAgICAgdGhpcy5pbnZlbnRvcnkuZGVsZXRlKGlkKTtcbiAgICAgICAgdGhpcy5zaXplIC09IDE7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlXG5cbiAgICAgICAgaXRlbS5pbnZlbnRvcnkgPSBudWxsO1xuXG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIHB1YmxpYyBpdGVtcygpOiBJdGVyYWJsZUl0ZXJhdG9yPEl0ZW0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW52ZW50b3J5LnZhbHVlcygpXG4gICAgfVxuXG4gICAgcHVibGljIGZpbmQoZnVuYzogKGl0ZW06IEl0ZW0pID0+IGJvb2xlYW4pOiBJdGVtIHwgbnVsbCB7XG4gICAgICAgIGxldCBpdGVtID0gQXJyYXkuZnJvbSh0aGlzLmludmVudG9yeS52YWx1ZXMoKSkuZmluZChmdW5jKTtcbiAgICAgICAgcmV0dXJuIGl0ZW0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBpdGVtO1xuICAgIH1cblxuICAgIHB1YmxpYyBjbGVhbigpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5vbkNoYW5nZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLmZpcmVFdmVudCh0aGlzLm9uQ2hhbmdlLCB7IGlkOiB0aGlzLmlkLCBpbnZlbnRvcnk6IHRoaXMgfSk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IFVuaXF1ZSBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL0ludGVyZmFjZXMvVW5pcXVlXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBFbWl0dGVyIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9FdmVudHMvRW1pdHRlclwiO1xuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HYW1lTm9kZVwiO1xuaW1wb3J0IFNwcml0ZSBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvTm9kZXMvU3ByaXRlcy9TcHJpdGVcIjtcbmltcG9ydCBMYXllciBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvU2NlbmUvTGF5ZXJcIjtcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvU2NlbmUvU2NlbmVcIjtcbmltcG9ydCBCYXNpY1RhcmdldGFibGUgZnJvbSBcIi4uL1RhcmdldGluZy9CYXNpY1RhcmdldGFibGVcIjtcbmltcG9ydCBCYXNpY1RhcmdldGluZyBmcm9tIFwiLi4vVGFyZ2V0aW5nL0Jhc2ljVGFyZ2V0aW5nXCI7XG5cbmltcG9ydCBIVzRTY2VuZSBmcm9tIFwiLi4vLi4vU2NlbmVzL0hXNFNjZW5lXCI7XG5pbXBvcnQgSW52ZW50b3J5IGZyb20gXCIuL0ludmVudG9yeVwiO1xuaW1wb3J0IHsgVGFyZ2V0YWJsZUVudGl0eSB9IGZyb20gXCIuLi9UYXJnZXRpbmcvVGFyZ2V0YWJsZUVudGl0eVwiO1xuaW1wb3J0IHsgVGFyZ2V0aW5nRW50aXR5IH0gZnJvbSBcIi4uL1RhcmdldGluZy9UYXJnZXRpbmdFbnRpdHlcIjtcblxuXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBJdGVtIGltcGxlbWVudHMgVW5pcXVlLCBUYXJnZXRhYmxlRW50aXR5IHtcblxuICAgIHByb3RlY3RlZCBzcHJpdGU6IFNwcml0ZTtcbiAgICBwcm90ZWN0ZWQgZW1pdHRlcjogRW1pdHRlcjtcblxuICAgIHByb3RlY3RlZCBfaW52ZW50b3J5OiBJbnZlbnRvcnkgfCBudWxsO1xuICAgIHByb3RlY3RlZCBfdGFyZ2V0YWJsZTogVGFyZ2V0YWJsZUVudGl0eTtcblxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihzcHJpdGU6IFNwcml0ZSl7IFxuICAgICAgICB0aGlzLnNwcml0ZSA9IHNwcml0ZTtcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcblxuICAgICAgICB0aGlzLl9pbnZlbnRvcnkgPSBudWxsO1xuICAgICAgICB0aGlzLl90YXJnZXRhYmxlID0gbmV3IEJhc2ljVGFyZ2V0YWJsZSh0aGlzLnNwcml0ZSk7XG4gICAgfVxuXG4gICAgZ2V0VGFyZ2V0aW5nKCk6IFRhcmdldGluZ0VudGl0eVtdIHsgXG4gICAgICAgIHJldHVybiB0aGlzLl90YXJnZXRhYmxlLmdldFRhcmdldGluZygpOyBcbiAgICB9XG4gICAgYWRkVGFyZ2V0aW5nKHRhcmdldGluZzogVGFyZ2V0aW5nRW50aXR5KTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3RhcmdldGFibGUuYWRkVGFyZ2V0aW5nKHRhcmdldGluZyk7XG4gICAgfVxuICAgIHJlbW92ZVRhcmdldGluZyh0YXJnZXRpbmc6IFRhcmdldGluZ0VudGl0eSk6IHZvaWQge1xuICAgICAgICB0aGlzLl90YXJnZXRhYmxlLnJlbW92ZVRhcmdldGluZyh0YXJnZXRpbmcpO1xuICAgIH1cbiAgICBcbiAgICBwdWJsaWMgZ2V0IHJlbGF0aXZlUG9zaXRpb24oKTogVmVjMiB7IHJldHVybiB0aGlzLnNwcml0ZS5yZWxhdGl2ZVBvc2l0aW9uOyB9XG5cbiAgICBwdWJsaWMgZ2V0IGlkKCk6IG51bWJlciB7IHJldHVybiB0aGlzLnNwcml0ZS5pZDsgfVxuXG4gICAgcHVibGljIGdldCBwb3NpdGlvbigpOiBWZWMyIHsgcmV0dXJuIHRoaXMuc3ByaXRlLnBvc2l0aW9uOyB9XG5cbiAgICBwdWJsaWMgZ2V0IHZpc2libGUoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLnNwcml0ZS52aXNpYmxlOyB9XG4gICAgcHVibGljIHNldCB2aXNpYmxlKHZhbHVlOiBib29sZWFuKSB7IHRoaXMuc3ByaXRlLnZpc2libGUgPSB2YWx1ZTsgfVxuXG4gICAgcHVibGljIGdldCBpbnZlbnRvcnkoKTogSW52ZW50b3J5IHwgbnVsbCB7IHJldHVybiB0aGlzLl9pbnZlbnRvcnk7IH1cbiAgICBwdWJsaWMgc2V0IGludmVudG9yeSh2YWx1ZTogSW52ZW50b3J5IHwgbnVsbCkgeyB0aGlzLl9pbnZlbnRvcnkgPSB2YWx1ZTsgfVxuXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgU3ByaXRlIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZVwiO1xuaW1wb3J0IEhXNFNjZW5lIGZyb20gXCIuLi8uLi8uLi9TY2VuZXMvSFc0U2NlbmVcIjtcbmltcG9ydCBJdGVtIGZyb20gXCIuLi9JdGVtXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhlYWx0aHBhY2sgZXh0ZW5kcyBJdGVtIHtcbiAgICBcbiAgICBwcm90ZWN0ZWQgaHA6IG51bWJlcjtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihzcHJpdGU6IFNwcml0ZSkge1xuICAgICAgICBzdXBlcihzcHJpdGUpO1xuICAgICAgICB0aGlzLmhwID0gNTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGhlYWx0aCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5ocDsgfVxuICAgIHB1YmxpYyBzZXQgaGVhbHRoKGhwOiBudW1iZXIpIHsgdGhpcy5ocCA9IGhwOyB9XG5cblxufSIsImltcG9ydCBBQUJCIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvU2hhcGVzL0FBQkJcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IEdhbWVOb2RlLCB7IFR3ZWVuYWJsZVByb3BlcnRpZXMgfSBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvTm9kZXMvR2FtZU5vZGVcIjtcbmltcG9ydCBHcmFwaGljIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljXCI7XG5pbXBvcnQgeyBHcmFwaGljVHlwZSB9IGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljcy9HcmFwaGljVHlwZXNcIjtcbmltcG9ydCBMaW5lIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljcy9MaW5lXCI7XG5pbXBvcnQgU3ByaXRlIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZVwiO1xuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9TY2VuZS9TY2VuZVwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9VdGlscy9Db2xvclwiO1xuaW1wb3J0IHsgRWFzZUZ1bmN0aW9uVHlwZSB9IGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9VdGlscy9FYXNlRnVuY3Rpb25zXCI7XG5pbXBvcnQgSFc0U2NlbmUgZnJvbSBcIi4uLy4uLy4uL1NjZW5lcy9IVzRTY2VuZVwiO1xuaW1wb3J0IEl0ZW0gZnJvbSBcIi4uL0l0ZW1cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGFzZXJHdW4gZXh0ZW5kcyBJdGVtIHtcblxuICAgIHB1YmxpYyBkYW1hZ2U6IG51bWJlcjtcblxuICAgIHByb3RlY3RlZCBfbGFzZXI6IExpbmVcbiAgICBwcm90ZWN0ZWQgX2RpcmVjdGlvbjogVmVjMjtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihzcHJpdGU6IFNwcml0ZSwgbGFzZXI6IExpbmUpIHtcbiAgICAgICAgc3VwZXIoc3ByaXRlKTtcbiAgICAgICAgdGhpcy5fbGFzZXIgPSBsYXNlcjtcbiAgICAgICAgdGhpcy5fbGFzZXIuc3RhcnQuY29weShWZWMyLlpFUk9fU1RBVElDKTtcbiAgICAgICAgdGhpcy5fbGFzZXIuZW5kLmNvcHkoVmVjMi5aRVJPX1NUQVRJQyk7XG4gICAgICAgIHRoaXMuX2xhc2VyLmNvbG9yID0gQ29sb3IuR1JFRU47XG4gICAgICAgIHRoaXMuX2xhc2VyLnR3ZWVucy5hZGQoXCJmYWRlXCIsIHtcbiAgICAgICAgICAgIHN0YXJ0RGVsYXk6IDAsXG4gICAgICAgICAgICBkdXJhdGlvbjogMzAwLFxuICAgICAgICAgICAgZWZmZWN0czogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IFR3ZWVuYWJsZVByb3BlcnRpZXMuYWxwaGEsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiAxLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIGVhc2U6IEVhc2VGdW5jdGlvblR5cGUuT1VUX1NJTkVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgb25FbmQ6IFwiTGFzZXIgZmFkZWRcIlxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gVmVjMi5aRVJPO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgY3JlYXRlKHNwcml0ZTogU3ByaXRlLCBsYXNlcjogTGluZSk6IExhc2VyR3VuIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYXNlckd1bihzcHJpdGUsIGxhc2VyKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGRpcmVjdGlvbigpOiBWZWMyIHsgcmV0dXJuIHRoaXMuX2RpcmVjdGlvbjsgfVxuICAgIHB1YmxpYyBnZXQgbGFzZXJTdGFydCgpOiBWZWMyIHsgcmV0dXJuIHRoaXMuX2xhc2VyLnN0YXJ0OyB9XG4gICAgcHVibGljIGdldCBsYXNlckVuZCgpOiBWZWMyIHsgcmV0dXJuIHRoaXMuX2xhc2VyLmVuZDsgfVxuXG4gICAgcHVibGljIHBsYXlTaG9vdEFuaW1hdGlvbigpOiB2b2lkIHsgdGhpcy5fbGFzZXIudHdlZW5zLnBsYXkoXCJmYWRlXCIpOyB9XG4gICAgXG59IiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzaWNGaW5kZXI8VD4ge1xuXG4gICAgcHJvdGVjdGVkIHJlZHVjZXI6ICh0MTogVCwgdDI6IFQpID0+IFQgfCBudWxsO1xuICAgIHByb3RlY3RlZCBmaWx0ZXJzOiAoKHQ6IFQpID0+IGJvb2xlYW4pW107XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IocmVkdWNlcjogKHQxOiBULCB0MjogVCkgPT4gVCA9IG51bGwsIC4uLmZpbHRlcnM6ICgodDogVCkgPT4gYm9vbGVhbilbXSkge1xuICAgICAgICB0aGlzLnJlZHVjZXIgPSByZWR1Y2VyO1xuICAgICAgICB0aGlzLmZpbHRlcnMgPSBmaWx0ZXJzO1xuICAgIH1cblxuICAgIHB1YmxpYyBmaW5kKHRhcmdldHM6IFJlYWRvbmx5PFRbXT4pOiBUIHwgbnVsbCB7XG4gICAgICAgIGxldCBmaWx0ZXJlZCA9IHRhcmdldHMuZmlsdGVyKHRhcmdldCA9PiB0aGlzLmZpbHRlcnMuZXZlcnkoZmlsdGVyID0+IGZpbHRlcih0YXJnZXQpKSk7XG4gICAgICAgIHJldHVybiBmaWx0ZXJlZC5sZW5ndGggPT09IDAgPyBudWxsIDogdGhpcy5yZWR1Y2VyID09PSBudWxsID8gZmlsdGVyZWRbMF0gOiBmaWx0ZXJlZC5yZWR1Y2UodGhpcy5yZWR1Y2VyKTtcbiAgICB9XG5cbn0iLCJpbXBvcnQgUG9zaXRpb25lZCBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL0ludGVyZmFjZXMvUG9zaXRpb25lZFwiO1xuaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvVXRpbHMvTWF0aFV0aWxzXCI7XG5pbXBvcnQgQmF0dGxlciBmcm9tIFwiLi4vQmF0dGxlU3lzdGVtL0JhdHRsZXJcIjtcbmltcG9ydCBJdGVtIGZyb20gXCIuLi9JdGVtU3lzdGVtL0l0ZW1cIjtcbmltcG9ydCB7IFRhcmdldGFibGVFbnRpdHkgfSBmcm9tIFwiLi4vVGFyZ2V0aW5nL1RhcmdldGFibGVFbnRpdHlcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIEJhdHRsZXJBY3RpdmVGaWx0ZXIoKTogKGI6IEJhdHRsZXIpID0+IGJvb2xlYW4ge1xuICAgIHJldHVybiAoYjogQmF0dGxlcikgPT4gYi5iYXR0bGVyQWN0aXZlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gQmF0dGxlckhlYWx0aEZpbHRlcihtaW46IG51bWJlciwgbWF4OiBudW1iZXIpOiAoYjogQmF0dGxlcikgPT4gYm9vbGVhbiB7XG4gICAgcmV0dXJuIChiOiBCYXR0bGVyKSA9PiB7IHJldHVybiBNYXRoVXRpbHMuYmV0d2VlbihtaW4sIG1heCwgYi5oZWFsdGgsIHRydWUpOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBCYXR0bGVyR3JvdXBGaWx0ZXIoZ3JvdXBzOiBudW1iZXJbXSwgd2hpdGVsaXN0OiBib29sZWFuID0gdHJ1ZSk6IChiOiBCYXR0bGVyKSA9PiBib29sZWFuIHtcbiAgICByZXR1cm4gd2hpdGVsaXN0ID8gKGI6IEJhdHRsZXIpID0+IHsgcmV0dXJuIGdyb3Vwcy5pbmNsdWRlcyhiLmJhdHRsZUdyb3VwKTsgfSA6IChiOiBCYXR0bGVyKSA9PiB7IHJldHVybiAhZ3JvdXBzLmluY2x1ZGVzKGIuYmF0dGxlR3JvdXApOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBBbGx5RmlsdGVyKGJhdHRsZXI6IEJhdHRsZXIpOiAob3RoZXI6IEJhdHRsZXIpID0+IGJvb2xlYW4ge1xuICAgIHJldHVybiAob3RoZXI6IEJhdHRsZXIpID0+IHsgcmV0dXJuIGJhdHRsZXIuYmF0dGxlR3JvdXAgPT09IG90aGVyLmJhdHRsZUdyb3VwOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBFbmVteUZpbHRlcihiYXR0bGVyOiBCYXR0bGVyKTogKG90aGVyOiBCYXR0bGVyKSA9PiBib29sZWFuIHtcbiAgICByZXR1cm4gKG90aGVyOiBCYXR0bGVyKSA9PiB7IHJldHVybiBiYXR0bGVyLmJhdHRsZUdyb3VwICE9PSBvdGhlci5iYXR0bGVHcm91cDsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gUmFuZ2VGaWx0ZXIocG9zaXRpb25lZDogUG9zaXRpb25lZCwgbWluRGlzdFNxOiBudW1iZXIsIG1heERpc3RTcTogbnVtYmVyKTogKHQ6IFRhcmdldGFibGVFbnRpdHkpID0+IGJvb2xlYW4ge1xuICAgIHJldHVybiAodDogVGFyZ2V0YWJsZUVudGl0eSkgPT4geyBcbiAgICAgICAgbGV0IGRpc3RTcSA9IHQucG9zaXRpb24uZGlzdGFuY2VTcVRvKHBvc2l0aW9uZWQucG9zaXRpb24pXG4gICAgICAgIHJldHVybiBkaXN0U3EgPiBtaW5EaXN0U3EgJiYgZGlzdFNxIDwgbWF4RGlzdFNxO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEl0ZW1GaWx0ZXIoY29uc3RyOiBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBJdGVtKTogKGk6IEl0ZW0pID0+IGJvb2xlYW4ge1xuICAgIHJldHVybiAoaTogSXRlbSkgPT4geyByZXR1cm4gaS5jb25zdHJ1Y3RvciA9PT0gY29uc3RyOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBWaXNpYmxlSXRlbUZpbHRlcigpOiAoaTogSXRlbSkgPT4gYm9vbGVhbiB7XG4gICAgcmV0dXJuIChpOiBJdGVtKSA9PiBpLnZpc2libGU7XG59IiwiaW1wb3J0IFBvc2l0aW9uZWQgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1Bvc2l0aW9uZWRcIjtcbmltcG9ydCBCYXR0bGVyIGZyb20gXCIuLi9CYXR0bGVTeXN0ZW0vQmF0dGxlclwiO1xuaW1wb3J0IHsgVGFyZ2V0YWJsZUVudGl0eSB9IGZyb20gXCIuLi9UYXJnZXRpbmcvVGFyZ2V0YWJsZUVudGl0eVwiO1xuXG5leHBvcnQgZnVuY3Rpb24gQ2xvc2VzdFBvc2l0aW9uZWQ8UCBleHRlbmRzIFBvc2l0aW9uZWQ+KHBvc2l0aW9uZWQ6IFBvc2l0aW9uZWQpOiAocDE6IFAsIHAyOiBQKSA9PiBQIHtcbiAgICByZXR1cm4gKHAxOiBQLCBwMjogUCk6IFAgPT4geyBcbiAgICAgICAgcmV0dXJuIHAxLnBvc2l0aW9uLmRpc3RhbmNlU3FUbyhwb3NpdGlvbmVkLnBvc2l0aW9uKSA8IHAyLnBvc2l0aW9uLmRpc3RhbmNlU3FUbyhwb3NpdGlvbmVkLnBvc2l0aW9uKSA/IHAxIDogcDI7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gTG93ZXN0SGVhbHRoQmF0dGxlcihiMTogQmF0dGxlciwgYjI6IEJhdHRsZXIpOiBCYXR0bGVyIHtcbiAgICByZXR1cm4gYjEuaGVhbHRoIDwgYjIuaGVhbHRoID8gYjEgOiBiMlxufSIsImltcG9ydCBQb3NpdGlvbmVkIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvSW50ZXJmYWNlcy9Qb3NpdGlvbmVkXCI7XG5pbXBvcnQgVW5pcXVlIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VbmlxdWVcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IHsgVGFyZ2V0YWJsZUVudGl0eSB9IGZyb20gXCIuL1RhcmdldGFibGVFbnRpdHlcIjtcbmltcG9ydCB7IFRhcmdldGluZ0VudGl0eSB9IGZyb20gXCIuL1RhcmdldGluZ0VudGl0eVwiO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2ljVGFyZ2V0YWJsZSBpbXBsZW1lbnRzIFRhcmdldGFibGVFbnRpdHkge1xuICAgIHByb3RlY3RlZCBvd25lcjogUG9zaXRpb25lZDtcblxuICAgIHByb3RlY3RlZCB0YXJnZXRpbmc6IE1hcDxudW1iZXIsIFRhcmdldGluZ0VudGl0eT47XG5cbiAgICBjb25zdHJ1Y3Rvcihvd25lcjogUG9zaXRpb25lZCkge1xuICAgICAgICB0aGlzLm93bmVyID0gb3duZXI7XG4gICAgICAgIHRoaXMudGFyZ2V0aW5nID0gbmV3IE1hcDxudW1iZXIsIFRhcmdldGluZ0VudGl0eT4oKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0VGFyZ2V0aW5nKCk6IFRhcmdldGluZ0VudGl0eVtdIHsgXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMudGFyZ2V0aW5nLnZhbHVlcygpKTsgXG4gICAgfVxuXG4gICAgcHVibGljIGFkZFRhcmdldGluZyh0YXJnZXRpbmc6IFRhcmdldGluZ0VudGl0eSk6IHZvaWQge1xuICAgICAgICB0aGlzLnRhcmdldGluZy5zZXQodGFyZ2V0aW5nLmlkLCB0YXJnZXRpbmcpO1xuICAgIH1cbiAgICBcbiAgICBwdWJsaWMgcmVtb3ZlVGFyZ2V0aW5nKHRhcmdldGluZzogVGFyZ2V0aW5nRW50aXR5KTogdm9pZCB7XG4gICAgICAgIHRoaXMudGFyZ2V0aW5nLmRlbGV0ZSh0YXJnZXRpbmcuaWQpO1xuICAgIH1cblxuICAgIGdldCBwb3NpdGlvbigpOiBWZWMyIHsgcmV0dXJuIHRoaXMub3duZXIucG9zaXRpb247IH1cbiAgICBnZXQgcmVsYXRpdmVQb3NpdGlvbigpOiBWZWMyIHsgcmV0dXJuIHRoaXMub3duZXIucmVsYXRpdmVQb3NpdGlvbjsgfVxuXG59IiwiaW1wb3J0IFVuaXF1ZSBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL0ludGVyZmFjZXMvVW5pcXVlXCI7XG5pbXBvcnQgeyBUYXJnZXRhYmxlRW50aXR5IH0gZnJvbSBcIi4vVGFyZ2V0YWJsZUVudGl0eVwiO1xuaW1wb3J0IHsgVGFyZ2V0aW5nRW50aXR5IH0gZnJvbSBcIi4vVGFyZ2V0aW5nRW50aXR5XCI7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzaWNUYXJnZXRpbmcgaW1wbGVtZW50cyBUYXJnZXRpbmdFbnRpdHkge1xuXG4gICAgcHJvdGVjdGVkIG93bmVyOiBVbmlxdWU7XG4gICAgcHJvdGVjdGVkIF90YXJnZXQ6IFRhcmdldGFibGVFbnRpdHkgfCBudWxsO1xuXG4gICAgY29uc3RydWN0b3Iob3duZXI6IFVuaXF1ZSkge1xuICAgICAgICB0aGlzLm93bmVyID0gb3duZXI7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBjbGVhclRhcmdldCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMudGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmVUYXJnZXRpbmcodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0gbnVsbDtcbiAgICB9XG4gICAgc2V0VGFyZ2V0KHRhcmdldGFibGU6IFRhcmdldGFibGVFbnRpdHkpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMudGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmVUYXJnZXRpbmcodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXRhYmxlO1xuICAgICAgICB0aGlzLnRhcmdldC5hZGRUYXJnZXRpbmcodGhpcyk7XG4gICAgfVxuICAgIGdldFRhcmdldCgpOiBUYXJnZXRhYmxlRW50aXR5IHtcbiAgICAgICAgaWYgKHRoaXMudGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUYXJnZXQgbm90IHNldCFcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0O1xuICAgIH1cblxuICAgIGhhc1RhcmdldCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0ICE9PSBudWxsO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgaWQoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMub3duZXIuaWQ7IH1cblxuICAgIHByb3RlY3RlZCBnZXQgdGFyZ2V0KCk6IFRhcmdldGFibGVFbnRpdHkgfCBudWxsIHsgcmV0dXJuIHRoaXMuX3RhcmdldDsgfVxuICAgIHByb3RlY3RlZCBzZXQgdGFyZ2V0KHRhcmdldDogVGFyZ2V0YWJsZUVudGl0eSB8IG51bGwpIHsgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0OyB9XG59IiwiaW1wb3J0IFBvc2l0aW9uZWQgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1Bvc2l0aW9uZWRcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xuXG4vKipcbiAqIEEgd3JhcHBlciBjbGFzcyBhcm91bmQgYSBWZWMyIGltcGxlbWVudGluZyB0aGUgUG9zaXRpb25lZCBpbnRlcmZhY2UuIFRoZSBwb2ludFxuICogb2YgdGhpcyBjbGFzcyBpcyB0byBsZXQgeW91IHVzZSBhbiBhcmJpdHJhcnkgcG9zaXRpb24gYXMgYSBUYXJnZXRhYmxlRW50aXR5LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb3NpdGlvbiBpbXBsZW1lbnRzIFBvc2l0aW9uZWQge1xuXG4gICAgcHJpdmF0ZSBfcG9zaXRpb246IFZlYzI7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoeDogbnVtYmVyLCB5OiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fcG9zaXRpb24gPSBuZXcgVmVjMih4LCB5KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHBvc2l0aW9uKCk6IFZlYzIge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9zaXRpb247XG4gICAgfVxuXG4gICAgcmVsYXRpdmVQb3NpdGlvbjogVmVjMjtcbiAgICBcbn0iLCJpbXBvcnQgU3RhY2sgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9Db2xsZWN0aW9ucy9TdGFja1wiO1xuaW1wb3J0IEVkZ2VOb2RlIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvR3JhcGhzL0VkZ2VOb2RlXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvR2FtZU5vZGVcIjtcbmltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9UaWxlbWFwXCI7XG5pbXBvcnQgT3J0aG9nb25hbFRpbGVtYXAgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL1RpbGVtYXBzL09ydGhvZ29uYWxUaWxlbWFwXCI7XG5pbXBvcnQgTmF2aWdhdGlvbk1hbmFnZXIgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1BhdGhmaW5kaW5nL05hdmlnYXRpb25NYW5hZ2VyXCI7XG5pbXBvcnQgTmF2aWdhdGlvblBhdGggZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1BhdGhmaW5kaW5nL05hdmlnYXRpb25QYXRoXCI7XG5pbXBvcnQgTmF2bWVzaCBmcm9tIFwiLi4vLi4vV29sZmllMkQvUGF0aGZpbmRpbmcvTmF2bWVzaFwiO1xuaW1wb3J0IE5hdlBhdGhTdHJhdCBmcm9tIFwiLi4vLi4vV29sZmllMkQvUGF0aGZpbmRpbmcvU3RyYXRlZ2llcy9OYXZpZ2F0aW9uU3RyYXRlZ3lcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBWaWV3cG9ydCBmcm9tIFwiLi4vLi4vV29sZmllMkQvU2NlbmVHcmFwaC9WaWV3cG9ydFwiO1xuaW1wb3J0IEdyYXBoVXRpbHMgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1V0aWxzL0dyYXBoVXRpbHNcIjtcblxuLy8gVE9ETyBDb25zdHJ1Y3QgYSBOYXZpZ2F0aW9uUGF0aCBvYmplY3QgdXNpbmcgQSpcblxuLyoqXG4gKiBUaGUgQXN0YXJTdHJhdGVneSBjbGFzcyBpcyBhbiBleHRlbnNpb24gb2YgdGhlIGFic3RyYWN0IE5hdlBhdGhTdHJhdGVneSBjbGFzcy4gRm9yIG91ciBuYXZpZ2F0aW9uIHN5c3RlbSwgeW91IGNhblxuICogbm93IHNwZWNpZnkgYW5kIGRlZmluZSB5b3VyIG93biBwYXRoZmluZGluZyBzdHJhdGVneS4gT3JpZ2luYWxseSwgdGhlIHR3byBvcHRpb25zIHdlcmUgdG8gdXNlIERqaWtzdHJhcyBvciBhXG4gKiBkaXJlY3QgKHBvaW50IEEgLT4gcG9pbnQgQikgc3RyYXRlZ3kuIFRoZSBvbmx5IHdheSB0byBjaGFuZ2UgaG93IHRoZSBwYXRoZmluZGluZyB3YXMgZG9uZSB3YXMgYnkgaGFyZC1jb2RpbmcgdGhpbmdzXG4gKiBpbnRvIHRoZSBjbGFzc2VzIGFzc29jaWF0ZWQgd2l0aCB0aGUgbmF2aWdhdGlvbiBzeXN0ZW0uIFxuICogXG4gKiAtIFBldGVyXG4gKi9cblxuaW50ZXJmYWNlIE5vZGUge1xuICAgIHBvc2l0aW9uOiBWZWMyO1xuICAgIGc6IG51bWJlcjtcbiAgICBoOiBudW1iZXI7XG4gICAgZjogbnVtYmVyO1xuICAgIHBhcmVudDogTm9kZSB8IG51bGw7XG4gIH1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXN0YXJTdHJhdGVneSBleHRlbmRzIE5hdlBhdGhTdHJhdCBcbntcbiAgICAvKipcbiAgICAgKiBAc2VlIE5hdlBhdGhTdHJhdC5idWlsZFBhdGgoKVxuICAgICAqL1xuICAgIHB1YmxpYyBidWlsZFBhdGgodG86IFZlYzIsIGZyb206IFZlYzIpOiBOYXZpZ2F0aW9uUGF0aCBcbiAgICB7XG4gICAgICAgIGxldCBwYXRoU3RhY2s6IFN0YWNrPFZlYzI+ID0gbmV3IFN0YWNrPFZlYzI+KHRoaXMubWVzaC5ncmFwaC5udW1WZXJ0aWNlcyk7XG5cbiAgICAgICAgbGV0IHN0YXJ0Tm9kZTogTm9kZSA9ICB7cG9zaXRpb246IGZyb20sIGc6IDAsIGg6IGZyb20uZGlzdGFuY2VUbyh0byksIGY6IGZyb20uZGlzdGFuY2VUbyh0byksIHBhcmVudDogbnVsbH07XG5cbiAgICAgICAgbGV0IG9wZW5MaXN0OiBBcnJheTxOb2RlPiA9IG5ldyBBcnJheTxOb2RlPigwKTtcbiAgICAgICAgY29uc29sZS5sb2cob3Blbkxpc3QpO1xuICAgICAgICBsZXQgY2xvc2VkTGlzdDogQXJyYXk8Tm9kZT4gPSBuZXcgQXJyYXk8Tm9kZT4oMCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGNsb3NlZExpc3QpO1xuXG4gICAgICAgIG9wZW5MaXN0LnB1c2goc3RhcnROb2RlKTtcbiAgICAgICAgY29uc29sZS5sb2cob3Blbkxpc3QpO1xuICAgICAgICBsZXQgY3VycmVudE5vZGU6IE5vZGU7XG4gICAgICAgIFxuICAgICAgICB3aGlsZShvcGVuTGlzdC5sZW5ndGggIT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgY3VycmVudE5vZGUgPSB0aGlzLmxvd2VzdEYob3Blbkxpc3QpO1xuICAgICAgICAgICAgY2xvc2VkTGlzdC5wdXNoKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgIG9wZW5MaXN0LnNwbGljZShvcGVuTGlzdC5pbmRleE9mKGN1cnJlbnROb2RlKSwgMSk7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG9wZW5MaXN0KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ3VycmVudCBQb3M6IChcIiArIGN1cnJlbnROb2RlLnBvc2l0aW9uLnggKyBcIiwgXCIgKyBjdXJyZW50Tm9kZS5wb3NpdGlvbi55ICsgXCIpXCIpO1xuXG4gICAgICAgICAgICBpZihjdXJyZW50Tm9kZS5wb3NpdGlvbi5lcXVhbHModG8pKSBicmVhaztcblxuICAgICAgICAgICAgbGV0IGFyb3VuZE5vZGVzOiBBcnJheTxOb2RlPiA9IHRoaXMuZ2V0YXJvdW5kTm9kZXMoY3VycmVudE5vZGUsIHRvLCBjbG9zZWRMaXN0KTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcm91bmROb2Rlcy5sZW5ndGg7IGkrKykgXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGV0IGV4aXN0c0luT3Blbkxpc3Q6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCBvcGVuTGlzdC5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmKG9wZW5MaXN0W2pdLnBvc2l0aW9uLmVxdWFscyhhcm91bmROb2Rlc1tpXS5wb3NpdGlvbikpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG9wZW5MaXN0W2pdLmcgPiBhcm91bmROb2Rlc1tpXS5nKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5MaXN0W2pdLnBhcmVudCA9IGFyb3VuZE5vZGVzW2ldLnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVuTGlzdFtqXS5nID0gYXJvdW5kTm9kZXNbaV0uZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVuTGlzdFtqXS5oID0gYXJvdW5kTm9kZXNbaV0uaDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVuTGlzdFtqXS5mID0gYXJvdW5kTm9kZXNbaV0uZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0c0luT3Blbkxpc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYoIWV4aXN0c0luT3Blbkxpc3QpICAgXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBvcGVuTGlzdC5wdXNoKGFyb3VuZE5vZGVzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0cmFja2luZ05vZGUgPSBjdXJyZW50Tm9kZTtcblxuICAgICAgICBsZXQgc3RhY2s6IFN0YWNrPFZlYzI+ID0gbmV3IFN0YWNrPFZlYzI+KHRoaXMubWVzaC5ncmFwaC5udW1WZXJ0aWNlcyk7XG5cbiAgICAgICAgd2hpbGUodHJhY2tpbmdOb2RlLnBhcmVudCAhPSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlRyYWNraW5nIFBvczogKFwiICsgdHJhY2tpbmdOb2RlLnBvc2l0aW9uLnggKyBcIiwgXCIgKyB0cmFja2luZ05vZGUucG9zaXRpb24ueSArIFwiKVwiKTtcbiAgICAgICAgICAgIHBhdGhTdGFjay5wdXNoKHRyYWNraW5nTm9kZS5wb3NpdGlvbik7XG4gICAgICAgICAgICB0cmFja2luZ05vZGUgPSB0cmFja2luZ05vZGUucGFyZW50O1xuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBOYXZpZ2F0aW9uUGF0aChwYXRoU3RhY2spO1xuICAgIH1cblxuICAgIHByaXZhdGUgd2FsbENoZWNrKHBvczogVmVjMik6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tZXNoLmdyYXBoLm51bVZlcnRpY2VzOyBpKyspIFxuICAgICAgICB7XG4gICAgICAgICAgICBpZih0aGlzLm1lc2guZ3JhcGguZ2V0Tm9kZVBvc2l0aW9uKGkpLmRpc3RhbmNlVG8ocG9zKSA8IDIpICAgIFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHByaXZhdGUgbG93ZXN0Rihub2RlTGlzdDogQXJyYXk8Tm9kZT4pOiBOb2RlXG4gICAge1xuICAgICAgICBsZXQgbG93ZXN0ID0gbm9kZUxpc3RbMF07XG5cbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IG5vZGVMaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgdGVtcCA9IG5vZGVMaXN0W2ldO1xuXG4gICAgICAgICAgICBpZihsb3dlc3QuZiA+IHRlbXAuZikgICBsb3dlc3QgPSB0ZW1wO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvd2VzdDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGxpc3RDaGVjayhub2RlOiBOb2RlLCBjaGVja2xpc3Q6IEFycmF5PE5vZGU+KTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGVja2xpc3QubGVuZ3RoOyBpKyspIFxuICAgICAgICB7XG4gICAgICAgICAgICBpZihjaGVja2xpc3RbaV0ucG9zaXRpb24uZXF1YWxzKG5vZGUucG9zaXRpb24pKSBcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIHByaXZhdGUgZ2V0YXJvdW5kTm9kZXMoY3VycmVudE5vZGU6IE5vZGUsIHRvOiBWZWMyLCBjbG9zZWQ6IEFycmF5PE5vZGU+KTogQXJyYXk8Tm9kZT5cbiAgICB7XG4gICAgICAgIGxldCBhcm91bmROb2RlczogQXJyYXk8Tm9kZT4gPSBuZXcgQXJyYXk8Tm9kZT47XG4gICAgICAgIFxuICAgICAgICBsZXQgY3VycmVudFBvcyA9IGN1cnJlbnROb2RlLnBvc2l0aW9uO1xuICAgICAgICBsZXQgbGVmdE1pZGRsZVBvcyA9IG5ldyBWZWMyKGN1cnJlbnRQb3MueCAtIDEsIGN1cnJlbnRQb3MueSk7XG4gICAgICAgIGxldCBsZWZ0VXBQb3MgPSBuZXcgVmVjMihjdXJyZW50UG9zLnggLSAxLCBjdXJyZW50UG9zLnkgLSAxKTtcbiAgICAgICAgbGV0IGxlZnREb3duUG9zID0gbmV3IFZlYzIoY3VycmVudFBvcy54IC0gMSwgY3VycmVudFBvcy55ICsgMSk7XG4gICAgICAgIGxldCBtaWRkbGVVcFBvcyA9IG5ldyBWZWMyKGN1cnJlbnRQb3MueCwgY3VycmVudFBvcy55IC0gMSk7XG4gICAgICAgIGxldCBtaWRkbGVEb3duUG9zID0gbmV3IFZlYzIoY3VycmVudFBvcy54LCBjdXJyZW50UG9zLnkgKyAxKTtcbiAgICAgICAgbGV0IHJpZ2h0TWlkZGxlUG9zID0gbmV3IFZlYzIoY3VycmVudFBvcy54ICsgMSwgY3VycmVudFBvcy55KTtcbiAgICAgICAgbGV0IHJpZ2h0VXBQb3MgPSBuZXcgVmVjMihjdXJyZW50UG9zLnggKyAxLCBjdXJyZW50UG9zLnkgLSAxKTtcbiAgICAgICAgbGV0IHJpZ2h0RG93blBvcyA9IG5ldyBWZWMyKGN1cnJlbnRQb3MueCArIDEsIGN1cnJlbnRQb3MueSArIDEpO1xuXG4gICAgICAgIGxldCBsZWZ0TWlkZGxlTm9kZTogTm9kZSA9IHtwb3NpdGlvbjogbGVmdE1pZGRsZVBvcywgXG4gICAgICAgICAgICBnOiBjdXJyZW50Tm9kZS5nICsgY3VycmVudFBvcy5kaXN0YW5jZVRvKGxlZnRNaWRkbGVQb3MpLCBcbiAgICAgICAgICAgIGg6IGxlZnRNaWRkbGVQb3MuZGlzdGFuY2VUbyh0byksIFxuICAgICAgICAgICAgZjogY3VycmVudE5vZGUuZyArIGN1cnJlbnRQb3MuZGlzdGFuY2VUbyhsZWZ0TWlkZGxlUG9zKSArIGxlZnRNaWRkbGVQb3MuZGlzdGFuY2VUbyh0byksIFxuICAgICAgICAgICAgcGFyZW50OiBjdXJyZW50Tm9kZSB9O1xuICAgICAgICBsZXQgbGVmdFVwTm9kZTogTm9kZSA9IHtwb3NpdGlvbjogbGVmdFVwUG9zLCBcbiAgICAgICAgICAgIGc6IGN1cnJlbnROb2RlLmcgKyBjdXJyZW50UG9zLmRpc3RhbmNlVG8obGVmdFVwUG9zKSwgXG4gICAgICAgICAgICBoOiBsZWZ0TWlkZGxlUG9zLmRpc3RhbmNlVG8odG8pLFxuICAgICAgICAgICAgZjogY3VycmVudE5vZGUuZyArIGN1cnJlbnRQb3MuZGlzdGFuY2VUbyhsZWZ0VXBQb3MpICsgbGVmdE1pZGRsZVBvcy5kaXN0YW5jZVRvKHRvKSwgXG4gICAgICAgICAgICBwYXJlbnQ6IGN1cnJlbnROb2RlIH07XG4gICAgICAgIGxldCBsZWZ0RG93bk5vZGU6IE5vZGUgPSB7cG9zaXRpb246IGxlZnREb3duUG9zLCBcbiAgICAgICAgICAgIGc6IGN1cnJlbnROb2RlLmcgKyBjdXJyZW50UG9zLmRpc3RhbmNlVG8obGVmdERvd25Qb3MpLCBcbiAgICAgICAgICAgIGg6IGxlZnRNaWRkbGVQb3MuZGlzdGFuY2VUbyh0byksIFxuICAgICAgICAgICAgZjogY3VycmVudE5vZGUuZyArIGN1cnJlbnRQb3MuZGlzdGFuY2VUbyhsZWZ0RG93blBvcykgKyBsZWZ0TWlkZGxlUG9zLmRpc3RhbmNlVG8odG8pLCBcbiAgICAgICAgICAgIHBhcmVudDogY3VycmVudE5vZGUgfTtcbiAgICAgICAgbGV0IG1pZGRsZVVwTm9kZTogTm9kZSA9IHtwb3NpdGlvbjogbWlkZGxlVXBQb3MsIFxuICAgICAgICAgICAgZzogY3VycmVudE5vZGUuZyArIGN1cnJlbnRQb3MuZGlzdGFuY2VUbyhtaWRkbGVVcFBvcyksIFxuICAgICAgICAgICAgaDogbGVmdE1pZGRsZVBvcy5kaXN0YW5jZVRvKHRvKSwgXG4gICAgICAgICAgICBmOiBjdXJyZW50Tm9kZS5nICsgY3VycmVudFBvcy5kaXN0YW5jZVRvKG1pZGRsZVVwUG9zKSArIGxlZnRNaWRkbGVQb3MuZGlzdGFuY2VUbyh0byksIFxuICAgICAgICAgICAgcGFyZW50OiBjdXJyZW50Tm9kZSB9O1xuICAgICAgICBsZXQgbWlkZGxlRG93bk5vZGU6IE5vZGUgPSB7cG9zaXRpb246IG1pZGRsZURvd25Qb3MsIFxuICAgICAgICAgICAgZzogY3VycmVudE5vZGUuZyArIGN1cnJlbnRQb3MuZGlzdGFuY2VUbyhtaWRkbGVEb3duUG9zKSwgXG4gICAgICAgICAgICBoOiBsZWZ0TWlkZGxlUG9zLmRpc3RhbmNlVG8odG8pLCBcbiAgICAgICAgICAgIGY6IGN1cnJlbnROb2RlLmcgKyBjdXJyZW50UG9zLmRpc3RhbmNlVG8obWlkZGxlRG93blBvcykgKyBsZWZ0TWlkZGxlUG9zLmRpc3RhbmNlVG8odG8pLCBcbiAgICAgICAgICAgIHBhcmVudDogY3VycmVudE5vZGUgfTtcbiAgICAgICAgbGV0IHJpZ2h0TWlkZGxlTm9kZTogTm9kZSA9IHtwb3NpdGlvbjogcmlnaHRNaWRkbGVQb3MsIFxuICAgICAgICAgICAgZzogY3VycmVudE5vZGUuZyArIGN1cnJlbnRQb3MuZGlzdGFuY2VUbyhyaWdodE1pZGRsZVBvcyksIFxuICAgICAgICAgICAgaDogbGVmdE1pZGRsZVBvcy5kaXN0YW5jZVRvKHRvKSwgXG4gICAgICAgICAgICBmOiBjdXJyZW50Tm9kZS5nICsgY3VycmVudFBvcy5kaXN0YW5jZVRvKHJpZ2h0TWlkZGxlUG9zKSArIGxlZnRNaWRkbGVQb3MuZGlzdGFuY2VUbyh0byksIFxuICAgICAgICAgICAgcGFyZW50OiBjdXJyZW50Tm9kZSB9O1xuICAgICAgICBsZXQgcmlnaHRVcE5vZGU6IE5vZGUgPSB7cG9zaXRpb246IHJpZ2h0VXBQb3MsIFxuICAgICAgICAgICAgZzogY3VycmVudE5vZGUuZyArIGN1cnJlbnRQb3MuZGlzdGFuY2VUbyhyaWdodFVwUG9zKSwgXG4gICAgICAgICAgICBoOiBsZWZ0TWlkZGxlUG9zLmRpc3RhbmNlVG8odG8pLCBcbiAgICAgICAgICAgIGY6IGN1cnJlbnROb2RlLmcgKyBjdXJyZW50UG9zLmRpc3RhbmNlVG8ocmlnaHRVcFBvcykgKyBsZWZ0TWlkZGxlUG9zLmRpc3RhbmNlVG8odG8pLCBcbiAgICAgICAgICAgIHBhcmVudDogY3VycmVudE5vZGUgfTtcbiAgICAgICAgbGV0IHJpZ2h0RG93bk5vZGU6IE5vZGUgPSB7cG9zaXRpb246IHJpZ2h0RG93blBvcywgXG4gICAgICAgICAgICBnOiBjdXJyZW50Tm9kZS5nICsgY3VycmVudFBvcy5kaXN0YW5jZVRvKHJpZ2h0RG93blBvcyksIFxuICAgICAgICAgICAgaDogbGVmdE1pZGRsZVBvcy5kaXN0YW5jZVRvKHRvKSwgXG4gICAgICAgICAgICBmOiBjdXJyZW50Tm9kZS5nICsgY3VycmVudFBvcy5kaXN0YW5jZVRvKHJpZ2h0RG93blBvcykgKyBsZWZ0TWlkZGxlUG9zLmRpc3RhbmNlVG8odG8pLCBcbiAgICAgICAgICAgIHBhcmVudDogY3VycmVudE5vZGUgfTtcblxuICAgICAgICBpZih0aGlzLndhbGxDaGVjayhsZWZ0TWlkZGxlUG9zKSA9PSBmYWxzZSBcbiAgICAgICAgJiYgdGhpcy5saXN0Q2hlY2sobGVmdE1pZGRsZU5vZGUsIGNsb3NlZCkgPT0gZmFsc2VcbiAgICAgICAgJiYgbGVmdE1pZGRsZVBvcy54ID4gMCAmJiBsZWZ0TWlkZGxlUG9zLnkgPiAwKSBcbiAgICAgICAgICAgIGFyb3VuZE5vZGVzLnB1c2gobGVmdE1pZGRsZU5vZGUpO1xuICAgICAgICBpZih0aGlzLndhbGxDaGVjayhsZWZ0VXBQb3MpID09IGZhbHNlIFxuICAgICAgICAmJiB0aGlzLmxpc3RDaGVjayhsZWZ0VXBOb2RlLCBjbG9zZWQpID09IGZhbHNlXG4gICAgICAgICYmIGxlZnRVcFBvcy54ID4gMCAmJiBsZWZ0VXBQb3MueSA+IDApIFxuICAgICAgICAgICAgYXJvdW5kTm9kZXMucHVzaChsZWZ0VXBOb2RlKTtcbiAgICAgICAgaWYodGhpcy53YWxsQ2hlY2sobWlkZGxlVXBQb3MpID09IGZhbHNlIFxuICAgICAgICAmJiAhdGhpcy5saXN0Q2hlY2sobWlkZGxlVXBOb2RlLCBjbG9zZWQpID09IGZhbHNlXG4gICAgICAgICYmIG1pZGRsZVVwUG9zLnggPiAwICYmIG1pZGRsZVVwUG9zLnkgPiAwKSAgICAgICBcbiAgICAgICAgICAgIGFyb3VuZE5vZGVzLnB1c2gobWlkZGxlVXBOb2RlKTsgICBcbiAgICAgICAgaWYodGhpcy53YWxsQ2hlY2socmlnaHRVcFBvcykgPT0gZmFsc2UgXG4gICAgICAgICYmIHRoaXMubGlzdENoZWNrKHJpZ2h0VXBOb2RlLCBjbG9zZWQpID09IGZhbHNlXG4gICAgICAgICYmIHJpZ2h0VXBQb3MueCA+IDAgJiYgcmlnaHRVcFBvcy55ID4gMCApICAgICAgICBcbiAgICAgICAgICAgIGFyb3VuZE5vZGVzLnB1c2gocmlnaHRVcE5vZGUpO1xuICAgICAgICBpZih0aGlzLndhbGxDaGVjayhyaWdodE1pZGRsZVBvcykgPT0gZmFsc2UgXG4gICAgICAgICYmIHRoaXMubGlzdENoZWNrKHJpZ2h0TWlkZGxlTm9kZSwgY2xvc2VkKSA9PSBmYWxzZVxuICAgICAgICAmJiByaWdodE1pZGRsZVBvcy54ID4gMCAmJiByaWdodE1pZGRsZVBvcy55ID4gMCkgXG4gICAgICAgICAgICBhcm91bmROb2Rlcy5wdXNoKHJpZ2h0TWlkZGxlTm9kZSk7XG4gICAgICAgIGlmKHRoaXMud2FsbENoZWNrKHJpZ2h0RG93blBvcykgPT0gZmFsc2UgXG4gICAgICAgICYmIHRoaXMubGlzdENoZWNrKHJpZ2h0RG93bk5vZGUsIGNsb3NlZCkgPT0gZmFsc2VcbiAgICAgICAgJiYgcmlnaHREb3duUG9zLnggPiAwICYmIHJpZ2h0RG93blBvcy55ID4gMCkgICAgIFxuICAgICAgICAgICAgYXJvdW5kTm9kZXMucHVzaChyaWdodERvd25Ob2RlKTtcbiAgICAgICAgaWYodGhpcy53YWxsQ2hlY2sobWlkZGxlRG93blBvcykgPT0gZmFsc2UgXG4gICAgICAgICYmIHRoaXMubGlzdENoZWNrKG1pZGRsZURvd25Ob2RlLCBjbG9zZWQpID09IGZhbHNlXG4gICAgICAgICYmIG1pZGRsZURvd25Qb3MueCA+IDAgJiYgbWlkZGxlRG93blBvcy55ID4gMCkgICBcbiAgICAgICAgICAgIGFyb3VuZE5vZGVzLnB1c2gobWlkZGxlRG93bk5vZGUpO1xuICAgICAgICBpZih0aGlzLndhbGxDaGVjayhsZWZ0RG93blBvcykgPT0gZmFsc2UgXG4gICAgICAgICYmIHRoaXMubGlzdENoZWNrKGxlZnREb3duTm9kZSwgY2xvc2VkKSA9PSBmYWxzZVxuICAgICAgICAmJiBsZWZ0RG93blBvcy54ID4gMCAmJiBsZWZ0RG93blBvcy55ID4gMCkgICBcbiAgICAgICAgICAgIGFyb3VuZE5vZGVzLnB1c2gobGVmdERvd25Ob2RlKTsgICAgICBcblxuICAgICAgICByZXR1cm4gYXJvdW5kTm9kZXM7XG4gICAgfVxufSIsImltcG9ydCBQb3NpdGlvbkdyYXBoIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvR3JhcGhzL1Bvc2l0aW9uR3JhcGhcIjtcbmltcG9ydCBBQUJCIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvU2hhcGVzL0FBQkJcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IHsgR3JhcGhpY1R5cGUgfSBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvR3JhcGhpY3MvR3JhcGhpY1R5cGVzXCI7XG5pbXBvcnQgT3J0aG9nb25hbFRpbGVtYXAgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL1RpbGVtYXBzL09ydGhvZ29uYWxUaWxlbWFwXCI7XG5pbXBvcnQgTmF2aWdhdGlvblBhdGggZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1BhdGhmaW5kaW5nL05hdmlnYXRpb25QYXRoXCI7XG5pbXBvcnQgTmF2bWVzaCBmcm9tIFwiLi4vLi4vV29sZmllMkQvUGF0aGZpbmRpbmcvTmF2bWVzaFwiO1xuaW1wb3J0IERpcmVjdFN0cmF0ZWd5IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9QYXRoZmluZGluZy9TdHJhdGVnaWVzL0RpcmVjdFN0cmF0ZWd5XCI7XG5pbXBvcnQgRGppa3N0cmFQYXRoU3RyYXQgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1BhdGhmaW5kaW5nL1N0cmF0ZWdpZXMvRGppa3N0cmFTdHJhdGVneVwiO1xuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9TY2VuZS9TY2VuZVwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9VdGlscy9Db2xvclwiO1xuaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vLi4vV29sZmllMkQvVXRpbHMvTWF0aFV0aWxzXCI7XG5pbXBvcnQgTlBDQWN0b3IgZnJvbSBcIi4uL0FjdG9ycy9OUENBY3RvclwiO1xuaW1wb3J0IEFzdGFyU3RyYXRlZ3kgZnJvbSBcIi4uL1BhdGhmaW5kaW5nL0FzdGFyU3RyYXRlZ3lcIjtcbmltcG9ydCBNYWluTWVudSBmcm9tIFwiLi9NYWluTWVudVwiO1xuXG4vKipcbiAqIFRoaXMgaXMgYSBkdW1teSBzY2VuZSB0byB0ZXN0IGlmIHlvdXIgaW1wbGVtZW50YXRpb24gb2YgQSogaXMgd29ya2luZyBvciBub3QuIElmIHlvdXIgaW1wbGVtZW50YXRpb24gXG4gKiBpcyB3b3JraW5nIGNvcnJlY3RseSwgeW91IHNob3VsZCBzZWUgdGhlIGJsdWUgbnBjIG1ha2UgaXQncyB3YXkgdG8gdGhlIHNtYWxsIGJsdWUgYm94IGluIHRoZSB0b3AtcmlnaHQgXG4gKiBjb3JuZXIgb2YgdGhlIHNjcmVlbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQVN0YXJEZW1vU2NlbmUgZXh0ZW5kcyBTY2VuZSB7XG5cbiAgICBwcm90ZWN0ZWQgbnBjOiBOUENBY3RvcjtcbiAgICBwcm90ZWN0ZWQgZGVzdGluYXRpb246IFZlYzI7XG4gICAgcHJvdGVjdGVkIHBhdGg6IE5hdmlnYXRpb25QYXRoO1xuXG4gICAgcHVibGljIGxvYWRTY2VuZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2FkLnRpbGVtYXAoXCJsZXZlbFwiLCBcImh3NF9hc3NldHMvdGlsZW1hcHMvSFc0VGlsZW1hcC5qc29uXCIpO1xuICAgICAgICB0aGlzLmxvYWQuc3ByaXRlc2hlZXQoXCJCbHVlRW5lbXlcIiwgXCJodzRfYXNzZXRzL3Nwcml0ZXNoZWV0cy9CbHVlRW5lbXkuanNvblwiKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhcnRTY2VuZSgpOiB2b2lkIHtcbiAgICAgICAgbGV0IHRpbGVtYXBMYXllcnMgPSB0aGlzLmFkZC50aWxlbWFwKFwibGV2ZWxcIik7XG4gICAgICAgIGxldCB3YWxscyA9IDxPcnRob2dvbmFsVGlsZW1hcD50aWxlbWFwTGF5ZXJzWzFdLmdldEl0ZW1zKClbMF07XG5cbiAgICAgICAgdGhpcy52aWV3cG9ydC5zZXRCb3VuZHMoMCwgMCwgd2FsbHMuc2l6ZS54LCB3YWxscy5zaXplLnkpO1xuICAgICAgICB0aGlzLnZpZXdwb3J0LnNldFpvb21MZXZlbCgyKTtcbiAgICAgICAgdGhpcy5hZGRMYXllcihcInByaW1hcnlcIiwgMTApO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgYSBuYXZtZXNoIGNvdmVyaW5nIHRoZSB0aWxlbWFwXG4gICAgICAgIGxldCBuYXZtZXNoID0gdGhpcy5pbml0aWFsaXplTmF2bWVzaChuZXcgUG9zaXRpb25HcmFwaCgpLCB3YWxscyk7XG4gICAgICAgIHRoaXMubmF2TWFuYWdlci5hZGROYXZpZ2FibGVFbnRpdHkoXCJuYXZtZXNoXCIsIG5hdm1lc2gpO1xuXG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBkaWZmZXJlbnQgcGF0aGZpbmRpbmcgc3RyYXRlZ2llcyB3aXRoIHRoZSBuYXZtZXNoXG4gICAgICAgIG5hdm1lc2gucmVnaXN0ZXJTdHJhdGVneShcImRpcmVjdFwiLCBuZXcgRGlyZWN0U3RyYXRlZ3kobmF2bWVzaCkpO1xuICAgICAgICBuYXZtZXNoLnJlZ2lzdGVyU3RyYXRlZ3koXCJhc3RhclwiLCBuZXcgQXN0YXJTdHJhdGVneShuYXZtZXNoKSk7XG4gICAgICAgIG5hdm1lc2gucmVnaXN0ZXJTdHJhdGVneShcImRpamtzdHJhXCIsIG5ldyBEamlrc3RyYVBhdGhTdHJhdChuYXZtZXNoKSk7XG5cbiAgICAgICAgXG4gICAgICAgIC8vIFRPRE8gU2V0IHRoZSBuYXZpZ2F0aW9uIHN0cmF0ZWd5IHRvIGJlIEEqXG4gICAgICAgIG5hdm1lc2guc2V0U3RyYXRlZ3koXCJhc3RhclwiKTtcblxuXG4gICAgICAgIC8vIENyZWF0ZSBhIGR1bW15IE5QQ1xuICAgICAgICB0aGlzLm5wYyA9IHRoaXMuYWRkLmFuaW1hdGVkU3ByaXRlKE5QQ0FjdG9yLCBcIkJsdWVFbmVteVwiLCBcInByaW1hcnlcIilcbiAgICAgICAgdGhpcy5ucGMuYWRkUGh5c2ljcygpO1xuICAgICAgICB0aGlzLm5wYy5wb3NpdGlvbi5jb3B5KG5ldyBWZWMyKDI1LCA0NTApKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBWZWMyKDQ1MCwgMjUpO1xuXG4gICAgICAgIC8vIFRoZSBsaXR0bGUgYmx1ZSByZWN0YW5nbGUgaW4gdGhlIHRvcC1yaWdodCBpcyB3aGVyZSB0aGUgTlBDIGlzIHRyeWluZyB0byBnZXQgdG9cbiAgICAgICAgbGV0IGRlc3RpbmF0aW9uID0gdGhpcy5hZGQuZ3JhcGhpYyhHcmFwaGljVHlwZS5SRUNULCBcInByaW1hcnlcIiwge3Bvc2l0aW9uOiB0aGlzLmRlc3RpbmF0aW9uLCBzaXplOiBuZXcgVmVjMigyMCwgMjApfSlcbiAgICAgICAgZGVzdGluYXRpb24uY29sb3IgPSBDb2xvci5CTFVFO1xuICAgICAgICBkZXN0aW5hdGlvbi5jb2xvci5hID0gLjUwO1xuXG4gICAgICAgIC8vIENvbnN0cnVjdCBhIHBhdGggdXNpbmcgdGhlIG5hdm1lc2ggZnJvbSB0aGUgbnBjJ3MgcG9zaXRpb24gdG8gdGhlIHRhcmdldCBkZXN0aW5hdGlvblxuICAgICAgICB0aGlzLnBhdGggPSBuYXZtZXNoLmdldE5hdmlnYXRpb25QYXRoKHRoaXMubnBjLnBvc2l0aW9uLCB0aGlzLmRlc3RpbmF0aW9uKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgdXBkYXRlU2NlbmUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgLy8gTW92ZSB0aGUgbnBjIGFsb25nIHRoZSBwYXRoXG4gICAgICAgIHRoaXMubnBjLm1vdmVPblBhdGgoMSwgdGhpcy5wYXRoKTtcblxuICAgICAgICBpZih0aGlzLm5wYy5wb3NpdGlvbi5lcXVhbHModGhpcy5kZXN0aW5hdGlvbikpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyLmNoYW5nZVRvU2NlbmUoTWFpbk1lbnUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBuYXZtZXNoIGdyYXBoIHVzZWQgYnkgdGhlIE5QQ3MgaW4gdGhlIEhXNFNjZW5lLiBUaGlzIG1ldGhvZCBpcyBhIGxpdHRsZSBidWdneSwgYW5kXG4gICAgICogYW5kIGl0IHNraXBzIG92ZXIgc29tZSBvZiB0aGUgcG9zaXRpb25zIG9uIHRoZSB0aWxlbWFwLiBJZiB5b3UgY2FuIGZpeCBteSBuYXZtZXNoIGdlbmVyYXRpb24gYWxnb3JpdGhtLFxuICAgICAqIGdvIGZvciBpdC5cbiAgICAgKiBAYXV0aG9yIFBldGV5THVtcGtpbnNcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgaW5pdGlhbGl6ZU5hdm1lc2goZ3JhcGg6IFBvc2l0aW9uR3JhcGgsIHdhbGxzOiBPcnRob2dvbmFsVGlsZW1hcCk6IE5hdm1lc2gge1xuXG4gICAgICAgIGxldCBkaW06IFZlYzIgPSB3YWxscy5nZXREaW1lbnNpb25zKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGltLnk7IGkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBkaW0ueDsgaisrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRpbGU6IEFBQkIgPSB3YWxscy5nZXRUaWxlQ29sbGlkZXIoaiwgaSk7XG4gICAgICAgICAgICAgICAgZ3JhcGguYWRkUG9zaXRpb25lZE5vZGUodGlsZS5jZW50ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJjOiBWZWMyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyYXBoLm51bVZlcnRpY2VzOyBpKyspIHtcbiAgICAgICAgICAgIHJjID0gd2FsbHMuZ2V0VGlsZUNvbFJvdyhpKTtcbiAgICAgICAgICAgIGlmICghd2FsbHMuaXNUaWxlQ29sbGlkYWJsZShyYy54LCByYy55KSAmJlxuICAgICAgICAgICAgICAgICF3YWxscy5pc1RpbGVDb2xsaWRhYmxlKE1hdGhVdGlscy5jbGFtcChyYy54IC0gMSwgMCwgZGltLnggLSAxKSwgcmMueSkgJiZcbiAgICAgICAgICAgICAgICAhd2FsbHMuaXNUaWxlQ29sbGlkYWJsZShNYXRoVXRpbHMuY2xhbXAocmMueCArIDEsIDAsIGRpbS54IC0gMSksIHJjLnkpICYmXG4gICAgICAgICAgICAgICAgIXdhbGxzLmlzVGlsZUNvbGxpZGFibGUocmMueCwgTWF0aFV0aWxzLmNsYW1wKHJjLnkgLSAxLCAwLCBkaW0ueSAtIDEpKSAmJlxuICAgICAgICAgICAgICAgICF3YWxscy5pc1RpbGVDb2xsaWRhYmxlKHJjLngsIE1hdGhVdGlscy5jbGFtcChyYy55ICsgMSwgMCwgZGltLnkgLSAxKSkgJiZcbiAgICAgICAgICAgICAgICAhd2FsbHMuaXNUaWxlQ29sbGlkYWJsZShNYXRoVXRpbHMuY2xhbXAocmMueCArIDEsIDAsIGRpbS54IC0gMSksIE1hdGhVdGlscy5jbGFtcChyYy55ICsgMSwgMCwgZGltLnkgLSAxKSkgJiZcbiAgICAgICAgICAgICAgICAhd2FsbHMuaXNUaWxlQ29sbGlkYWJsZShNYXRoVXRpbHMuY2xhbXAocmMueCAtIDEsIDAsIGRpbS54IC0gMSksIE1hdGhVdGlscy5jbGFtcChyYy55ICsgMSwgMCwgZGltLnkgLSAxKSkgJiZcbiAgICAgICAgICAgICAgICAhd2FsbHMuaXNUaWxlQ29sbGlkYWJsZShNYXRoVXRpbHMuY2xhbXAocmMueCArIDEsIDAsIGRpbS54IC0gMSksIE1hdGhVdGlscy5jbGFtcChyYy55IC0gMSwgMCwgZGltLnkgLSAxKSkgJiZcbiAgICAgICAgICAgICAgICAhd2FsbHMuaXNUaWxlQ29sbGlkYWJsZShNYXRoVXRpbHMuY2xhbXAocmMueCAtIDEsIDAsIGRpbS54IC0gMSksIE1hdGhVdGlscy5jbGFtcChyYy55IC0gMSwgMCwgZGltLnkgLSAxKSlcblxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGVkZ2UgdG8gdGhlIGxlZnRcbiAgICAgICAgICAgICAgICByYyA9IHdhbGxzLmdldFRpbGVDb2xSb3coaSArIDEpO1xuICAgICAgICAgICAgICAgIGlmICgoaSArIDEpICUgZGltLnggIT09IDAgJiYgIXdhbGxzLmlzVGlsZUNvbGxpZGFibGUocmMueCwgcmMueSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGguYWRkRWRnZShpLCBpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMuYWRkLmdyYXBoaWMoR3JhcGhpY1R5cGUuTElORSwgXCJncmFwaFwiLCB7c3RhcnQ6IHRoaXMuZ3JhcGguZ2V0Tm9kZVBvc2l0aW9uKGkpLCBlbmQ6IHRoaXMuZ3JhcGguZ2V0Tm9kZVBvc2l0aW9uKGkgKyAxKX0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBlZGdlIGJlbG93XG4gICAgICAgICAgICAgICAgcmMgPSB3YWxscy5nZXRUaWxlQ29sUm93KGkgKyBkaW0ueCk7XG4gICAgICAgICAgICAgICAgaWYgKGkgKyBkaW0ueCA8IGdyYXBoLm51bVZlcnRpY2VzICYmICF3YWxscy5pc1RpbGVDb2xsaWRhYmxlKHJjLngsIHJjLnkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYXBoLmFkZEVkZ2UoaSwgaSArIGRpbS54KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcy5hZGQuZ3JhcGhpYyhHcmFwaGljVHlwZS5MSU5FLCBcImdyYXBoXCIsIHtzdGFydDogdGhpcy5ncmFwaC5nZXROb2RlUG9zaXRpb24oaSksIGVuZDogdGhpcy5ncmFwaC5nZXROb2RlUG9zaXRpb24oaSArIGRpbS54KX0pXG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCB0aGlzIGdyYXBoIGFzIGEgbmF2aWdhYmxlIGVudGl0eVxuICAgICAgICByZXR1cm4gbmV3IE5hdm1lc2goZ3JhcGgpO1xuXG4gICAgfVxufSIsImltcG9ydCBQb3NpdGlvbkdyYXBoIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvR3JhcGhzL1Bvc2l0aW9uR3JhcGhcIjtcbmltcG9ydCBBY3RvciBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL0ludGVyZmFjZXMvQWN0b3JcIjtcbmltcG9ydCBBQUJCIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvU2hhcGVzL0FBQkJcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vLi4vV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFwiO1xuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HYW1lTm9kZVwiO1xuaW1wb3J0IHsgR3JhcGhpY1R5cGUgfSBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvR3JhcGhpY3MvR3JhcGhpY1R5cGVzXCI7XG5pbXBvcnQgTGluZSBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvR3JhcGhpY3MvTGluZVwiO1xuaW1wb3J0IE9ydGhvZ29uYWxUaWxlbWFwIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9UaWxlbWFwcy9PcnRob2dvbmFsVGlsZW1hcFwiO1xuaW1wb3J0IE5hdm1lc2ggZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1BhdGhmaW5kaW5nL05hdm1lc2hcIjtcbmltcG9ydCBEaXJlY3RTdHJhdGVneSBmcm9tIFwiLi4vLi4vV29sZmllMkQvUGF0aGZpbmRpbmcvU3RyYXRlZ2llcy9EaXJlY3RTdHJhdGVneVwiO1xuaW1wb3J0IFJlbmRlcmluZ01hbmFnZXIgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1JlbmRlcmluZy9SZW5kZXJpbmdNYW5hZ2VyXCI7XG5pbXBvcnQgU2NlbmVNYW5hZ2VyIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9TY2VuZS9TY2VuZU1hbmFnZXJcIjtcbmltcG9ydCBWaWV3cG9ydCBmcm9tIFwiLi4vLi4vV29sZmllMkQvU2NlbmVHcmFwaC9WaWV3cG9ydFwiO1xuaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vLi4vV29sZmllMkQvVXRpbHMvTWF0aFV0aWxzXCI7XG5pbXBvcnQgTlBDQWN0b3IgZnJvbSBcIi4uL0FjdG9ycy9OUENBY3RvclwiO1xuaW1wb3J0IFBsYXllckFjdG9yIGZyb20gXCIuLi9BY3RvcnMvUGxheWVyQWN0b3JcIjtcbmltcG9ydCBHdWFyZEJlaGF2aW9yIGZyb20gXCIuLi9BSS9OUEMvTlBDQmVoYXZpb3IvR2F1cmRCZWhhdmlvclwiO1xuaW1wb3J0IFBsYXllckFJIGZyb20gXCIuLi9BSS9QbGF5ZXIvUGxheWVyQUlcIjtcbmltcG9ydCB7IEl0ZW1FdmVudCwgUGxheWVyRXZlbnQsIEJhdHRsZXJFdmVudCB9IGZyb20gXCIuLi9FdmVudHNcIjtcbmltcG9ydCBCYXR0bGVyIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9CYXR0bGVTeXN0ZW0vQmF0dGxlclwiO1xuaW1wb3J0IEhlYWx0aGJhckhVRCBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvSFVEL0hlYWx0aGJhckhVRFwiO1xuaW1wb3J0IEludmVudG9yeSBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvSXRlbVN5c3RlbS9JbnZlbnRvcnlcIjtcbmltcG9ydCBJdGVtIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9JdGVtU3lzdGVtL0l0ZW1cIjtcbmltcG9ydCBIZWFsdGhwYWNrIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9JdGVtU3lzdGVtL0l0ZW1zL0hlYWx0aHBhY2tcIjtcbmltcG9ydCBMYXNlckd1biBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvSXRlbVN5c3RlbS9JdGVtcy9MYXNlckd1blwiO1xuaW1wb3J0IHsgQ2xvc2VzdFBvc2l0aW9uZWQgfSBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvU2VhcmNoaW5nL0hXNFJlZHVjZXJzXCI7XG5pbXBvcnQgQmFzaWNUYXJnZXRhYmxlIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9UYXJnZXRpbmcvQmFzaWNUYXJnZXRhYmxlXCI7XG5pbXBvcnQgUG9zaXRpb24gZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL1RhcmdldGluZy9Qb3NpdGlvblwiO1xuaW1wb3J0IEFzdGFyU3RyYXRlZ3kgZnJvbSBcIi4uL1BhdGhmaW5kaW5nL0FzdGFyU3RyYXRlZ3lcIjtcbmltcG9ydCBIVzRTY2VuZSBmcm9tIFwiLi9IVzRTY2VuZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHdWFyZERlbW9TY2VuZSBleHRlbmRzIEhXNFNjZW5lIHtcblxuICAgIHByaXZhdGUgcGxheWVyOiBQbGF5ZXJBY3RvcjtcbiAgICAvKiogQWxsIHRoZSBiYXR0bGVycyBpbiB0aGUgSFc0U2NlbmUgKGluY2x1ZGluZyB0aGUgcGxheWVyKSAqL1xuICAgIHByaXZhdGUgYmF0dGxlcnM6IChCYXR0bGVyICYgQWN0b3IpW107XG4gICAgLyoqIEhlYWx0aGJhcnMgZm9yIHRoZSBiYXR0bGVycyAqL1xuICAgIHByaXZhdGUgaGVhbHRoYmFyczogTWFwPG51bWJlciwgSGVhbHRoYmFySFVEPjtcblxuICAgIHByaXZhdGUgaGVhbHRocGFja3M6IEFycmF5PEhlYWx0aHBhY2s+O1xuICAgIHByaXZhdGUgbGFzZXJndW5zOiBBcnJheTxMYXNlckd1bj47XG5cbiAgICAvLyBUaGUgd2FsbCBsYXllciBvZiB0aGUgdGlsZW1hcFxuICAgIHByaXZhdGUgd2FsbHM6IE9ydGhvZ29uYWxUaWxlbWFwO1xuXG4gICAgLy8gVGhlIHBvc2l0aW9uIGdyYXBoIGZvciB0aGUgbmF2bWVzaFxuICAgIHByaXZhdGUgZ3JhcGg6IFBvc2l0aW9uR3JhcGg7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3Iodmlld3BvcnQ6IFZpZXdwb3J0LCBzY2VuZU1hbmFnZXI6IFNjZW5lTWFuYWdlciwgcmVuZGVyaW5nTWFuYWdlcjogUmVuZGVyaW5nTWFuYWdlciwgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgICAgICBzdXBlcih2aWV3cG9ydCwgc2NlbmVNYW5hZ2VyLCByZW5kZXJpbmdNYW5hZ2VyLCBvcHRpb25zKTtcblxuICAgICAgICB0aGlzLmJhdHRsZXJzID0gbmV3IEFycmF5PEJhdHRsZXIgJiBBY3Rvcj4oKTtcbiAgICAgICAgdGhpcy5oZWFsdGhiYXJzID0gbmV3IE1hcDxudW1iZXIsIEhlYWx0aGJhckhVRD4oKTtcblxuICAgICAgICB0aGlzLmxhc2VyZ3VucyA9IG5ldyBBcnJheTxMYXNlckd1bj4oKTtcbiAgICAgICAgdGhpcy5oZWFsdGhwYWNrcyA9IG5ldyBBcnJheTxIZWFsdGhwYWNrPigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzZWUgU2NlbmUudXBkYXRlKClcbiAgICAgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgbG9hZFNjZW5lKCkge1xuICAgICAgICAvLyBMb2FkIHRoZSBwbGF5ZXIgYW5kIGVuZW15IHNwcml0ZXNoZWV0c1xuICAgICAgICB0aGlzLmxvYWQuc3ByaXRlc2hlZXQoXCJwbGF5ZXIxXCIsIFwiaHc0X2Fzc2V0cy9zcHJpdGVzaGVldHMvcGxheWVyMS5qc29uXCIpO1xuXG4gICAgICAgIC8vIExvYWQgaW4gdGhlIGVuZW15IHNwcml0ZXNcbiAgICAgICAgdGhpcy5sb2FkLnNwcml0ZXNoZWV0KFwiQmx1ZUVuZW15XCIsIFwiaHc0X2Fzc2V0cy9zcHJpdGVzaGVldHMvQmx1ZUVuZW15Lmpzb25cIik7XG4gICAgICAgIHRoaXMubG9hZC5zcHJpdGVzaGVldChcIlJlZEVuZW15XCIsIFwiaHc0X2Fzc2V0cy9zcHJpdGVzaGVldHMvUmVkRW5lbXkuanNvblwiKTtcbiAgICAgICAgdGhpcy5sb2FkLnNwcml0ZXNoZWV0KFwiQmx1ZUhlYWxlclwiLCBcImh3NF9hc3NldHMvc3ByaXRlc2hlZXRzL0JsdWVIZWFsZXIuanNvblwiKTtcbiAgICAgICAgdGhpcy5sb2FkLnNwcml0ZXNoZWV0KFwiUmVkSGVhbGVyXCIsIFwiaHc0X2Fzc2V0cy9zcHJpdGVzaGVldHMvUmVkSGVhbGVyLmpzb25cIik7XG5cbiAgICAgICAgLy8gTG9hZCB0aGUgdGlsZW1hcFxuICAgICAgICB0aGlzLmxvYWQudGlsZW1hcChcImxldmVsXCIsIFwiaHc0X2Fzc2V0cy90aWxlbWFwcy9IVzRUaWxlbWFwLmpzb25cIik7XG5cbiAgICAgICAgLy8gTG9hZCB0aGUgZW5lbXkgbG9jYXRpb25zXG4gICAgICAgIHRoaXMubG9hZC5vYmplY3QoXCJyZWRcIiwgXCJodzRfYXNzZXRzL2RhdGEvZW5lbWllcy9yZWQuanNvblwiKTtcbiAgICAgICAgdGhpcy5sb2FkLm9iamVjdChcImJsdWVcIiwgXCJodzRfYXNzZXRzL2RhdGEvZW5lbWllcy9ibHVlLmpzb25cIik7XG5cbiAgICAgICAgLy8gTG9hZCB0aGUgaGVhbHRocGFjayBhbmQgbGFzZXJndW4gbG9hY3Rpb25zXG4gICAgICAgIHRoaXMubG9hZC5vYmplY3QoXCJoZWFsdGhwYWNrc1wiLCBcImh3NF9hc3NldHMvZGF0YS9pdGVtcy9oZWFsdGhwYWNrcy5qc29uXCIpO1xuICAgICAgICB0aGlzLmxvYWQub2JqZWN0KFwibGFzZXJndW5zXCIsIFwiaHc0X2Fzc2V0cy9kYXRhL2l0ZW1zL2xhc2VyZ3Vucy5qc29uXCIpO1xuXG4gICAgICAgIC8vIExvYWQgdGhlIGhlYWx0aHBhY2ssIGludmVudG9yeSBzbG90LCBhbmQgbGFzZXIgZ3VuIHNwcml0ZXNcbiAgICAgICAgdGhpcy5sb2FkLmltYWdlKFwiaGVhbHRocGFja1wiLCBcImh3NF9hc3NldHMvc3ByaXRlcy9oZWFsdGhwYWNrLnBuZ1wiKTtcbiAgICAgICAgdGhpcy5sb2FkLmltYWdlKFwiaW52ZW50b3J5U2xvdFwiLCBcImh3NF9hc3NldHMvc3ByaXRlcy9pbnZlbnRvcnkucG5nXCIpO1xuICAgICAgICB0aGlzLmxvYWQuaW1hZ2UoXCJsYXNlckd1blwiLCBcImh3NF9hc3NldHMvc3ByaXRlcy9sYXNlckd1bi5wbmdcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzZWUgU2NlbmUuc3RhcnRTY2VuZVxuICAgICAqL1xuICAgIHB1YmxpYyBvdmVycmlkZSBzdGFydFNjZW5lKCkge1xuICAgICAgICAvLyBBZGQgaW4gdGhlIHRpbGVtYXBcbiAgICAgICAgbGV0IHRpbGVtYXBMYXllcnMgPSB0aGlzLmFkZC50aWxlbWFwKFwibGV2ZWxcIik7XG5cbiAgICAgICAgLy8gR2V0IHRoZSB3YWxsIGxheWVyXG4gICAgICAgIHRoaXMud2FsbHMgPSA8T3J0aG9nb25hbFRpbGVtYXA+dGlsZW1hcExheWVyc1sxXS5nZXRJdGVtcygpWzBdO1xuXG4gICAgICAgIC8vIFNldCB0aGUgdmlld3BvcnQgYm91bmRzIHRvIHRoZSB0aWxlbWFwXG4gICAgICAgIGxldCB0aWxlbWFwU2l6ZTogVmVjMiA9IHRoaXMud2FsbHMuc2l6ZTtcblxuICAgICAgICB0aGlzLnZpZXdwb3J0LnNldEJvdW5kcygwLCAwLCB0aWxlbWFwU2l6ZS54LCB0aWxlbWFwU2l6ZS55KTtcbiAgICAgICAgdGhpcy52aWV3cG9ydC5zZXRab29tTGV2ZWwoMik7XG5cbiAgICAgICAgdGhpcy5pbml0TGF5ZXJzKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgdGhlIHBsYXllclxuICAgICAgICB0aGlzLmluaXRpYWxpemVQbGF5ZXIoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplSXRlbXMoKTtcblxuICAgICAgICB0aGlzLmluaXRpYWxpemVOYXZtZXNoKCk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBOUENTXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZU5QQ3MoKTtcblxuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gcmVsZXZhbnQgZXZlbnRzXG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKFwiaGVhbHRocGFja1wiKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoXCJlbmVteURpZWRcIik7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKEl0ZW1FdmVudC5JVEVNX1JFUVVFU1QpO1xuXG4gICAgICAgIC8vIEFkZCBhIFVJIGZvciBoZWFsdGhcbiAgICAgICAgdGhpcy5hZGRVSUxheWVyKFwiaGVhbHRoXCIpO1xuXG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKFBsYXllckV2ZW50LlBMQVlFUl9LSUxMRUQpO1xuICAgICAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZShCYXR0bGVyRXZlbnQuQkFUVExFUl9LSUxMRUQpO1xuICAgICAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZShCYXR0bGVyRXZlbnQuQkFUVExFUl9SRVNQQVdOKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHNlZSBTY2VuZS51cGRhdGVTY2VuZVxuICAgICAqL1xuICAgIHB1YmxpYyBvdmVycmlkZSB1cGRhdGVTY2VuZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB3aGlsZSAodGhpcy5yZWNlaXZlci5oYXNOZXh0RXZlbnQoKSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFdmVudCh0aGlzLnJlY2VpdmVyLmdldE5leHRFdmVudCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhlYWx0aGJhcnMuZm9yRWFjaChoZWFsdGhiYXIgPT4gaGVhbHRoYmFyLnVwZGF0ZShkZWx0YVQpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgZXZlbnRzIGZyb20gdGhlIHJlc3Qgb2YgdGhlIGdhbWVcbiAgICAgKiBAcGFyYW0gZXZlbnQgYSBnYW1lIGV2ZW50XG4gICAgICovXG4gICAgcHVibGljIGhhbmRsZUV2ZW50KGV2ZW50OiBHYW1lRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIEJhdHRsZXJFdmVudC5CQVRUTEVSX0tJTExFRDoge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBCYXR0bGVyRXZlbnQuQkFUVExFUl9SRVNQQVdOOiB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEl0ZW1FdmVudC5JVEVNX1JFUVVFU1Q6IHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUl0ZW1SZXF1ZXN0KGV2ZW50LmRhdGEuZ2V0KFwibm9kZVwiKSwgZXZlbnQuZGF0YS5nZXQoXCJpbnZlbnRvcnlcIikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5oYW5kbGVkIGV2ZW50IHR5cGUgXCIke2V2ZW50LnR5cGV9XCIgY2F1Z2h0IGluIEhXNFNjZW5lIGV2ZW50IGhhbmRsZXJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBoYW5kbGVJdGVtUmVxdWVzdChub2RlOiBHYW1lTm9kZSwgaW52ZW50b3J5OiBJbnZlbnRvcnkpOiB2b2lkIHtcbiAgICAgICAgbGV0IGl0ZW1zOiBJdGVtW10gPSBuZXcgQXJyYXk8SXRlbT4oLi4udGhpcy5oZWFsdGhwYWNrcywgLi4udGhpcy5sYXNlcmd1bnMpLmZpbHRlcigoaXRlbTogSXRlbSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaW52ZW50b3J5ID09PSBudWxsICYmIGl0ZW0ucG9zaXRpb24uZGlzdGFuY2VUbyhub2RlLnBvc2l0aW9uKSA8PSAxMDA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpbnZlbnRvcnkuYWRkKGl0ZW1zLnJlZHVjZShDbG9zZXN0UG9zaXRpb25lZChub2RlKSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEluaXRpYWxpemVzIHRoZSBsYXllcnMgaW4gdGhlIHNjZW5lICovXG4gICAgcHJvdGVjdGVkIGluaXRMYXllcnMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuYWRkTGF5ZXIoXCJwcmltYXJ5XCIsIDEwKTtcbiAgICAgICAgdGhpcy5hZGRVSUxheWVyKFwic2xvdHNcIik7XG4gICAgICAgIHRoaXMuYWRkVUlMYXllcihcIml0ZW1zXCIpO1xuICAgICAgICB0aGlzLmdldExheWVyKFwic2xvdHNcIikuc2V0RGVwdGgoMSk7XG4gICAgICAgIHRoaXMuZ2V0TGF5ZXIoXCJpdGVtc1wiKS5zZXREZXB0aCgyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgcGxheWVyIGluIHRoZSBzY2VuZVxuICAgICAqL1xuICAgIHByb3RlY3RlZCBpbml0aWFsaXplUGxheWVyKCk6IHZvaWQge1xuICAgICAgICBsZXQgcGxheWVyID0gdGhpcy5hZGQuYW5pbWF0ZWRTcHJpdGUoUGxheWVyQWN0b3IsIFwicGxheWVyMVwiLCBcInByaW1hcnlcIik7XG4gICAgICAgIHBsYXllci5wb3NpdGlvbi5zZXQoNDAsIDQwKTtcbiAgICAgICAgcGxheWVyLmJhdHRsZUdyb3VwID0gMjtcbiAgICAgICAgcGxheWVyLmhlYWx0aCA9IDEwO1xuICAgICAgICBwbGF5ZXIubWF4SGVhbHRoID0gMTA7XG4gICAgICAgIHBsYXllci5pbnZlbnRvcnkub25DaGFuZ2UgPSBJdGVtRXZlbnQuSU5WRU5UT1JZX0NIQU5HRURcbiAgICAgICAgcGxheWVyLmFkZFBoeXNpY3MobmV3IEFBQkIoVmVjMi5aRVJPLCBuZXcgVmVjMig4LCA4KSkpO1xuICAgICAgICBsZXQgaGVhbHRoYmFyID0gbmV3IEhlYWx0aGJhckhVRCh0aGlzLCBwbGF5ZXIsIFwicHJpbWFyeVwiLCB7c2l6ZTogcGxheWVyLnNpemUuY2xvbmUoKS5zY2FsZWQoMiwgMS8yKSwgb2Zmc2V0OiBwbGF5ZXIuc2l6ZS5jbG9uZSgpLnNjYWxlZCgwLCAtMS8yKX0pO1xuICAgICAgICB0aGlzLmhlYWx0aGJhcnMuc2V0KHBsYXllci5pZCwgaGVhbHRoYmFyKTtcblxuICAgICAgICBwbGF5ZXIuYWRkQUkoUGxheWVyQUkpO1xuICAgICAgICBwbGF5ZXIuYW5pbWF0aW9uLnBsYXkoXCJJRExFXCIpO1xuICAgICAgICB0aGlzLnBsYXllciA9IHBsYXllclxuICAgICAgICB0aGlzLmJhdHRsZXJzLnB1c2gocGxheWVyKTtcbiAgICAgICAgdGhpcy52aWV3cG9ydC5mb2xsb3cocGxheWVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgTlBDcyBcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgaW5pdGlhbGl6ZU5QQ3MoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBvYmplY3QgZGF0YSBmb3IgdGhlIHJlZCBlbmVtaWVzXG4gICAgICAgIGxldCByZWQgPSB0aGlzLmxvYWQuZ2V0T2JqZWN0KFwicmVkXCIpO1xuXG4gICAgICAgIGxldCBucGMgPSB0aGlzLmFkZC5hbmltYXRlZFNwcml0ZShOUENBY3RvciwgXCJSZWRFbmVteVwiLCBcInByaW1hcnlcIik7XG4gICAgICAgIG5wYy5wb3NpdGlvbi5zZXQocmVkLmVuZW1pZXNbMF1bMF0sIHJlZC5lbmVtaWVzWzBdWzFdKTtcbiAgICAgICAgbnBjLmFkZFBoeXNpY3MobmV3IEFBQkIoVmVjMi5aRVJPLCBuZXcgVmVjMig3LCA3KSksIG51bGwsIGZhbHNlKTtcbiAgICAgICAgbGV0IGhlYWx0aGJhciA9IG5ldyBIZWFsdGhiYXJIVUQodGhpcywgbnBjLCBcInByaW1hcnlcIiwge3NpemU6IG5wYy5zaXplLmNsb25lKCkuc2NhbGVkKDIsIDEvMiksIG9mZnNldDogbnBjLnNpemUuY2xvbmUoKS5zY2FsZWQoMCwgLTEvMil9KTtcbiAgICAgICAgdGhpcy5oZWFsdGhiYXJzLnNldChucGMuaWQsIGhlYWx0aGJhcik7XG4gICAgICAgIG5wYy5iYXR0bGVHcm91cCA9IDFcbiAgICAgICAgbnBjLnNwZWVkID0gNTtcbiAgICAgICAgbnBjLmhlYWx0aCA9IDEwO1xuICAgICAgICBucGMubWF4SGVhbHRoID0gMTA7XG4gICAgICAgIG5wYy5uYXZrZXkgPSBcIm5hdm1lc2hcIjtcbiAgICAgICAgbnBjLmFkZEFJKEd1YXJkQmVoYXZpb3IsIHt0YXJnZXQ6IG5ldyBCYXNpY1RhcmdldGFibGUobmV3IFBvc2l0aW9uKG5wYy5wb3NpdGlvbi54LCBucGMucG9zaXRpb24ueSkpLCByYW5nZTogMTAwfSk7XG4gICAgICAgIG5wYy5hbmltYXRpb24ucGxheShcIklETEVcIik7XG4gICAgICAgIHRoaXMuYmF0dGxlcnMucHVzaChucGMpO1xuXG4gICAgICAgIC8vIFNldHVwIHRoZSBmb2xsb3dlcnNcblxuICAgICAgICBsZXQgZm9sbG93ZXIxID0gdGhpcy5hZGQuYW5pbWF0ZWRTcHJpdGUoTlBDQWN0b3IsIFwiUmVkRW5lbXlcIiwgXCJwcmltYXJ5XCIpO1xuICAgICAgICBmb2xsb3dlcjEucG9zaXRpb24uc2V0KHJlZC5lbmVtaWVzWzFdWzBdLCByZWQuZW5lbWllc1sxXVsxXSk7XG4gICAgICAgIGZvbGxvd2VyMS5hZGRQaHlzaWNzKG5ldyBBQUJCKFZlYzIuWkVSTywgbmV3IFZlYzIoNywgNykpLCBudWxsLCBmYWxzZSk7XG4gICAgICAgIGhlYWx0aGJhciA9IG5ldyBIZWFsdGhiYXJIVUQodGhpcywgZm9sbG93ZXIxLCBcInByaW1hcnlcIiwge3NpemU6IGZvbGxvd2VyMS5zaXplLmNsb25lKCkuc2NhbGVkKDIsIDEvMiksIG9mZnNldDogZm9sbG93ZXIxLnNpemUuY2xvbmUoKS5zY2FsZWQoMCwgLTEvMil9KTtcbiAgICAgICAgdGhpcy5oZWFsdGhiYXJzLnNldChmb2xsb3dlcjEuaWQsIGhlYWx0aGJhcik7XG4gICAgICAgIGZvbGxvd2VyMS5iYXR0bGVHcm91cCA9IDJcbiAgICAgICAgZm9sbG93ZXIxLnNwZWVkID0gNTtcbiAgICAgICAgZm9sbG93ZXIxLmhlYWx0aCA9IDEwO1xuICAgICAgICBmb2xsb3dlcjEubWF4SGVhbHRoID0gMTA7XG4gICAgICAgIGZvbGxvd2VyMS5uYXZrZXkgPSBcIm5hdm1lc2hcIjtcbiAgICAgICAgZm9sbG93ZXIxLmFkZEFJKEd1YXJkQmVoYXZpb3IsIHt0YXJnZXQ6IG5ldyBCYXNpY1RhcmdldGFibGUodGhpcy5wbGF5ZXIpLCByYW5nZTogMTAwfSk7XG4gICAgICAgIGZvbGxvd2VyMS5hbmltYXRpb24ucGxheShcIklETEVcIik7XG4gICAgICAgIHRoaXMuYmF0dGxlcnMucHVzaChucGMpO1xuXG5cbiAgICAgICAgbGV0IGZvbGxvd2VyMiA9IHRoaXMuYWRkLmFuaW1hdGVkU3ByaXRlKE5QQ0FjdG9yLCBcIlJlZEVuZW15XCIsIFwicHJpbWFyeVwiKTtcbiAgICAgICAgZm9sbG93ZXIyLnBvc2l0aW9uLnNldChyZWQuZW5lbWllc1swXVswXSwgcmVkLmVuZW1pZXNbMF1bMV0pO1xuICAgICAgICBmb2xsb3dlcjIuYWRkUGh5c2ljcyhuZXcgQUFCQihWZWMyLlpFUk8sIG5ldyBWZWMyKDcsIDcpKSwgbnVsbCwgZmFsc2UpO1xuICAgICAgICBoZWFsdGhiYXIgPSBuZXcgSGVhbHRoYmFySFVEKHRoaXMsIGZvbGxvd2VyMiwgXCJwcmltYXJ5XCIsIHtzaXplOiBmb2xsb3dlcjIuc2l6ZS5jbG9uZSgpLnNjYWxlZCgyLCAxLzIpLCBvZmZzZXQ6IGZvbGxvd2VyMi5zaXplLmNsb25lKCkuc2NhbGVkKDAsIC0xLzIpfSk7XG4gICAgICAgIHRoaXMuaGVhbHRoYmFycy5zZXQoZm9sbG93ZXIyLmlkLCBoZWFsdGhiYXIpO1xuICAgICAgICBmb2xsb3dlcjIuYmF0dGxlR3JvdXAgPSAyXG4gICAgICAgIGZvbGxvd2VyMi5zcGVlZCA9IDU7XG4gICAgICAgIGZvbGxvd2VyMi5oZWFsdGggPSAxMDtcbiAgICAgICAgZm9sbG93ZXIyLm1heEhlYWx0aCA9IDEwO1xuICAgICAgICBmb2xsb3dlcjIubmF2a2V5ID0gXCJuYXZtZXNoXCI7XG4gICAgICAgIGZvbGxvd2VyMi5hZGRBSShHdWFyZEJlaGF2aW9yLCB7dGFyZ2V0OiBuZXcgQmFzaWNUYXJnZXRhYmxlKGZvbGxvd2VyMSksIHJhbmdlOiAxMDB9KTtcbiAgICAgICAgZm9sbG93ZXIyLmFuaW1hdGlvbi5wbGF5KFwiSURMRVwiKTtcbiAgICAgICAgdGhpcy5iYXR0bGVycy5wdXNoKGZvbGxvd2VyMik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlIGl0ZW1zIGluIHRoZSBzY2VuZSAoaGVhbHRocGFja3MgYW5kIGxhc2VyIGd1bnMpXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGluaXRpYWxpemVJdGVtcygpOiB2b2lkIHtcbiAgICAgICAgbGV0IGxhc2VyZ3VucyA9IHRoaXMubG9hZC5nZXRPYmplY3QoXCJsYXNlcmd1bnNcIik7XG4gICAgICAgIHRoaXMubGFzZXJndW5zID0gbmV3IEFycmF5PExhc2VyR3VuPihsYXNlcmd1bnMuaXRlbXMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXNlcmd1bnMuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzcHJpdGUgPSB0aGlzLmFkZC5zcHJpdGUoXCJsYXNlckd1blwiLCBcInByaW1hcnlcIik7XG4gICAgICAgICAgICBsZXQgbGluZSA9IDxMaW5lPnRoaXMuYWRkLmdyYXBoaWMoR3JhcGhpY1R5cGUuTElORSwgXCJwcmltYXJ5XCIsIHtzdGFydDogVmVjMi5aRVJPLCBlbmQ6IFZlYzIuWkVST30pO1xuICAgICAgICAgICAgdGhpcy5sYXNlcmd1bnNbaV0gPSBMYXNlckd1bi5jcmVhdGUoc3ByaXRlLCBsaW5lKTtcbiAgICAgICAgICAgIHRoaXMubGFzZXJndW5zW2ldLnBvc2l0aW9uLnNldChsYXNlcmd1bnMuaXRlbXNbaV1bMF0sIGxhc2VyZ3Vucy5pdGVtc1tpXVsxXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIG5hdm1lc2ggZ3JhcGggdXNlZCBieSB0aGUgTlBDcyBpbiB0aGUgSFc0U2NlbmUuIFRoaXMgbWV0aG9kIGlzIGEgbGl0dGxlIGJ1Z2d5LCBhbmRcbiAgICAgKiBhbmQgaXQgc2tpcHMgb3ZlciBzb21lIG9mIHRoZSBwb3NpdGlvbnMgb24gdGhlIHRpbGVtYXAuIElmIHlvdSBjYW4gZml4IG15IG5hdm1lc2ggZ2VuZXJhdGlvbiBhbGdvcml0aG0sXG4gICAgICogZ28gZm9yIGl0LlxuICAgICAqIFxuICAgICAqIC0gUGV0ZXJcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgaW5pdGlhbGl6ZU5hdm1lc2goKTogdm9pZCB7XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgZ3JhcGhcbiAgICAgICAgdGhpcy5ncmFwaCA9IG5ldyBQb3NpdGlvbkdyYXBoKCk7XG5cbiAgICAgICAgbGV0IGRpbTogVmVjMiA9IHRoaXMud2FsbHMuZ2V0RGltZW5zaW9ucygpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbS55OyBpKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZGltLng7IGorKykge1xuICAgICAgICAgICAgICAgIGxldCB0aWxlOiBBQUJCID0gdGhpcy53YWxscy5nZXRUaWxlQ29sbGlkZXIoaiwgaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmFwaC5hZGRQb3NpdGlvbmVkTm9kZSh0aWxlLmNlbnRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmM6IFZlYzI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ncmFwaC5udW1WZXJ0aWNlczsgaSsrKSB7XG4gICAgICAgICAgICByYyA9IHRoaXMud2FsbHMuZ2V0VGlsZUNvbFJvdyhpKTtcbiAgICAgICAgICAgIGlmICghdGhpcy53YWxscy5pc1RpbGVDb2xsaWRhYmxlKHJjLngsIHJjLnkpICYmXG4gICAgICAgICAgICAgICAgIXRoaXMud2FsbHMuaXNUaWxlQ29sbGlkYWJsZShNYXRoVXRpbHMuY2xhbXAocmMueCAtIDEsIDAsIGRpbS54IC0gMSksIHJjLnkpICYmXG4gICAgICAgICAgICAgICAgIXRoaXMud2FsbHMuaXNUaWxlQ29sbGlkYWJsZShNYXRoVXRpbHMuY2xhbXAocmMueCArIDEsIDAsIGRpbS54IC0gMSksIHJjLnkpICYmXG4gICAgICAgICAgICAgICAgIXRoaXMud2FsbHMuaXNUaWxlQ29sbGlkYWJsZShyYy54LCBNYXRoVXRpbHMuY2xhbXAocmMueSAtIDEsIDAsIGRpbS55IC0gMSkpICYmXG4gICAgICAgICAgICAgICAgIXRoaXMud2FsbHMuaXNUaWxlQ29sbGlkYWJsZShyYy54LCBNYXRoVXRpbHMuY2xhbXAocmMueSArIDEsIDAsIGRpbS55IC0gMSkpICYmXG4gICAgICAgICAgICAgICAgIXRoaXMud2FsbHMuaXNUaWxlQ29sbGlkYWJsZShNYXRoVXRpbHMuY2xhbXAocmMueCArIDEsIDAsIGRpbS54IC0gMSksIE1hdGhVdGlscy5jbGFtcChyYy55ICsgMSwgMCwgZGltLnkgLSAxKSkgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy53YWxscy5pc1RpbGVDb2xsaWRhYmxlKE1hdGhVdGlscy5jbGFtcChyYy54IC0gMSwgMCwgZGltLnggLSAxKSwgTWF0aFV0aWxzLmNsYW1wKHJjLnkgKyAxLCAwLCBkaW0ueSAtIDEpKSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLndhbGxzLmlzVGlsZUNvbGxpZGFibGUoTWF0aFV0aWxzLmNsYW1wKHJjLnggKyAxLCAwLCBkaW0ueCAtIDEpLCBNYXRoVXRpbHMuY2xhbXAocmMueSAtIDEsIDAsIGRpbS55IC0gMSkpICYmXG4gICAgICAgICAgICAgICAgIXRoaXMud2FsbHMuaXNUaWxlQ29sbGlkYWJsZShNYXRoVXRpbHMuY2xhbXAocmMueCAtIDEsIDAsIGRpbS54IC0gMSksIE1hdGhVdGlscy5jbGFtcChyYy55IC0gMSwgMCwgZGltLnkgLSAxKSlcblxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGVkZ2UgdG8gdGhlIGxlZnRcbiAgICAgICAgICAgICAgICByYyA9IHRoaXMud2FsbHMuZ2V0VGlsZUNvbFJvdyhpICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKChpICsgMSkgJSBkaW0ueCAhPT0gMCAmJiAhdGhpcy53YWxscy5pc1RpbGVDb2xsaWRhYmxlKHJjLngsIHJjLnkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGguYWRkRWRnZShpLCBpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMuYWRkLmdyYXBoaWMoR3JhcGhpY1R5cGUuTElORSwgXCJncmFwaFwiLCB7c3RhcnQ6IHRoaXMuZ3JhcGguZ2V0Tm9kZVBvc2l0aW9uKGkpLCBlbmQ6IHRoaXMuZ3JhcGguZ2V0Tm9kZVBvc2l0aW9uKGkgKyAxKX0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBlZGdlIGJlbG93XG4gICAgICAgICAgICAgICAgcmMgPSB0aGlzLndhbGxzLmdldFRpbGVDb2xSb3coaSArIGRpbS54KTtcbiAgICAgICAgICAgICAgICBpZiAoaSArIGRpbS54IDwgdGhpcy5ncmFwaC5udW1WZXJ0aWNlcyAmJiAhdGhpcy53YWxscy5pc1RpbGVDb2xsaWRhYmxlKHJjLngsIHJjLnkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGguYWRkRWRnZShpLCBpICsgZGltLngpO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzLmFkZC5ncmFwaGljKEdyYXBoaWNUeXBlLkxJTkUsIFwiZ3JhcGhcIiwge3N0YXJ0OiB0aGlzLmdyYXBoLmdldE5vZGVQb3NpdGlvbihpKSwgZW5kOiB0aGlzLmdyYXBoLmdldE5vZGVQb3NpdGlvbihpICsgZGltLngpfSlcbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHRoaXMgZ3JhcGggYXMgYSBuYXZpZ2FibGUgZW50aXR5XG4gICAgICAgIGxldCBuYXZtZXNoID0gbmV3IE5hdm1lc2godGhpcy5ncmFwaCk7XG4gICAgICAgIC8vIEFkZCBkaWZmZXJlbnQgc3RyYXRlZ2llcyB0byB1c2UgZm9yIHRoaXMgbmF2bWVzaFxuICAgICAgICBuYXZtZXNoLnJlZ2lzdGVyU3RyYXRlZ3koXCJkaXJlY3RcIiwgbmV3IERpcmVjdFN0cmF0ZWd5KG5hdm1lc2gpKTtcbiAgICAgICAgbmF2bWVzaC5yZWdpc3RlclN0cmF0ZWd5KFwiYXN0YXJcIiwgbmV3IEFzdGFyU3RyYXRlZ3kobmF2bWVzaCkpO1xuICAgICAgICAvLyBTZWxlY3QgQSogYXMgb3VyIG5hdmlnYXRpb24gc3RyYXRlZ3lcbiAgICAgICAgbmF2bWVzaC5zZXRTdHJhdGVneShcImFzdGFyXCIpO1xuXG4gICAgICAgIC8vIEFkZCB0aGlzIG5hdm1lc2ggdG8gdGhlIG5hdmlnYXRpb24gbWFuYWdlclxuICAgICAgICB0aGlzLm5hdk1hbmFnZXIuYWRkTmF2aWdhYmxlRW50aXR5KFwibmF2bWVzaFwiLCBuYXZtZXNoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0QmF0dGxlcnMoKTogQmF0dGxlcltdIHsgcmV0dXJuIHRoaXMuYmF0dGxlcnM7IH1cblxuICAgIHB1YmxpYyBnZXRXYWxscygpOiBPcnRob2dvbmFsVGlsZW1hcCB7IHJldHVybiB0aGlzLndhbGxzOyB9XG5cbiAgICBwdWJsaWMgZ2V0SGVhbHRocGFja3MoKTogSGVhbHRocGFja1tdIHsgcmV0dXJuIHRoaXMuaGVhbHRocGFja3M7IH1cblxuICAgIHB1YmxpYyBnZXRMYXNlckd1bnMoKTogTGFzZXJHdW5bXSB7IHJldHVybiB0aGlzLmxhc2VyZ3VuczsgfVxuXG4gICAgcHVibGljIGlzVGFyZ2V0VmlzaWJsZShwb3NpdGlvbjogVmVjMiwgdGFyZ2V0OiBWZWMyKTogYm9vbGVhbiB7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBuZXcgcGxheWVyIGxvY2F0aW9uXG4gICAgICAgIGxldCBzdGFydCA9IHBvc2l0aW9uLmNsb25lKCk7XG4gICAgICAgIGxldCBkZWx0YSA9IHRhcmdldC5jbG9uZSgpLnN1YihzdGFydCk7XG5cbiAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSB0aWxlbWFwIHJlZ2lvbiB1bnRpbCB3ZSBmaW5kIGEgY29sbGlzaW9uXG4gICAgICAgIGxldCBtaW5YID0gTWF0aC5taW4oc3RhcnQueCwgdGFyZ2V0LngpO1xuICAgICAgICBsZXQgbWF4WCA9IE1hdGgubWF4KHN0YXJ0LngsIHRhcmdldC54KTtcbiAgICAgICAgbGV0IG1pblkgPSBNYXRoLm1pbihzdGFydC55LCB0YXJnZXQueSk7XG4gICAgICAgIGxldCBtYXhZID0gTWF0aC5tYXgoc3RhcnQueSwgdGFyZ2V0LnkpO1xuXG4gICAgICAgIC8vIEdldCB0aGUgd2FsbCB0aWxlbWFwXG4gICAgICAgIGxldCB3YWxscyA9IHRoaXMuZ2V0V2FsbHMoKTtcblxuICAgICAgICBsZXQgbWluSW5kZXggPSB3YWxscy5nZXRUaWxlbWFwUG9zaXRpb24obWluWCwgbWluWSk7XG4gICAgICAgIGxldCBtYXhJbmRleCA9IHdhbGxzLmdldFRpbGVtYXBQb3NpdGlvbihtYXhYLCBtYXhZKTtcblxuICAgICAgICBsZXQgdGlsZVNpemUgPSB3YWxscy5nZXRTY2FsZWRUaWxlU2l6ZSgpO1xuXG4gICAgICAgIGZvciAobGV0IGNvbCA9IG1pbkluZGV4Lng7IGNvbCA8PSBtYXhJbmRleC54OyBjb2wrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gbWluSW5kZXgueTsgcm93IDw9IG1heEluZGV4Lnk7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdhbGxzLmlzVGlsZUNvbGxpZGFibGUoY29sLCByb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcG9zaXRpb24gb2YgdGhpcyB0aWxlXG4gICAgICAgICAgICAgICAgICAgIGxldCB0aWxlUG9zID0gbmV3IFZlYzIoY29sICogdGlsZVNpemUueCArIHRpbGVTaXplLnggLyAyLCByb3cgKiB0aWxlU2l6ZS55ICsgdGlsZVNpemUueSAvIDIpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIGNvbGxpZGVyIGZvciB0aGlzIHRpbGVcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbGxpZGVyID0gbmV3IEFBQkIodGlsZVBvcywgdGlsZVNpemUuc2NhbGVkKDEgLyAyKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGhpdCA9IGNvbGxpZGVyLmludGVyc2VjdFNlZ21lbnQoc3RhcnQsIGRlbHRhLCBWZWMyLlpFUk8pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChoaXQgIT09IG51bGwgJiYgc3RhcnQuZGlzdGFuY2VTcVRvKGhpdC5wb3MpIDwgc3RhcnQuZGlzdGFuY2VTcVRvKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhpdCBhIHdhbGwsIHdlIGNhbid0IHNlZSB0aGUgcGxheWVyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICB9XG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1NjZW5lL1NjZW5lXCI7XG5pbXBvcnQgT3J0aG9nb25hbFRpbGVtYXAgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL1RpbGVtYXBzL09ydGhvZ29uYWxUaWxlbWFwXCI7XG5pbXBvcnQgTGFzZXJHdW4gZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL0l0ZW1TeXN0ZW0vSXRlbXMvTGFzZXJHdW5cIjtcbmltcG9ydCBIZWFsdGhwYWNrIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9JdGVtU3lzdGVtL0l0ZW1zL0hlYWx0aHBhY2tcIjtcbmltcG9ydCBCYXR0bGVyIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9CYXR0bGVTeXN0ZW0vQmF0dGxlclwiO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIEhXNFNjZW5lIGV4dGVuZHMgU2NlbmUge1xuXG4gICAgcHVibGljIGFic3RyYWN0IGdldEJhdHRsZXJzKCk6IEJhdHRsZXJbXTtcblxuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXRXYWxscygpOiBPcnRob2dvbmFsVGlsZW1hcDtcblxuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXRIZWFsdGhwYWNrcygpOiBIZWFsdGhwYWNrW107XG5cbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0TGFzZXJHdW5zKCk6IExhc2VyR3VuW107XG5cbiAgICBwdWJsaWMgYWJzdHJhY3QgaXNUYXJnZXRWaXNpYmxlKHBvc2l0aW9uOiBWZWMyLCB0YXJnZXQ6IFZlYzIpOiBib29sZWFuO1xuICAgIFxufSIsImltcG9ydCBQb3NpdGlvbkdyYXBoIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvR3JhcGhzL1Bvc2l0aW9uR3JhcGhcIjtcbmltcG9ydCBBY3RvciBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL0ludGVyZmFjZXMvQWN0b3JcIjtcbmltcG9ydCBBQUJCIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvU2hhcGVzL0FBQkJcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IERlYnVnIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EZWJ1Zy9EZWJ1Z1wiO1xuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vLi4vV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFwiO1xuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HYW1lTm9kZVwiO1xuaW1wb3J0IHsgR3JhcGhpY1R5cGUgfSBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvR3JhcGhpY3MvR3JhcGhpY1R5cGVzXCI7XG5pbXBvcnQgTGluZSBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvR3JhcGhpY3MvTGluZVwiO1xuaW1wb3J0IE9ydGhvZ29uYWxUaWxlbWFwIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9UaWxlbWFwcy9PcnRob2dvbmFsVGlsZW1hcFwiO1xuaW1wb3J0IE5hdm1lc2ggZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1BhdGhmaW5kaW5nL05hdm1lc2hcIjtcbmltcG9ydCBEaXJlY3RTdHJhdGVneSBmcm9tIFwiLi4vLi4vV29sZmllMkQvUGF0aGZpbmRpbmcvU3RyYXRlZ2llcy9EaXJlY3RTdHJhdGVneVwiO1xuaW1wb3J0IERqaWtzdHJhUGF0aFN0cmF0IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9QYXRoZmluZGluZy9TdHJhdGVnaWVzL0RqaWtzdHJhU3RyYXRlZ3lcIjtcbmltcG9ydCBSZW5kZXJpbmdNYW5hZ2VyIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9SZW5kZXJpbmcvUmVuZGVyaW5nTWFuYWdlclwiO1xuaW1wb3J0IFNjZW5lTWFuYWdlciBmcm9tIFwiLi4vLi4vV29sZmllMkQvU2NlbmUvU2NlbmVNYW5hZ2VyXCI7XG5pbXBvcnQgVmlld3BvcnQgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1NjZW5lR3JhcGgvVmlld3BvcnRcIjtcbmltcG9ydCBUaW1lciBmcm9tIFwiLi4vLi4vV29sZmllMkQvVGltaW5nL1RpbWVyXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1V0aWxzL0NvbG9yXCI7XG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9VdGlscy9NYXRoVXRpbHNcIjtcbmltcG9ydCBSYW5kVXRpbHMgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1V0aWxzL1JhbmRVdGlsc1wiO1xuaW1wb3J0IE5QQ0FjdG9yIGZyb20gXCIuLi9BY3RvcnMvTlBDQWN0b3JcIjtcbmltcG9ydCBQbGF5ZXJBY3RvciBmcm9tIFwiLi4vQWN0b3JzL1BsYXllckFjdG9yXCI7XG5pbXBvcnQgR3VhcmRCZWhhdmlvciBmcm9tIFwiLi4vQUkvTlBDL05QQ0JlaGF2aW9yL0dhdXJkQmVoYXZpb3JcIjtcbmltcG9ydCBIZWFsZXJCZWhhdmlvciBmcm9tIFwiLi4vQUkvTlBDL05QQ0JlaGF2aW9yL0hlYWxlckJlaGF2aW9yXCI7XG5pbXBvcnQgUGxheWVyQUkgZnJvbSBcIi4uL0FJL1BsYXllci9QbGF5ZXJBSVwiO1xuaW1wb3J0IHsgSXRlbUV2ZW50LCBQbGF5ZXJFdmVudCwgQmF0dGxlckV2ZW50IH0gZnJvbSBcIi4uL0V2ZW50c1wiO1xuaW1wb3J0IEJhdHRsZXIgZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL0JhdHRsZVN5c3RlbS9CYXR0bGVyXCI7XG5pbXBvcnQgQmF0dGxlckJhc2UgZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL0JhdHRsZVN5c3RlbS9CYXR0bGVyQmFzZVwiO1xuaW1wb3J0IEhlYWx0aGJhckhVRCBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvSFVEL0hlYWx0aGJhckhVRFwiO1xuaW1wb3J0IEludmVudG9yeUhVRCBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvSFVEL0ludmVudG9yeUhVRFwiO1xuaW1wb3J0IEludmVudG9yeSBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvSXRlbVN5c3RlbS9JbnZlbnRvcnlcIjtcbmltcG9ydCBJdGVtIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9JdGVtU3lzdGVtL0l0ZW1cIjtcbmltcG9ydCBIZWFsdGhwYWNrIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9JdGVtU3lzdGVtL0l0ZW1zL0hlYWx0aHBhY2tcIjtcbmltcG9ydCBMYXNlckd1biBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvSXRlbVN5c3RlbS9JdGVtcy9MYXNlckd1blwiO1xuaW1wb3J0IHsgQ2xvc2VzdFBvc2l0aW9uZWQgfSBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvU2VhcmNoaW5nL0hXNFJlZHVjZXJzXCI7XG5pbXBvcnQgQmFzaWNUYXJnZXRhYmxlIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9UYXJnZXRpbmcvQmFzaWNUYXJnZXRhYmxlXCI7XG5pbXBvcnQgUG9zaXRpb24gZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL1RhcmdldGluZy9Qb3NpdGlvblwiO1xuaW1wb3J0IEFzdGFyU3RyYXRlZ3kgZnJvbSBcIi4uL1BhdGhmaW5kaW5nL0FzdGFyU3RyYXRlZ3lcIjtcbmltcG9ydCBIVzRTY2VuZSBmcm9tIFwiLi9IVzRTY2VuZVwiO1xuXG5jb25zdCBCYXR0bGVyR3JvdXBzID0ge1xuICAgIFJFRDogMSxcbiAgICBCTFVFOiAyXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYWluSFc0U2NlbmUgZXh0ZW5kcyBIVzRTY2VuZSB7XG5cbiAgICAvKiogR2FtZVN5c3RlbXMgaW4gdGhlIEhXNCBTY2VuZSAqL1xuICAgIHByaXZhdGUgaW52ZW50b3J5SHVkOiBJbnZlbnRvcnlIVUQ7XG5cbiAgICAvKiogQWxsIHRoZSBiYXR0bGVycyBpbiB0aGUgSFc0U2NlbmUgKGluY2x1ZGluZyB0aGUgcGxheWVyKSAqL1xuICAgIHByaXZhdGUgYmF0dGxlcnM6IChCYXR0bGVyICYgQWN0b3IpW107XG4gICAgLyoqIEhlYWx0aGJhcnMgZm9yIHRoZSBiYXR0bGVycyAqL1xuICAgIHByaXZhdGUgaGVhbHRoYmFyczogTWFwPG51bWJlciwgSGVhbHRoYmFySFVEPjtcblxuXG4gICAgcHJpdmF0ZSBiYXNlczogQmF0dGxlckJhc2VbXTtcblxuICAgIHByaXZhdGUgaGVhbHRocGFja3M6IEFycmF5PEhlYWx0aHBhY2s+O1xuICAgIHByaXZhdGUgbGFzZXJndW5zOiBBcnJheTxMYXNlckd1bj47XG5cbiAgICAvLyBUaGUgd2FsbCBsYXllciBvZiB0aGUgdGlsZW1hcFxuICAgIHByaXZhdGUgd2FsbHM6IE9ydGhvZ29uYWxUaWxlbWFwO1xuXG4gICAgLy8gVGhlIHBvc2l0aW9uIGdyYXBoIGZvciB0aGUgbmF2bWVzaFxuICAgIHByaXZhdGUgZ3JhcGg6IFBvc2l0aW9uR3JhcGg7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3Iodmlld3BvcnQ6IFZpZXdwb3J0LCBzY2VuZU1hbmFnZXI6IFNjZW5lTWFuYWdlciwgcmVuZGVyaW5nTWFuYWdlcjogUmVuZGVyaW5nTWFuYWdlciwgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgICAgICBzdXBlcih2aWV3cG9ydCwgc2NlbmVNYW5hZ2VyLCByZW5kZXJpbmdNYW5hZ2VyLCBvcHRpb25zKTtcblxuICAgICAgICB0aGlzLmJhdHRsZXJzID0gbmV3IEFycmF5PEJhdHRsZXIgJiBBY3Rvcj4oKTtcbiAgICAgICAgdGhpcy5oZWFsdGhiYXJzID0gbmV3IE1hcDxudW1iZXIsIEhlYWx0aGJhckhVRD4oKTtcblxuICAgICAgICB0aGlzLmxhc2VyZ3VucyA9IG5ldyBBcnJheTxMYXNlckd1bj4oKTtcbiAgICAgICAgdGhpcy5oZWFsdGhwYWNrcyA9IG5ldyBBcnJheTxIZWFsdGhwYWNrPigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzZWUgU2NlbmUudXBkYXRlKClcbiAgICAgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgbG9hZFNjZW5lKCkge1xuICAgICAgICAvLyBMb2FkIHRoZSBwbGF5ZXIgYW5kIGVuZW15IHNwcml0ZXNoZWV0c1xuICAgICAgICB0aGlzLmxvYWQuc3ByaXRlc2hlZXQoXCJwbGF5ZXIxXCIsIFwiaHc0X2Fzc2V0cy9zcHJpdGVzaGVldHMvcGxheWVyMS5qc29uXCIpO1xuXG4gICAgICAgIC8vIExvYWQgaW4gdGhlIGVuZW15IHNwcml0ZXNcbiAgICAgICAgdGhpcy5sb2FkLnNwcml0ZXNoZWV0KFwiQmx1ZUVuZW15XCIsIFwiaHc0X2Fzc2V0cy9zcHJpdGVzaGVldHMvQmx1ZUVuZW15Lmpzb25cIik7XG4gICAgICAgIHRoaXMubG9hZC5zcHJpdGVzaGVldChcIlJlZEVuZW15XCIsIFwiaHc0X2Fzc2V0cy9zcHJpdGVzaGVldHMvUmVkRW5lbXkuanNvblwiKTtcbiAgICAgICAgdGhpcy5sb2FkLnNwcml0ZXNoZWV0KFwiQmx1ZUhlYWxlclwiLCBcImh3NF9hc3NldHMvc3ByaXRlc2hlZXRzL0JsdWVIZWFsZXIuanNvblwiKTtcbiAgICAgICAgdGhpcy5sb2FkLnNwcml0ZXNoZWV0KFwiUmVkSGVhbGVyXCIsIFwiaHc0X2Fzc2V0cy9zcHJpdGVzaGVldHMvUmVkSGVhbGVyLmpzb25cIik7XG5cbiAgICAgICAgLy8gTG9hZCB0aGUgdGlsZW1hcFxuICAgICAgICB0aGlzLmxvYWQudGlsZW1hcChcImxldmVsXCIsIFwiaHc0X2Fzc2V0cy90aWxlbWFwcy9IVzRDdXN0b21UaWxlbWFwLmpzb25cIik7XG5cbiAgICAgICAgLy8gTG9hZCB0aGUgZW5lbXkgbG9jYXRpb25zXG4gICAgICAgIHRoaXMubG9hZC5vYmplY3QoXCJyZWRcIiwgXCJodzRfYXNzZXRzL2RhdGEvZW5lbWllcy9yZWQuanNvblwiKTtcbiAgICAgICAgdGhpcy5sb2FkLm9iamVjdChcImJsdWVcIiwgXCJodzRfYXNzZXRzL2RhdGEvZW5lbWllcy9ibHVlLmpzb25cIik7XG5cbiAgICAgICAgLy8gTG9hZCB0aGUgaGVhbHRocGFjayBhbmQgbGFzZXJndW4gbG9hY3Rpb25zXG4gICAgICAgIHRoaXMubG9hZC5vYmplY3QoXCJoZWFsdGhwYWNrc1wiLCBcImh3NF9hc3NldHMvZGF0YS9pdGVtcy9oZWFsdGhwYWNrcy5qc29uXCIpO1xuICAgICAgICB0aGlzLmxvYWQub2JqZWN0KFwibGFzZXJndW5zXCIsIFwiaHc0X2Fzc2V0cy9kYXRhL2l0ZW1zL2xhc2VyZ3Vucy5qc29uXCIpO1xuXG4gICAgICAgIC8vIExvYWQgdGhlIGhlYWx0aHBhY2ssIGludmVudG9yeSBzbG90LCBhbmQgbGFzZXIgZ3VuIHNwcml0ZXNcbiAgICAgICAgdGhpcy5sb2FkLmltYWdlKFwiaGVhbHRocGFja1wiLCBcImh3NF9hc3NldHMvc3ByaXRlcy9oZWFsdGhwYWNrLnBuZ1wiKTtcbiAgICAgICAgdGhpcy5sb2FkLmltYWdlKFwiaW52ZW50b3J5U2xvdFwiLCBcImh3NF9hc3NldHMvc3ByaXRlcy9pbnZlbnRvcnkucG5nXCIpO1xuICAgICAgICB0aGlzLmxvYWQuaW1hZ2UoXCJsYXNlckd1blwiLCBcImh3NF9hc3NldHMvc3ByaXRlcy9sYXNlckd1bi5wbmdcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzZWUgU2NlbmUuc3RhcnRTY2VuZVxuICAgICAqL1xuICAgIHB1YmxpYyBvdmVycmlkZSBzdGFydFNjZW5lKCkge1xuICAgICAgICAvLyBBZGQgaW4gdGhlIHRpbGVtYXBcbiAgICAgICAgbGV0IHRpbGVtYXBMYXllcnMgPSB0aGlzLmFkZC50aWxlbWFwKFwibGV2ZWxcIik7XG5cbiAgICAgICAgLy8gR2V0IHRoZSB3YWxsIGxheWVyXG4gICAgICAgIHRoaXMud2FsbHMgPSA8T3J0aG9nb25hbFRpbGVtYXA+dGlsZW1hcExheWVyc1sxXS5nZXRJdGVtcygpWzBdO1xuXG4gICAgICAgIC8vIFNldCB0aGUgdmlld3BvcnQgYm91bmRzIHRvIHRoZSB0aWxlbWFwXG4gICAgICAgIGxldCB0aWxlbWFwU2l6ZTogVmVjMiA9IHRoaXMud2FsbHMuc2l6ZTtcblxuICAgICAgICB0aGlzLnZpZXdwb3J0LnNldEJvdW5kcygwLCAwLCB0aWxlbWFwU2l6ZS54LCB0aWxlbWFwU2l6ZS55KTtcbiAgICAgICAgdGhpcy52aWV3cG9ydC5zZXRab29tTGV2ZWwoMik7XG5cbiAgICAgICAgdGhpcy5pbml0TGF5ZXJzKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgdGhlIHBsYXllclxuICAgICAgICB0aGlzLmluaXRpYWxpemVQbGF5ZXIoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplSXRlbXMoKTtcblxuICAgICAgICB0aGlzLmluaXRpYWxpemVOYXZtZXNoKCk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBOUENTXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZU5QQ3MoKTtcblxuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gcmVsZXZhbnQgZXZlbnRzXG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKFwiaGVhbHRocGFja1wiKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoXCJlbmVteURpZWRcIik7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKEl0ZW1FdmVudC5JVEVNX1JFUVVFU1QpO1xuXG4gICAgICAgIC8vIEFkZCBhIFVJIGZvciBoZWFsdGhcbiAgICAgICAgdGhpcy5hZGRVSUxheWVyKFwiaGVhbHRoXCIpO1xuXG5cbiAgICAgICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoUGxheWVyRXZlbnQuUExBWUVSX0tJTExFRCk7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKEJhdHRsZXJFdmVudC5CQVRUTEVSX0tJTExFRCk7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKEJhdHRsZXJFdmVudC5CQVRUTEVSX1JFU1BBV04pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc2VlIFNjZW5lLnVwZGF0ZVNjZW5lXG4gICAgICovXG4gICAgcHVibGljIG92ZXJyaWRlIHVwZGF0ZVNjZW5lKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHdoaWxlICh0aGlzLnJlY2VpdmVyLmhhc05leHRFdmVudCgpKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUV2ZW50KHRoaXMucmVjZWl2ZXIuZ2V0TmV4dEV2ZW50KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW52ZW50b3J5SHVkLnVwZGF0ZShkZWx0YVQpO1xuICAgICAgICB0aGlzLmhlYWx0aGJhcnMuZm9yRWFjaChoZWFsdGhiYXIgPT4gaGVhbHRoYmFyLnVwZGF0ZShkZWx0YVQpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgZXZlbnRzIGZyb20gdGhlIHJlc3Qgb2YgdGhlIGdhbWVcbiAgICAgKiBAcGFyYW0gZXZlbnQgYSBnYW1lIGV2ZW50XG4gICAgICovXG4gICAgcHVibGljIGhhbmRsZUV2ZW50KGV2ZW50OiBHYW1lRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIEJhdHRsZXJFdmVudC5CQVRUTEVSX0tJTExFRDoge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQmF0dGxlcktpbGxlZChldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEJhdHRsZXJFdmVudC5CQVRUTEVSX1JFU1BBV046IHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgSXRlbUV2ZW50LklURU1fUkVRVUVTVDoge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlSXRlbVJlcXVlc3QoZXZlbnQuZGF0YS5nZXQoXCJub2RlXCIpLCBldmVudC5kYXRhLmdldChcImludmVudG9yeVwiKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmhhbmRsZWQgZXZlbnQgdHlwZSBcIiR7ZXZlbnQudHlwZX1cIiBjYXVnaHQgaW4gSFc0U2NlbmUgZXZlbnQgaGFuZGxlcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGhhbmRsZUl0ZW1SZXF1ZXN0KG5vZGU6IEdhbWVOb2RlLCBpbnZlbnRvcnk6IEludmVudG9yeSk6IHZvaWQge1xuICAgICAgICBsZXQgaXRlbXM6IEl0ZW1bXSA9IG5ldyBBcnJheTxJdGVtPiguLi50aGlzLmhlYWx0aHBhY2tzLCAuLi50aGlzLmxhc2VyZ3VucykuZmlsdGVyKChpdGVtOiBJdGVtKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5pbnZlbnRvcnkgPT09IG51bGwgJiYgaXRlbS5wb3NpdGlvbi5kaXN0YW5jZVRvKG5vZGUucG9zaXRpb24pIDw9IDEwMDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGludmVudG9yeS5hZGQoaXRlbXMucmVkdWNlKENsb3Nlc3RQb3NpdGlvbmVkKG5vZGUpKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGFuIE5QQyBiZWluZyBraWxsZWQgYnkgdW5yZWdpc3RlcmluZyB0aGUgTlBDIGZyb20gdGhlIHNjZW5lcyBzdWJzeXN0ZW1zXG4gICAgICogQHBhcmFtIGV2ZW50IGFuIE5QQy1raWxsZWQgZXZlbnRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgaGFuZGxlQmF0dGxlcktpbGxlZChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIGxldCBpZDogbnVtYmVyID0gZXZlbnQuZGF0YS5nZXQoXCJpZFwiKTtcbiAgICAgICAgbGV0IGJhdHRsZXIgPSB0aGlzLmJhdHRsZXJzLmZpbmQoYiA9PiBiLmlkID09PSBpZCk7XG5cbiAgICAgICAgaWYgKGJhdHRsZXIpIHtcbiAgICAgICAgICAgIGJhdHRsZXIuYmF0dGxlckFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5oZWFsdGhiYXJzLmdldChpZCkudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgIH1cblxuICAgIC8qKiBJbml0aWFsaXplcyB0aGUgbGF5ZXJzIGluIHRoZSBzY2VuZSAqL1xuICAgIHByb3RlY3RlZCBpbml0TGF5ZXJzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmFkZExheWVyKFwicHJpbWFyeVwiLCAxMCk7XG4gICAgICAgIHRoaXMuYWRkVUlMYXllcihcInNsb3RzXCIpO1xuICAgICAgICB0aGlzLmFkZFVJTGF5ZXIoXCJpdGVtc1wiKTtcbiAgICAgICAgdGhpcy5nZXRMYXllcihcInNsb3RzXCIpLnNldERlcHRoKDEpO1xuICAgICAgICB0aGlzLmdldExheWVyKFwiaXRlbXNcIikuc2V0RGVwdGgoMik7XG4gICAgfVxuXG5cblxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHBsYXllciBpbiB0aGUgc2NlbmVcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgaW5pdGlhbGl6ZVBsYXllcigpOiB2b2lkIHtcbiAgICAgICAgbGV0IHBsYXllciA9IHRoaXMuYWRkLmFuaW1hdGVkU3ByaXRlKFBsYXllckFjdG9yLCBcInBsYXllcjFcIiwgXCJwcmltYXJ5XCIpO1xuICAgICAgICBwbGF5ZXIucG9zaXRpb24uc2V0KDQwLCA0MCk7XG4gICAgICAgIHBsYXllci5iYXR0bGVHcm91cCA9IDI7XG5cbiAgICAgICAgcGxheWVyLmhlYWx0aCA9IDEwO1xuICAgICAgICBwbGF5ZXIubWF4SGVhbHRoID0gMTA7XG5cbiAgICAgICAgcGxheWVyLmludmVudG9yeS5vbkNoYW5nZSA9IEl0ZW1FdmVudC5JTlZFTlRPUllfQ0hBTkdFRFxuICAgICAgICB0aGlzLmludmVudG9yeUh1ZCA9IG5ldyBJbnZlbnRvcnlIVUQodGhpcywgcGxheWVyLmludmVudG9yeSwgXCJpbnZlbnRvcnlTbG90XCIsIHtcbiAgICAgICAgICAgIHN0YXJ0OiBuZXcgVmVjMigyMzIsIDI0KSxcbiAgICAgICAgICAgIHNsb3RMYXllcjogXCJzbG90c1wiLFxuICAgICAgICAgICAgcGFkZGluZzogOCxcbiAgICAgICAgICAgIGl0ZW1MYXllcjogXCJpdGVtc1wiXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEdpdmUgdGhlIHBsYXllciBwaHlzaWNzXG4gICAgICAgIHBsYXllci5hZGRQaHlzaWNzKG5ldyBBQUJCKFZlYzIuWkVSTywgbmV3IFZlYzIoOCwgOCkpKTtcblxuICAgICAgICAvLyBHaXZlIHRoZSBwbGF5ZXIgYSBoZWFsdGhiYXJcbiAgICAgICAgbGV0IGhlYWx0aGJhciA9IG5ldyBIZWFsdGhiYXJIVUQodGhpcywgcGxheWVyLCBcInByaW1hcnlcIiwge3NpemU6IHBsYXllci5zaXplLmNsb25lKCkuc2NhbGVkKDIsIDEvMiksIG9mZnNldDogcGxheWVyLnNpemUuY2xvbmUoKS5zY2FsZWQoMCwgLTEvMil9KTtcbiAgICAgICAgdGhpcy5oZWFsdGhiYXJzLnNldChwbGF5ZXIuaWQsIGhlYWx0aGJhcik7XG5cbiAgICAgICAgLy8gR2l2ZSB0aGUgcGxheWVyIFBsYXllckFJXG4gICAgICAgIHBsYXllci5hZGRBSShQbGF5ZXJBSSk7XG5cbiAgICAgICAgLy8gU3RhcnQgdGhlIHBsYXllciBpbiB0aGUgXCJJRExFXCIgYW5pbWF0aW9uXG4gICAgICAgIHBsYXllci5hbmltYXRpb24ucGxheShcIklETEVcIik7XG5cbiAgICAgICAgdGhpcy5iYXR0bGVycy5wdXNoKHBsYXllcik7XG4gICAgICAgIHRoaXMudmlld3BvcnQuZm9sbG93KHBsYXllcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlIE5QQ3MgXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGluaXRpYWxpemVOUENzKCk6IHZvaWQge1xuXG4gICAgICAgIC8vIEdldCB0aGUgb2JqZWN0IGRhdGEgZm9yIHRoZSByZWQgZW5lbWllc1xuICAgICAgICBsZXQgcmVkID0gdGhpcy5sb2FkLmdldE9iamVjdChcInJlZFwiKTtcblxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSByZWQgaGVhbGVyc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlZC5oZWFsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbnBjID0gdGhpcy5hZGQuYW5pbWF0ZWRTcHJpdGUoTlBDQWN0b3IsIFwiUmVkSGVhbGVyXCIsIFwicHJpbWFyeVwiKTtcbiAgICAgICAgICAgIC8vIG5wYy5wb3NpdGlvbi5zZXQocmVkLmhlYWxlcnNbaV1bMF0sIHJlZC5oZWFsZXJzW2ldWzFdKTtcbiAgICAgICAgICAgIG5wYy5wb3NpdGlvbi5zZXQoUmFuZFV0aWxzLnJhbmRJbnQoOSwgdGhpcy52aWV3cG9ydC5nZXRIYWxmU2l6ZSgpLnggLSA4KVxuICAgICAgICAgICAgLCBSYW5kVXRpbHMucmFuZEZsb2F0KDksIHRoaXMudmlld3BvcnQuZ2V0SGFsZlNpemUoKS55IC0gOCkpO1xuICAgICAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IHRoaXMud2FsbHMuZ2V0VGlsZXNldHMoKS5sZW5ndGg7IGorKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZihucGMucG9zaXRpb24uXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlVG8odGhpcy53YWxscy5nZXRXb3JsZFBvc2l0aW9uKHRoaXMud2FsbHMuZ2V0VGlsZUNvbFJvdyhqKS54LCB0aGlzLndhbGxzLmdldFRpbGVDb2xSb3coaikueSkpIDw9IDIwMClcbiAgICAgICAgICAgICAgICB7ICAgXG4gICAgICAgICAgICAgICAgICAgIG5wYy5wb3NpdGlvbi5zZXQoUmFuZFV0aWxzLnJhbmRJbnQoOSwgdGhpcy52aWV3cG9ydC5nZXRIYWxmU2l6ZSgpLnggLSA4KVxuICAgICAgICAgICAgICAgICAgICAsIFJhbmRVdGlscy5yYW5kRmxvYXQoOSwgdGhpcy52aWV3cG9ydC5nZXRIYWxmU2l6ZSgpLnkgLSA4KSk7XG4gICAgICAgICAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5wYy5hZGRQaHlzaWNzKG5ldyBBQUJCKFZlYzIuWkVSTywgbmV3IFZlYzIoNywgNykpLCBudWxsLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIG5wYy5iYXR0bGVHcm91cCA9IDE7XG4gICAgICAgICAgICBucGMuc3BlZWQgPSAxMDtcbiAgICAgICAgICAgIG5wYy5oZWFsdGggPSAxMDtcbiAgICAgICAgICAgIG5wYy5tYXhIZWFsdGggPSAxMDtcbiAgICAgICAgICAgIG5wYy5uYXZrZXkgPSBcIm5hdm1lc2hcIjtcblxuICAgICAgICAgICAgLy8gR2l2ZSB0aGUgTlBDIGEgaGVhbHRoYmFyXG4gICAgICAgICAgICBsZXQgaGVhbHRoYmFyID0gbmV3IEhlYWx0aGJhckhVRCh0aGlzLCBucGMsIFwicHJpbWFyeVwiLCB7c2l6ZTogbnBjLnNpemUuY2xvbmUoKS5zY2FsZWQoMiwgMS8yKSwgb2Zmc2V0OiBucGMuc2l6ZS5jbG9uZSgpLnNjYWxlZCgwLCAtMS8yKX0pO1xuICAgICAgICAgICAgdGhpcy5oZWFsdGhiYXJzLnNldChucGMuaWQsIGhlYWx0aGJhcik7XG5cbiAgICAgICAgICAgIG5wYy5hZGRBSShIZWFsZXJCZWhhdmlvcik7XG4gICAgICAgICAgICBucGMuYW5pbWF0aW9uLnBsYXkoXCJJRExFXCIpO1xuICAgICAgICAgICAgdGhpcy5iYXR0bGVycy5wdXNoKG5wYyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlZC5lbmVtaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbnBjID0gdGhpcy5hZGQuYW5pbWF0ZWRTcHJpdGUoTlBDQWN0b3IsIFwiUmVkRW5lbXlcIiwgXCJwcmltYXJ5XCIpO1xuICAgICAgICAgICAgLy8gbnBjLnBvc2l0aW9uLnNldChyZWQuZW5lbWllc1tpXVswXSwgcmVkLmVuZW1pZXNbaV1bMV0pO1xuXG4gICAgICAgICAgICBucGMucG9zaXRpb24uc2V0KFJhbmRVdGlscy5yYW5kSW50KDksIHRoaXMudmlld3BvcnQuZ2V0SGFsZlNpemUoKS54IC0gOClcbiAgICAgICAgICAgICwgUmFuZFV0aWxzLnJhbmRGbG9hdCg5LCB0aGlzLnZpZXdwb3J0LmdldEhhbGZTaXplKCkueSAtIDgpKTtcbiAgICAgICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCB0aGlzLndhbGxzLmdldFRpbGVzZXRzKCkubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYobnBjLnBvc2l0aW9uLlxuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZVRvKHRoaXMud2FsbHMuZ2V0V29ybGRQb3NpdGlvbih0aGlzLndhbGxzLmdldFRpbGVDb2xSb3coaikueCwgdGhpcy53YWxscy5nZXRUaWxlQ29sUm93KGopLnkpKSA8PSAyMDApXG4gICAgICAgICAgICAgICAgeyAgIFxuICAgICAgICAgICAgICAgICAgICBucGMucG9zaXRpb24uc2V0KFJhbmRVdGlscy5yYW5kSW50KDksIHRoaXMudmlld3BvcnQuZ2V0SGFsZlNpemUoKS54IC0gOClcbiAgICAgICAgICAgICAgICAgICAgLCBSYW5kVXRpbHMucmFuZEZsb2F0KDksIHRoaXMudmlld3BvcnQuZ2V0SGFsZlNpemUoKS55IC0gOCkpO1xuICAgICAgICAgICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5wYy5hZGRQaHlzaWNzKG5ldyBBQUJCKFZlYzIuWkVSTywgbmV3IFZlYzIoNywgNykpLCBudWxsLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIC8vIEdpdmUgdGhlIE5QQyBhIGhlYWx0aGJhclxuICAgICAgICAgICAgbGV0IGhlYWx0aGJhciA9IG5ldyBIZWFsdGhiYXJIVUQodGhpcywgbnBjLCBcInByaW1hcnlcIiwge3NpemU6IG5wYy5zaXplLmNsb25lKCkuc2NhbGVkKDIsIDEvMiksIG9mZnNldDogbnBjLnNpemUuY2xvbmUoKS5zY2FsZWQoMCwgLTEvMil9KTtcbiAgICAgICAgICAgIHRoaXMuaGVhbHRoYmFycy5zZXQobnBjLmlkLCBoZWFsdGhiYXIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTZXQgdGhlIE5QQ3Mgc3RhdHNcbiAgICAgICAgICAgIG5wYy5iYXR0bGVHcm91cCA9IDFcbiAgICAgICAgICAgIG5wYy5zcGVlZCA9IDEwO1xuICAgICAgICAgICAgbnBjLmhlYWx0aCA9IDE7XG4gICAgICAgICAgICBucGMubWF4SGVhbHRoID0gMTA7XG4gICAgICAgICAgICBucGMubmF2a2V5ID0gXCJuYXZtZXNoXCI7XG5cbiAgICAgICAgICAgIG5wYy5hZGRBSShHdWFyZEJlaGF2aW9yLCB7dGFyZ2V0OiBuZXcgQmFzaWNUYXJnZXRhYmxlKG5ldyBQb3NpdGlvbihucGMucG9zaXRpb24ueCwgbnBjLnBvc2l0aW9uLnkpKSwgcmFuZ2U6IDEwMH0pO1xuXG4gICAgICAgICAgICAvLyBQbGF5IHRoZSBOUENzIFwiSURMRVwiIGFuaW1hdGlvbiBcbiAgICAgICAgICAgIG5wYy5hbmltYXRpb24ucGxheShcIklETEVcIik7XG4gICAgICAgICAgICAvLyBBZGQgdGhlIE5QQyB0byB0aGUgYmF0dGxlcnMgYXJyYXlcbiAgICAgICAgICAgIHRoaXMuYmF0dGxlcnMucHVzaChucGMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IHRoZSBvYmplY3QgZGF0YSBmb3IgdGhlIGJsdWUgZW5lbWllc1xuICAgICAgICBsZXQgYmx1ZSA9IHRoaXMubG9hZC5nZXRPYmplY3QoXCJibHVlXCIpO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGJsdWUgZW5lbWllc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsdWUuZW5lbWllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5wYyA9IHRoaXMuYWRkLmFuaW1hdGVkU3ByaXRlKE5QQ0FjdG9yLCBcIkJsdWVFbmVteVwiLCBcInByaW1hcnlcIik7XG4gICAgICAgICAgICAvLyBucGMucG9zaXRpb24uc2V0KGJsdWUuZW5lbWllc1tpXVswXSwgYmx1ZS5lbmVtaWVzW2ldWzFdKTtcbiAgICAgICAgICAgIG5wYy5wb3NpdGlvbi5zZXQoUmFuZFV0aWxzLnJhbmRJbnQodGhpcy52aWV3cG9ydC5nZXRIYWxmU2l6ZSgpLngsIDIgKiB0aGlzLnZpZXdwb3J0LmdldEhhbGZTaXplKCkueCAtIDgpXG4gICAgICAgICAgICAsIFJhbmRVdGlscy5yYW5kRmxvYXQodGhpcy52aWV3cG9ydC5nZXRIYWxmU2l6ZSgpLnksIDIgKiB0aGlzLnZpZXdwb3J0LmdldEhhbGZTaXplKCkueSAtIDgpKTtcbiAgICAgICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCB0aGlzLndhbGxzLmdldFRpbGVzZXRzKCkubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYobnBjLnBvc2l0aW9uLlxuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZVRvKHRoaXMud2FsbHMuZ2V0V29ybGRQb3NpdGlvbih0aGlzLndhbGxzLmdldFRpbGVDb2xSb3coaikueCwgdGhpcy53YWxscy5nZXRUaWxlQ29sUm93KGopLnkpKSA8PSAyMDApXG4gICAgICAgICAgICAgICAgeyAgIFxuICAgICAgICAgICAgICAgICAgICBucGMucG9zaXRpb24uc2V0KFJhbmRVdGlscy5yYW5kSW50KHRoaXMudmlld3BvcnQuZ2V0SGFsZlNpemUoKS54ICsgOSwgMiAqICB0aGlzLnZpZXdwb3J0LmdldEhhbGZTaXplKCkueCAtIDgpXG4gICAgICAgICAgICAgICAgICAgICwgUmFuZFV0aWxzLnJhbmRGbG9hdCh0aGlzLnZpZXdwb3J0LmdldEhhbGZTaXplKCkueSArIDksIDIgKiB0aGlzLnZpZXdwb3J0LmdldEhhbGZTaXplKCkueSAtIDgpKTtcbiAgICAgICAgICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBucGMuYWRkUGh5c2ljcyhuZXcgQUFCQihWZWMyLlpFUk8sIG5ldyBWZWMyKDcsIDcpKSwgbnVsbCwgZmFsc2UpO1xuXG4gICAgICAgICAgICAvLyBHaXZlIHRoZSBOUENTIHRoZWlyIGhlYWx0aGJhcnNcbiAgICAgICAgICAgIGxldCBoZWFsdGhiYXIgPSBuZXcgSGVhbHRoYmFySFVEKHRoaXMsIG5wYywgXCJwcmltYXJ5XCIsIHtzaXplOiBucGMuc2l6ZS5jbG9uZSgpLnNjYWxlZCgyLCAxLzIpLCBvZmZzZXQ6IG5wYy5zaXplLmNsb25lKCkuc2NhbGVkKDAsIC0xLzIpfSk7XG4gICAgICAgICAgICB0aGlzLmhlYWx0aGJhcnMuc2V0KG5wYy5pZCwgaGVhbHRoYmFyKTtcblxuICAgICAgICAgICAgbnBjLmJhdHRsZUdyb3VwID0gMlxuICAgICAgICAgICAgbnBjLnNwZWVkID0gMTA7XG4gICAgICAgICAgICBucGMuaGVhbHRoID0gMTtcbiAgICAgICAgICAgIG5wYy5tYXhIZWFsdGggPSAxMDtcbiAgICAgICAgICAgIG5wYy5uYXZrZXkgPSBcIm5hdm1lc2hcIjtcblxuICAgICAgICAgICAgLy8gR2l2ZSB0aGUgTlBDcyB0aGVpciBBSVxuICAgICAgICAgICAgbnBjLmFkZEFJKEd1YXJkQmVoYXZpb3IsIHt0YXJnZXQ6IHRoaXMuYmF0dGxlcnNbMF0sIHJhbmdlOiAxMDB9KTtcblxuICAgICAgICAgICAgLy8gUGxheSB0aGUgTlBDcyBcIklETEVcIiBhbmltYXRpb24gXG4gICAgICAgICAgICBucGMuYW5pbWF0aW9uLnBsYXkoXCJJRExFXCIpO1xuXG4gICAgICAgICAgICB0aGlzLmJhdHRsZXJzLnB1c2gobnBjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGJsdWUgaGVhbGVyc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsdWUuaGVhbGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBsZXQgbnBjID0gdGhpcy5hZGQuYW5pbWF0ZWRTcHJpdGUoTlBDQWN0b3IsIFwiQmx1ZUhlYWxlclwiLCBcInByaW1hcnlcIik7XG4gICAgICAgICAgICAvLyBucGMucG9zaXRpb24uc2V0KGJsdWUuaGVhbGVyc1tpXVswXSwgYmx1ZS5oZWFsZXJzW2ldWzFdKTtcbiAgICAgICAgICAgIG5wYy5wb3NpdGlvbi5zZXQoUmFuZFV0aWxzLnJhbmRJbnQodGhpcy52aWV3cG9ydC5nZXRIYWxmU2l6ZSgpLngsIDIgKiB0aGlzLnZpZXdwb3J0LmdldEhhbGZTaXplKCkueCAtIDgpXG4gICAgICAgICAgICAsIFJhbmRVdGlscy5yYW5kRmxvYXQodGhpcy52aWV3cG9ydC5nZXRIYWxmU2l6ZSgpLnksIDIgKiB0aGlzLnZpZXdwb3J0LmdldEhhbGZTaXplKCkueSAtIDgpKTtcbiAgICAgICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCB0aGlzLndhbGxzLmdldFRpbGVzZXRzKCkubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYobnBjLnBvc2l0aW9uLlxuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZVRvKHRoaXMud2FsbHMuZ2V0V29ybGRQb3NpdGlvbih0aGlzLndhbGxzLmdldFRpbGVDb2xSb3coaikueCwgdGhpcy53YWxscy5nZXRUaWxlQ29sUm93KGopLnkpKSA8PSAyMDApXG4gICAgICAgICAgICAgICAgeyAgIFxuICAgICAgICAgICAgICAgICAgICBucGMucG9zaXRpb24uc2V0KFJhbmRVdGlscy5yYW5kSW50KHRoaXMudmlld3BvcnQuZ2V0SGFsZlNpemUoKS54LCAyICogIHRoaXMudmlld3BvcnQuZ2V0SGFsZlNpemUoKS54IC0gOClcbiAgICAgICAgICAgICAgICAgICAgLCBSYW5kVXRpbHMucmFuZEZsb2F0KHRoaXMudmlld3BvcnQuZ2V0SGFsZlNpemUoKS55LCAyICogdGhpcy52aWV3cG9ydC5nZXRIYWxmU2l6ZSgpLnkgLSA4KSk7XG4gICAgICAgICAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5wYy5hZGRQaHlzaWNzKG5ldyBBQUJCKFZlYzIuWkVSTywgbmV3IFZlYzIoNywgNykpLCBudWxsLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIG5wYy5iYXR0bGVHcm91cCA9IDI7XG4gICAgICAgICAgICBucGMuc3BlZWQgPSAxMDtcbiAgICAgICAgICAgIG5wYy5oZWFsdGggPSAxO1xuICAgICAgICAgICAgbnBjLm1heEhlYWx0aCA9IDEwO1xuICAgICAgICAgICAgbnBjLm5hdmtleSA9IFwibmF2bWVzaFwiO1xuXG4gICAgICAgICAgICBsZXQgaGVhbHRoYmFyID0gbmV3IEhlYWx0aGJhckhVRCh0aGlzLCBucGMsIFwicHJpbWFyeVwiLCB7c2l6ZTogbnBjLnNpemUuY2xvbmUoKS5zY2FsZWQoMiwgMS8yKSwgb2Zmc2V0OiBucGMuc2l6ZS5jbG9uZSgpLnNjYWxlZCgwLCAtMS8yKX0pO1xuICAgICAgICAgICAgdGhpcy5oZWFsdGhiYXJzLnNldChucGMuaWQsIGhlYWx0aGJhcik7XG5cbiAgICAgICAgICAgIG5wYy5hZGRBSShIZWFsZXJCZWhhdmlvcik7XG4gICAgICAgICAgICBucGMuYW5pbWF0aW9uLnBsYXkoXCJJRExFXCIpO1xuICAgICAgICAgICAgdGhpcy5iYXR0bGVycy5wdXNoKG5wYyk7XG4gICAgICAgIH1cblxuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgaXRlbXMgaW4gdGhlIHNjZW5lIChoZWFsdGhwYWNrcyBhbmQgbGFzZXIgZ3VucylcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgaW5pdGlhbGl6ZUl0ZW1zKCk6IHZvaWQge1xuICAgICAgICBsZXQgbGFzZXJndW5zID0gdGhpcy5sb2FkLmdldE9iamVjdChcImxhc2VyZ3Vuc1wiKTtcbiAgICAgICAgdGhpcy5sYXNlcmd1bnMgPSBuZXcgQXJyYXk8TGFzZXJHdW4+KGxhc2VyZ3Vucy5pdGVtcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxhc2VyZ3Vucy5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHNwcml0ZSA9IHRoaXMuYWRkLnNwcml0ZShcImxhc2VyR3VuXCIsIFwicHJpbWFyeVwiKTtcbiAgICAgICAgICAgIGxldCBsaW5lID0gPExpbmU+dGhpcy5hZGQuZ3JhcGhpYyhHcmFwaGljVHlwZS5MSU5FLCBcInByaW1hcnlcIiwge3N0YXJ0OiBWZWMyLlpFUk8sIGVuZDogVmVjMi5aRVJPfSk7XG4gICAgICAgICAgICB0aGlzLmxhc2VyZ3Vuc1tpXSA9IExhc2VyR3VuLmNyZWF0ZShzcHJpdGUsIGxpbmUpO1xuICAgICAgICAgICAgLy8gdGhpcy5sYXNlcmd1bnNbaV0ucG9zaXRpb24uc2V0KGxhc2VyZ3Vucy5pdGVtc1tpXVswXSwgbGFzZXJndW5zLml0ZW1zW2ldWzFdKTtcbiAgICAgICAgICAgIHRoaXMubGFzZXJndW5zW2ldLnBvc2l0aW9uLnNldChSYW5kVXRpbHMucmFuZEludCg5LCAyICogdGhpcy52aWV3cG9ydC5nZXRIYWxmU2l6ZSgpLnggLSA4KVxuICAgICAgICAgICAgLCBSYW5kVXRpbHMucmFuZEZsb2F0KDksIDIgKiB0aGlzLnZpZXdwb3J0LmdldEhhbGZTaXplKCkueSAtIDgpKTtcbiAgICAgICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCB0aGlzLndhbGxzLmdldFRpbGVTaXplKCkueCAqIHRoaXMud2FsbHMuZ2V0VGlsZVNpemUoKS55OyBqKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5sYXNlcmd1bnNbaV0ucG9zaXRpb24uXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlVG8odGhpcy53YWxscy5nZXRXb3JsZFBvc2l0aW9uKHRoaXMud2FsbHMuZ2V0VGlsZUNvbFJvdyhqKS54LCB0aGlzLndhbGxzLmdldFRpbGVDb2xSb3coaikueSkpIDw9IDIwMClcbiAgICAgICAgICAgICAgICB7ICAgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzZXJndW5zW2ldLnBvc2l0aW9uLnNldChSYW5kVXRpbHMucmFuZEludCg5LCAyICogdGhpcy52aWV3cG9ydC5nZXRIYWxmU2l6ZSgpLnggLSA4KVxuICAgICAgICAgICAgICAgICAgICAsIFJhbmRVdGlscy5yYW5kSW50KDksIDIgKiB0aGlzLnZpZXdwb3J0LmdldEhhbGZTaXplKCkueSAtIDgpKTtcbiAgICAgICAgICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGhlYWx0aHBhY2tzID0gdGhpcy5sb2FkLmdldE9iamVjdChcImhlYWx0aHBhY2tzXCIpO1xuICAgICAgICB0aGlzLmhlYWx0aHBhY2tzID0gbmV3IEFycmF5PEhlYWx0aHBhY2s+KGhlYWx0aHBhY2tzLml0ZW1zLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhbHRocGFja3MuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzcHJpdGUgPSB0aGlzLmFkZC5zcHJpdGUoXCJoZWFsdGhwYWNrXCIsIFwicHJpbWFyeVwiKTtcbiAgICAgICAgICAgIHRoaXMuaGVhbHRocGFja3NbaV0gPSBuZXcgSGVhbHRocGFjayhzcHJpdGUpO1xuICAgICAgICAgICAgdGhpcy5oZWFsdGhwYWNrc1tpXS5wb3NpdGlvbi5zZXQoaGVhbHRocGFja3MuaXRlbXNbaV1bMF0sIGhlYWx0aHBhY2tzLml0ZW1zW2ldWzFdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgbmF2bWVzaCBncmFwaCB1c2VkIGJ5IHRoZSBOUENzIGluIHRoZSBIVzRTY2VuZS4gVGhpcyBtZXRob2QgaXMgYSBsaXR0bGUgYnVnZ3ksIGFuZFxuICAgICAqIGFuZCBpdCBza2lwcyBvdmVyIHNvbWUgb2YgdGhlIHBvc2l0aW9ucyBvbiB0aGUgdGlsZW1hcC4gSWYgeW91IGNhbiBmaXggbXkgbmF2bWVzaCBnZW5lcmF0aW9uIGFsZ29yaXRobSxcbiAgICAgKiBnbyBmb3IgaXQuXG4gICAgICogXG4gICAgICogLSBQZXRlclxuICAgICAqL1xuICAgIHByb3RlY3RlZCBpbml0aWFsaXplTmF2bWVzaCgpOiB2b2lkIHtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBncmFwaFxuICAgICAgICB0aGlzLmdyYXBoID0gbmV3IFBvc2l0aW9uR3JhcGgoKTtcblxuICAgICAgICBsZXQgZGltOiBWZWMyID0gdGhpcy53YWxscy5nZXREaW1lbnNpb25zKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGltLnk7IGkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBkaW0ueDsgaisrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRpbGU6IEFBQkIgPSB0aGlzLndhbGxzLmdldFRpbGVDb2xsaWRlcihqLCBpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBoLmFkZFBvc2l0aW9uZWROb2RlKHRpbGUuY2VudGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByYzogVmVjMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmdyYXBoLm51bVZlcnRpY2VzOyBpKyspIHtcbiAgICAgICAgICAgIHJjID0gdGhpcy53YWxscy5nZXRUaWxlQ29sUm93KGkpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLndhbGxzLmlzVGlsZUNvbGxpZGFibGUocmMueCwgcmMueSkgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy53YWxscy5pc1RpbGVDb2xsaWRhYmxlKE1hdGhVdGlscy5jbGFtcChyYy54IC0gMSwgMCwgZGltLnggLSAxKSwgcmMueSkgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy53YWxscy5pc1RpbGVDb2xsaWRhYmxlKE1hdGhVdGlscy5jbGFtcChyYy54ICsgMSwgMCwgZGltLnggLSAxKSwgcmMueSkgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy53YWxscy5pc1RpbGVDb2xsaWRhYmxlKHJjLngsIE1hdGhVdGlscy5jbGFtcChyYy55IC0gMSwgMCwgZGltLnkgLSAxKSkgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy53YWxscy5pc1RpbGVDb2xsaWRhYmxlKHJjLngsIE1hdGhVdGlscy5jbGFtcChyYy55ICsgMSwgMCwgZGltLnkgLSAxKSkgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy53YWxscy5pc1RpbGVDb2xsaWRhYmxlKE1hdGhVdGlscy5jbGFtcChyYy54ICsgMSwgMCwgZGltLnggLSAxKSwgTWF0aFV0aWxzLmNsYW1wKHJjLnkgKyAxLCAwLCBkaW0ueSAtIDEpKSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLndhbGxzLmlzVGlsZUNvbGxpZGFibGUoTWF0aFV0aWxzLmNsYW1wKHJjLnggLSAxLCAwLCBkaW0ueCAtIDEpLCBNYXRoVXRpbHMuY2xhbXAocmMueSArIDEsIDAsIGRpbS55IC0gMSkpICYmXG4gICAgICAgICAgICAgICAgIXRoaXMud2FsbHMuaXNUaWxlQ29sbGlkYWJsZShNYXRoVXRpbHMuY2xhbXAocmMueCArIDEsIDAsIGRpbS54IC0gMSksIE1hdGhVdGlscy5jbGFtcChyYy55IC0gMSwgMCwgZGltLnkgLSAxKSkgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy53YWxscy5pc1RpbGVDb2xsaWRhYmxlKE1hdGhVdGlscy5jbGFtcChyYy54IC0gMSwgMCwgZGltLnggLSAxKSwgTWF0aFV0aWxzLmNsYW1wKHJjLnkgLSAxLCAwLCBkaW0ueSAtIDEpKVxuXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgZWRnZSB0byB0aGUgbGVmdFxuICAgICAgICAgICAgICAgIHJjID0gdGhpcy53YWxscy5nZXRUaWxlQ29sUm93KGkgKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAoKGkgKyAxKSAlIGRpbS54ICE9PSAwICYmICF0aGlzLndhbGxzLmlzVGlsZUNvbGxpZGFibGUocmMueCwgcmMueSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmFwaC5hZGRFZGdlKGksIGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcy5hZGQuZ3JhcGhpYyhHcmFwaGljVHlwZS5MSU5FLCBcImdyYXBoXCIsIHtzdGFydDogdGhpcy5ncmFwaC5nZXROb2RlUG9zaXRpb24oaSksIGVuZDogdGhpcy5ncmFwaC5nZXROb2RlUG9zaXRpb24oaSArIDEpfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGVkZ2UgYmVsb3dcbiAgICAgICAgICAgICAgICByYyA9IHRoaXMud2FsbHMuZ2V0VGlsZUNvbFJvdyhpICsgZGltLngpO1xuICAgICAgICAgICAgICAgIGlmIChpICsgZGltLnggPCB0aGlzLmdyYXBoLm51bVZlcnRpY2VzICYmICF0aGlzLndhbGxzLmlzVGlsZUNvbGxpZGFibGUocmMueCwgcmMueSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmFwaC5hZGRFZGdlKGksIGkgKyBkaW0ueCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMuYWRkLmdyYXBoaWMoR3JhcGhpY1R5cGUuTElORSwgXCJncmFwaFwiLCB7c3RhcnQ6IHRoaXMuZ3JhcGguZ2V0Tm9kZVBvc2l0aW9uKGkpLCBlbmQ6IHRoaXMuZ3JhcGguZ2V0Tm9kZVBvc2l0aW9uKGkgKyBkaW0ueCl9KVxuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdGhpcyBncmFwaCBhcyBhIG5hdmlnYWJsZSBlbnRpdHlcbiAgICAgICAgbGV0IG5hdm1lc2ggPSBuZXcgTmF2bWVzaCh0aGlzLmdyYXBoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCBkaWZmZXJlbnQgc3RyYXRlZ2llcyB0byB1c2UgZm9yIHRoaXMgbmF2bWVzaFxuICAgICAgICBuYXZtZXNoLnJlZ2lzdGVyU3RyYXRlZ3koXCJkaXJlY3RcIiwgbmV3IERpcmVjdFN0cmF0ZWd5KG5hdm1lc2gpKTtcbiAgICAgICAgbmF2bWVzaC5yZWdpc3RlclN0cmF0ZWd5KFwiYXN0YXJcIiwgbmV3IEFzdGFyU3RyYXRlZ3kobmF2bWVzaCkpO1xuICAgICAgICBuYXZtZXNoLnJlZ2lzdGVyU3RyYXRlZ3koXCJkaWprc3RyYVwiLCBuZXcgRGppa3N0cmFQYXRoU3RyYXQobmF2bWVzaCkpO1xuXG4gICAgICAgIC8vIFRPRE8gc2V0IHRoZSBzdHJhdGVneSB0byB1c2UgQSogcGF0aGZpbmRpbmdcbiAgICAgICAgbmF2bWVzaC5zZXRTdHJhdGVneShcImRpcmVjdFwiKTtcblxuICAgICAgICAvLyBBZGQgdGhpcyBuYXZtZXNoIHRvIHRoZSBuYXZpZ2F0aW9uIG1hbmFnZXJcbiAgICAgICAgdGhpcy5uYXZNYW5hZ2VyLmFkZE5hdmlnYWJsZUVudGl0eShcIm5hdm1lc2hcIiwgbmF2bWVzaCk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldEJhdHRsZXJzKCk6IEJhdHRsZXJbXSB7IHJldHVybiB0aGlzLmJhdHRsZXJzOyB9XG5cbiAgICBwdWJsaWMgZ2V0V2FsbHMoKTogT3J0aG9nb25hbFRpbGVtYXAgeyByZXR1cm4gdGhpcy53YWxsczsgfVxuXG4gICAgcHVibGljIGdldEhlYWx0aHBhY2tzKCk6IEhlYWx0aHBhY2tbXSB7IHJldHVybiB0aGlzLmhlYWx0aHBhY2tzOyB9XG5cbiAgICBwdWJsaWMgZ2V0TGFzZXJHdW5zKCk6IExhc2VyR3VuW10geyByZXR1cm4gdGhpcy5sYXNlcmd1bnM7IH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdGFyZ2V0IHBvc2l0aW9uIGlzIHZpc2libGUgZnJvbSB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIFxuICAgICAqIEBwYXJhbSB0YXJnZXQgXG4gICAgICogQHJldHVybnMgXG4gICAgICovXG4gICAgcHVibGljIGlzVGFyZ2V0VmlzaWJsZShwb3NpdGlvbjogVmVjMiwgdGFyZ2V0OiBWZWMyKTogYm9vbGVhbiB7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBuZXcgcGxheWVyIGxvY2F0aW9uXG4gICAgICAgIGxldCBzdGFydCA9IHBvc2l0aW9uLmNsb25lKCk7XG4gICAgICAgIGxldCBkZWx0YSA9IHRhcmdldC5jbG9uZSgpLnN1YihzdGFydCk7XG5cbiAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSB0aWxlbWFwIHJlZ2lvbiB1bnRpbCB3ZSBmaW5kIGEgY29sbGlzaW9uXG4gICAgICAgIGxldCBtaW5YID0gTWF0aC5taW4oc3RhcnQueCwgdGFyZ2V0LngpO1xuICAgICAgICBsZXQgbWF4WCA9IE1hdGgubWF4KHN0YXJ0LngsIHRhcmdldC54KTtcbiAgICAgICAgbGV0IG1pblkgPSBNYXRoLm1pbihzdGFydC55LCB0YXJnZXQueSk7XG4gICAgICAgIGxldCBtYXhZID0gTWF0aC5tYXgoc3RhcnQueSwgdGFyZ2V0LnkpO1xuXG4gICAgICAgIC8vIEdldCB0aGUgd2FsbCB0aWxlbWFwXG4gICAgICAgIGxldCB3YWxscyA9IHRoaXMuZ2V0V2FsbHMoKTtcblxuICAgICAgICBsZXQgbWluSW5kZXggPSB3YWxscy5nZXRUaWxlbWFwUG9zaXRpb24obWluWCwgbWluWSk7XG4gICAgICAgIGxldCBtYXhJbmRleCA9IHdhbGxzLmdldFRpbGVtYXBQb3NpdGlvbihtYXhYLCBtYXhZKTtcblxuICAgICAgICBsZXQgdGlsZVNpemUgPSB3YWxscy5nZXRTY2FsZWRUaWxlU2l6ZSgpO1xuXG4gICAgICAgIGZvciAobGV0IGNvbCA9IG1pbkluZGV4Lng7IGNvbCA8PSBtYXhJbmRleC54OyBjb2wrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gbWluSW5kZXgueTsgcm93IDw9IG1heEluZGV4Lnk7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdhbGxzLmlzVGlsZUNvbGxpZGFibGUoY29sLCByb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcG9zaXRpb24gb2YgdGhpcyB0aWxlXG4gICAgICAgICAgICAgICAgICAgIGxldCB0aWxlUG9zID0gbmV3IFZlYzIoY29sICogdGlsZVNpemUueCArIHRpbGVTaXplLnggLyAyLCByb3cgKiB0aWxlU2l6ZS55ICsgdGlsZVNpemUueSAvIDIpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIGNvbGxpZGVyIGZvciB0aGlzIHRpbGVcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbGxpZGVyID0gbmV3IEFBQkIodGlsZVBvcywgdGlsZVNpemUuc2NhbGVkKDEgLyAyKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGhpdCA9IGNvbGxpZGVyLmludGVyc2VjdFNlZ21lbnQoc3RhcnQsIGRlbHRhLCBWZWMyLlpFUk8pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChoaXQgIT09IG51bGwgJiYgc3RhcnQuZGlzdGFuY2VTcVRvKGhpdC5wb3MpIDwgc3RhcnQuZGlzdGFuY2VTcVRvKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhpdCBhIHdhbGwsIHdlIGNhbid0IHNlZSB0aGUgcGxheWVyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICB9XG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgeyBVSUVsZW1lbnRUeXBlIH0gZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvVUlFbGVtZW50VHlwZXNcIjtcbmltcG9ydCBMYXllciBmcm9tIFwiLi4vLi4vV29sZmllMkQvU2NlbmUvTGF5ZXJcIjtcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vLi4vV29sZmllMkQvU2NlbmUvU2NlbmVcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vV29sZmllMkQvVXRpbHMvQ29sb3JcIjtcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9MYWJlbFwiO1xuaW1wb3J0IE1haW5IVzRTY2VuZSBmcm9tIFwiLi9NYWluSFc0U2NlbmVcIjtcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnRcIjtcbmltcG9ydCBBc3RhckRlbW9TY2VuZSBmcm9tIFwiLi9Bc3RhckRlbW9TY2VuZVwiO1xuaW1wb3J0IEd1YXJkRGVtb1NjZW5lIGZyb20gXCIuL0d1YXJkRGVtb1NjZW5lXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1haW5NZW51IGV4dGVuZHMgU2NlbmUge1xuICAgIC8vIExheWVycywgZm9yIG11bHRpcGxlIG1haW4gbWVudSBzY3JlZW5zXG4gICAgcHJpdmF0ZSBtYWluTWVudTogTGF5ZXI7XG4gICAgcHJpdmF0ZSBhYm91dDogTGF5ZXI7XG4gICAgcHJpdmF0ZSBjb250cm9sOiBMYXllcjtcblxuICAgIHB1YmxpYyBsb2FkU2NlbmUoKXt9XG5cbiAgICBwdWJsaWMgc3RhcnRTY2VuZSgpe1xuICAgICAgICBjb25zdCBjZW50ZXIgPSB0aGlzLnZpZXdwb3J0LmdldENlbnRlcigpO1xuXG4gICAgICAgIC8vIFRoZSBtYWluIG1lbnVcbiAgICAgICAgdGhpcy5tYWluTWVudSA9IHRoaXMuYWRkVUlMYXllcihcIm1haW5NZW51XCIpO1xuXG4gICAgICAgIGNvbnN0IHBsYXkgPSB0aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5CVVRUT04sIFwibWFpbk1lbnVcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCwgY2VudGVyLnkgLSAxMDApLCB0ZXh0OiBcIlBsYXlcIn0pO1xuICAgICAgICBwbGF5LnNpemUuc2V0KDIwMCwgNTApO1xuICAgICAgICBwbGF5LmJvcmRlcldpZHRoID0gMjtcbiAgICAgICAgcGxheS5ib3JkZXJDb2xvciA9IENvbG9yLldISVRFO1xuICAgICAgICBwbGF5LmJhY2tncm91bmRDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xuICAgICAgICBwbGF5Lm9uQ2xpY2tFdmVudElkID0gXCJwbGF5XCI7XG5cbiAgICAgICAgY29uc3QgYXN0YXIgPSB0aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5CVVRUT04sIFwibWFpbk1lbnVcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCwgY2VudGVyLnkpLCB0ZXh0OiBcIkEqIFRlc3QgU2NlbmVcIn0pO1xuICAgICAgICBhc3Rhci5zaXplLnNldCgyMDAsIDUwKTtcbiAgICAgICAgYXN0YXIuYm9yZGVyV2lkdGggPSAyO1xuICAgICAgICBhc3Rhci5ib3JkZXJDb2xvciA9IENvbG9yLldISVRFO1xuICAgICAgICBhc3Rhci5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcbiAgICAgICAgYXN0YXIub25DbGlja0V2ZW50SWQgPSBcImFzdGFyXCI7XG5cbiAgICAgICAgY29uc3QgZ3VhcmQgPSB0aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5CVVRUT04sIFwibWFpbk1lbnVcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCwgY2VudGVyLnkgKyAxMDApLCB0ZXh0OiBcIkd1YXJkIGRlbW9cIn0pO1xuICAgICAgICBndWFyZC5zaXplLnNldCgyMDAsIDUwKTtcbiAgICAgICAgZ3VhcmQuYm9yZGVyV2lkdGggPSAyO1xuICAgICAgICBndWFyZC5ib3JkZXJDb2xvciA9IENvbG9yLldISVRFO1xuICAgICAgICBndWFyZC5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcbiAgICAgICAgZ3VhcmQub25DbGlja0V2ZW50SWQgPSBcImd1YXJkXCI7XG5cbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSBidXR0b24gZXZlbnRzXG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKFwicGxheVwiKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoXCJhc3RhclwiKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoXCJndWFyZFwiKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgdXBkYXRlU2NlbmUoKXtcbiAgICAgICAgd2hpbGUodGhpcy5yZWNlaXZlci5oYXNOZXh0RXZlbnQoKSl7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUV2ZW50KHRoaXMucmVjZWl2ZXIuZ2V0TmV4dEV2ZW50KCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGhhbmRsZUV2ZW50KGV2ZW50OiBHYW1lRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgc3dpdGNoKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJwbGF5XCI6IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lTWFuYWdlci5jaGFuZ2VUb1NjZW5lKE1haW5IVzRTY2VuZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiYXN0YXJcIjoge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyLmNoYW5nZVRvU2NlbmUoQXN0YXJEZW1vU2NlbmUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImd1YXJkXCI6IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lTWFuYWdlci5jaGFuZ2VUb1NjZW5lKEd1YXJkRGVtb1NjZW5lKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgR2FtZSBmcm9tIFwiLi9Xb2xmaWUyRC9Mb29wL0dhbWVcIjtcbmltcG9ydCBNYWluTWVudSBmcm9tIFwiLi9odzQvU2NlbmVzL01haW5NZW51XCI7XG5pbXBvcnQgeyBQbGF5ZXJJbnB1dCB9IGZyb20gXCIuL2h3NC9BSS9QbGF5ZXIvUGxheWVyQ29udHJvbGxlclwiO1xuXG4vLyBUaGUgbWFpbiBmdW5jdGlvbiBpcyB5b3VyIGVudHJ5cG9pbnQgaW50byBXb2xmaWUyRC4gU3BlY2lmeSB5b3VyIGZpcnN0IHNjZW5lIGFuZCBhbnkgb3B0aW9ucyBoZXJlLlxuKGZ1bmN0aW9uIG1haW4oKXtcbiAgICAvLyBSdW4gYW55IHRlc3RzXG4gICAgcnVuVGVzdHMoKTtcblxuICAgIC8vIFNldCB1cCBvcHRpb25zIGZvciBvdXIgZ2FtZVxuICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgICBjYW52YXNTaXplOiB7eDogMTAyNCwgeTogMTAyNH0sICAgICAgICAgIC8vIFRoZSBzaXplIG9mIHRoZSBnYW1lXG4gICAgICAgIGNsZWFyQ29sb3I6IHtyOiAwLjEsIGc6IDAuMSwgYjogMC4xfSwgICAvLyBUaGUgY29sb3IgdGhlIGdhbWUgY2xlYXJzIHRvXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge25hbWU6IFBsYXllcklucHV0Lk1PVkVfVVAsIGtleXM6IFtcIndcIl19LFxuICAgICAgICAgICAge25hbWU6IFBsYXllcklucHV0Lk1PVkVfRE9XTiwga2V5czogW1wic1wiXX0sXG4gICAgICAgICAgICB7bmFtZTogUGxheWVySW5wdXQuTU9WRV9MRUZULCBrZXlzOiBbXCJhXCJdfSxcbiAgICAgICAgICAgIHtuYW1lOiBQbGF5ZXJJbnB1dC5NT1ZFX1JJR0hULCBrZXlzOiBbXCJkXCJdfSxcbiAgICAgICAgICAgIHtuYW1lOiBQbGF5ZXJJbnB1dC5QSUNLVVBfSVRFTSwga2V5czogW1wiZVwiXX0sXG4gICAgICAgICAgICB7bmFtZTogUGxheWVySW5wdXQuRFJPUF9JVEVNLCBrZXlzOiBbXCJxXCJdfSxcbiAgICAgICAgICAgIHtuYW1lOiBcInNsb3QxXCIsIGtleXM6IFtcIjFcIl19LFxuICAgICAgICAgICAge25hbWU6IFwic2xvdDJcIiwga2V5czogW1wiMlwiXX0sXG4gICAgICAgIF0sXG4gICAgICAgIHVzZVdlYkdMOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAvLyBUZWxsIHRoZSBnYW1lIHdlIHdhbnQgdG8gdXNlIHdlYmdsXG4gICAgICAgIHNob3dEZWJ1ZzogZmFsc2UgICAgICAgICAgICAgICAgICAgICAgLy8gV2hldGhlciB0byBzaG93IGRlYnVnIG1lc3NhZ2VzLiBZb3UgY2FuIGNoYW5nZSB0aGlzIHRvIHRydWUgaWYgeW91IHdhbnRcbiAgICB9XG5cbiAgICAvLyBTZXQgdXAgY3VzdG9tIHJlZ2lzdHJpZXNcblxuICAgIC8vIENyZWF0ZSBhIGdhbWUgd2l0aCB0aGUgb3B0aW9ucyBzcGVjaWZpZWRcbiAgICBjb25zdCBnYW1lID0gbmV3IEdhbWUob3B0aW9ucyk7XG5cbiAgICAvLyBTdGFydCBvdXIgZ2FtZVxuICAgIGdhbWUuc3RhcnQoTWFpbk1lbnUsIHt9KTtcblxufSkoKTtcblxuZnVuY3Rpb24gcnVuVGVzdHMoKXt9OyJdfQ==
